<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Expresiones Regulares en Flex</TITLE>
<META NAME="description" CONTENT="Expresiones Regulares en Flex">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node84.html">
<LINK REL="previous" HREF="node82.html">
<LINK REL="up" HREF="node81.html">
<LINK REL="next" HREF="node84.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2786"
  HREF="node84.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2780"
  HREF="node81.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2774"
  HREF="node82.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2782"
  HREF="node194.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2784"
  HREF="node197.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2787"
  HREF="node84.html">unput()</A>
<B>Sup:</B> <A NAME="tex2html2781"
  HREF="node81.html">Expresiones Regulares en C</A>
<B> Ant:</B> <A NAME="tex2html2775"
  HREF="node82.html">Expresiones Regulares Posix en</A>
<B> Con:</B> 
<A NAME="tex2html2782"
  HREF="node194.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html2784"
  HREF="node197.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2788"
  HREF="node83.html#SECTION05221000000000000000">Estructura de un programa LEX</A>
<UL>
<LI><A NAME="tex2html2789"
  HREF="node83.html#SECTION05221010000000000000">Estructura de un programa</A>
<LI><A NAME="tex2html2790"
  HREF="node83.html#SECTION05221020000000000000">Compilación</A>
<LI><A NAME="tex2html2791"
  HREF="node83.html#SECTION05221030000000000000">Ejecución</A>
<LI><A NAME="tex2html2792"
  HREF="node83.html#SECTION05221040000000000000">Secci&#243;n de definiciones</A>
<LI><A NAME="tex2html2793"
  HREF="node83.html#SECTION05221050000000000000">El Lenguaje de las Expresiones Regulares Flex</A>
<LI><A NAME="tex2html2794"
  HREF="node83.html#SECTION05221060000000000000">Las Acciones Semánticas</A>
</UL>
<BR>
<LI><A NAME="tex2html2795"
  HREF="node83.html#SECTION05222000000000000000">Versi&#243;n Utilizada</A>
<LI><A NAME="tex2html2796"
  HREF="node83.html#SECTION05223000000000000000">Espacios en blanco dentro de la expresión regular</A>
<LI><A NAME="tex2html2797"
  HREF="node83.html#SECTION05224000000000000000">Ejemplo Simple</A>
<LI><A NAME="tex2html2798"
  HREF="node83.html#SECTION05225000000000000000">Suprimir</A>
<LI><A NAME="tex2html2799"
  HREF="node83.html#SECTION05226000000000000000">Declaraci&#243;n de yytext</A>
<LI><A NAME="tex2html2800"
  HREF="node83.html#SECTION05227000000000000000">Declaraci&#243;n de yylex()</A>
<LI><A NAME="tex2html2801"
  HREF="node83.html#SECTION05228000000000000000">yywrap()</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05220000000000000000">
Expresiones Regulares en Flex</A>
</H1> 
Puede encontrar los ejemplos de este capítulo en
<A NAME="tex2html134"
  HREF="https://github.com/crguezl/flex-examples">https://github.com/crguezl/flex-examples</A>.

<P>
Un lenguaje regular es aquel que puede ser descrito mediante expresiones
regulares como las que se utilizan en <code>ex</code>, <code>vi</code>, <code>sed</code>,
<code>perl</code> y en tantas otras utilidades UNIX. Dado un lenguaje regular,
un analizador l&#233;xico es un programa capaz de reconocer las entradas
que pertenecen a dicho lenguaje y realizar las acciones sem&#225;nticas
que se hayan asociado con los estados de aceptaci&#243;n.
Un generador de analizadores l&#233;xicos es una herramienta que facilita
la construcci&#243;n de un analizador l&#233;xico. Un generador de analizadores
l&#233;xicos parte, por tanto, de un lenguaje adecuado para la descripci&#243;n
de lenguajes regulares (y de su sem&#225;ntica) y produce como salida
una funci&#243;n (en C, por ejemplo) que materializa el correspondiente
analizador l&#233;xico.
La mayor parte de los generadores producen a partir del conjunto de
expresiones regulares los correspondientes tablas de los autómatas
finitos deterministas. Utilizando dichas tablas y un algoritmo de
simulación genérico del autómata finito determinista se obtiene el
analizador léxico. Una vez obtenido el estado de aceptación a partir de
la entrada es posible, mediante una sentencia <code>switch</code> ejecutar la
acción semántica asociada con la correspondiente expresión regular.

<P>

<H2><A NAME="SECTION05221000000000000000"></A>
<A NAME="section:estructuraflex"></A>
<BR>
Estructura de un programa LEX
</H2>

<P>

<H4><A NAME="SECTION05221010000000000000">
Estructura de un programa</A>
</H4>
  

<P>
 <TT>LEX</TT>  y  <TT>FLEX</TT>  son ejemplos de generadores léxicos.  <TT>Flex</TT> 
lee desde la entrada est&#225;ndar si no se especifica explícitamente
un fichero de entrada. El fichero de entrada <code>reglen.l</code> (se suele usar el tipo <code>l</code>)
debe tener la forma:
<BR>
<P>
<TT>%{              
<BR>
declaration C1              
<BR>.
<BR>.
<BR>.
<BR>
<BR>
declaration CM              
<BR>%}              
<BR>
macro_name1 regular_definition1                  
<BR>.
<BR>.
<BR>.
<BR>
<BR>
macro_nameR regular_definitionR                  
<BR></TT>
<P>
<TT>%x exclusive_state
<BR>%s inclusive_state
<BR>%%              
<BR>              
<BR>
regular_expression1 { action1(); }              
<BR>.
<BR>.
<BR>.
<BR>
<BR>
regular_expressionN { actionN(); }              
<BR>              
<BR>%%              
<BR>
support_routine1() {              
<BR>}              
<BR>.
<BR>.
<BR>.
<BR>
<BR>
support_routineS() {              
<BR>}              
<BR></TT>

<P>
Como vemos,  un programa <code>LEX</code> consta de 3 secciones, separadas
por <code>%%</code>. La primera secci&#243;n se denomina <A NAME="2843"></A><SPAN  CLASS="textit">secci&#243;n de
definiciones</SPAN>,
la segunda <A NAME="2845"></A><SPAN  CLASS="textit">secci&#243;n de reglas</SPAN> 
y la tercera <A NAME="2847"></A><SPAN  CLASS="textit">secci&#243;n de c&#243;digo</SPAN>. 
La primera y la &#250;ltima son opcionales, as&#305; el programa legal <code>LEX</code> mas simple es:

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><PRE>
%%
</PRE></TD>
</TR>
</TABLE>

<P>
que genera un analizador que copia su entrada en <code>stdout</code>.

<P>

<H4><A NAME="SECTION05221020000000000000">
Compilación</A>
</H4>
  

<P>
Una vez compilado el fichero de entrada <code>regleng.l</code>
mediante la correspondiente orden:

<P>
<code>flex reglen.l</code> 

<P>
obtenemos un fichero denominado <code>lex.yy.c</code>. Este fichero
contiene la rutina <code>yylex()</code> que realiza el an&#225;lisis l&#233;xico
del lenguaje descrito en <code>regleng.l</code>. Supuesto que una de las
<code>support_routines</code> es una funci&#243;n <code>main()</code> que llama a la
funci&#243;n <code>yylex()</code>, podemos compilar el fichero generado con un
compilador C para obtener un ejecutable <code>a.out</code>:

<P>
<code>cc lex.yy.c -lfl</code> 

<P>
La inclusi&#243;n de la opci&#243;n <code>-fl</code> enlaza con la
librer&#305;a de <code>flex</code>, que contiene dos funciones: <code>main</code>
y <code>yywrap()</code>.

<P>

<H4><A NAME="SECTION05221030000000000000">
Ejecución</A>
</H4>
  

<P>
Cuando ejecutamos el programa <code>a.out</code>, la funci&#243;n <code>yylex()</code>
analiza las entradas, buscando la secuencia mas larga que casa con alguna
de las expresiones regulares (<code>regular_expressionK</code>) y ejecuta la
correspondiente acci&#243;n (<code>actionK()</code>).
Si no se encuentra ningun  emparejamiento se ejecuta la <A NAME="2857"></A><SPAN  CLASS="textit">regla por defecto</SPAN>, que es:

<P>
<code>(.|\n)  { printf("%s",yytext); }</code>

<P>
Si encuentran dos expresiones regulares con las que la cadena mas larga
casa, elige la que figura primera en el programa <code>lex</code>.
Una vez que <code>yylex()</code> ha encontrado el <SPAN  CLASS="textit">token</SPAN>, esto es, el
patr&#243;n que casa con la cadena mas larga, dicha cadena queda disponible
a trav&#233;s del puntero global  <TT>yytext</TT> , y su longitud queda en la
variable entera global  <TT>yyleng</TT> .

<P>
Una vez que se ha ejecutado la correspondiente acci&#243;n, <code>yylex()</code>
contin&#250;a con el resto de la entrada, buscando por subsiguientes
emparejamientos. Asi continúa hasta encontrar un <code>end of file</code>,
en cuyo caso termina, retornando un cero o bien hasta que una de las
acciones explicitamente ejecuta una sentencia <code>return</code>.

<P>

<H4><A NAME="SECTION05221040000000000000">
Secci&#243;n de definiciones</A>
</H4>
  

<P>
La primera secci&#243;n contiene, si las hubiera,  las definiciones regulares
y las declaraciones de los estados de arranque.

<P>
Las definiciones tiene la forma:

<P>
<SPAN  CLASS="textit">name regular_definition</SPAN>

<P>
donde <SPAN  CLASS="textit">name</SPAN> puede ser descrito mediante la expresi&#243;n regular:

<P>
<code>[a-zA-Z_][a-zA-Z_0-9-]*</code> 

<P>
La <SPAN  CLASS="textit">regular_definition</SPAN> comienza en el primer car&#225;cter no
blanco que sigue a <SPAN  CLASS="textit">name</SPAN> y termina al final de la l&#305;nea. La
definici&#243;n es una expresi&#243;n regular extendida. Las subsiguientes
definiciones pueden ``llamar'' a la macro <code>{name}</code> escribi&#233;ndola
entre llaves. La macro se expande entonces a <code>(regular_definition)</code>
en <code>flex</code> y a <code>regular_definition</code> en <code>lex</code>.

<P>
El c&#243;digo entre los delimitadores <code>%{</code> y <code>%}</code> se copia
verbatim al fichero de salida, situ&#225;ndose en la parte de declaraciones
globales. Los delimitadores deben aparecer (s&#243;los) al comienzo de
la l&#305;nea.

<P>

<H4><A NAME="SECTION05221050000000000000">
El Lenguaje de las Expresiones Regulares Flex</A>
</H4>
  

<P>
La sint&#225;xis que puede utilizarse para la descripci&#243;n de las
expresiones regulares es la que se conoce como ``extendida'':

<P>

<UL>
<LI><code>x</code>	      Casa con 'x'
</LI>
<LI><code>.</code>	      Cualquier car&#225;cter, excepto <code>\n</code>.
</LI>
<LI><code>[xyz]</code>      Una ``clase''; en este caso una de las letras <code>x</code>, <code>y</code>, <code>z</code>
</LI>
<LI><code>[abj-oZ]</code>   Una ``clase'' con un rango; casa con  <code>a</code>,  <code>b</code>, cualquier letra desde  <code>j</code> hasta <code>o</code>, o una <code>Z</code>
</LI>
<LI><code>[^A-Z]</code>     Una ``Clase complementada'' esto es, todos los caracteres que no est&#225;n en la clase. Cualquier car&#225;cter, excepto las letras may&#250;sculas. Obs&#233;rvese que el retorno de carro <code>\n</code> casa
con esta expresion. As&#305; es posible que, &lt;un patr&#243;n como <code>[^"]+</code> pueda casar con todo el fichero!.
</LI>
<LI><code>[^A-Z\n]</code>   Cualquier car&#225;cter, excepto las letras may&#250;sculas o un <code>\n</code>.
</LI>
<LI><P>
<code>[[:alnum:]]</code> Casa con cualquier caracter alfanum&#233;rico. Aqui <code>[:alnum:]</code> se refiere a una de las clases predefinidas. Las otras clases son: <code>[:alpha:]</code> <code>[:blank:]</code> <code>[:cntrl:]</code> <code>[:digit:]</code> <code>[:graph:]</code> <code>[:lower:]</code> <code>[:print:]</code> <code>[:punct:]</code> <code>[:space:]</code> <code>[:upper:]</code> <code>[:xdigit:]</code>. Estas clases designan el mismo conjunto de caracteres que la correspondiente funci&#243;n C <code>isXXXX</code>.

<P>
</LI>
<LI><code>r*</code>	Cero o mas <code>r</code>.
</LI>
<LI><code>r+</code>       Una o mas <code>r</code>.
</LI>
<LI><code>r?</code>	Cero o una  <code>r</code>.
</LI>
<LI><code>r{2,5}</code>     Entre 2 y 5  <code>r</code>.
</LI>
<LI><code>r{2,}</code>      2 o mas <code>r</code>. 
<code>r{4}</code>	  Exactamente 4 <code>r</code>. 
</LI>
<LI><code>{macro_name}</code>     La expansi&#243;n de <code>macro_name</code> por su <SPAN  CLASS="textit">regular_definition</SPAN>
</LI>
<LI><code>"[xyz]\"foo"</code> Exactamente la cadena: [xyz]"foo
</LI>
<LI><code>\X</code>	      Si <code>X</code> is an <code>a</code>, <code>b</code>, <code>f</code>, <code>n</code>, <code>r</code>, <code>t</code>, o <code>v</code>, entonces, la interpretaci&#243;n ANSI-C de <code>\x</code>.  En cualquier otro caso <code>X</code>.
</LI>
<LI><code>\0</code>	      El car&#225;cter NUL (ASCII 0).
</LI>
<LI><code>\123</code>	      El car&#225;cter cuyo c&#243;digo octal es 123.
</LI>
<LI><code>\x2a</code>	      El car&#225;cter cuyo c&#243;digo hexadecimal es 2a.
</LI>
<LI><code>(r)</code>	      Los par&#233;ntesis son utilizados para cambiar la precedencia.
</LI>
<LI><code>rs</code>	      Concatenation
</LI>
<LI><code>r|s</code>	      Casa con  <code>r</code> o <code>s</code>
</LI>
<LI><code>r/s</code>	      Una <code>r</code> pero s&#243;lo si va seguida de una <code>s</code>. El texto casado con <code>s</code> se incluye a la hora de decidir cual es el emparejamiento mas largo, pero se devuelve a la entrada cuando se ejecuta la acci&#243;n. La acci&#243;n s&#243;lo ve el texto asociado con <code>r</code>. Este tipo de patr&#243;n se denomina <SPAN  CLASS="textit">trailing context</SPAN> o <SPAN  CLASS="textit">lookahead</SPAN> positivo.  
</LI>
<LI><code>^r</code>	      Casa con <code>r</code>, al comienzo de una l&#305;nea.
                      Un <code>^</code> que no aparece al comienzo de la l&#305;nea o un <code>$</code> que no aparece al final de la l&#305;nea, pierde su naturaleza de ``ancla'' y es tratado como un car&#225;cter ordinario. Asi: <code>foo|(bar$)</code> se empareja con <code>bar$</code>. Si lo que se quer&#305;a es la otra interpretaci&#243;n, es posible escribir <code>foo|(bar\n)</code>, o bien:
<PRE>
foo |
bar$   { /* action */ }
</PRE>
</LI>
<LI><code>r$</code>	      Casa con <code>r</code>, al final de una l&#305;nea. Este es tambi&#233;n un operador de <SPAN  CLASS="textit">trailing context</SPAN>. Una regla no puede tener mas de un operador de <SPAN  CLASS="textit">trailing context</SPAN>. Por ejemplo, la expresi&#243;n <code>foo/bar$</code> es incorrecta.
</LI>
<LI><code>&lt;s&gt;r</code>	      Casa con <code>r</code>, pero s&#243;lo si se est&#225; en el estado <code>s</code>.
</LI>
<LI><code>&lt;s1,s2,s3&gt;r</code>    Idem, si se esta en alguno de los estados <code>s1</code>, <code>s2</code>, or <code>s3</code>
</LI>
<LI><code>&lt;*&gt;r</code>	      Casa con <code>r</code> cualquiera que sea el estado, incluso si este es exclusivo.
</LI>
<LI><code>&lt;&lt;EOF&gt;&gt;</code>        Un final de fichero.
</LI>
<LI><code>&lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;</code> Un final de fichero, si los estados son <code>s1</code> o <code>s2</code>
</LI>
</UL>

<P>
Los operadores han sido listados en orden de precedencia, de la
mas alta a la mas baja. Por ejemplo <code>foo|bar+</code> es lo mismo que
<code>(foo)|(ba(r)+)</code>.

<P>

<H4><A NAME="SECTION05221060000000000000">
Las Acciones Semánticas</A>
</H4>
  

<P>
Cada patrón regular tiene su correspondiente acción asociada. El patrón
termina en el primer espacio en blanco (sin contar aquellos que están
entre comillas dobles o prefijados de secuencias de escape).
Si la acción comienza con <code>{</code>, entonces se puede extender a través
de multiples líneas, hasta la correspondiente <code>}</code>.  El programa
<code>flex</code>  no hace un análisis del código C dentro de la acción.
Existen tres directivas que pueden insertarse dentro de las acciones:
<code>BEGIN</code>, <code>ECHO</code> y <code>REJECT</code>. Su uso se muestra en los
subsiguientes ejemplos.

<P>
La secci&#243;n de c&#243;digo se copia verbatim en <code>lex.yy.c</code>. Es
utilizada para proveer las funciones de apoyo que se requieran para la
descripci&#243;n de las acciones asociadas con los patrones que parecen en
la secci&#243;n de reglas.

<P>

<H2><A NAME="SECTION05222000000000000000">
Versi&#243;n Utilizada</A>
</H2>
Todos los ejemplos que aparecen en este documento fueron
preparados con la versi&#243;n 2.5.4 de <SPAN  CLASS="textit">flex</SPAN> en un entorno
Linux 
<PRE>
$ uname -a
Linux nereida.deioc.ull.es 2.2.12-20 #10 Mon May 8 19:40:16 WEST 2000 i686 unknown
$ flex --version   
flex version 2.5.4
</PRE>
y con la versi&#243;n 2.5.2 en un entorno Solaris
<PRE>
&gt; uname -a
SunOS fonil 5.7 Generic_106541-04 sun4u sparc SUNW,Ultra-5_10
&gt; flex --version
flex version 2.5.2
</PRE>

<P>

<H2><A NAME="SECTION05223000000000000000"></A>
<A NAME="section:blancos"></A>
<BR>
Espacios en blanco dentro de la expresión regular
</H2>
La expresión regular va desde el comienzo de la línea hasta el primer espacio en blanco 
no escapado. Todos los espacios en blanco que formen parte de la 
expresión regular 
deben ser escapados o protegidos entre comillas. Así, el siguiente
programa produce un error en tiempo de compilación C:
<PRE>
&gt; cat spaces.l
%%
one two { printf("spaces\n"; }
%%
nereida:~/public_html/regexpr/lex/src&gt; flex spaces.l
nereida:~/public_html/regexpr/lex/src&gt; gcc lex.yy.c
spaces.l: In function `yylex':
spaces.l:2: `two' undeclared (first use in this function)
spaces.l:2: (Each undeclared identifier is reported only once
spaces.l:2: for each function it appears in.)
spaces.l:2: parse error before `{'
spaces.l:4: case label not within a switch statement
lex.yy.c:632: case label not within a switch statement
lex.yy.c:635: case label not within a switch statement
lex.yy.c:757: default label not within a switch statement
lex.yy.c: At top level:
lex.yy.c:762: parse error before `}'
</PRE>
Deberíamos escapar el blanco entre <code>one</code> y <code>two</code> o bien
proteger la cadena poniéndola entre comillas: <code>"one two"</code>.

<P>

<H2><A NAME="SECTION05224000000000000000"></A>
<A NAME="section:ejemplosimple"></A>
<BR>
Ejemplo Simple
</H2>
Este primer ejemplo sustituye las apariciones de la palabra 
<SPAN  CLASS="textit">username</SPAN> por el <SPAN  CLASS="textit">login</SPAN> del usuario:
<PRE>
$ cat subst.l
%option main
%{
#include &lt;unistd.h&gt;
%}
%%
username    printf( "%s",  getlogin());
%%
$ flex -osubst.c subst.l
$ gcc -o subst subst.c
$ subst
Dear username:
Dear pl:
</PRE>
He presionado CTRL-D para finalizar la entrada.
<BR>
Observe el uso de la opci&#243;n <code>%option main</code> en el fichero
<SPAN  CLASS="textit">subst.l</SPAN> para hacer que <SPAN  CLASS="textit">flex</SPAN> genere una funci&#243;n
<SPAN  CLASS="textit">main</SPAN>. Tambi&#233;n merece especial
atenci&#243;n el uso de la opci&#243;n  <code>-osubst</code> para cambiar el
nombre del fichero de salida, que por defecto ser&#225; <SPAN  CLASS="textit">lex.yy.c</SPAN>.

<P>

<H2><A NAME="SECTION05225000000000000000"></A>
<A NAME="section:suprimir"></A>
<BR>
Suprimir
</H2>
Al igual que en <SPAN  CLASS="textit">sed</SPAN> y <SPAN  CLASS="textit">awk</SPAN>, es muy sencillo
suprimir las apariciones de una expresi&#243;n regular. 
<PRE>
$ cat delete.l
/* delete all entries of zap me */
%%
"zap me"
$ flex delete.l ; gcc lex.yy.c -lfl; a.out
this is zap me a first zap me phrase
this is  a first  phrase
</PRE>

<P>

<H2><A NAME="SECTION05226000000000000000"></A>
<A NAME="section:yytextdec"></A>
<BR>
Declaraci&#243;n de yytext
</H2>
En la sección de definiciones es posible utilizar las directivas
<code>%pointer</code> o <code>%array</code>. Estas directivas hacen que  <TT>yytext</TT> 
se declare como un puntero o un <SPAN  CLASS="textit">array</SPAN> respectivamente.
La opción por defecto es declararlo como un puntero, salvo que se haya
usado la opción <code>-l</code> en la línea de comandos, para garantizar una
mayor compatibilidad con <code>LEX</code>.
Sin embargo, y aunque la opci&#243;n  <code>%pointer</code> es la mas eficiente
(el análisis es mas rápido y se evitan los <SPAN  CLASS="textit">buffer overflow</SPAN>),
limita la posible manipulaci&#243;n de <SPAN  CLASS="textit">yytext</SPAN> y de las llamadas
a <code>unput()</code>.
<PRE>
$ cat yytextp.l
%%
hello {
        strcat(yytext, " world");
        printf("\n%d: %s\n",strlen(yytext),yytext);
      }
$ flex yytextp.l ; gcc lex.yy.c -lfl ; a.out
hello
 
11: hello world
 
fatal flex scanner internal error--end of buffer missed
</PRE>
Este error no aparece si se utiliza la opci&#243;n <code>%array</code>:
<PRE>
$ cat yytext.l
%array
%%
hello {
        strcat(yytext, " world");
        printf("\n%d: %s\n",strlen(yytext),yytext);
      }
$ flex yytext.l; gcc lex.yy.c -lfl; a.out
hello
 
11: hello world
</PRE>

<P>
Además, algunos programs <code>LEX</code>  modifican directamente <code>yytext</code>, utilizando la declaración:

<P>
<code>extern char yytext[]</code>

<P>
que es incompatible con la directiva <code>%pointer</code> (pero correcta con <code>%array</code>).
La directiva <code>%array</code> define <code>yytext</code> como un <SPAN  CLASS="textit">array</SPAN> de tamaño <code>YYLMAX</code>.
Si deseamos trabajar con un mayor tamaño, basta con redefinir <code>YYLMAX</code>.

<P>

<H2><A NAME="SECTION05227000000000000000"></A>
<A NAME="section:yylexdec"></A>
<BR>
Declaraci&#243;n de yylex()
</H2>
Por defecto la funci&#243;n <SPAN  CLASS="textit">yylex()</SPAN> que realiza el an&#225;lisis l&#233;xico es
declarada como  <code>int yylex()</code>. Es posible cambiar la declaraci&#243;n
por defecto utilizando la macro <SPAN  CLASS="textit">YY_DECL</SPAN>. En el siguiente ejemplo
la definici&#243;n:
<PRE>
#define YY_DECL char *scanner(int *numcount, int *idcount)
</PRE>
hace que la rutina de an&#225;lisis l&#233;xico pase a llamarse 
<SPAN  CLASS="textit">scanner</SPAN> y tenga dos parametros de entrada, retornando
un valor de tipo <code>char *</code>.
<PRE>
$ cat decl.l
%{
#define YY_DECL char *scanner(int *numcount, int *idcount)
%}
 
num [0-9]+
id [a-z]+
%%
{num} {(*numcount)++;}
halt  {return ((char *) strdup(yytext));}
{id}  {(*idcount)++;}
%%
main() {
  int a,b;
  char *t;
 
  a = 0; b = 0;
  t = scanner(&amp;a, &amp;b);
  printf("numcount = %d, idcount = %d, yytext = %s\n",a,b,t);
  t = scanner(&amp;a, &amp;b);
  printf("numcount = %d, idcount = %d, yytext = %s\n",a,b,t);
}
 
int yywrap() {
  return 1;
}
</PRE>
La ejecuci&#243;n del programa anterior produce la siguiente salida:
<PRE>
$ decl
a b 1 2 3 halt
     numcount = 3, idcount = 2, yytext = halt
 
e 4 5 f
 
numcount = 5, idcount = 4, yytext = (null)
$ decl
a b 1 2 3 halt
     numcount = 3, idcount = 2, yytext = halt
 
e 4 f 5 halt
    numcount = 5, idcount = 4, yytext = halt
</PRE>

<P>

<H2><A NAME="SECTION05228000000000000000">
yywrap()</A>
</H2>
Cuando el analizador l&#233;xico alcanza el final del fichero, el
comportamiento en las subsiguientes llamadas a <SPAN  CLASS="textit">yylex</SPAN>
resulta indefinido.  En el momento en que  <SPAN  CLASS="textit">yylex()</SPAN>
alcanza el final del fichero llama a la funci&#243;n <SPAN  CLASS="textit">yywrap</SPAN>, la cual retorna un
valor de 0 o 1 seg&#250;n haya mas entrada o no. Si el valor es 0,
la funci&#243;n <SPAN  CLASS="textit">yylex</SPAN> asume que la propia <SPAN  CLASS="textit">yywrap</SPAN>
se ha encargado de abrir el nuevo fichero y asignarselo
a  <TT>yyin</TT> .  Otra manera de continuar es haciendo uso de
la funci&#243;n <SPAN  CLASS="textit">yyrestart(FILE *file)</SPAN>. 
El siguiente ejemplo cuenta el n&#250;mero de l&#305;neas, palabras y
caracteres en una lista de ficheros proporcionados como entrada.

<P>
<PRE>
%{
unsigned long charCount = 0, wordCount = 0, lineCount = 0;
%}

word [^ \t\n]+ 
eol \n 

%%
{word} { wordCount++; charCount += yyleng; }
{eol} { charCount++; lineCount++; }
. charCount++;

%%

char **fileList;
unsigned nFiles;
unsigned currentFile = 0;
unsigned long totalCC = 0;
unsigned long totalWC = 0;
unsigned long totalLC = 0;

main ( int argc, char **argv) {
  FILE *file;

  fileList = argv + 1; nFiles = argc - 1;

  if (nFiles == 0) {
    fprintf(stderr,"Usage is:\n%s file1 file2 file3 ...\n",argv[0]);
    exit(1);
  }
  file = fopen (fileList[0], "r");
  if (!file) {
      fprintf (stderr, "could not open %s\n", argv[1]);
      exit (1);
  }
  currentFile = 1; yyrestart(file);
  yylex ();
  printf ("%8lu %8lu %8lu %s\n", lineCount, wordCount,
    charCount, fileList[currentFile - 1]);
  if (argc &gt; 2) {
      totalCC += charCount; totalWC += wordCount; totalLC += lineCount;
      printf ("%8lu %8lu %8lu total\n", totalLC, totalWC, totalCC);
  }
  return 0;
}

int yywrap () {
  FILE *file;

  if (currentFile &lt; nFiles) {
     printf ("%8lu %8lu %8lu %s\n", lineCount, wordCount,
       charCount, fileList[currentFile - 1]);
     totalCC += charCount; totalWC += wordCount; totalLC += lineCount;
     charCount = wordCount = lineCount = 0;
     fclose (yyin);

     while (fileList[currentFile] != (char *) 0) {
       file = fopen (fileList[currentFile++], "r");
       if (file != NULL) { yyrestart(file); break; }
	  fprintf (stderr, "could not open %s\n", fileList[currentFile - 1]);
     }
     return (file ? 0 : 1);
    }
    return 1;
}
</PRE>

<P>
La figura muestra el proceso de compilaci&#243;n y la ejecuci&#243;n:
<PRE>
$ flex countlwc.l;gcc lex.yy.c; a.out *.l
      58      179     1067 ape-05.l
      88      249     1759 countlwc.l
      11       21      126 magic.l
       9       17      139 mgrep.l
       9       16      135 mlg.l
       5       15      181 ml.l
       7       12       87 subst.l
     187      509     3494 total
</PRE>
La diferencia esencial entre asignar <SPAN  CLASS="textit">yyin</SPAN> o llamar a la
funci&#243;n <SPAN  CLASS="textit">yyrestart</SPAN> es que esta &#250;ltima puede ser utilizada para
conmutar entre ficheros en medio de un an&#225;lisis l&#233;xico. El
funcionamiento del programa anterior no se modifica si se 
se intercambian asignaciones a <SPAN  CLASS="textit">yyin</SPAN> (<SPAN  CLASS="textit">yyin = file</SPAN>)
y llamadas a <SPAN  CLASS="textit">yyrestart(file)</SPAN>.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2786"
  HREF="node84.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2780"
  HREF="node81.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2774"
  HREF="node82.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2782"
  HREF="node194.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2784"
  HREF="node197.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2787"
  HREF="node84.html">unput()</A>
<B>Sup:</B> <A NAME="tex2html2781"
  HREF="node81.html">Expresiones Regulares en C</A>
<B> Ant:</B> <A NAME="tex2html2775"
  HREF="node82.html">Expresiones Regulares Posix en</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-04-12</I>
</ADDRESS>
</BODY>
</HTML>
