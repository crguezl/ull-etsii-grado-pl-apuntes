<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Análisis Léxico</TITLE>
<META NAME="description" CONTENT="Análisis Léxico">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node116.html">
<LINK REL="previous" HREF="node114.html">
<LINK REL="up" HREF="node112.html">
<LINK REL="next" HREF="node116.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html3951"
  HREF="node116.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3945"
  HREF="node112.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html3939"
  HREF="node114.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3947"
  HREF="node211.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3949"
  HREF="node214.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html3952"
  HREF="node116.html">Pruebas para el Analizador</A>
<B>Sup:</B> <A NAME="tex2html3946"
  HREF="node112.html">Análisis Sintáctico Descendente en</A>
<B> Ant:</B> <A NAME="tex2html3940"
  HREF="node114.html">Las Fases de un</A>
<B> Con:</B> 
<A NAME="tex2html3947"
  HREF="node211.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html3949"
  HREF="node214.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html3953"
  HREF="node115.html#SECTION05730010000000000000">El Operador de Binding</A>
<LI><A NAME="tex2html3954"
  HREF="node115.html#SECTION05730020000000000000">Casando a partir del Ültimo Emparejamiento</A>
<LI><A NAME="tex2html3955"
  HREF="node115.html#SECTION05730030000000000000">La opción <TT>g</TT></A>
<LI><A NAME="tex2html3956"
  HREF="node115.html#SECTION05730040000000000000">La opción <TT>c</TT></A>
<LI><A NAME="tex2html3957"
  HREF="node115.html#SECTION05730050000000000000">La opción <TT>i</TT></A>
<LI><A NAME="tex2html3958"
  HREF="node115.html#SECTION05730060000000000000">Código del Analizador Léxico</A>
<LI><A NAME="tex2html3959"
  HREF="node115.html#SECTION05730070000000000000">Relación de corutina con el Analizador Sintáctico</A>
<LI><A NAME="tex2html3960"
  HREF="node115.html#SECTION05730080000000000000">Manejo de Errores</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html3961"
  HREF="node115.html#SECTION05731000000000000000">Ejercicio: La opción <TT>g</TT></A>
<LI><A NAME="tex2html3962"
  HREF="node115.html#SECTION05732000000000000000">Ejercicio: Opciones <TT>g</TT> y <TT>c</TT> en Expresiones Regulares</A>
<LI><A NAME="tex2html3963"
  HREF="node115.html#SECTION05733000000000000000">Ejercicio: El orden de las expresiones regulares</A>
<LI><A NAME="tex2html3964"
  HREF="node115.html#SECTION05734000000000000000">Ejercicio: Regexp para cadenas</A>
<LI><A NAME="tex2html3965"
  HREF="node115.html#SECTION05735000000000000000">Ejercicio: El <TT>or</TT> es vago</A>
<LI><A NAME="tex2html3966"
  HREF="node115.html#SECTION05736000000000000000">Práctica: Números de Línea, Errores, Cadenas y Comentarios</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05730000000000000000"></A>
<A NAME="section:analisislexico"></A>
<BR>
Análisis Léxico
</H1>
Comenzaremos con la parte mas sencilla del compilador: el analizador 
léxico. 
Habitualmente el término ``análisis léxico'' se refiere al tratamiento
de la entrada que produce como salida
la lista de <SPAN  CLASS="textbf">tokens</SPAN>. Un <SPAN  CLASS="textbf">token</SPAN> hace alusión 
a las unidades mas simples que tiene significado. Habitualmente 
un <SPAN  CLASS="textbf">token</SPAN> o lexema queda descrito por una expresión regular.
Léxico viene del griego <SPAN  CLASS="textbf">lexis</SPAN>, que significa ``palabra''.
Perl es, sobra decirlo, una herramienta eficaz para encontrar en que lugar 
de la cadena se produce un emparejamiento.
Sin embargo, en el análisis léxico, el problema es encontrar la subcadena
a partir de la última posición en la que se produjo un emparejamiento
y que es aceptada por una de las expresiones
regulares que definen los lexemas del lenguaje dado.

<P>
La estructura general del analizador léxico consiste en un bucle en el que se va
recorriendo la entrada, buscando por un emparejamiento con 
uno de los patrones/lexemas especificados y, cuando se encuentra, se retorna esa información
al analziador sintáctico. Como no tenemos escrito el analaizador sintáctico 
simplemente iremos añadiéndo los terminales al final de una lista.

<P>
Una iteración del bucle tiene la forma de una secuencia de condicionales
en las que se va comprobando si la entrada casa con cada una de las expresiones regulares
que definen los terminales del lenguaje. Las condiciones tienen un aspecto similar a este:

<P>
<PRE>
     ...
     if (m{\G\s*(\d+)}gc) {
       push @tokens, 'NUM', $1;
     } 
     elsif (m{\G\s*([a-z_]\w*)\b}igc) {
       push @tokens, 'ID', $1;
     } 
     ...
</PRE>

<P>
Una expresión como <code>m{\G\s*(\d+)}gc</code> es una expresión regular.
Es conveniente que en este punto repase la introducción a las 
expresiones regulares en 
<A HREF="#section:introregexp">
<IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> [<A
 HREF="node215.html#CasianoIntroAPerl">10</A>]. 

<P>

<H4><A NAME="SECTION05730010000000000000">
El Operador de Binding</A>
</H4>
  

<P>
Nótese que, puesto que no se menciona sobre que variable
se hace el <SPAN  CLASS="textbf">binding</SPAN> (no se usa ninguno de los operadores
de <SPAN  CLASS="textbf">binding</SPAN> <code>=~</code> y <code>!~</code>): se entiende que 
es sobre la variable por defecto <code>$_</code> sobre la que se 
hace el matching.

<P>

<H4><A NAME="SECTION05730020000000000000">
Casando a partir del Ültimo Emparejamiento</A>
</H4>
  

<P>
El ancla <code>\G</code> 
casa con el punto en la cadena en el que terminó el último emparejamiento.

<P>
La expresión regular describiendo el patrón de interés se pone
entre paréntesis para usar la estrategia de los paréntesis
con memoria (véanse 
<A HREF="node97.html#section:variablesmagicasereg">31.1.4</A>
y
<A HREF="node97.html#section:dolar1">31.1.1</A>). 

<P>
Las opciones <code>c</code> y <code>g</code> son especialmente 
útiles para la construcción del analizador.

<P>

<H4><A NAME="SECTION05730030000000000000">
La opción <TT>g</TT></A>
</H4>
  

<P>
<SPAN  CLASS="textbf">
Como lo usamos en un contexto escalar, la opción <TT>g</TT> itera sobre la cadena, devolviendo
cierto cada vez que casa, y falso cuando deja de casar.</SPAN> 
Se puede averiguar la posicion del emparejamiento
utilizando la función <code>pos</code>. 
(véase la sección <A HREF="node97.html#section:g">31.1.6</A> para mas información sobre la opción <code>g</code>).

<P>

<H4><A NAME="SECTION05730040000000000000">
La opción <TT>c</TT></A>
</H4>
  

<P>
La opción
<code>/c</code> afecta a las operaciones de emparejamiento
con <code>/g</code> en un contexto escalar. Normalmente, <SPAN  CLASS="textbf">cuando una
búsqueda global escalar tiene lugar y no ocurre casamiento,
la posici&#243;n de comienzo de búsqueda es reestablecida</SPAN> al comienzo de
la cadena.
La opci&#243;n <code>/c</code> hace que la posici&#243;n inicial de 
emparejamiento permanezca donde la dej&#243; el &#250;ltimo
emparejamiento con &#233;xito y no se vaya al comienzo. 
Al combinar esto con el ancla <code>\G</code>, la cuál
casa con el final del último emparejamiento, obtenemos que la combinación

<P>
<PRE>
                            m{\G\s*(...)}gc
</PRE>

<P>
logra el efecto deseado: Si la primera expresión regular
en la cadena <code>elsif</code> fracasa, la posición de búsqueda no es inicializada
de nuevo gracias a la opción <code>c</code> y el ancla <code>\G</code> sigue recordando
donde terminó el ultimo casamiento.

<P>

<H4><A NAME="SECTION05730050000000000000">
La opción <TT>i</TT></A>
</H4>
  

<P>
Por último, la opción <code>i</code> permite ignorar el tipo de letra (mayúsculas 
o minúsculas).

<P>
Repase la sección
<A HREF="node97.html#section:opciones">31.1.6</A>
para ver algunas de las opciones mas usadas.

<P>

<H4><A NAME="SECTION05730060000000000000">
Código del Analizador Léxico</A>
</H4>
  

<P>
Este es el código completo de la subrutina <code>scanner</code> que se encarga
del análisis léxico:

<P>
<PRE>
 1 package Lexical::Analysis;
 2 sub scanner {
 3   local $_ = shift;
 4   { # Con el redo del final hacemos un bucle "infinito"
 5     if (m{\G\s*(\d+)}gc) {
 6       push @tokens, 'NUM', $1;
 7     } 
 8     elsif (m{\G\s*int\b}igc) {
 9       push @tokens, 'INT', 'INT';
10     } 
11     elsif (m{\G\s*string\b}igc) {
12       push @tokens, 'STRING', 'STRING';
13     } 
14     elsif (m{\G\s*p\b}igc) {
15       push @tokens, 'P', 'P'; # P para imprimir
16     } 
17     elsif (m{\G\s*([a-z_]\w*)\b}igc) {
18       push @tokens, 'ID', $1;
19     } 
20     elsif (m{\G\s*\"([^"]*)\"}igc) {
21       push @tokens, 'STR', $1;
22     } 
23     elsif (m{\G\s*([+*()=;,])}gc) {
24       push @tokens, 'PUN', $1;
25     }
26     elsif (m{\G\s*(\S)}gc) { # Hay un caracter "no blanco"
27       Error::fatal "Caracter invalido: $1\n";
28     }
29     else {
30       last;
31     }
32     redo;
33   }
34 }
</PRE>

<P>

<H4><A NAME="SECTION05730070000000000000">
Relación de corutina con el Analizador Sintáctico</A>
</H4>
  

<P>
Si decidieramos establecer una relación de corutina con el analizador léxico los 
condicionales se pueden programar siguiendo secuencias con esta estructura:

<P>
<PRE>
      return ('INT', 'INT') if (m{\G\s*int\b}igc);
</PRE>

<P>

<H4><A NAME="SECTION05730080000000000000">
Manejo de Errores</A>
</H4>
  

<P>
Para completar el analizador solo quedan declarar 
las variables usadas y las subrutinas de manejo de errores:

<P>
<PRE>
######## global scope variables
our @tokens = ();
our $errorflag = 0;

package Error;

sub error($) {
  my $msg = shift;
  if (!$errorflag) {
    warn "Error: $msg\n";
    $errorflag = 1;
  }
}

sub fatal($) {
  my $msg = shift;
  die "Error: $msg\n";
}
</PRE>

<P>
El uso de <code>our</code> es necesario porque hemos 
declarado al comienzo del módulo <code>use strict</code>.
El pragma <TT>use strict</TT> le indica al compilador Perl 
que debe considerar como obligatorias un conjunto de reglas de
buen estilo de programación. Entre otras restricciones, el uso del
pragma implica que
todas las variables (no-mágicas) 
deben ser declaradas explícitamente (uso de <code>my</code>, <code>our</code>, etc.)
La declaración <code>our</code> se describe en <A HREF="#subsection:our">
<IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> [<A
 HREF="node215.html#CasianoIntroAPerl">10</A>].

<P>

<H2><A NAME="SECTION05731000000000000000">
Ejercicio: La opción <TT>g</TT></A>
</H2>
   <A NAME="12078"></A>

<P>
Explique cada una de las líneas que siguen:
<PRE>
$ perl -wde 0
main::(-e:1):   0
  DB&lt;1&gt; $x = "ababab"
  DB&lt;2&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 2
  DB&lt;3&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 4
  DB&lt;4&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 6
  DB&lt;5&gt; print "falso" unless $x =~ m{b}g
falso
</PRE>

<P>

<H2><A NAME="SECTION05732000000000000000">
Ejercicio: Opciones <TT>g</TT> y <TT>c</TT> en Expresiones Regulares</A>
</H2>
   <A NAME="12086"></A>

<P>
Explique cada una de las conductas que siguen

<UL>
<LI>¿Porqué en la línea 18 se casa con la primera <code>b</code>?
<PRE>
  DB&lt;5&gt; $x = "bbabab"
  DB&lt;6&gt; $x =~ m{a}g; print "match= ".$&amp;." pos = ".pos($x)
match= a pos = 3
  DB&lt;7&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 4
  DB&lt;8&gt; $x =~ m{c}g; print "match= ".$&amp;." pos = ".pos($x)
Use of uninitialized value in concatenation (.) 
  DB&lt;18&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 1
</PRE>

<P>
</LI>
<LI>¿Porqué en la línea 27 se casa con la última <code>b</code>?
<PRE>
  DB&lt;23&gt; $x = "bbabab"
  DB&lt;24&gt; $x =~ m{a}g; print "match= ".$&amp;." pos = ".pos($x)
match= a pos = 3
  DB&lt;25&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 4
  DB&lt;26&gt; $x =~ m{c}gc
  DB&lt;27&gt; $x =~ m{b}g; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 6
</PRE>

<P>
</LI>
<LI>¿Porqué en la línea 5 se produce casamiento y en la línea 8 no?
<PRE>
  DB&lt;3&gt; $x = "bcbabab"
  DB&lt;4&gt; $x =~ m{b}gc; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 1
  DB&lt;5&gt; $x =~ m{a}gc; print "match= ".$&amp;." pos = ".pos($x)
match= a pos = 4

  DB&lt;6&gt; $x = "bcbabab"
  DB&lt;7&gt; $x =~ m{b}gc; print "match= ".$&amp;." pos = ".pos($x)
match= b pos = 1
  DB&lt;8&gt; $x =~ m{\Ga}gc; print "match= ".$&amp;." pos = ".pos($x)
Use of uninitialized value in concatenation 
match=  pos = 1
</PRE>
</LI>
</UL>

<P>

<H2><A NAME="SECTION05733000000000000000"></A>
   <A NAME="12092"></A>
<BR>
Ejercicio: El orden de las expresiones regulares
</H2>
  
¿Que ocurriría en la subrutina <code>scanner</code> si el código en las líneas
17-19 que reconoce los identificadores se adelanta a la línea 8? 
¿Que ocurriría con el reconocimiento de las palabras reservadas como
<code>INT</code>? ¿Seguiría funcionando correctamente 
el analizador?

<P>

<H2><A NAME="SECTION05734000000000000000"></A>
   <A NAME="12094"></A>
<BR>
Ejercicio: Regexp para cadenas
</H2>
  
En la rutina <code>scanner</code>. ¿Es legal que una cadena correspondiente
al terminal <code>STR</code> contenga retornos de carro entre las comillas dobles?

<P>

<H2><A NAME="SECTION05735000000000000000">
Ejercicio: El <TT>or</TT> es vago</A>
</H2>
   <A NAME="12099"></A>
  
Explique el resultado de la siguiente sesión con el depurador:
<PRE>
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL/Lexical$ perl -de 0
  DB&lt;1&gt; 'bb' =~ m{b|bb}; print $&amp;
  b
  DB&lt;2&gt; 'bb' =~ m{bb|b}; print $&amp;
  bb
</PRE>
Perl convierte la expresión regular en un NFA. A diferencia de lo 
que ocurre en otras herramientas, el NFA no es convertido en un DFA.
El NFA es entonces simulado. ¿Que está ocurriendo en la simulación? 

<P>

<H2><A NAME="SECTION05736000000000000000"></A>
   <A NAME="12103"></A>
  
<A NAME="practica:lineasyerrores"></A>
<BR>
Práctica: Números de Línea, Errores, Cadenas y Comentarios
</H2>
Extienda el analizador léxico para que:

<UL>
<LI>Reescriba la expresión regular para las cadenas de manera que acepte comillas dobles 
escapadas <code>\"</code> en el interior de una cadena.
Por ejemplo en <code>"esta \"palabra\" va entre comillas"</code>.

<P>
Analice esta solución ¿Es correcta?:
<PRE>
 DB&lt;1&gt; $stringre = qr{"(\\.|[^\\"])*"}
 DB&lt;2&gt; print $&amp; if '"esta \"palabra\" va entre comillas"' =~ $stringre
 "esta \"palabra\" va entre comillas"
</PRE>

<P>
</LI>
<LI>Consuma comentarios a la Perl: 
cualesquiera caracteres después de una almohadilla hasta el final 
de la línea (<code># ...</code>).
</LI>
<LI>Consuma comentarios no anidados a la <SPAN  CLASS="textbf">C</SPAN> (<code>/* ... */</code>.).
Repase las secciones sobre expresiones regulares no ``greedy'' (p. ej. sección
<A HREF="node97.html#section:nogreedy">31.1.1</A>) y la sección <A HREF="node97.html#section:x">31.1.1</A>.
Recuerde que, en una expresión regular, 
la opción <code>/s</code> hace que el punto <code>'.'</code> empareje con un 
retorno de carro <code>\n</code>.  Esto es, el punto ``casa'' con cualquier carácter.

<P>
Observe el siguiente ejemplo:
<PRE>
pl@nereida:~/src/perl/testing$ cat -n ccomments.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  sub showmatches {
 5   my ($x, $re) = @_;
 6
 7    for (my $i = 0; $x =~ /$re/gsx; $i++) {
 8      print "matching $i: $1\n";
 9      $i++;
10    }
11  }
12
13  my $x = &lt;&lt;'EOC';
14  if (x) {
15    /* a comment */ return x + 1; /* another comment */
16  }
17  else {
18    return x + 2; /* a last comment */
19  }
20  EOC
21
22  print "\n************************\n";
23
24  my $greedy = q{ (
25           /\*  # Abrir comentario
26           .*   # Consumir caracteres (greedy)
27           \*/  # Cerrar comentario
28           )
29  };
30  print "Greedy:\n";
31  showmatches($x, $greedy);
32
33  print "\n************************\n";
34
35  my $lazy = q{ (
36           /\*  # Abrir comentario
37           .*?  # Consumir caracteres (lazy)
38           \*/  # Cerrar comentario
39           )
40  };
41  print "Lazy:\n";
42  showmatches($x, $lazy);
</PRE>
Cuando se ejecuta produce:
<PRE>
pl@nereida:~/src/perl/testing$ ccomments.pl

************************
Greedy:
matching 0: /* a comment */ return x + 1; /* another comment */
}
else {
  return x + 2; /* a last comment */

************************
Lazy:
matching 0: /* a comment */
matching 2: /* another comment */
matching 4: /* a last comment */
</PRE>

<P>
Explique la conducta.

<P>
</LI>
<LI>Números en punto flotante (como <code>-1.32e-04</code> o <code>.91</code>).
El siguiente ejemplo intenta ayudarle en la búsqueda de la solución:
<PRE>
lhp@nereida:~$ perl -de 0
  DB&lt;1&gt; print "Si" if  ('.5' =~ m{\d+})
Si
  DB&lt;2&gt; print "Si" if  ('.5' =~ m{^\d+})

  DB&lt;3&gt; print "Si" if  '0.7' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}
Si
  DB&lt;4&gt; print "Si" if  '.7' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}

  DB&lt;5&gt; print "Si" if  '1e2' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}
Si
  DB&lt;6&gt; print "Si " while  'ababa' =~ m{a}g
Si Si Si
  DB&lt;7&gt; print "@a" if @a = 'ababa' =~ m{(a)}g
a a a
</PRE>
¿Sabría decir porque la respuesta al primer comando del depurador es
<code>si</code>?.

<P>
</LI>
<LI>Tenga presente el posible conflicto entre los terminales <code>INT</code> y <code>FLOAT</code>.
Si la entrada contiene <code>3.5</code> el terminal debería ser <code>(FLOAT, '3.5')</code>
y no <code>(INT, 3), ('.', '.'), (INT, 5)</code>.

<P>
</LI>
<LI>En esta práctica si lo desea puede instalar y usar 
<A NAME="tex2html354"
  HREF="http://search.cpan.org/~abigail/Regexp-Common-2.120/lib/Regexp/Common.pm">el módulo</A>
<TT>Regexp::Common</TT> 
<A NAME="tex2html355"
  HREF="http://search.cpan.org/~abigail/">mantenido por</A>
<A NAME="12105"></A><SPAN  CLASS="textbf">Abigail</SPAN> el cual provee expresiones regulares para las situaciones mas comunes: números, 
teléfonos, IP, códigos postales, listas, etc. Puede incluso usarlo para encontrar 
soluciones a las cuestiones planteadas en esta práctica:

<P>
<PRE>
nereida:~/doc/casiano/PLBOOK/PLBOOK&gt; perl -MRegexp::Common -e 'print "$RE{num}{int}\n"'
(?:(?:[+-]?)(?:[0123456789]+))
</PRE>
Podemos hacer uso directo del hash <code>%RE</code> directamente 
en las expresiones regulares aprovechando que estas interpolan
las variables en su interior:
 <PRE>
nereida:/tmp&gt; cat -n prueba.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Regexp::Common;
     4
     5  my $input = &lt;&gt;;
     6
     7  print "$&amp;\n" if $input =~ /^$RE{num}{real}$/;
nereida:/tmp&gt; ./prueba.pl
23.45
23.45
nereida:/tmp&gt; ./prueba.pl
jshdf
nereida:/tmp&gt;
</PRE>
</LI>
<LI>Para mejorar la calidad de los mensajes de error extienda el par <code>(terminal, valor)</code>
devuelto por el <code>scanner</code> a un par <code>(terminal, [valor, número de línea ])</code> cuya
segunda componente es un array anónimo conteniendo 
el valor y el número de línea en el que aparece el terminal.

<P>
El siguiente extracto de un analizador léxico muestra como hacerlo:

<P>
<PRE>
sub _Lexer {

  return('', undef) unless defined($input);

  #Skip blanks
      $input=~m{\G((?:
              \s+       # any white space char
          |   \#[^\n]*  # Perl like comments
          )+)}xsgc
    and do {
        my($blanks)=$1;

        #Maybe At EOF
            pos($input) &gt;= length($input)
        and return('', undef);
        $tokenend += $blanks =~ tr/\n//;
    };
    
    $tokenbegin = $tokenend;

      $input=~/\G(and)/gc
    and return($1, [$1, $tokenbegin]);

      $input=~/\G(?:[A-Za-z_][A-Za-z0-9_]*::)*([A-Za-z_][A-Za-z0-9_]*)/gc
    and do {
      return('IDENT', [$1, $tokenbegin]);
    };

    ....................

        $input=~/\G{/gc
    and do {
        my($level,$from,$code);

        $from=pos($input);

        $level=1;
        while($input=~/([{}])/gc) {
                substr($input,pos($input)-1,1) eq '\\' #Quoted
            and next;
                $level += ($1 eq '{' ? 1 : -1)
            or last;
        }
            $level
        and  _SyntaxError("Not closed open curly bracket { at $tokenbegin");
        $code = substr($input,$from,pos($input)-$from-1);
        $tokenend+= $code=~tr/\n//;
        return('CODE', [$code, $tokenbegin]);
    };


    #Always return something
      $input=~/\G(.)/sg
    and do {
      $1 eq "\n" and ++$tokenend;
      return ($1, [$1, $tokenbegin]);
    };
    #At EOF
    return('', undef);
}
</PRE>
El operador <code>tr</code> ha sido utilizado para contar los retornos de carro
(descrito en la sección 
<A HREF="node102.html#section:tr">31.5</A>). El operador, ademas de reemplazar
devuelve el número de carácteres reeemplazados
o suprimidos: 
<PRE>
$cuenta = $cielo =~ tr/*/*/; # cuenta el numero de estrellas en cielo
</PRE>
Para aprender soluciones alternativas consulte 
<code>perldoc -q 'substring'</code>.
</LI>
<LI>Mejore sus mensajes de error ahora que lleva la cuenta de los números
de línea. En vez de usar las rutinas <code>error</code> y <code>fatal</code>
introducidas en la sección anterior escriba una sola rutina
que recibe el nivel de severidad del error (parámetro <code>$level</code>
en el siguiente ejemplo)
y ejecuta la acción apropiada. El código de <code>_SyntaxError</code>
ilustra como hacerlo:
<PRE>
sub _SyntaxError {
  my($level,$message,$lineno)=@_;

  $message= "*".
      [ 'Warning', 'Error', 'Fatal' ]-&gt;[$level].
      "* $message, at ".
      ($lineno &lt; 0 ? "eof" : "line $lineno")." at file $filename\n";

      $level &gt; 1
  and die $message;

  warn $message;

  $level &gt; 0 and ++$nberr;

      $nberr == $max_errors
  and die "*Fatal* Too many errors detected.\n"
}
</PRE>

<P>
</LI>
</UL>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html3951"
  HREF="node116.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3945"
  HREF="node112.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html3939"
  HREF="node114.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3947"
  HREF="node211.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3949"
  HREF="node214.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html3952"
  HREF="node116.html">Pruebas para el Analizador</A>
<B>Sup:</B> <A NAME="tex2html3946"
  HREF="node112.html">Análisis Sintáctico Descendente en</A>
<B> Ant:</B> <A NAME="tex2html3940"
  HREF="node114.html">Las Fases de un</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-05-03</I>
</ADDRESS>
</BODY>
</HTML>
