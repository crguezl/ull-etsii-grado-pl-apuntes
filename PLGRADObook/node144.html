<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Análisis de Ámbito con Parse::Eyapp::Scope</TITLE>
<META NAME="description" CONTENT="Análisis de Ámbito con Parse::Eyapp::Scope">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node145.html">
<LINK REL="previous" HREF="node143.html">
<LINK REL="up" HREF="node138.html">
<LINK REL="next" HREF="node145.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html4689"
  HREF="node145.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4683"
  HREF="node138.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4677"
  HREF="node143.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4685"
  HREF="node234.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4687"
  HREF="node237.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html9"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html4690"
  HREF="node145.html">Resultado del Análisis de</A>
<B>Sup:</B> <A NAME="tex2html4684"
  HREF="node138.html">Análisis de Ámbito en</A>
<B> Ant:</B> <A NAME="tex2html4678"
  HREF="node143.html">La Dificultad de Elaboración</A>
<B> Con:</B> 
<A NAME="tex2html4685"
  HREF="node234.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html4687"
  HREF="node237.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html4691"
  HREF="node144.html#SECTION041260010000000000000">El Método <TT>Parse::Eyapp::Scope-&gt;new</TT></A>
<LI><A NAME="tex2html4692"
  HREF="node144.html#SECTION041260020000000000000">El Método  <TT>begin_scope</TT>  </A>
<LI><A NAME="tex2html4693"
  HREF="node144.html#SECTION041260030000000000000">El Método  <TT>end_scope </TT>  </A>
<LI><A NAME="tex2html4694"
  HREF="node144.html#SECTION041260040000000000000">El Método  <TT>key</TT>  para Nodos con Ámbito</A>
<LI><A NAME="tex2html4695"
  HREF="node144.html#SECTION041260050000000000000">El Modo de Llamada Simplificado a <TT>end_scope</TT></A>
<LI><A NAME="tex2html4696"
  HREF="node144.html#SECTION041260060000000000000">El Método  <TT>scope_instance</TT>  </A>
<LI><A NAME="tex2html4697"
  HREF="node144.html#SECTION041260070000000000000">Cálculo del Ámbito en Bloques</A>
<LI><A NAME="tex2html4698"
  HREF="node144.html#SECTION041260080000000000000">La Jerarquía de Bloques</A>
<LI><A NAME="tex2html4699"
  HREF="node144.html#SECTION041260090000000000000">El Método <TT>names</TT></A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION041260000000000000000">
Análisis de Ámbito con <TT>Parse::Eyapp::Scope</TT></A>
</H1>

<P>
Para calcular la relación entre una instancia de un identificador
y su declaración usaremos el módulo  <TT>Parse::Eyapp::Scope</TT> :
<PRE>
l@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '1,/^ *$/p' Scope.eyp | cat -n
 1  /*
 2  File: lib/Simple/Scope.eyp
 3  Full Scope Analysis
 4  Test it with:
 5    lib/Simple/
 6    eyapp -m Simple::Scope Scope.eyp
 7    treereg -nonumbers -m Simple::Scope Trans
 8    script/
 9    usescope.pl prueba12.c
10  */
11  %{
12  use strict;
13  use Data::Dumper;
14  use List::MoreUtils qw(firstval lastval);
15  use Simple::Trans;
16  use Parse::Eyapp::Scope qw(:all);
</PRE>

<P>
Véamos el 
manejo de las reglas de <code>program</code>:

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^program:/,/^;$/p' Scope.eyp | cat -n
 1  program:
 2        {
 3          reset_file_scope_vars();
 4        }
 5      definition&lt;%name PROGRAM +&gt;.program
 6        {
 7          $program-&gt;{symboltable} = { %st };  # creates a copy of the s.t.
 8          for (keys %type) {
 9            $type{$_} = Parse::Eyapp::Node-&gt;hnew($_);
10          }
11          $program-&gt;{depth} = 0;
12          $program-&gt;{line}  = 1;
13          $program-&gt;{types} = { %type };
14          $program-&gt;{lines} = $tokenend;
15
16          my ($nondec, $declared) = $ids-&gt;end_scope($program-&gt;{symboltable}, $program, 'type');
17
18          if (@$nondec) {
19            warn "Identifier ".$_-&gt;key." not declared at line ".$_-&gt;line."\n" for @$nondec;
20            die "\n";
21          }
22
23          # Type checking: add a direct pointer to the data-structure
24          # describing the type
25          $_-&gt;{t} = $type{$_-&gt;{type}} for @$declared;
26
27          my $out_of_loops = $loops-&gt;end_scope($program);
28          if (@$out_of_loops) {
29            warn "Error: ".ref($_)." outside of loop at line $_-&gt;{line}\n" for @$out_of_loops;
30            die "\n";
31          }
32
33          # Check that are not dangling breaks
34          reset_file_scope_vars();
35
36          $program;
37        }
38  ;
</PRE>

<P>
Antes de comenzar la construcción del AST se inicializan las variables visibles
en todo el fichero:

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^sub reset_file_scope_vars/,/^}$/p' Scope.eyp | cat -n
 1  sub reset_file_scope_vars {
 2    %st = (); # reset symbol table
 3    ($tokenbegin, $tokenend) = (1, 1);
 4    %type = ( INT  =&gt; 1,
 5              CHAR =&gt; 1,
 6              VOID =&gt; 1,
 7            );
 8    $depth = 0;
 9    $ids = Parse::Eyapp::Scope-&gt;new(
10             SCOPE_NAME =&gt; 'block',
11             ENTRY_NAME =&gt; 'info',
12             SCOPE_DEPTH =&gt; 'depth',
13    );
14    $loops = Parse::Eyapp::Scope-&gt;new(
15             SCOPE_NAME =&gt; 'exits',
16    );
17    $ids-&gt;begin_scope();
18    $loops-&gt;begin_scope(); # just for checking
19  }
</PRE>

<P>

<H4><A NAME="SECTION041260010000000000000">
El Método <TT>Parse::Eyapp::Scope-&gt;new</TT></A>
</H4>
  

<P>
El método   <TT>Parse::Eyapp::Scope-&gt;new</TT> 
crea un objeto del tipo manejador de ámbito. 

<P>
Un <A NAME="22368"></A><SPAN  CLASS="textbf">manejador de ámbito</SPAN> es un objeto que ayuda en el cómputo de la función que asigna 
a cada <SPAN  CLASS="textbf">nodo instancia</SPAN> de un nombre (variable, función, etiqueta, constante, identificador de tipo,
etc.)
su <SPAN  CLASS="textbf">declaración</SPAN>, esto es su entrada en su tabla de símbolos.

<P>
En la línea 9 creamos el manejador de ámbito
de los objetos identificadores <code>$ids</code> (ámbito de variables, funciones, etc.). 
En la línea 14 creamos un manejador de ámbito para los bucles (sentencias <code>CONTINUE</code>, <code>break</code>, etc.).
El manejo de ámbito de los bucles consiste en asignar cada ocurrencia de una 
sentencia <code>BREAK</code> o <code>CONTINUE</code> con el bucle en el que ocurre. Por ejemplo:

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/script$ usescope.pl outbreak.c 2
  1 test (int n, int m)
  2 {
  3   break;
  4   while (n &gt; 0) {
  5     if (n&gt;m) {
  6       break;
  7     }
  8     else if (m&gt;n){
  9       continue;
 10     }
 11     n = n-1;
 12   }
 13 }
Error: BREAK outside of loop at line 3
</PRE>
En esta sección mostraremos como usar  <TT>Parse::Eyapp::Scope</TT> 
cuando trabajemos en el análisis de condiciones
dependientes del contexto.

<P>
La filosofía de <A NAME="tex2html382"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp::Scope"><TT>Parse::Eyapp::Scope</TT></A>
es que existen tres tipos de nodos en el AST:

<OL>
<LI>Nodos que definen un ámbito y que tienen asociado un atributo 'tabla de símbolos', 
por ejemplo: Nodos programa, nodos función, nodos bloque conteniendo
declaraciones, etc. Además del atributo tabla de símbolos es común que dichos nodos
dispongan de un atributo 'profundidad de ámbito' que indique su nivel de anidamiento cuando el
lenguaje siendo analizado usa ámbitos anidados.

<P>
</LI>
<LI>Nodos que conllevan un uso de un nombre (<A NAME="22374"></A><SPAN  CLASS="textbf">nodos de uso</SPAN>): 
por ejemplo, nodos de uso de una variable en una
expresión. El propósito del análisis de ámbito es dotar a cada uno de estos nodos de uso con
un atributo 'scope' que referencia al <A NAME="22376"></A><SPAN  CLASS="textbf">nodo ámbito</SPAN> en el que se ha guardado
la información que define las propiedades del objeto. Es posible que además
queramos tener en dicho nodo un atributo 'entry' que sea una referencia
directa a la entrada en la tabla de símbolos asociada con el nombre.

<P>
</LI>
<LI>Otros tipos de nodo. Estos últimos pueden ser ignorados desde el 
punto de vista del análisis de ámbito
</LI>
</OL>

<P>
La asignación de ámbito se implanta 
a través de atributos que se añaden a las nodos de uso y a los nodos ámbito.

<P>
Algunos de los nombres de dichos atributos pueden ser especificados mediante los parámetros 
de <code>new</code>. En concreto:

<P>

<UL>
<LI><TT>SCOPE_NAME</TT>  es el nombre del atributo de la instancia 
que contendrá la referencia al nodo
'bloque' en el que ocurre esta instancia. Si no se especifica toma el valor <code>scope</code>.

<P>
En el ejemplo:

<P>
<PRE>
 9    $ids = Parse::Eyapp::Scope-&gt;new(
10             SCOPE_NAME =&gt; 'block',
11             ENTRY_NAME =&gt; 'info',
12             SCOPE_DEPTH =&gt; 'depth',
13    );
</PRE>

<P>
cada nodo asociado con una instancia de uso tendrá un atributo con clave <code>block</code>
que será una referencia al nodo <code>BLOCK</code> en el que fué declarado el identificador.

<P>
</LI>
<LI><TT>ENTRY_NAME</TT>  es el nombre del atributo de la instancia
que contendrá la referencia a 
la entrada de símbolos que corresponde a esta instancia. Si no se
especifica tomará el valor <code>entry</code>.

<P>
En el ejemplo que estamos trabajando cada nodo <code>BLOCK</code> tendrá un atributo
<code>symboltable</code> que será una referencia a la tabla de símbolos asociada con el bloque.
Dado que el atributo <code>block</code> de un nodo <code>$n</code> asociado 
con una instancia de un identificador <code>$id</code> apunta
al nodo <code>BLOCK</code> en el que se define, siempre sería posible
acceder a la entrada de la tabla de símbolos mediante el código: 
<PRE>
                                   $n-&gt;{block}{symboltable}{$id}
</PRE>
El atributo <code>entry</code> crea una referencia directa en el nodo:
<PRE>
                            $n-&gt;{entry} = $n-&gt;{block}{symboltable}{$id}
</PRE>
de esta forma es mas directo acceder a la entrada de símbolos de una instancia
de uso de un identificador.

<P>
Obviamente el atributo <code>entry</code> no tiene sentido
en aquellos casos en que el análisis de ámbito no requiere
de la presencia de tablas de símbolos, como es el caso del
análisis de ámbito de las sentencias de cambio de flujo en
bucles: 
<PRE>
14    $loops = Parse::Eyapp::Scope-&gt;new(
15             SCOPE_NAME =&gt; 'exits',
16    );
</PRE>
</LI>
<LI><TT>SCOPE_DEPTH</TT>  es el nombre del atributo del nodo ámbito (nodo bloque)
y contiene la profundidad de anidamiento del ámbito. Es opcional. Si no
se especifica no será guardado.
</LI>
</UL>

<P>

<H4><A NAME="SECTION041260020000000000000">
El Método  <TT>begin_scope</TT>  </A>
</H4>
  

<P>
Este método debe ser llamado cada vez que se entra en una nueva región de ámbito.
<A NAME="tex2html383"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp::Scope"><TT>Parse::Eyapp::Scope</TT></A>
asume un esquema de ámbitos léxicos anidados como ocurre en la mayoría
de los lenguajes de programación: se supone que 
todos los nodos declarados mediante llamadas al método <code>scope_instance</code>
entre dos llamadas consecutivas a <code>begin_scope</code> y <code>end_scope</code>
definen la región del ámbito.
Por ejemplo, en el analisis de ámbito de SimpleC llamamos a
<code>begin_scope</code> cada vez que se entra en una definición de función:
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^funcDef:/,/^;$/p' Scope.eyp | cat -n
  1  funcDef:
  2      $ID
  3         {
  4           $ids-&gt;begin_scope();
  5         }
  6      '('  $params  ')'
  7      $block
  8        {
 ..           ........................................
 35        }
 36  ;
</PRE>
y cada vez que se entra en un bloque:
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^block:/,/^;$/p' Scope.eyp | cat -n
  1  block:
  2      '{'.bracket
  3         { $ids-&gt;begin_scope(); }
  4       declaration&lt;%name DECLARATIONS *&gt;.decs statement&lt;%name STATEMENTS *&gt;.sts '}'
  5         {
 25           ................
 26         }
 27
 28  ;
</PRE>

<P>
En el caso del análisis de
ámbito de bucles la entrada en un bucle crea una nueva región de ámbito:

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^loopPrefix:/,/^;$/p' Scope.eyp | cat -n
  1  loopPrefix:
  2      $WHILE '(' expression ')'
  3        {
  4          $loops-&gt;begin_scope;
  5          $_[3]-&gt;{line} = $WHILE-&gt;[1];
  6          $_[3]
  7        }
  8  ;
</PRE>

<P>

<H4><A NAME="SECTION041260030000000000000">
 El Método  <TT>end_scope </TT>  </A>
</H4>
  

<P>
En el código que sigue
el método <code>end_scope</code> es llamado con tres argumentos:
<PRE>
           my ($nodec, $dec) = $ids-&gt;end_scope($st, $block, 'type');
</PRE>
El significado de estos argumentos es el siguiente:

<OL>
<LI>Una referencia a un hash <code>$st</code>.
Este hash es la tabla de símbolos asociada con el bloque actual.
Se asume que la clave de entrada de un nodo <code>$n</code> del árbol
se obtiene mediante una llamada al método del nodo <code>key</code> definido 
por el programador: <code>$st-&gt;{$n-&gt;key}</code>. Se asume también que los 
valores del hash son una referencia a un hash conteniendo los atributos
asociados con la clave <code>$n-&gt;key</code>.
</LI>
<LI>Una referencia
al nodo bloque <code>$block</code> o nodo de ámbito asociado con el hash. 
En nuestro ejemplo del análisis de ámbito de los identificadores
las instancias de identificadores declarados en el presente bloque
seran decorados con un atributo <code>block</code> que apunta a dicho nodo.
El nombre es  <code>block</code> porque así se específico en la llamada a <code>new</code>:
<PRE>
 9    $ids = Parse::Eyapp::Scope-&gt;new(
10             SCOPE_NAME =&gt; 'block',
11             ENTRY_NAME =&gt; 'info',
12             SCOPE_DEPTH =&gt; 'depth',
13    );
</PRE>

<P>
</LI>
<LI>Los argumentos adicionales como <code>'type'</code>
que sean pasados a <code>end_scope</code> son interpretados como claves del hash 
apuntado por su entrada en la tabla de símbolos <code>$n-&gt;key</code>.
Para cada uno de esos argumentos se crean referencias directas en el nodo <code>$n</code> a los mismos:
<PRE>
$n-&gt;{type} = $st-&gt;{$n-&gt;key}{type}
</PRE>
</LI>
</OL>
La llamada <code>$ids-&gt;end_scope($st, $block, 'type')</code> ocurre después del
análisis de todo el bloque de la función:
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^funcDef:/,/^;$/p' Scope.eyp | cat -n
 1  funcDef:
 2      $ID
 3         {
 4           $ids-&gt;begin_scope();
 5         }
 6      '('  $params  ')'
 7      $block
 8        {
 9           my $st = $block-&gt;{symboltable};
10           my @decs = $params-&gt;children();
11           $block-&gt;{parameters} = [];
12           while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
..             ..................................................
24           }
25           $block-&gt;{function_name} = $ID;
26           $block-&gt;type("FUNCTION");
27
28           my ($nodec, $dec) = $ids-&gt;end_scope($st, $block, 'type');
29
30           # Type checking: add a direct pointer to the data-structure
31           # describing the type
32           $_-&gt;{t} = $type{$_-&gt;{type}} for @$dec;
33
34           return $block;
35        }
36  ;
</PRE>
Todos los nodos <code>$n</code> del árbol que fueron
declarados como instancias mediante llamadas al método
<code>scope_instance</code>
desde la última llamada a  <code>begin_scope</code>
son buscados en el hash referenciado por <code>$st</code>.
Si la clave <code>$n-&gt;key</code> asociada con el nodo <code>$n</code>
se encuentra entre las claves del hash (esto es,
<code>exists $st-&gt;{$n-&gt;key}</code>) el nodo se
anota como <SPAN  CLASS="textbf">declarado</SPAN>. Los nodos-instancia para los cuales
no existe una entrada en la tabla de símbolos se consideran
<SPAN  CLASS="textbf">no declarados</SPAN>.

<P>
Cuando un nodo se determina como declarado 
se establecen los atributos de 
declaración: 

<UL>
<LI>Una referencia a su entrada en la tabla de símbolos
(cuyo nombre fue establecido mediante el parámetro <code>ENTRY_NAME</code>
de <code>new</code>) 
<PRE>
$n-&gt;{$ids-&gt;{ENTRY_NAME}} = $st-&gt;{$n-&gt;key}
</PRE>
Si por ejemplo el nodo siendo usado se corresponde con el uso de una variable de nombre <code>a</code>,
entonces <code>$n-&gt;key</code> deberá retornar <code>a</code> y la asignación anterior, asumiendo la declaración
previa del manejador de ámbito <code>$ids</code>, sería:
<PRE>
$n-&gt;{info} = $st-&gt;{a}
</PRE>

<P>
</LI>
<LI>Una referencia al bloque
en el que fué declarado (el nombre del atributo será el establecido
en <code>SCOPE_NAME</code>). 
<PRE>
$n-&gt;{$ids-&gt;{SCOPE_NAME}} = $block
</PRE>
Si por ejemplo el nodo siendo usado se corresponde con el uso de una variable de nombre <code>a</code>,
la asignación anterior, asumiendo la declaración
previa del manejador de ámbito <code>$ids</code>, sería:
<PRE>
$n-&gt;{block} = $block
</PRE>
donde <code>$block</code> es el nodo asociado con el bloque en el que fue declarado
<code>$a</code>.
</LI>
<LI>Cualesquiera argumentos
adicionales - como <code>'type'</code> en el ejemplo - 
que sean pasados a <code>end_scope</code> son interpretados
como claves del hash apuntado por su entrada en la tabla de 
símbolos <code>$st-&gt;{$n-&gt;key}</code>. Para cada uno de esos argumentos
se crean referencias directas en el nodo <code>$n</code> a los mismos.
<PRE>
$n-&gt;{type} = $st-&gt;{$n-&gt;key}{type}
</PRE>
esto es:
<PRE>
$n-&gt;{type} = $st-&gt;{a}{type}
</PRE>
</LI>
</UL>

<P>
Se supone que antes de la llamada
a <TT>end_scope</TT> las declaraciones de los diferentes objetos
han sido procesadas
y la tabla hash ha sido rellenada con las mismas.

<P>
Los nodos <code>$n</code> que no aparezcan entre los
declarados en este ámbito  son apilados en la esperanza de que 
hayan sido declarados en un ámbito superior.

<P>
Para un ejemplo de uso véase la línea 28 en el código anterior. 
El tercer argumento <code>type</code> indica que para cada instancia
de variable global que ocurre en el ámbito de <code>program</code>
queremos que se cree una referencia desde el nodo a su entrada
<code>type</code> en la tabla de símbolos. De este modo se puede
conseguir un acceso mas rápido al tipo de la instancia si bien a costa
de aumentar el consumo de memoria.

<P>
En un contexto de lista <code>end_scope</code> devuelve un par de referencias.
La primera es una referencia a la lista de instancias/nodos
del ámbito actual que no aparecen como claves
del hash. La segunda a los que aparecen. 

<P>
En un contexto escalar devuelve la lista de instancias/nodos 
no declarados.

<P>

<H4><A NAME="SECTION041260040000000000000">
El Método  <TT>key</TT>  para Nodos con Ámbito</A>
</H4>
  

<P>
El programador deberá proveer a cada clase de nodo (subclases de <code>Parse::Eyapp::Node</code>)
que pueda ser instanciado/usado en un ámbito o bloque de un método  <TT>key</TT> . 
En nuestro caso los nodos 
del tipo <code>VAR</code>, <code>VARARRAY</code> y <code>FUNCTIONCALL</code> son los que 
pueden
ser usados dentro de expresiones y sentencias.

<P>
El método  <TT>key</TT>  
se usa para computar el valor de la clave de 
entrada en el hash para esa clase de nodo.

<P>
Para la tabla de símbolos de los identificadores
en SimpleC necesitamos definir el método <code>key</code> para los nodos <code>VAR</code>,
<code>VARARRAY</code> y <code>FUNCTIONCALL</code>:

<P>
<PRE>
827 sub VAR::key {
828   my $self = shift;
829
830   return $self-&gt;child(0)-&gt;{attr}[0];
831 }
832
833 *VARARRAY::key = *FUNCTIONCALL::key = \&amp;VAR::key;
</PRE>

<P>
Si tiene dudas repase la definición de <code>Variable</code>
en la descripción de la gramática en la página <A HREF="node140.html#parrafo:elcuerpo"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>:

<P>
<PRE>
Variable:
    %name VAR
    ID 
  | %name  VARARRAY
    $ID ('[' binary ']') &lt;%name INDEXSPEC +&gt; 
;
</PRE>
y el subárbol para la asignación de <code>a = 2</code> en la página <A HREF="node140.html#parrafo:ejemplodearbolconstruido"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.
<PRE>
ASSIGN(
  VAR(
    TERMINAL[a:5]
  ),
  INUM(
    TERMINAL[2:5]
  )
) # ASSIGN,
</PRE>

<P>

<H4><A NAME="SECTION041260050000000000000">
El Modo de Llamada Simplificado a <TT>end_scope</TT></A>
</H4>
  

<P>
En el caso de un análisis de ámbito simple como es el análisis de ámbito
de los bucles no se requiere de la presencia de una tabla de símbolos.
El único argumento de <code>end_scope</code> es la referencia al nodo que define 
el ámbito. 

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^statement:/,/^;$/p' Scope.eyp | cat -n
  1  statement:
  2      expression ';' { $_[1] }
  3    | ';'
  4    | %name BREAK
  5      $BREAK ';'
  6        {
  7          my $self = shift;
  8          my $node = $self-&gt;YYBuildAST(@_);
  9          $node-&gt;{line} = $BREAK-&gt;[1];
 10          $loops-&gt;scope_instance($node);
 11          return $node;
 12        }
 13    | %name CONTINUE
 14       $CONTINUE ';'
 15        {
 19          ...............................
 21        }
 ..    .....................................
 34    | %name WHILE
 35      $loopPrefix statement
 36        {
 37          my $self = shift;
 38          my $wnode = $self-&gt;YYBuildAST(@_);
 39          $wnode-&gt;{line} = $loopPrefix-&gt;{line};
 40          my $breaks = $loops-&gt;end_scope($wnode);
 41          return $wnode;
 42        }
 43  ;
</PRE>

<P>

<H4><A NAME="SECTION041260060000000000000">
El Método  <TT>scope_instance</TT>  </A>
</H4>
  

<P>
Este método del objeto <A NAME="tex2html384"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp::Scope"><TT>Parse::Eyapp::Scope</TT></A>
empuja el nodo 
que se le pasa como argumento en la cola de instancias del 
manejador de ámbito.
El nodo se considerará una ocurrencia de un objeto dentro 
del ámbito actual (el que comienza en la última ejecución 
de <code>begin_scope</code>).  En el compilador de <code>SimpleC</code> debemos hacer:

<P>
<A NAME="code:primary"></A><PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^Primary:/,/^;$/p' Scope.eyp | cat -n
  1  Primary:
  2      %name INUM
  3      INUM
  4    | %name CHARCONSTANT
  5      CHARCONSTANT
  6    | $Variable
  7        {
  8          $ids-&gt;scope_instance($Variable);
  9          return $Variable
 10        }
 11    | '(' expression ')' { $_[2] }
 12    | $function_call
 13        {
 14          $ids-&gt;scope_instance($function_call);
 15          return $function_call  # bypass
 16        }
 17  ;
</PRE>

<P>
Otros lugares en los que ocurren instancias de identificadores son las 
asignaciones:
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^binary:/,/^;$/p' Scope.eyp | cat -n
  1  binary:
  2      Unary { $_[1] }
  3    | %name PLUS
  4      binary '+' binary
 ..    ...................
 23    | %name ASSIGN
 24      $Variable '=' binary
 25        {
 26          goto &amp;declare_instance_and_build_node;
 27        }
 28    | %name PLUSASSIGN
 29      $Variable '+=' binary
 30        {
 31          goto &amp;declare_instance_and_build_node;
 32        }
 33    | %name MINUSASSIGN
 34      $Variable '-=' binary
 35        {
 36          goto &amp;declare_instance_and_build_node;
 37        }
 38    | %name TIMESASSIGN
 39      $Variable '*=' binary
 40        {
 41          goto &amp;declare_instance_and_build_node;
 42        }
 43    | %name DIVASSIGN
 44      $Variable '/=' binary
 45        {
 46          goto &amp;declare_instance_and_build_node;
 47        }
 48    | %name MODASSIGN
 49      $Variable '%=' binary
 50        {
 51          goto &amp;declare_instance_and_build_node;
 52        }
 53  ;
</PRE>
Como indica su nombre, la función <code>declare_instance_and_build_node</code>
declara la instancia y crea el nodo del AST:
<PRE>
116 sub declare_instance_and_build_node {
117   my ($parser, $Variable) = @_[0,1];
118
119   $ids-&gt;scope_instance($Variable);
120   goto &amp;Parse::Eyapp::Driver::YYBuildAST;
121 }
</PRE>

<P>
En el caso del análisis de ámbito en bucles las instancias ocurren en las
sentencias de <code>break</code> y <code>continue</code>:

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^statement:/,/^;$/p' Scope.eyp | cat -n
 1  statement:
 2      expression ';' { $_[1] }
 3    | ';'
 4    | %name BREAK
 5      $BREAK ';'
 6        {
 7          my $self = shift;
 8          my $node = $self-&gt;YYBuildAST(@_);
 9          $node-&gt;{line} = $BREAK-&gt;[1];
10          $loops-&gt;scope_instance($node);
11          return $node;
12        }
13    | %name CONTINUE
14       $CONTINUE ';'
15        {
16          my $self = shift;
17          my $node = $self-&gt;YYBuildAST(@_);
18          $node-&gt;{line} = $CONTINUE-&gt;[1];
19          $loops-&gt;scope_instance($node);
20          return $node;
21        }
..    .....................................
34    | %name WHILE
35      $loopPrefix statement
36        {
37          my $self = shift;
38          my $wnode = $self-&gt;YYBuildAST(@_);
39          $wnode-&gt;{line} = $loopPrefix-&gt;{line};
40          my $breaks = $loops-&gt;end_scope($wnode);
41          return $wnode;
42        }
43  ;
</PRE>

<P>

<H4><A NAME="SECTION041260070000000000000">
Cálculo del Ámbito en Bloques</A>
</H4>

<P>
El modo de uso se ilustra en el manejo de los bloques
<PRE>
                      block: '{' declaration * statement * '}'
</PRE>

<P>
La computación del ámbito requiere las siguientes etapas:

<OL>
<LI>Es necesario introducir una acción intermedia (línea 3) para indicar
que una "llave abrir" determina el comienzo de un bloque. 
</LI>
<LI><P>
Durante las sucesivas visitas a <code>declaration</code> construímos
tablas de símbolos que son mezcladas en las líneas 8-15.
</LI>
<LI><P>
Todas
las instancias de nodos-nombre que ocurren cuando se 
visitan los hijos de <code>statements</code> son declaradas como
instanciaciones con <code>scope_instance</code> (véanse los acciones
semánticas para <code>Primary</code> en la página <A HREF="node144.html#code:primary"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>).
</LI>
<LI><P>
La llamada a <code>end_scope</code> de la línea 19
produce la computación parcial de la función de asignación de ámbito
para los nodos/nombre que fueron instanciados en este bloque.
</LI>
</OL>

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/^block:/,/^;$/p' Scope.eyp | cat -n
 1  block:
 2      '{'.bracket
 3         { $ids-&gt;begin_scope(); }
 4       declaration&lt;%name DECLARATIONS *&gt;.decs statement&lt;%name STATEMENTS *&gt;.sts '}'
 5         {
 6           my %st;
 7
 8           for my $lst ($decs-&gt;children) {
 9
10               # control duplicated declarations
11             my $message;
12             die $message if $message = is_duplicated(\%st, $lst);
13
14             %st = (%st, %$lst);
15           }
16           $sts-&gt;{symboltable} = \%st;
17           $sts-&gt;{line} = $bracket-&gt;[1];
18           $sts-&gt;type("BLOCK") if (%st);
19           my ($nondec, $dec) = $ids-&gt;end_scope(\%st, $sts, 'type');
20
21           # Type checking: add a direct pointer to the data-structure
22           # describing the type
23           $_-&gt;{t} = $type{$_-&gt;{type}} for @$dec;
24
25           return $sts;
26         }
27
28  ;
</PRE>

<P>
Actualmente las acciones intermedias tal y como la que se ven en el código anterior
se usan habitualmente para producir efectos laterales en la construcción
del árbol. No dan lugar a la inserción de un nodo. Esto es, la variable 
auxiliar/temporal generada para dar lugar a la acción intermedia
no es introducida en el árbol generado.

<P>

<H4><A NAME="SECTION041260080000000000000">
La Jerarquía de Bloques</A>
</H4>
  

<P>
Para completar el análisis de ámbito queremos decorar cada nodo <code>BLOCK</code>
con un atributo <code>fatherblock</code> que referencia al nodo bloque 
que lo contiene. Para esta fase usaremos el lenguaje  <TT>Treeregexp</TT> . 
Las frases de este lenguaje permiten definir conjuntos de árboles. Cuando van en un fichero aparte los programas 
<code>Treeregexp</code> suelen tener la extensión <code>trg</code>. Por ejemplo,
el siguiente programa 
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ cat -n Trans.trg
     1  /* Scope Analysis */
     2  blocks:  /BLOCK|FUNCTION|PROGRAM/
     3
     4  retscope: /FUNCTION|RETURN/
     5
     6  loop_control: /BREAK|CONTINUE|WHILE/
</PRE>
define tres expresiones árbol a las que nos podremos referir en el
cliente mediante las variables <code>$blocks</code>, <code>$retscope</code> y 
<code>loops_control</code>. La primera expresión árbol tiene por nombre <code>blocks</code>
y casará con cualesquiera árboles de las clases <code>BLOCK</code>, <code>FUNCTION</code> o <code>PROGRAM</code>.
Es necesario compilar el programa <code>Treeregexp</code>:
<PRE>
l@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ treereg -m Simple::Scope Trans
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ ls -ltr | tail -2
-rw-r--r-- 1 pl users   122 2007-12-10 11:49 Trans.trg
-rw-r--r-- 1 pl users  1544 2007-12-10 11:49 Trans.pm
</PRE>
El módulo generado <code>Trans.pm</code> contendrá una subrutina por cada expresión
regular árbol en el programa <code>Treeregexp</code>. 
La subrutina devuelve cierto si el nodo que se le pasa como primer argumento 
casa con la expresión árbol. La subrutina espera como primer argumento el nodo, como
segundo argumento el padre del nodo y como tercero el objeto <code>Parse::Eyapp::YATW</code> que encapsula 
la transformación:
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '19,31p' Trans.pm
  sub blocks {
    my $blocks = $_[3]; # reference to the YATW pattern object
    my $W;

    {
      my $child_index = 0;

      return 0 unless ref($W = $_[$child_index]) =~ m{\bBLOCK\b|\bFUNCTION\b|\bPROGRAM\b}x;

    } # end block of child_index
    1;

  } # end of blocks
</PRE>
No solo se construye una subrutina <code>blocks</code> sino que en el espacio de nombres
correspondiente se crean objetos  <code>Parse::Eyapp::YATW</code> por cada una de las
transformaciones especificadas en el programa <code>trg</code>, como muestra el siguiente
fragmento del módulo conteniendo el código generado por <code>treeregexp</code>:
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '16p' Trans.pm
our @all = ( our $blocks, our $retscope, our $loop_control, ) = 
  Parse::Eyapp::YATW-&gt;buildpatterns(
    blocks =&gt; \&amp;blocks, 
    retscope =&gt; \&amp;retscope, 
    loop_control =&gt; \&amp;loop_control, 
  );
</PRE>

<P>
Estos objetos <code>Parse::Eyapp::YATW</code> estan disponibles 
en el programa eyapp ya que hemos importado el módulo: 
<PRE>
l@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '1,/^ *$/p' Scope.eyp | cat -n
 1  /*
 2  File: lib/Simple/Scope.eyp
 3  Full Scope Analysis
 4  Test it with:
 5    lib/Simple/
 6    eyapp -m Simple::Scope Scope.eyp
 7    treereg -nonumbers -m Simple::Scope Trans
 8    script/
 9    usescope.pl prueba12.c
10  */
11  %{
12  use strict;
13  use Data::Dumper;
14  use List::MoreUtils qw(firstval lastval);
15  use Simple::Trans;
16  use Parse::Eyapp::Scope qw(:all);
</PRE>

<P>
Es por eso que, una vez realizadas las fases de análisis léxico, 
sintáctico y de ámbito podemos usar el objeto  <code>$blocks</code> 
y el método <code>m</code> (por <code>matching</code>) de dicho objeto
(véase la línea 14 en el código de <code>compile</code>):

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/lib/Simple$ sed -ne '/sub comp/,/^}/p' Scope.eyp | cat -n
 1  sub compile {
 2   my($self)=shift;
 3
 4   my ($t);
 5
 6   $self-&gt;YYData-&gt;{INPUT} = shift;
 7
 8   $t = $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
 9                        #yydebug =&gt; 0x1F
10       );
11
12   # Scope Analysis: Block Hierarchy
13   our $blocks;
14   my @blocks = $blocks-&gt;m($t);
15   $_-&gt;node-&gt;{fatherblock} = $_-&gt;father-&gt;{node} for (@blocks[1..$#blocks]);
16
..   .................................
28
29   return $t;
30  }
</PRE>

<P>
El método <code>m</code> para árboles y expresiones regulares árbol
<code>YATW</code> funciona de manera parecida 
al método <code>m</code> para cadenas y expresiones regulares convencionales.
El resultado de un matching en árboles es un árbol. Si se trabaja en un contexto
de lista es una lista de árboles.

<P>
La llamada <code>$blocks-&gt;m($t)</code> permite la búsqueda 
de los nodos de <code>$t</code> que casan con la expresión regular árbol para <code>blocks</code>.
En un contexto de lista <code>m</code> devuelve una 
lista con nodos del
tipo  <TT>Parse::Eyapp::Node::Match</TT>  que referencian
a los nodos que han casado. 
Los nodos <code>Parse::Eyapp::Node::Match</code>
son a su vez nodos (heredan de) 
<code>Parse::Eyapp::Node</code>.
Los nodos 
aparecen en la lista retornada en orden primero profundo de 
recorrido del árbol <code>$t</code>.

<P>
Los nodos en la lista
se estructuran según un árbol (atributos <code>children</code> y <code>father</code>)
de manera que el padre
de un nodo <code>$n</code> del tipo <code>Parse::Eyapp::Node::Match</code> es el 
nodo <code>$f</code> que referencia al inmediato antecesor 
en el árbol que ha casado. 

<P>
Un nodo <code>$r</code> de la clase 
<code>Parse::Eyapp::Node::Match</code> dispone de varios atributos
y métodos:

<UL>
<LI>El método <code>$r-&gt;node</code> retorna el nódo del árbol <code>$t</code> que ha casado
</LI>
<LI>El método <code>$r-&gt;father</code> retorna el nodo padre en el árbol the matching.
Se cumple que <code>$r-&gt;father-&gt;node</code> es 
una referencia al antepasado mas cercano en <code>$t</code>
de  <code>$r-&gt;node</code> que casa con el patrón árbol.
</LI>
<LI>El método <code>$r-&gt;coord</code> retorna las coordenadas del nódo del árbol que ha casado
usando una notación con puntos. Por ejemplo la coordenada
<code>".1.3.2"</code> 
denota al nodo <code>$t-&gt;child(1)-&gt;child(3)-&gt;child(2)</code>, siendo <code>$t</code>
la raíz del árbol de búsqueda.
</LI>
<LI>El método <code>$r-&gt;depth</code> retorna la profundidad del nódo del árbol que ha casado
</LI>
</UL>

<P>
En un contexto escalar <code>m</code> devuelve el primer
elemento de la lista de nodos <code>Parse::Eyapp::Node::Match</code>.

<P>
<PRE>
pl@nereida:~/Lbook/code/Simple-Scope/script$ perl -wd usescope.pl blocks.c 2

Loading DB routines from perl5db.pl version 1.28
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(usescope.pl:6):  my $filename = shift || die "Usage:\n$0 file.c\n";
  DB&lt;1&gt; c Simple::Scope::compile

   1 test (int n)
   2 {
   3   int a;
   4
   5   while (1) {
   6     if (1&gt;0) {
   7       int a;
   8       break;
   9     }
  10     else if (2&gt;0){
  11       char b;
  12       continue;
  13     }
  14   }
  15 }
Simple::Scope::compile(Scope.eyp:784):
784:     my($self)=shift;
 DB&lt;2&gt; l 783,797
783     sub compile {
784==&gt;   my($self)=shift;
785
786:     my ($t);
787
788:     $self-&gt;YYData-&gt;{INPUT} = shift;
789
790:     $t = $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
791                           #yydebug =&gt; 0x1F
792          );
793
794      # Scope Analysis: Block Hierarchy
795:     our $blocks;
796:     my @blocks = $blocks-&gt;m($t);
797:     $_-&gt;node-&gt;{fatherblock} = $_-&gt;father-&gt;{node} for (@blocks[1..$#blocks]);
  DB&lt;3&gt; c 797
Simple::Scope::compile(Scope.eyp:797):
797:     $_-&gt;node-&gt;{fatherblock} = $_-&gt;father-&gt;{node} for (@blocks[1..$#blocks]);
  DB&lt;4&gt; x Parse::Eyapp::Node-&gt;str(@blocks)
0  '
Match[[PROGRAM:0:blocks]](
  Match[[FUNCTION:1:blocks:test]](
    Match[[BLOCK:6:blocks:10:4]],
    Match[[BLOCK:5:blocks:6:4]]
  )
)'
1  '
Match[[FUNCTION:1:blocks:test]](
  Match[[BLOCK:6:blocks:10:4]],
  Match[[BLOCK:5:blocks:6:4]]
)'
2  '
Match[[BLOCK:5:blocks:6:4]]'
3  '
Match[[BLOCK:6:blocks:10:4]]'
</PRE>
La información que aparece en los nodos <code>Match</code> es como sigue:

<UL>
<LI>La clase del nodo al que referencia <code>PROGRAM</code>, <code>FUNCTION</code>, etc.
</LI>
<LI>La profundidad del nodo que ha casado en <code>$t</code>
</LI>
<LI>Los nombres de las transformaciones con las que casó el nodo
</LI>
<LI>Si el nodo tiene un método <code>info</code> la información asociada.
En este caso la línea y la profundidad en los bloques.
</LI>
</UL>

<P>
<PRE>
 DB&lt;5&gt; p $t-&gt;str

PROGRAM^{0}(
  FUNCTION[test]^{1}(                                 #  test (int n) {
    WHILE(                                            #    while (1) {
      INUM(TERMINAL[1:5]),
      STATEMENTS(
        IFELSE(                                       #      if (1&gt;0) {
          GT(INUM( TERMINAL[1:6]), INUM(TERMINAL[0:6])),
          BLOCK[6:4]^{2}(
            BREAK                                     #         break;
          ),                                          #      }
          IF(                                         #      else if (2&gt;0){
            GT(INUM(TERMINAL[2:10]), INUM(TERMINAL[0:10])),
            BLOCK[10:4]^{3}(
              CONTINUE                                #         continue
            )                                         #      }
          )
        )
      )
    )
  )
)
....
  DB&lt;6&gt; x map {$_-&gt;coord} @blocks
0  ''
1  '.0'
2  '.0.0.1.0.1'
3  '.0.0.1.0.2.1'
  DB&lt;7&gt;  p $t-&gt;descendant('.0.0.1.0.2.1')-&gt;str

BLOCK[10:4]^{0}(
  CONTINUE
)
---------------------------
0)
Symbol Table of block at line 10
$VAR1 = {
          'b' =&gt; {
                   'type' =&gt; 'CHAR',
                   'line' =&gt; 11
                 }
        };
 DB&lt;8&gt; x map {$_-&gt;depth} @blocks
0  0
1  1
2  5
3  6
  DB&lt;9&gt; x  map {ref($_-&gt;node) } @blocks
0  'PROGRAM'
1  'FUNCTION'
2  'BLOCK'
3  'BLOCK'
  DB&lt;10&gt; x  map {ref($_-&gt;father) } @blocks
0  ''
1  'Parse::Eyapp::Node::Match'
2  'Parse::Eyapp::Node::Match'
3  'Parse::Eyapp::Node::Match'
  DB&lt;11&gt; x  map {ref($_-&gt;father-&gt;node) } @blocks[1..3]
0  'PROGRAM'
1  'FUNCTION'
2  'FUNCTION'
  DB&lt;12&gt; x  $blocks[2]-&gt;father-&gt;node-&gt;{function_name}
0  ARRAY(0x86ed84c)
   0  'test'
   1  1
</PRE>

<P>

<H4><A NAME="SECTION041260090000000000000">
El Método <TT>names</TT></A>
</H4>
  

<P>
La clase <code>Parse::Eyapp::Node::Match</code> 
dispone además de otros métodos
para el caso en que se usan varios patrones en la misma búsqueda.
Por ejemplo, el método <code>$r-&gt;names</code> retorna una referencia a los nombres de los patrones
que han casado con el nodo.
En el ejemplo que sigue aparecen tres transformaciones
<code>fold</code>, <code>zxw</code> y <code>wxz</code>. La llamada a 
<code>m</code> de la línea 19 toma una forma diferente. ahora
<code>m</code> es usado como método del árbol <code>$t</code> y recibe como argumentos
la lista con los objetos expresiones regulares árbol (<code>Parse::Eyapp::YATW</code>).
<PRE>
pl@nereida:~/LEyapp/examples$ cat -n m2.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Rule6;
 4  use Parse::Eyapp::Treeregexp;
 5
 6  Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
 7    fold: /TIMES|PLUS|DIV|MINUS/(NUM, NUM)
 8    zxw: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 }
 9    wxz: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 }
10  })-&gt;generate();
11
12  # Syntax analysis
13  my $parser = new Rule6();
14  my $input = "0*0*0";
15  my $t = $parser-&gt;Run(\$input);
16  print "Tree:",$t-&gt;str,"\n";
17
18  # Search
19  my $m = $t-&gt;m(our ($fold, $zxw, $wxz));
20  print "Match Node:\n",$m-&gt;str,"\n";
</PRE>
La primera expresión regular árbol <code>fold</code> casa con cualquier árbol tal
que la clase del nodo raíz case con la expresión regular (clásica) 
<code>/TIMES|PLUS|DIV|MINUS/</code> y tenga dos hijos de clase <code>NUM</code>.

<P>
La segunda expresión regular <code>zxw</code> (por <SPAN  CLASS="textbf">zero
times whatever</SPAN>) casa con cualquier árbol tal que la clase del 
nodo raíz es <code>TIMES</code> y cuyo primer hijo pertenece a la clase
<code>NUM</code>. Se debe cumplir además que el hijo del nodo <code>NUM</code> 
(el nodo <code>TERMINAL</code> proveído por el analizador léxico)
debe tener su atributo <code>attr</code> a cero. La notación
<code>NUM($x)</code> hace que en <code>$x</code> se almacene una referencia al nodo
hijo de <code>NUM</code>.
La expresión regular árbol <code>wxz</code> es la simétrica de <code>zxw</code>.

<P>
Cuando se ejecuta, el programa produce la salida:
<PRE>
pl@nereida:~/LEyapp/examples$ m2.pl
Tree:TIMES(TIMES(NUM(TERMINAL),NUM(TERMINAL)),NUM(TERMINAL))
Match Node:
Match[[TIMES:0:wxz]](Match[[TIMES:1:fold,zxw,wxz]])
</PRE>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html4689"
  HREF="node145.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4683"
  HREF="node138.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4677"
  HREF="node143.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4685"
  HREF="node234.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4687"
  HREF="node237.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html9"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html4690"
  HREF="node145.html">Resultado del Análisis de</A>
<B>Sup:</B> <A NAME="tex2html4684"
  HREF="node138.html">Análisis de Ámbito en</A>
<B> Ant:</B> <A NAME="tex2html4678"
  HREF="node143.html">La Dificultad de Elaboración</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-01-17</I>
</ADDRESS>
</BODY>
</HTML>
