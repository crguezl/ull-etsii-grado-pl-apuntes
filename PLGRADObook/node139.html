<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Análisis de Ámbito: Conceptos</TITLE>
<META NAME="description" CONTENT="Análisis de Ámbito: Conceptos">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node140.html">
<LINK REL="previous" HREF="node138.html">
<LINK REL="up" HREF="node138.html">
<LINK REL="next" HREF="node140.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html4593"
  HREF="node140.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4587"
  HREF="node138.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4581"
  HREF="node138.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4589"
  HREF="node234.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4591"
  HREF="node237.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html9"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html4594"
  HREF="node140.html">Descripción Eyapp del Lenguaje</A>
<B>Sup:</B> <A NAME="tex2html4588"
  HREF="node138.html">Análisis de Ámbito en</A>
<B> Ant:</B> <A NAME="tex2html4582"
  HREF="node138.html">Análisis de Ámbito en</A>
<B> Con:</B> 
<A NAME="tex2html4589"
  HREF="node234.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html4591"
  HREF="node237.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html4595"
  HREF="node139.html#SECTION041210010000000000000">El Problema del Análisis de Ámbito</A>
<LI><A NAME="tex2html4596"
  HREF="node139.html#SECTION041210020000000000000">Binding Estático y Binding Dinámico</A>
<LI><A NAME="tex2html4597"
  HREF="node139.html#SECTION041210030000000000000">Intervención del Programador en Tiempo de Compilación</A>
<LI><A NAME="tex2html4598"
  HREF="node139.html#SECTION041210040000000000000">Visibilidad</A>
<LI><A NAME="tex2html4599"
  HREF="node139.html#SECTION041210050000000000000">Declaraciones y Definiciones</A>
<LI><A NAME="tex2html4600"
  HREF="node139.html#SECTION041210060000000000000">Inferencia, Declaraciones Implícitas y Ámbito</A>
<LI><A NAME="tex2html4601"
  HREF="node139.html#SECTION041210070000000000000">Ámbito Dinámico</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION041210000000000000000">
Análisis de Ámbito: Conceptos</A>
</H1>

<P>

<H4><A NAME="SECTION041210010000000000000">
El Problema del Análisis de Ámbito</A>
</H4>
  

<P>
En los lenguajes de programación <A NAME="22213"></A><SPAN  CLASS="textbf">name binding</SPAN> (binding = encuadernado, encarpetado,
ligadura, unificación) es la asociación de valores con identificadores. 
Decimos de un identificador ligado a un valor que es una <SPAN  CLASS="textbf">referencia</SPAN> a dicho valor.
El concepto de binding es un concepto proveído por los lenguajes de programación:
a nivel de máquina no existe el concepto de binding, de relación (nombre, valor).
El concepto de Binding esta intimamente relacionado con el concepto de ámbito
<A NAME="22215"></A><SPAN  CLASS="textbf">scope</SPAN>), ya que el <A NAME="22217"></A><SPAN  CLASS="textbf">análisis de ámbito</SPAN> es la determinación de las relaciones
de binding.

<P>
El problema del análisis de ámbito sería sencillo sino fuera porque 
los lenguajes de programación suelen permitir el uso del mismo
<A NAME="22219"></A><SPAN  CLASS="textbf">nombre</SPAN><A NAME="tex2html379"
  HREF="footnode.html#foot21588"><SUP><SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A> 
para denotar distintos elementos de un
programa. Es por ello que es necesario determinar que definición o declaración
se aplica a una determinada ocurrencia de un elemento.

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>En un lenguaje de programación, una <A NAME="22221"></A><SPAN  CLASS="textbf">declaración</SPAN> es un constructo sintáctico que define y provee información 
sobre un nombre.
La declaración provee información sobre las propiedades asociadas con el uso del nombre: 'este nombre es una función que recibe enteros y
retorna enteros', 'este nombre puede ser usado para referirse a listas de enteros y es visible sólo en el ámbito actual', etc.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>Las <A NAME="22223"></A><SPAN  CLASS="textbf">reglas de ámbito</SPAN> de un lenguaje determinan que declaración
del nombre es la que se <SPAN  CLASS="textbf">aplica</SPAN> cuando el nombre es usado.</I></DIV><P></P>

<P>

<H4><A NAME="SECTION041210020000000000000">
Binding Estático y Binding Dinámico</A>
</H4>
  

<P>
En la definición anterior no se especifica en que momento se resuelve
la correspondencia (nombre, definición).

<P>
Se habla de <A NAME="22229"></A><SPAN  CLASS="textbf">static binding</SPAN> 
cuando las reglas y la resolución de la  correspondencia (nombre, definición)
puede ser  resuelta en tiempo de compilación, a partir del análisis 
del texto del programa fuente (también se habla de <A NAME="22231"></A><SPAN  CLASS="textbf">early binding</SPAN>).

<P>
Por el contrario cuando se habla de <A NAME="22233"></A><SPAN  CLASS="textbf">dynamic binding</SPAN> 
cuando la determinación de que definición se aplica a un nombre es 
establecida en tiempo de ejecución (también se denomina <A NAME="22235"></A><SPAN  CLASS="textbf">late binding</SPAN> o <A NAME="22237"></A><SPAN  CLASS="textbf">virtual binding</SPAN>).

<P>
Un ejemplo de static binding es una llamada a a una función en C:
la función referenciada por un identificador no puede cambiarse en tiempo 
de ejecución. Un ejemplo de binding dinámico puede ocurrir cuando se trabaja 
con métodos polimorfos en un lenguaje de programación orientada a objetos, 
ya que la definición completa del tipo del objeto no
se conoce hasta el momento de la ejecución. 

<P>
El siguiente ejemplo de <A NAME="tex2html380"
  HREF="http://en.wikipedia.org/wiki/Dynamic_binding">Dynamic_binding</A>tomado de la wikipedia,  
ilustra el binding dinámico. 

<P>
Supongamos que todas las formas de vida son mortales.
En OOP podemos decir que la clase <code>Persona</code> y la clase <code>Planta</code> 
deben implementar los métodos de <code>Mortal</code>, el cual contiene
el método <code>muere</code>.

<P>
Las personas y las plantas mueren de forma diferente, por ejemplo las plantas 
no tienen un corazón que se detenga. Dynamic binding
es la práctica de determinar que definición/declaración se aplica 
a un método en tiempo de ejecución:

<P>
<PRE>
void mata(Mortal m) {
  m.muere();
}
</PRE>

<P>
No esta claro cual es la clase actual de <code>m</code>, una persona o una planta. 
Ambos <code>Planta.muere</code> y <code>Persona.muere</code> pueden ser invocados.
Cuando se usa dynamic binding, el objeto <code>m</code> es examinado en tiempo de 
ejecución para determinar que método es invocado. Esto supone una 'renuncia' por
parte del lenguaje y su compilador a obtener una definición completa del objeto.

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>Cuando se usa <SPAN  CLASS="textbf">static binding</SPAN>,
la parte del texto del programa al cual se aplica la declaración de un 
nombre se denomina <A NAME="22241"></A><SPAN  CLASS="textbf">ámbito de la declaración</SPAN></I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>En el siguiente código existen dos definiciones para 
el nombre <code>one</code>, una en la línea 11 y otra en la
línea 20.
</I>
<P><PRE>
pl@europa:~/src/perl/perltesting$ cat -n ds.pl
     1  package Father;
     2  use warnings;
     3  use strict;
     4
     5  sub new {
     6    my $class = shift;
     7
     8    bless { @_ }, $class;
     9  }
    10
    11  sub one {
    12    "Executing Father::one\n";
    13  }
    14
    15  package Child;
    16  use warnings;
    17  use strict;
    18  our @ISA = 'Father';
    19
    20  sub one {
    21    "Executing Child::one\n";
    22  }
    23
    24  package main;
    25
    26  for (1..10) {
    27    my $class = int(rand(2)) ? 'Child' : 'Father';
    28    my $c = $class-&gt;new;
    29    print $c-&gt;one;
    30  }
</PRE><I>
¿Que definiciones se aplican a los 10 usos del nombre <code>one</code>
en la línea 28? 
¿Estos usos constituyen un ejemplo de binding estático
o dinámico?
¿Cuál es el ámbito de las declaraciones de <code>one</code>?</I></DIV><P></P>

<P>
Incluso en los casos en los que la resolución del binding se deja para el momento de la ejecución
el compilador debe tener información suficiente para poder generar código. En el caso
anterior, el compilador de Perl infiere de la presencia de la flecha en <code>$c-&gt;one</code> 
que <code>one</code> es el nombre de una subrutina. 

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>En el siguiente ejemplo se usa una referencia simbólica para
acceder a una función:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n symbolic.pl
 1  use warnings;
 2  use strict;
 3
 4  sub one {
 5    "1\n";
 6  }
 7
 8  sub two {
 9    "2\n";
10  }
11
12  my $x = &lt;&gt;;
13  chomp($x);
14
15  no strict 'refs';
16  print &amp;$x();
</PRE><I>
Al ejecutarlo con entrada <code>one</code> obtenenmos:
</I><PRE>
pl@europa:~/src/perl/testing$ perl symbolic.pl
one
1
</PRE><I>
¿El uso de la línea 16 es un ejemplo de binding estático o dinámico?
¿Cuál es el binding de las declaraciones de <code>x</code>?</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>En el siguiente ejemplo la clase <code>Two</code> hereda de <code>One</code>.
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n latebinding.pl
     1  package One;
     2  use warnings;
     3  use strict;
     4
     5  our $x = 1;
     6  sub tutu {
     7    "Inside tutu: x = $x\n";
     8  }
     9
    10  package Two;
    11  use warnings;
    12  use strict;
    13  our @ISA = 'One';
    14
    15  our $x = 2;
    16
    17  print Two-&gt;tutu();
</PRE><I>
¿Qué definición de <code>$x</code> se aplica al uso en la línea 7?
¿Cuál será la salida del programa?</I></DIV><P></P>

<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN></B> &nbsp; 
<I>La tarea de asignar las ocurrencias de las declaraciones de nombres a las 
ocurrencias de uso  de los nombres de acuerdo a las reglas de ámbito
del lenguaje se denomina <A NAME="22243"></A><SPAN  CLASS="textbf">identificación de los nombres</SPAN></I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN></B> &nbsp; 
<I>Una ocurrencia de un nombre se dice <A NAME="22245"></A><SPAN  CLASS="textbf">local</SPAN> si está en el ámbito 
de una declaración que no se aplica desde el comienzo de la declaración 
hasta el final del texto del programa. Tal declaración
es una <A NAME="22247"></A><SPAN  CLASS="textbf">declaración local</SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN></B> &nbsp; 
<I>Si, por el contrario, una ocurrencia de un nombre está en el ámbito
de una declaración que se aplica desde el comienzo de la declaración 
hasta el final del texto del programa se dice que la declaración
es una <A NAME="22249"></A><SPAN  CLASS="textbf">declaración global</SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN></B> &nbsp; 
<I>Aunque la definición anterior establece el <A NAME="22251"></A><SPAN  CLASS="textbf">atributo ámbito</SPAN>
como un atributo de la declaración es usual y conveniente
hablar del 
</I>
<BLOCKQUOTE><I>"<SPAN  CLASS="textbf">ámbito del nombre <TT>x</TT></SPAN>" 
</I></BLOCKQUOTE><I>
como una abreviación
de 
</I>
<BLOCKQUOTE><I>"<SPAN  CLASS="textbf">el ámbito de la declaración del nombre <TT>x</TT>
que se aplica a esta ocurrencia de <TT>x</TT></SPAN>"
</I></BLOCKQUOTE></DIV><P></P>

<P>

<H4><A NAME="SECTION041210030000000000000">
Intervención del Programador en Tiempo de Compilación</A>
</H4>
  

<P>
En algunos lenguajes - especialmente en los lenguajes dinámicos- la diferenciación 
entre tiempo de compilación y tiempo de ejecución puede ser difusa.
En el siguiente fragmento de código Perl se usa el módulo
 <TT>Contextual::Return</TT> 
para crear una variable cuya definición cambia 
con la forma de uso.

<P>
<PRE>
lhp@nereida:~/Lperl/src/testing$ cat -n context1.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use Contextual::Return;
 4
 5  my $x = BOOL { 0 } NUM { 3.14 } STR { "pi" };
 6
 7  unless ($x) { warn "¡El famoso número $x (".(0+$x).") pasa a ser falso!\n" } # executed!

lhp@nereida:~/Lperl/src/testing$ context1.pl
¡El famoso número pi (3.14) pasa a ser falso!
</PRE>

<P>
Obsérvese que el binding de <code>$x</code> es estático y que a los 
tres usos de <code>$x</code> en la línea 7 se les asigna la definición 
en la línea 5.
La declaración de <code>$x</code> ocurre en lo que Perl denomina
'tiempo de compilación', 
sin embargo, el hecho de que un módulo cargado en tiempo de compilación
puede ejecutar sentencias permite a  <TT>Contextual::Return</TT> 
expandir el lenguaje de las declaraciones Perl.

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN></B> &nbsp; 
<I>Considere el siguiente código Perl:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n contextual.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Contextual::Return;
     4
     5  sub sensible {
     6    return STR { "one" }
     7           NUM { 1 }
     8           LIST   { 1,2,3 }
     9           HASHREF   { {name =&gt; 'foo', value =&gt; 99} }
    10    ;
    11  }
    12
    13  print "Result = ".sensible()."\n";
    14  print "Result = ".(0+sensible())."\n";
    15  print "Result = ",sensible(),"\n";
    16  print "Result = (name = ",sensible()-&gt;{name},", value = ", sensible()-&gt;{value},")\n";
</PRE><I>
Cuando se ejecuta, este programa produce la siguiente salida:
</I><PRE>
pl@europa:~/src/perl/testing$ ./contextual.pl
Result = one
Result = 1
Result = 123
Result = (name = foo, value = 99)
</PRE>
<P>
<I>Las relaciones de definición-uso de la función <code>sensible</code> ¿Son un caso de
binding estático o de binding dinámico?
¿Cuál es el ámbito de la declaración de <code>sensible</code> en las líneas 5-11?</I></DIV><P></P>

<P>

<H4><A NAME="SECTION041210040000000000000">
Visibilidad</A>
</H4>
  

<P>
Como ya sabemos, es falso que en el ámbito de una declaración que define a <code>x</code> 
dicha declaración se aplique a todas las ocurrencias de <code>x</code> en su ámbito.
En un ámbito estático, una declaración local a la anterior puede <A NAME="22263"></A><SPAN  CLASS="textbf">ocultar la visibilidad</SPAN> de 
la declaración anterior de <code>x</code>.

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN></B> &nbsp; 
<I>Las <A NAME="22265"></A><SPAN  CLASS="textbf">reglas de visibilidad</SPAN> de un lenguaje especifican como se relacionan los nombres
con las declaraciones que se les aplican.</I></DIV><P></P>

<P>
El concepto de nombre depende del lenguaje. 
Algunos lenguajes permiten que en un cierto ámbito haya mas de una definición asociada 
con un identificador.  Un mecanismo que puede ser usado para determinar univocamente que definición
se aplica a un determinado uso de un nombre es que el uso del nombre vaya acompañado
de un sigil.
(podría reinterpretarse que en realidad el nombre de una variable en Perl incluye el sigil).

<P>
Así, en Perl tenemos que es 
legal tener diferentes variables con nombre <code>x</code>: <code>$x</code>, <code>@x</code>, <code>%x</code>, <code>&amp;x</code>, <code>*x</code>,
etc. ya que van prefijadas por diferentes <SPAN  CLASS="textbf">sigils</SPAN> 
<code>$</code>, <code>@</code>, etc. El sigil que prefija <code>x</code> determina que definición se aplica al uso de <code>x</code>
(La palabra sigil hace referencia a 'sellos mágicos' - combinaciones de símbolos 
y figuras geométricas - que son usados en algunas invocaciones con el propósito de producir un
sortilegio).

<P>
En algunos casos existen mecanismos para la
extensión de los nombres.
En Perl es posible acceder a una variable de paquete
ocultada por una léxica usando su nombre completo.

<P>
La asignación de una declaración a ciertos usos de un identificador puede requerir
de otras fases de análisis semántico, como el análisis de tipos.
El uso de los nombres de campo de un registro en  Pascal y en C 
constituye un ejemplo:

<P>
<PRE>
 1	type 
 2	  a = ^b;
 3	  b = record
 4	        a: Integer;
 5	        b: Char;
 6	        c: a
 7	      end;
 8	var
 9	  pointertob: a;
10	  c         : Integer;
11	
12	...
13	new(pointertob);
14	
15	pointertob^.c := nil;
16	c             := 4;
17	...
</PRE>

<P>
El uso de <code>c</code> en la ĺinea 15 es posible porque el tipo de la expresión <code>pointertob^</code>
es un registro. La definición que se aplica al uso de <code>c</code> en la línea 16 es la de la línea 10.

<P>
También es posible hacer visible un nombre escondido - sin necesidad de extender el identificador - 
mediante alguna directiva que lo haga visible: 
Un ejemplo es la declaración <code>with</code> the Pascal:

<P>
<PRE>
new(pointertob);
 
with pointertob^ do
begin
  a := 10;
  b := 'A';
  c := nil
end;
...
</PRE>

<P>

<H4><A NAME="SECTION041210050000000000000">
Declaraciones y Definiciones</A>
</H4>
  

<P>
En algunos lenguajes se distingue entre declaraciones que sólo proporcionan información sobre el elemento
y lo hacen <SPAN  CLASS="textbf">visible</SPAN> - pero no asignan memoria o producen código para la implementación del mismo - y otras
que si producen dicho código. A las primeras se las suele llamar declaraciones
y a las segundas definiciones.
En tales lenguajes se considera un error que dos declaraciones de un mismo elemento difieran.

<P>
Por ejemplo, en C una variable o función sólo es definida una vez,
pero puede ser declarada varias veces.
El calificativo <code>extern</code> es usado en C para indicar que una declaración provee
visibilidad pero no conlleva definición (creación):

<P>
<PRE>
extern char stack[10];
extern int stkptr;
</PRE>

<P>
Estas declaraciones le dicen al compilador C que las definiciones de los nombres
<code>stack</code> y <code>stackptr</code> se encuentran en otro fichero. 
Si la palabra <code>extern</code> fuera omitida el compilador asignaría memoria para
las mismas.

<P>
Otro ejemplo en el que una directiva hace visible una definición escondida
es el uso de la declaración  <TT>our</TT>  de Perl cuando un paquete está repartido
entre varios ficheros que usan repetitivamente <code>strict</code>:

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN></B> &nbsp; 
<I>Considere el siguiente programa:
</I><PRE>
pl@europa:~/src/perl/perltesting$ cat -n useA.pl
     1  #!/usr/bin/perl
     2  package A;
     3  use warnings;
     4  use strict;
     5
     6  use A;
     7
     8  #our $x;
     9  print "$x\n";
</PRE><I>
La variable <code>$x</code> esta declarada en el fichero <code>A.pm</code>:
</I><PRE>
pl@europa:~/src/perl/perltesting$ cat -n A.pm
     1  package A;
     2  use warnings;
     3  use strict;
     4
     5  our $x = 1;
     6
     7  1;
</PRE>
<P>
<I>Sin embargo la compilación de <code>useA.pl</code> produce errores,
pues <code>$x</code> no es visible:
</I><PRE>
pl@europa:~/src/perl/perltesting$ perl -c useA.pl
Variable "$x" is not imported at useA.pl line 9.
Global symbol "$x" requires explicit package name at useA.pl line 9.
useA.pl had compilation errors.
</PRE><I>
El mensaje se arregla descomentando la declaración de <code>$x</code>
en la línea 8 de <code>useA.pl</code>:
</I><PRE>
pl@europa:~/src/perl/perltesting$ perl -ce `sed -e 's/#our/our/' useA.pl`
-e syntax OK
</PRE><I>
La declaración de la línea 8 hace visible la variable <code>$x</code> en el
fichero <code>useA.pl</code>. 
</I>
<P>
<I>¿Cual es entonces el ámbito de la declaración de <code>$x</code> en la línea 5 de 
<code>A.pm</code>? ¿Es todo el paquete? ¿O sólo el segmento del paquete que está en
el fichero <code>A.pm</code>? (se supone que trabajamos con <code>strict</code> activado).</I></DIV><P></P>

<P>

<H4><A NAME="SECTION041210060000000000000">
Inferencia, Declaraciones Implícitas y Ámbito</A>
</H4>
  

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN></B> &nbsp; 
<I>Tanto en los lenguajes estáticos como en los dinámicos
se suele requerir que exista una declaración del objeto usado que determine las propiedades del mismo.
</I>
<P>
<I>Aunque en los lenguajes dinámicos la creación/definición del elemento asociado
con un nombre puede postergarse hasta el tiempo de ejecución, la generación de
código para la sentencia de uso suele requerir un conocimiento (aunque sea
mínimo) del objeto que esta siendo usado. En algunos casos, es necesario
inferir la declaración a partir del uso, de manera que la declaración asociada
con un uso es construida a partir del propio uso.
</I>
<P>
<I>Los lenguajes típicamente estáticos fuertemente tipeados suelen requerir que
para todo uso exista una declaración explícita y completa del nombre y de las
operaciones que son válidas sobre el mismo al finalizar la fase de compilación.
Sin embargo, el código para la creación/definición de algunos objetos puede ser
postergado a la fase de enlace. De hecho, la resolución de ciertos enlaces
pueden ocurrir durante la fase de ejecución (énlace dinámico). 
</I>
<P>
<I>El siguiente ejemplo hace uso de un typeglob selectivo en la línea 8 para 
definir la función <code>ONE</code>:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n glob.pl
     1  use warnings;
     2  use strict;
     3
     4  sub one {
     5    "1\n"
     6  }
     7
     8  *ONE = \&amp;one;
     9  print ONE();
</PRE><I>
Al ejecutar este programa se produce la salida;
</I><PRE>
pl@europa:~/src/perl/testing$ perl glob.pl
1
</PRE><I>
 ¿El uso de <code>ONE</code> en la línea 9 es un ejemplo de binding estático o dinámico?
¿Cuál es el ámbito de la declaración de <code>ONE</code>?
</I>
<P>
<I>Responda estas mismas preguntas para esta otra variante del ejemplo anterior:
</I>
<P><PRE>
pl@nereida:~/src/perl/perltesting$ cat -n coderef.pl
     1  use warnings;
     2  use strict;
     3
     4  *ONE = sub { "1\n" };
     5  print ONE();
</PRE></DIV><P></P>

<P>
En los ejemplos anteriores el propio uso del nombre <code>ONE</code> 
actúa como una declaración: Perl deduce 
de la presencia de paréntesis después de <code>ONE</code> que <code>ONE</code> es el nombre de una función.
Esta información es suficiente para generar el código necesario. Podría decirse
que la forma del uso declara al ente <code>ONE</code> y que la línea de uso conlleva una declaración
implícita. Sin embargo, la creación/definición completa de <code>ONE</code> es postergada hasta la fase de 
ejecución.

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN></B> &nbsp; 
<I>La conducta del compilador de Perl cambia si se sustituye el programa anterior por este otro:
</I><PRE>
pl@europa:~/src/perl/testing$ cat -n globwarn.pl
     1  use warnings;
     2  use strict;
     3
     4  sub one {
     5    "1\n"
     6  }
     7
     8  *ONE = \&amp;one;
     9  my $x = ONE;
    10  print $x;
</PRE><I>
Al compilar se obtiene un error:
</I><PRE>
pl@europa:~/src/perl/testing$ perl -c globwarn.pl
Bareword "ONE" not allowed while "strict subs" in use at globwarn.pl line 9.
globwarn.pl had compilation errors.
</PRE><I>
¿Sabría explicar la causa de este cambio de conducta?</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN></B> &nbsp; 
<I>El error que se observa en el ejercicio anterior desaparece 
cuando se modifica el código como sigue:
</I><PRE>
lusasoft@LusaSoft:~/src/perl/perltesting$ cat -n globheader.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use strict;
     4
     5  sub ONE;
     6
     7  sub one {
     8    "1\n"
     9  }
    10
    11  *ONE = \&amp;one;
    12  my $x = ONE;
    13  print $x;
</PRE><I>
¿Cual es el significado de la línea 5?</I></DIV><P></P>

<P>
En el caso del lenguaje Simple C introducido en la práctica 
<A HREF="node141.html#practica:esquemadetradsimple">12.3</A>
hay una única declaración que se aplica a cada 
ocurrencia correcta de un nombre en el ámbito de dicha declaración.

<P>
Esto no tiene porque ser siempre así: en ciertos lenguajes 
una redeclaración de un cierto nombre <code>x</code> puede que sólo oculte 
a otra declaración previa de <code>x</code> si las dos declaraciones
asignan el mismo tipo a <code>x</code>. Esta idea suele conocerse
como <A NAME="22276"></A><SPAN  CLASS="textbf">sobrecarga de identificadores</SPAN>. De todos modos, sigue 
siendo cierto que para que el programa
sea considerado correcto es necesario que sea posible <I>inferir</I>
para cada ocurrencia de un identificador que única definición se
aplica. Así una llamada  a una cierta función
<code>min(x,y)</code> llamaría a diferentes 
funciones <code>min</code> según fueran los tipos de <code>x</code> e <code>y</code>.
Para resolver este caso es necesario combinar las fases
de análisis de ámbito y de análisis de tipos.

<P>
Algunos lenguajes - especialmente los lenguajes funcionales - logran eliminar la mayoría 
de las declaraciones. Disponen de un mecanismo de inferencia que les permite - en
tiempo de compilación - deducir
del uso la definición y propiedades del nombre. 

<P>
Véase como ejemplo de inferencia la siguiente sesión en <A NAME="tex2html381"
  HREF="http://en.wikipedia.org/wiki/OCaml">OCaml</A>
<PRE>
pl@nereida:~/src/perl/attributegrammar/Language-AttributeGrammar-0.08/examples$ ocaml
        Objective Caml version 3.09.2

# let minimo = fun i j -&gt; if i&lt;j then i else j;;
val minimo : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
# minimo 2 3;;
- : int = 2
# minimo 4.9 5.3;;
- : float = 4.9
# minimo "hola" "mundo";;
- : string = "hola"
</PRE>

<P>
El compilador <code>OCaml</code> infiere el tipo de las expresiones. 
Así el tipo asociado con la función <code>minimo</code> es

<P>
<PRE>
                    'a -&gt; 'a -&gt; 'a
</PRE>

<P>
que es una <A NAME="22280"></A><SPAN  CLASS="textbf">expresión de tipo</SPAN> que contiene
<A NAME="22282"></A><SPAN  CLASS="textbf">variables de tipo</SPAN>. El operador <code>-&gt;</code> es asociativo a derechas
y asi la expresión debe ser leída como <code>'a -&gt; ('a -&gt; 'a)</code>. 
Básicamente dice: 

<P>
El tipo de la expresión es una función que toma un argumento de tipo <code>'a</code>
(donde <code>'a</code> es una variable tipo que será instanciada en el momento del
uso de la función) y devuelve una función que toma elementos de tipo <code>'a</code>
y retorna elementos de tipo <code>'a</code>. 

<P>

<H4><A NAME="SECTION041210070000000000000">
Ámbito Dinámico</A>
</H4>
  

<P>
En el <A NAME="22288"></A><SPAN  CLASS="textbf">ámbito dinámico</SPAN>, cada nombre para el que se usa ámbito dinámico
tiene asociada una pila de bindings. Cuando se crea un nuevo ámbito
dinámico se empuja en la pila el viejo valor (que podría no estar definido).
Cuando se sale del ámbito se saca de la pila el antiguo valor.
La evaluación de <code>x</code> retorna siempre el valor en el top de la pila.

<P>
La sentencia  <TT>local</TT>  de Perl provee de ámbito dinámico
a las variables de paquete.
Una aproximaci&#243;n a lo que ocurre cuando se ejecuta 
<code>local</code> es:

<P>
<BR>
<BR>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>DECLARACI&#211;N  DE <code>local</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>SIGNIFICADO</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><PRE>
{
  local($SomeVar);
  $SomeVar = 'My Value';
       ...
}
</PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><PRE>
{
  my $TempCopy = $SomeVar;
  $SomeVar = undef;
  $SomeVar = 'My Value';
       ...
  $SomeVar = $TempCopy;
}
</PRE></TD>
</TR>
</TABLE>
</DIV>
<BR>
<BR>

<P>
La diferencia entre ámbito dinámico y estático debería quedar mas clara observando
la conducta del siguiente código

<P>
<PRE>
lhp@nereida:~/Lperl/src$ cat -n local.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  our $x;
 5
 6  sub pr { print "$x\n"; }
 7  sub titi { my $x = "titi"; pr(); }
 8  sub toto { local $x = "toto"; &amp;pr(); &amp;titi(); }
 9
10  $x = "global";
11  &amp;pr();
12  &amp;toto();
13  &amp;titi();
</PRE>

<P>
Cuando se ejecuta, se obtiene la siguiente salida:

<P>
<PRE>
&gt; local.pl
global
toto
toto
global
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">9</SPAN></B> &nbsp; 
<I>¿Es <code>local</code> una declaración o una sentencia?
¿Que declaraciones se aplican a los diferentes 
usos de <code>$x</code> en las líneas 6, 7, 8 y 10?.</I></DIV><P></P>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html4593"
  HREF="node140.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4587"
  HREF="node138.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4581"
  HREF="node138.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4589"
  HREF="node234.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4591"
  HREF="node237.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html9"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html4594"
  HREF="node140.html">Descripción Eyapp del Lenguaje</A>
<B>Sup:</B> <A NAME="tex2html4588"
  HREF="node138.html">Análisis de Ámbito en</A>
<B> Ant:</B> <A NAME="tex2html4582"
  HREF="node138.html">Análisis de Ámbito en</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-01-17</I>
</ADDRESS>
</BODY>
</HTML>
