<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Casos de Estudio</TITLE>
<META NAME="description" CONTENT="Casos de Estudio">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node27.html">
<LINK REL="previous" HREF="node25.html">
<LINK REL="up" HREF="node21.html">
<LINK REL="next" HREF="node27.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2680"
  HREF="node27.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2674"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2668"
  HREF="node25.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2676"
  HREF="node217.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2678"
  HREF="node220.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2681"
  HREF="node27.html">tr y split</A>
<B>Sup:</B> <A NAME="tex2html2675"
  HREF="node21.html">Expresiones Regulares en Perl</A>
<B> Ant:</B> <A NAME="tex2html2669"
  HREF="node25.html">Expresiones Regulares en Otros</A>
<B> Con:</B> 
<A NAME="tex2html2676"
  HREF="node217.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html2678"
  HREF="node220.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2682"
  HREF="node26.html#SECTION04351000000000000000">Secuencias de números de tamaño fijo</A>
<UL>
<LI><A NAME="tex2html2683"
  HREF="node26.html#SECTION04351010000000000000">Solución usando el ancla <TT><!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$ \backslash$"></SPAN> G</TT></A>
<LI><A NAME="tex2html2684"
  HREF="node26.html#SECTION04351020000000000000">Sustitución</A>
</UL>
<BR>
<LI><A NAME="tex2html2685"
  HREF="node26.html#SECTION04352000000000000000">Palabras Repetidas</A>
<LI><A NAME="tex2html2686"
  HREF="node26.html#SECTION04353000000000000000">Análisis de cadenas con datos separados por comas</A>
<LI><A NAME="tex2html2687"
  HREF="node26.html#SECTION04354000000000000000">Las Expresiones Regulares como Exploradores de un Árbol de Soluciones</A>
<UL>
<LI><A NAME="tex2html2688"
  HREF="node26.html#SECTION04354010000000000000">Números Primos</A>
<LI><A NAME="tex2html2689"
  HREF="node26.html#SECTION04354020000000000000">Ecuaciones Diofánticas: Una solución</A>
<LI><A NAME="tex2html2690"
  HREF="node26.html#SECTION04354030000000000000">Ecuaciones Diofánticas: Todas las soluciones</A>
<LI><A NAME="tex2html2691"
  HREF="node26.html#SECTION04354040000000000000">Ecuaciones Diofánticas: Resolutor general</A>
<LI><A NAME="tex2html2692"
  HREF="node26.html#SECTION04354050000000000000">Las  Tres Hijas</A>
<LI><A NAME="tex2html2693"
  HREF="node26.html#SECTION04354060000000000000">Mochila 0-1</A>
<LI><A NAME="tex2html2694"
  HREF="node26.html#SECTION04354070000000000000">Véase también</A>
</UL>
<BR>
<LI><A NAME="tex2html2695"
  HREF="node26.html#SECTION04355000000000000000">Número de substituciones realizadas</A>
<LI><A NAME="tex2html2696"
  HREF="node26.html#SECTION04356000000000000000">Expandiendo y comprimiendo tabs</A>
<LI><A NAME="tex2html2697"
  HREF="node26.html#SECTION04357000000000000000">Modificación de Múltiples Ficheros: one liner</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04350000000000000000">
Casos de Estudio</A>
</H1>

<P>

<H2><A NAME="SECTION04351000000000000000"></A>
<A NAME="section:numeros"></A>
<BR>
Secuencias de números de tamaño fijo
</H2>
El siguiente problema y sus soluciones se describen en el libro de J.E.F. Friedl
[<A
 HREF="node221.html#friedl">2</A>].
Supongamos que tenemos un texto conteniendo códigos que son 
números de tamaño fijo, digamos 
seis dígitos, todos pegados, sin separadores entre ellos, como sigue:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><TT>012345678901<B>123334</B>234567890123<B>125934</B>890123345126
</TT>
</DIV>

<P>
El problema es encontrar los códigos que comienzan por <TT>12</TT>. En negrita 
se han resaltado las soluciones.  Son soluciones sólo aquellas que, comienzan
por <code>12</code> en una posición múltiplo de seis. 
Una solución es:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
@nums = grep {m/^12/} m/\d{6}/g;
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
que genera una lista con los números y luego selecciona los que comienzan por
<code>12</code>.
Otra solución es:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
@nums = grep { defined } m/(12\d{4})|\d{6}/g;
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
que aprovecha que la expresión regular devolverá una lista vacía cuando
el número no empieza por <code>12</code>:
<PRE>
DB&lt;1&gt; $x = '012345678901123334234567890123125934890123345126'
DB&lt;2&gt; x  ($x =~ m/(12\d{4})|\d{6}/g)
0  undef
1  undef
2  123334
3  undef
4  undef
5  125934
6  undef
7  undef
</PRE>
Obsérvese que se esta utilizando también que el operador <code>|</code> no es <SPAN  CLASS="textbf">greedy</SPAN>.

<P>
¿Se puede resolver el problema usando sólamente una expresión regular?
Obsérvese que esta solución ``casi funciona'':

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
 DB&lt;3&gt; x @nums = $x =~ m/(?:\d{6})*?(12\d{4})/g;
0  123334
1  125934
2  123345
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
recoge la secuencia mas corta de grupos de seis dígitos que no casan, seguida 
de una secuencia que casa. 
El problema que tiene esta solución 
es al final, cuando se han casado todas las soluciones, entonces 
la búsqueda exhaustiva hará que nos muestre soluciones que no comienzan en posiciones
múltiplo de seis. Por eso encuentra <code>123345</code>:
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><TT>012345678901<B>123334</B>234567890123<B>125934</B>890<B>123345</B>126
</TT>
</DIV>
Por eso, Friedl propone esta solución:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
@nums = m/(?:\d{6})*?(12\d{4})(?:(?!12)\d{6})*/g;
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
Se asume que existe al menos un éxito en la entrada inicial.
Que es un extraordinario ejemplo de como el uso de paréntesis de agrupamiento
simplifica y mejora la legibilidad de la solución. Es fantástico también el uso
del operador de predicción negativo.

<P>

<H4><A NAME="SECTION04351010000000000000">
Solución usando el ancla <TT><!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$ \backslash$"></SPAN> G</TT></A>
</H4>
  

<P>
El ancla <code>\G</code> ha sido concebida para su uso con la opción <code>/g</code>.
Casa con el punto en la cadena en el que terminó el último emparejamiento.
Cuando se trata del primer intento o no se está usando <code>/g</code>, usar <code>\G</code>
es lo mismo que usar <code>\A</code>.

<P>
Mediante el uso de este ancla es posible formular la siguiente solución 
al problema planteado:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
DB&lt;1&gt; $_ = '012345678901123334234567890123125934890123345126'
DB&lt;2&gt; x m/\G(?:\d{6})*?(12\d{4})/g
0  123334
1  125934
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H4><A NAME="SECTION04351020000000000000">
Sustitución</A>
</H4>
  

<P>
Si lo que se quiere es sustituir las secuencias deseadas es poisble hacerlo con 
la siguiente expresión regular:
<PRE>
casiano@nereida:~/docs/curriculums/CV_MEC$ perl -wde 0
DB&lt;1&gt; x $x = '012345678901123334234567890123125934890123345126'
0  012345678901123334234567890123125934890123345126
DB&lt;2&gt; x  ($y = $x) =~ s/(12\d{4})|\d{6}/$1? "-$1-":$&amp; /ge
0  8
DB&lt;3&gt; p $y
012345678901-123334-234567890123-125934-890123345126
</PRE>

<P>

<H2><A NAME="SECTION04352000000000000000"></A>
<A NAME="section:repetidas"></A>
<BR>
Palabras Repetidas
</H2>
Su jefe le pide una herramienta que compruebe la aparición de
duplicaciones consecutivas en un texto texto (como esta esta y la anterior anterior).
La solución debe cumplir las siguientes especificaciones:

<UL>
<LI>Aceptar cualquier número de ficheros. Resaltar las apariciones
de duplicaciones. Cada línea del informe debe estar precedida del nombre del fichero.
</LI>
<LI>Funcionar no sólo cuando la duplicación ocurre en la misma línea.
</LI>
<LI>Funcionar independientemente del <SPAN  CLASS="textbf">case</SPAN> y de los blancos usados en medio
de ambas palabras.
</LI>
<LI>Las palabras en cuestión pueden estar separadas por <SPAN  CLASS="textbf">tags</SPAN> <code>HTML</code>.
</LI>
</UL>

<P>

<pre>
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use </span>Term::ANSIScreen <span class="synConstant">qw/:constants/</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$bold</span> = BOLD();
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$clear</span> = CLEAR();
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synComment"># read paragraph</span>
<span class="synLinenum">   10</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synConstant">".</span><span class="synSpecial">\n</span><span class="synConstant">"</span>;
<span class="synLinenum">   11</span> <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$par</span> = &lt;&gt;) {
<span class="synLinenum">   12</span>   <span class="synStatement">next</span> <span class="synStatement">unless</span> <span class="synIdentifier">$par</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">\b</span><span class="synConstant">                 # start word </span><span class="synSpecial">...</span>
<span class="synLinenum">   14</span> <span class="synConstant">        </span><span class="synSpecial">([a-z]+)</span><span class="synConstant">           # grab word in </span><span class="synIdentifier">$1</span><span class="synConstant"> and </span><span class="synSpecial">\1</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">(</span><span class="synConstant">                  # save the tags and spaces in </span><span class="synIdentifier">$2</span>
<span class="synLinenum">   16</span> <span class="synConstant">        </span><span class="synSpecial">(\s</span><span class="synConstant">|&lt;</span><span class="synSpecial">[^&gt;]+</span><span class="synConstant">&gt;</span><span class="synSpecial">)+</span><span class="synConstant">      # spaces or HTML tags </span>
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">)</span><span class="synConstant">   </span>
<span class="synLinenum">   18</span> <span class="synConstant">        </span><span class="synSpecial">(\1\b)</span><span class="synConstant">             # repeated word in </span><span class="synIdentifier">$4</span>
<span class="synLinenum">   19</span> <span class="synConstant">  </span><span class="synStatement">}</span>!<span class="synIdentifier">$bold$1$clear$2$bold$4$clear</span>!igx;
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synIdentifier">$par</span> =~ <span class="synStatement">s/</span><span class="synConstant">^</span><span class="synStatement">/</span><span class="synConstant">"</span><span class="synIdentifier">$ARGV</span><span class="synConstant">(".</span><span class="synIdentifier">$line</span><span class="synConstant">++."): "</span><span class="synStatement">/meg</span>;   <span class="synComment"># insert filename and line number</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">print</span> <span class="synIdentifier">$par</span>;
<span class="synLinenum">   24</span> }
</pre>
<P>
Sigue un ejemplo de uso:
<pre>
pl@nereida:~/Lperltesting$ cat -n t.t
     1  one one
     2  nothing rep
     3  is two three
     4  three four
     5
pl@nereida:~/Lperltesting$ ./repeatedwords2.pl t.t
t.t(1): <font color="blue">one one</font>
t.t(2): nothing rep
t.t(3): is two <font color="blue">three</font>
t.t(4): <font color="blue">three</font> four
t.t(5):
</pre>

<P>

<H2><A NAME="SECTION04353000000000000000"></A>
<A NAME="section:csv"></A>
<BR>
Análisis de cadenas con datos separados por comas
</H2>
Supongamos que tenemos cierto texto en <code>$text</code> proveniente
de un fichero <code>CSV</code> (<SPAN  CLASS="textbf">Comma Separated Values</SPAN>). Esto es
el fichero contiene líneas con el formato:

<P>
<PRE>
"earth",1,"moon",9.374
</PRE>

<P>
Esta línea representa cinco campos.
Es razonable querer guardar esta información en un <SPAN  CLASS="textbf">array</SPAN>,
digamos <code>@field</code>, de manera que <code>$field[0] == 'earth'</code>,
<code>$field[1] == '1'</code>, etc.
Esto no sólo implica descomponer la cadena en campos sino
también quitar las comillas de los campos entrecomillados.
La primera solución que se nos ocurre es hacer uso de la
función <code>split</code>:

<P>
<PRE>
@fields = split(/,/,$text);
</PRE>

<P>
Pero esta solución deja las comillas dobles en  los campos
entrecomillados.  Peor aún, los campos entrecomillados pueden contener
comas, en cuyo caso  la división proporcionada por <code>split</code> sería
errónea. 

<P>
<PRE>
   1 #!/usr/bin/perl -w
   2 use Text::ParseWords;
   3 
   4 sub parse_csv {
   5   my $text = shift;
   6   my @fields = (); # initialize @fields to be empty
   7 
   8   while ($text =~ 
   9     m/"(([^"\\]|\\.)*)",? # quoted fields
  10       | 
  11       ([^,]+),?           # $3 = non quoted fields
  12       | 
  13       ,                   # allows empty fields
  14     /gx 
  15     )
  16   {
  17     push(@fields, defined($1)? $1:$3); # add the just matched field
  18   }
  19   push(@fields, undef) if $text =~ m/,$/; #account for an empty last field
  20   return @fields;
  21 }
  22        
  23 $test = '"earth",1,"a1, a2","moon",9.374';
  24 print "string = \'$test\'\n";
  25 print "Using parse_csv\n:";
  26 @fields = parse_csv($test);
  27 foreach $i (@fields) {
  28   print "$i\n";
  29 }
  30 
  31 print "Using Text::ParseWords\n:";
  32 #  @words = &amp;quotewords($delim, $keep, @lines);  
  33 #The $keep argument is a boolean flag.  If true, then the
  34 #tokens are split on the specified delimiter, but all other
  35 #characters (quotes, backslashes, etc.) are kept in the
  36 #tokens.  If $keep is false then the &amp;*quotewords()
  37 #functions remove all quotes and backslashes that are not
  38 #themselves backslash-escaped or inside of single quotes
  39 #(i.e., &amp;quotewords() tries to interpret these characters
  40 #just like the Bourne shell). 
  41 
  42 @fields = quotewords(',',0,$test);
  43 foreach $i (@fields) {
  44   print "$i\n";
  45 }
</PRE>

<P>
Las subrutinas  en Perl reciben sus argumentos en el <SPAN  CLASS="textbf">array</SPAN>
<code>@_</code>. Si la lista de argumentos contiene listas, estas 
son ``aplanadas'' en una única lista. Si, como es el caso, la subrutina
ha sido declarada antes de la llamada, los argumentos pueden
escribirse sin paréntesis que les rodeen:
<PRE>
@fields = parse_csv $test;
</PRE>

<P>
Otro modo de llamar una subrutina es usando el prefijo <code>&amp;</code>,
pero sin proporcionar lista de argumentos.
<PRE>
@fields = &amp;parse_csv;
</PRE>
En este caso se le pasa a la rutina el valor actual del  <SPAN  CLASS="textbf">array</SPAN> <code>@_</code>.

<P>
Los operadores <code>push</code> (usado en la línea 17) y <code>pop</code> trabajan
sobre el final del <SPAN  CLASS="textbf">array</SPAN>. De manera análoga los operadores
<code>shift</code> y <code>unshift</code> lo hacen sobre el comienzo.
El operador ternario <code>?</code> trabaja de manera análoga como lo hace en C.

<P>
El código del <code>push</code> podría sustituirse por este otro:
<PRE>
push(@fields, $+);
</PRE>
Puesto que la variable <code>$+</code> contiene la cadena que ha casado
con el último paréntesis que haya casado en el ultimo ``matching''.

<P>
La segunda parte del código muestra que existe un 
módulo en Perl, el módulo <code>Text::Parsewords</code> que proporciona la rutina <code>quotewords</code> que hace la misma función que nuestra subrutina.

<P>
Sigue un ejemplo de ejecución:
<PRE>
&gt; csv.pl
string = '"earth",1,"a1, a2","moon",9.374'
Using parse_csv
:earth
1
a1, a2
moon
9.374
Using Text::ParseWords
:earth
1
a1, a2
moon
9.374
</PRE>

<P>

<H2><A NAME="SECTION04354000000000000000">
Las Expresiones Regulares como Exploradores de un Árbol de Soluciones</A>
</H2>

<P>

<H4><A NAME="SECTION04354010000000000000">
Números Primos</A>
</H4>
  

<P>
El siguiente programa evalúa si un número es primo o no:
<PRE>
pl@nereida:~/Lperltesting$ cat -n isprime.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  my $num = shift;
 5  die "Usage: $0 integer\n" unless (defined($num) &amp;&amp; $num =~ /^\d+$/);
 6
 7  if (("1" x $num) =~ /^(11+)\1+$/) {
 8    my $factor = length($1);
 9    print "$num is $factor x ".$num/$factor."\n";
10  }
11  else {
12    print "$num is prime\n";
13  }
</PRE>
Siguen varias ejecuciones:
<PRE>
pl@nereida:~/Lperltesting$ ./isprime.pl 35.32
Usage: ./isprime.pl integer
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 147
147 is 49 x 3
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 49
49 is 7 x 7
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
</PRE>

<P>

<H4><A NAME="SECTION04354020000000000000">
Ecuaciones Diofánticas: Una solución</A>
</H4>
  

<P>
Según dice la entrada <A NAME="tex2html277"
  HREF="http://en.wikipedia.org/wiki/Diophantine_equation">Diophantine_equation</A>
en la wikipedia:

<P>
<BLOCKQUOTE><I>In mathematics, a Diophantine equation is an indeterminate polynomial equation that allows the variables to be integers only. 
</I></BLOCKQUOTE>

<P>
La siguiente sesión con el depurador muestra como se puede 
resolver una ecuación lineal diofántica con coeficientes 
positivos usando una expresión regular:

<P>
<PRE>
  DB&lt;1&gt; # Resolvamos 3x + 2y + 5z = 40
DB&lt;2&gt; x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
1  'aa'
2  'aaaaa'
DB&lt;3&gt; x map { length }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  33
1  2
2  5
DB&lt;4&gt; @c = (3, 2, 5)
DB&lt;5&gt; x map { length($_) / $c[$i++] }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  11
1  1
2  1
DB&lt;6&gt; p 3*11+2*1+5*1
40
</PRE>

<P>

<H4><A NAME="SECTION04354030000000000000">
Ecuaciones Diofánticas: Todas las soluciones</A>
</H4>
  

<P>
Usando el verbo <code>(*FAIL)</code> es posible obtener todas las soluciones:
<PRE>
main::(-e:1):   0
DB&lt;1&gt;  sub equ { my @c = @_; print "\t3*$c[0]+2*$c[1]+5*$c[2] = ",3*$c[0]+2*$c[1]+5*$c[2],"\n" }
DB&lt;2&gt; sub f { my @c = ((length($1)/3), (length($2)/2), (length($3)/5)); equ(@c); }
DB&lt;3&gt; x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$(?{ f() })(*FAIL)/x
        3*11+2*1+5*1 = 40
        3*9+2*4+5*1 = 40
        3*8+2*3+5*2 = 40
        3*7+2*7+5*1 = 40
        3*7+2*2+5*3 = 40
        3*6+2*6+5*2 = 40
        3*6+2*1+5*4 = 40
        3*5+2*10+5*1 = 40
        3*5+2*5+5*3 = 40
        3*4+2*9+5*2 = 40
        3*4+2*4+5*4 = 40
        3*3+2*13+5*1 = 40
        3*3+2*8+5*3 = 40
        3*3+2*3+5*5 = 40
        3*2+2*12+5*2 = 40
        3*2+2*7+5*4 = 40
        3*2+2*2+5*6 = 40
        3*1+2*16+5*1 = 40
        3*1+2*11+5*3 = 40
        3*1+2*6+5*5 = 40
        3*1+2*1+5*7 = 40
  empty array
DB&lt;4&gt;
</PRE>

<P>

<H4><A NAME="SECTION04354040000000000000">
Ecuaciones Diofánticas: Resolutor general</A>
</H4>
  

<P>
El siguiente programa recibe en línea de comandos los coeficientes y 
término inependeinte de una ecuación lineal diofántica con coeficientes 
positivos y muestra todas las soluciones. El
algoritmo primero crea una cadena conteniendo 
el código Perl que contiene la expresión regular adecuada 
para pasar luego a evaluarlo:
<PRE>
pl@nereida:~/Lperltesting$ cat -n diophantinesolvergen.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3  use strict;
 4
 5  # Writes a Perl solver for
 6  # a1 x1 + a2 x2 + ... + an xn = b
 7  # a_i and b integers &gt; 0
 8  #
 9
10  my $b = pop;
11  my @a = @ARGV;
12  my $debug = 1;
13
14  my $b1 = '1'x$b;
15  my @a1 = map { '1'x$_ } @a;
16  my @index = map { 'length($'.$_.")/".$a[$_-1] } 1..(@a);
17  my $aux = join ",", @index;
18
19  my $regexp = '^';
20  $regexp .= "((?:$_)+)" for @a1;
21
22  $regexp .= '$(?{ f() })(*FAIL)';
23
24  my $solver = &lt;&lt;"SOLVER";
25  my \@stack;
26  sub f {
27    my \@s = ($aux);
28    push \@stack, [ \@s ];
29  }
30
31  q{$b1} =~ m{$regexp}x;
32
33  return \@stack;
34  SOLVER
35
36  print "Solver:\n--------\n$solver\n--------\n" if $debug;
37
38  my @stack = eval $solver;
39
40  say("@$_") for @stack
</PRE>
Sigue un ejemplo de ejecución:
<PRE>
pl@nereida:~/Lperltesting$ ./diophantinesolvergen.pl 3 2 5 40
Solver:
--------
my @stack;
sub f {
  my @s = (length($1)/3,length($2)/2,length($3)/5);
  push @stack, [ @s ];
}

q{1111111111111111111111111111111111111111} =~ m{^((?:111)+)((?:11)+)((?:11111)+)$(?{ f() })(*FAIL)}x;

return @stack;

--------
11 1 1
9 4 1
8 3 2
7 7 1
7 2 3
6 6 2
6 1 4
5 10 1
5 5 3
4 9 2
4 4 4
3 13 1
3 8 3
3 3 5
2 12 2
2 7 4
2 2 6
1 16 1
1 11 3
1 6 5
1 1 7
</PRE>

<P>

<H4><A NAME="SECTION04354050000000000000">
Las  Tres Hijas</A>
</H4>
  

<A NAME="parrfo:lastreshijas"></A>
<P>
En la páginas de Retos Matemáticos de

<P>
<A NAME="tex2html278"
  HREF="http://divulgamat.ehu.es/weborriak/RetosMatematicos/Problemas/Prob15.asp">DIVULGAMAT</A>
<P>
puede encontrarse el siguiente problema:

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Dos matemáticos se vieron en la calle después de muchos años sin coincidir.
</I>
<P>
<UL>
<LI>¡Hola!, ¿qué tal?, ¿te casaste?, y... ¿cuántos hijos tienes?
</LI>
<LI>Pues tengo tres hijas.
</LI>
<LI>¿y qué años tienen?
</LI>
<LI>¡A ver si lo adivinas!: el producto de las edades de las tres es 36, y su suma es el número del portal que ves enfrente...
</LI>
<LI>¡Me falta un dato!
</LI>
<LI>¡Ah, sí!, ¡la mayor toca el piano!
</LI>
</UL>
<P>
<I>¿Qué edad tendrán las tres hijas?
</I>
<P>
<I>¿Podemos ayudarnos de una expresión regular para resolver el problema?
Al ejecutar el siguiente programa:
</I>
<P><PRE>
pl@nereida:~/Lperltesting$ cat -n playspiano.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
 2  use v5.10;
 3  use strict;
 4  use List::Util qw{sum};
 5
 6  local our %u;
 7  sub f {
 8    my @a = @_;
 9    @a = sort { $b &lt;=&gt; $a } (length($a[1]), length($a[0])/length($a[1]), 36/length($a[0]) );
10
11    local $" = ", ";
12    say "(@a)\t ".sum(@a) unless exists($u{"@a"});
13    $u{"@a"} = undef;
14  }
15
16  say "SOL\t\tNUMBER";
17  my @a =  ('1'x36) =~
18           /^((1+)\2+)(\1+)$
19                     (?{ f($1, $2, $3)
20                      })
21             (*FAIL)
22           /x;
</PRE>
<P>
<I>obtenemos la salida:
</I>
<P><PRE>
pl@nereida:~/Lperltesting$ ./playspiano.pl
SOL             NUMBER
(9, 2, 2)        13
(6, 3, 2)        11
(4, 3, 3)        10
(18, 2, 1)       21
(12, 3, 1)       16
(9, 4, 1)        14
(6, 6, 1)        13
</PRE>
<P>
<I>Explique el funcionamiento del programa. 
A la vista de la salida ¿Cuáles eran las 
edades de las hijas?</I></DIV><P></P>

<P>

<H4><A NAME="SECTION04354060000000000000">
Mochila 0-1</A>
</H4>
  

<P>
Para una definición del problema vea la sección 
<A NAME="tex2html279"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/node205.html">El Problema de la Mochila 0-1</A>
en los apuntes de LHP
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>¿Sería capaz de resolver usando expresiones regulares el problema de la mochila 0-1?
</I>
<P>
<I>¡Si lo logra merece el premio a la solución mas freak que se haya encontrado para dicho problema!</I></DIV><P></P>

<P>

<H4><A NAME="SECTION04354070000000000000">
Véase también</A>
</H4>
  

<P>
Véase  también:

<UL>
<LI>Véase el nodo en <A NAME="tex2html280"
  HREF="http://www.perlmonks.org/?node_id=796576">PerlMonks</A>
<SPAN  CLASS="textbf">The Oldest Plays the Piano</SPAN>
</LI>
<LI><A NAME="tex2html281"
  HREF="http://blog.stevenlevithan.com/archives/algebra-with-regexes">Solving Algebraic Equations Using Regular Expressions</A>
</LI>
</UL>

<P>

<H2><A NAME="SECTION04355000000000000000">
Número de substituciones realizadas</A>
</H2>
El operador de substitución devuelve el número de substituciones
realizadas, que puede ser mayor que uno si se usa la opción
<code>/g</code>. En cualquier otro caso retorna el valor falso.
<PRE>
   1 #!/usr/bin/perl -w
   2 undef($/);
   3 $paragraph = &lt;STDIN&gt;;
   4 $count = 0;
   5 $count = ($paragraph =~ s/Mister\b/Mr./ig);
   6 print "$paragraph";
   7 print "\n$count\n";
</PRE>
El resultado de la ejecución es el siguiente:
<PRE>
&gt; numsust.pl
Dear Mister Bean,
Is a pleasure for me and Mister Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mister Goofy.
 
Yours sincerely
  Mister Mickey Mouse
Dear Mr. Bean,
Is a pleasure for me and Mr. Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mr. Goofy.
 
Yours sincerely
  Mr. Mickey Mouse
 
4
</PRE>

<P>

<H2><A NAME="SECTION04356000000000000000">
Expandiendo y comprimiendo tabs</A>
</H2>
Este programa convierte los tabs en el número apropiado de blancos.

<pre>
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span> <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = &lt;&gt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>   <span class="synStatement">while</span> (<span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$&amp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/e</span>) {}
<span class="synLinenum">    8</span>   <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span> }
</pre>
Sigue un ejemplo de ejecución:

<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">cat -nt tabs.in</span>
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ <span class="dbuser">./expandtabs.pl tabs.in | cat -tn</span>
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
</pre>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>¿Funciona igual si se cambia el bucle <code>while</code> por una opción <code>/g</code>?

<pre>
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = &lt;&gt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>     <span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$&amp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/ge</span>;
<span class="synLinenum">    8</span>     <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span>   }
</pre>
¿Porqué?</I></DIV><P></P>

<P>

<H2><A NAME="SECTION04357000000000000000">
Modificación de Múltiples Ficheros: one liner</A>
</H2>
Aunque no es la forma de uso habitual, Perl puede ser utilizado en ``modo sed'' para modificar el texto en múltiples ficheros: 

<P>
<code>perl  -e 's/nereida\.deioc\.ull\.es/miranda.deioc.ull.es/gi'  -p  -i.bak  *.html</code>

<P>
Este programa sustituye la palabra original (g)lobalmente e i)gnorando el ``case'') en todos los ficheros <code>*.html</code> y para cada uno de ellos crea una copia de seguridad <code>*.html.bak</code>. 

<P>
Otro ejemplo: la sustitución que sigue ocurre en todos los ficheros <code>info.txt</code> en todos
los subdirectorios de los subdirectorios que comiencen por <code>alu</code>:

<P>
<PRE>
perl -e 's/\|hyperpage//gi' -p -i.bak  alu*/*/info.txt
</PRE>

<P>
Las <A NAME="8858"></A><SPAN  CLASS="textbf">opciones de línea</SPAN> de comandos significan lo siguiente:

<P>
<DL COMPACT>
<DT>-e</DT>
<DD>puede usarse para definir el script en la línea de comandos. Multiples -e te permiten escribir un multi-script. Cuando se usa -e, perl
      no busca por un fichero de script entre la lista de argumentos. 

<P>
</DD>
<DT>-p</DT>
<DD>La opción <A NAME="8860"></A><TT>-p</TT> hace que perl incluya un bucle alrededor de tu ``script'' al estilo sed: 
<PRE>
while (&lt;&gt;) {
        ...             # your script goes here
} continue {
        print;
}
</PRE>
</DD>
<DT>-n</DT>
<DD>Nótese que las líneas se imprimen automáticamente. Para suprimir la impresión usa la opción 
<A NAME="8863"></A><TT>-n</TT> 

<P>
</DD>
<DT>-i[ext]</DT>
<DD>La opción <A NAME="8866"></A><TT>-i</TT> Expresa que los ficheros procesados serán modificados. Se renombra el fichero de entrada <code>file.in</code> a <code>file.in.ext</code>, abriendo el de salida con el mismo nombre del fichero de entrada <code>file.in</code>.
      Se selecciona dicho fichero como de salida por defecto para las sentencias <code>print</code>. Si se proporciona una extensión se hace una copia de seguridad. Si no, no se hace copia de seguridad.
</DD>
</DL>

<P>
En general las opciones pueden ponerse en la primera
línea del ``script'', donde se indica el intérprete. 
Asi pues, decir 

<P>
<code>perl -p -i.bak -e "s/foo/bar/;"</code> 

<P>
es equivalente a usar el ``script'': 
<PRE>
#!/usr/bin/perl -pi.bak
s/foo/bar/;
</PRE>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2680"
  HREF="node27.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2674"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2668"
  HREF="node25.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2676"
  HREF="node217.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2678"
  HREF="node220.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2681"
  HREF="node27.html">tr y split</A>
<B>Sup:</B> <A NAME="tex2html2675"
  HREF="node21.html">Expresiones Regulares en Perl</A>
<B> Ant:</B> <A NAME="tex2html2669"
  HREF="node25.html">Expresiones Regulares en Otros</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-03-30</I>
</ADDRESS>
</BODY>
</HTML>
