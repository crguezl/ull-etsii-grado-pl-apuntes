<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Análisis Sintáctico con Regexp::Grammars</TITLE>
<META NAME="description" CONTENT="Análisis Sintáctico con Regexp::Grammars">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="previous" HREF="node31.html">
<LINK REL="up" HREF="node21.html">
<LINK REL="next" HREF="node33.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2848"
  HREF="node33.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2842"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2838"
  HREF="node31.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2844"
  HREF="node227.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2846"
  HREF="node230.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2849"
  HREF="node33.html">Analizadores Descendentes Predictivos en</A>
<B>Sup:</B> <A NAME="tex2html2843"
  HREF="node21.html">Expresiones Regulares en Perl</A>
<B> Ant:</B> <A NAME="tex2html2839"
  HREF="node31.html">Práctica: Traducción de invitation</A>
<B> Con:</B> 
<A NAME="tex2html2844"
  HREF="node227.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html2846"
  HREF="node230.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2850"
  HREF="node32.html#SECTION043111000000000000000">Introducción</A>
<UL>
<LI><A NAME="tex2html2851"
  HREF="node32.html#SECTION043111010000000000000">El Problema</A>
<LI><A NAME="tex2html2852"
  HREF="node32.html#SECTION043111020000000000000">Una solución: <TT>Regexp::Grammars</TT></A>
<LI><A NAME="tex2html2853"
  HREF="node32.html#SECTION043111030000000000000">La sintaxis de una expresión regular <TT>Regexp::Grammars</TT></A>
<LI><A NAME="tex2html2854"
  HREF="node32.html#SECTION043111040000000000000">El hash <TT>%/</TT>: Una representación del AST</A>
<LI><A NAME="tex2html2855"
  HREF="node32.html#SECTION043111050000000000000">Diferencias entre <TT>token</TT> y <TT>rule</TT></A>
<LI><A NAME="tex2html2856"
  HREF="node32.html#SECTION043111060000000000000">Redefinición de los espacios en blanco</A>
<LI><A NAME="tex2html2857"
  HREF="node32.html#SECTION043111070000000000000">Llamando a las subreglas</A>
<LI><A NAME="tex2html2858"
  HREF="node32.html#SECTION043111080000000000000">Eliminación del anidamiento de ramas unarias en <TT>%/</TT></A>
<LI><A NAME="tex2html2859"
  HREF="node32.html#SECTION043111090000000000000">Ámbito de uso de <TT>Regexp::Grammars</TT></A>
</UL>
<BR>
<LI><A NAME="tex2html2860"
  HREF="node32.html#SECTION043112000000000000000">Objetos</A>
<LI><A NAME="tex2html2861"
  HREF="node32.html#SECTION043113000000000000000">Renombrando los resultados de una subregla</A>
<UL>
<LI><A NAME="tex2html2862"
  HREF="node32.html#SECTION043113010000000000000">Nombre de la regla versus Nombre del Resultado</A>
<LI><A NAME="tex2html2863"
  HREF="node32.html#SECTION043113020000000000000">Colisión de nombres de reglas</A>
<LI><A NAME="tex2html2864"
  HREF="node32.html#SECTION043113030000000000000">Aliasing</A>
<LI><A NAME="tex2html2865"
  HREF="node32.html#SECTION043113040000000000000">Normalización de los resultados mediante aliasing</A>
<LI><A NAME="tex2html2866"
  HREF="node32.html#SECTION043113050000000000000">Ejemplo</A>
</UL>
<BR>
<LI><A NAME="tex2html2867"
  HREF="node32.html#SECTION043114000000000000000">Listas</A>
<UL>
<LI><A NAME="tex2html2868"
  HREF="node32.html#SECTION043114010000000000000">El operador de cierre positivo</A>
<LI><A NAME="tex2html2869"
  HREF="node32.html#SECTION043114020000000000000">Operadores de listas y espacios en blanco</A>
<LI><A NAME="tex2html2870"
  HREF="node32.html#SECTION043114030000000000000">Una Solución al problema de recordar los resultados de una lista: El uso de brackets</A>
<LI><A NAME="tex2html2871"
  HREF="node32.html#SECTION043114040000000000000">Otra forma de resolver las colisiones de nombres: salvarlos en una lista</A>
<LI><A NAME="tex2html2872"
  HREF="node32.html#SECTION043114050000000000000">Aliasing de listas</A>
<LI><A NAME="tex2html2873"
  HREF="node32.html#SECTION043114060000000000000">Caveat: Cierres y Warnings</A>
</UL>
<BR>
<LI><A NAME="tex2html2874"
  HREF="node32.html#SECTION043115000000000000000">Pseudo sub-reglas</A>
<UL>
<LI><A NAME="tex2html2875"
  HREF="node32.html#SECTION043115010000000000000">Subpatrones</A>
<LI><A NAME="tex2html2876"
  HREF="node32.html#SECTION043115020000000000000">Bloques de código</A>
<LI><A NAME="tex2html2877"
  HREF="node32.html#SECTION043115030000000000000">Pseudo subreglas y depuración</A>
</UL>
<BR>
<LI><A NAME="tex2html2878"
  HREF="node32.html#SECTION043116000000000000000">Llamadas a subreglas desmemoriadas</A>
<UL>
<LI><A NAME="tex2html2879"
  HREF="node32.html#SECTION043116010000000000000">Ejemplo: Números entre comas</A>
</UL>
<BR>
<LI><A NAME="tex2html2880"
  HREF="node32.html#SECTION043117000000000000000">Destilación del resultado</A>
<UL>
<LI><A NAME="tex2html2881"
  HREF="node32.html#SECTION043117010000000000000">Destilación manual</A>
<LI><A NAME="tex2html2882"
  HREF="node32.html#SECTION043117020000000000000">Destilación en el programa</A>
</UL>
<BR>
<LI><A NAME="tex2html2883"
  HREF="node32.html#SECTION043118000000000000000">Llamadas privadas a subreglas y subreglas privadas</A>
<LI><A NAME="tex2html2884"
  HREF="node32.html#SECTION043119000000000000000">Mas sobre listas</A>
<UL>
<LI><A NAME="tex2html2885"
  HREF="node32.html#SECTION043119010000000000000">Reconocimiento manual de listas</A>
<LI><A NAME="tex2html2886"
  HREF="node32.html#SECTION043119020000000000000">Analizando listas manualmente</A>
<LI><A NAME="tex2html2887"
  HREF="node32.html#SECTION043119030000000000000">Influencia del orden en el lenguaje reconocido</A>
<LI><A NAME="tex2html2888"
  HREF="node32.html#SECTION043119040000000000000">Aplanamiento manual de listas</A>
<LI><A NAME="tex2html2889"
  HREF="node32.html#SECTION043119050000000000000">Los operadores de repetición</A>
<LI><A NAME="tex2html2890"
  HREF="node32.html#SECTION043119060000000000000">Listas separadas por Algo</A>
<LI><A NAME="tex2html2891"
  HREF="node32.html#SECTION043119070000000000000">Ejemplo: Listas de números separados por comas</A>
<LI><A NAME="tex2html2892"
  HREF="node32.html#SECTION043119080000000000000">Ejemplo: AST para las expresiones aritméticas</A>
</UL>
<BR>
<LI><A NAME="tex2html2893"
  HREF="node32.html#SECTION0431110000000000000000">La directiva <TT>require</TT></A>
<LI><A NAME="tex2html2894"
  HREF="node32.html#SECTION0431111000000000000000">Casando con las claves de un hash</A>
<UL>
<LI><A NAME="tex2html2895"
  HREF="node32.html#SECTION0431111010000000000000">Ejemplo de uso de la directiva hash</A>
</UL>
<BR>
<LI><A NAME="tex2html2896"
  HREF="node32.html#SECTION0431112000000000000000">Depuración</A>
<UL>
<LI><A NAME="tex2html2897"
  HREF="node32.html#SECTION0431112010000000000000">Debugging grammar creation</A>
<LI><A NAME="tex2html2898"
  HREF="node32.html#SECTION0431112020000000000000">Debugging grammar execution</A>
</UL>
<BR>
<LI><A NAME="tex2html2899"
  HREF="node32.html#SECTION0431113000000000000000">Mensajes de <TT>log</TT> del usuario</A>
<LI><A NAME="tex2html2900"
  HREF="node32.html#SECTION0431114000000000000000">Depuración de Regexps</A>
<LI><A NAME="tex2html2901"
  HREF="node32.html#SECTION0431115000000000000000">Manejo y recuperación de errores</A>
<LI><A NAME="tex2html2902"
  HREF="node32.html#SECTION0431116000000000000000">Mensajes de Warning</A>
<LI><A NAME="tex2html2903"
  HREF="node32.html#SECTION0431117000000000000000">Simplificando el AST</A>
<LI><A NAME="tex2html2904"
  HREF="node32.html#SECTION0431118000000000000000">Reciclando una <TT>Regexp::Grammar</TT></A>
<UL>
<LI><A NAME="tex2html2905"
  HREF="node32.html#SECTION0431118010000000000000">Ejecución</A>
<LI><A NAME="tex2html2906"
  HREF="node32.html#SECTION0431118020000000000000">Estructura de la aplicación</A>
<LI><A NAME="tex2html2907"
  HREF="node32.html#SECTION0431118030000000000000">Programa principal</A>
<LI><A NAME="tex2html2908"
  HREF="node32.html#SECTION0431118040000000000000">Las Clases de nodos del AST</A>
<LI><A NAME="tex2html2909"
  HREF="node32.html#SECTION0431118050000000000000">Definiendo <TT>sem</TT> para la evaluación de la expresión</A>
<LI><A NAME="tex2html2910"
  HREF="node32.html#SECTION0431118060000000000000">Definiendo <TT>sem</TT> para la traducción a postfijo</A>
</UL>
<BR>
<LI><A NAME="tex2html2911"
  HREF="node32.html#SECTION0431119000000000000000">Práctica: Calculadora con <TT>Regexp::Grammars</TT></A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION043110000000000000000">
Análisis Sintáctico con <TT>Regexp::Grammars</TT></A>
</H1>

<P>
El módulo <A NAME="tex2html300"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
escrito por <A NAME="tex2html301"
  HREF="http://en.wikipedia.org/wiki/Damian_Conway">Damian Conway</A>
extiende
las expresiones regulares Perl con 
la capacidad de generar representaciones del árbol 
de análisis sintáctico abstracto y obviando la necesidad 
de explicitar los blancos. El módulo necesita para funcionar una versión de Perl superior
o igual a la 5.10. 

<P>

<H2><A NAME="SECTION043111000000000000000">
Introducción</A>
</H2>

<P>

<H4><A NAME="SECTION043111010000000000000">
El Problema</A>
</H4>
  

<P>
La documentación de <A NAME="tex2html302"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A> establece cual es el problema que aborda 
el módulo:
<BLOCKQUOTE><I>...Perl5.10 makes possible to use regexes to recognize complex,
hierarchical-and even recursive-textual structures. The problem is that
Perl 5.10 doesn’t provide any support for extracting that
hierarchical data into nested data structures. In other words,
using Perl 5.10 you can match complex data, but not parse it into an internally useful form.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>An additional problem when using Perl 5.10 regexes to match
complex data formats is that you have to make sure you remember
to insert whitespace- matching constructs (such as <code>\s*</code>) at every
possible position where the data might contain ignorable whitespace. This
reduces the readability of such patterns, and increases the chance of
errors (typically caused by overlooking a location where whitespace
might appear).
</I></BLOCKQUOTE>
<P>
<H4><A NAME="SECTION043111020000000000000">
Una solución: <TT>Regexp::Grammars</TT></A>
</H4>
  

<P>
The <A NAME="tex2html303"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A> module solves both those problems.

<P>
If you import the module into a particular lexical scope, it preprocesses
any regex in that scope, so as to implement a number of extensions to the
standard Perl 5.10 regex syntax. These extensions simplify the task of
defining and calling subrules within a grammar, and allow those subrule
calls to capture and retain the components of they match in a proper
hierarchical manner.

<P>

<P>

<H4><A NAME="SECTION043111030000000000000">
La sintaxis de una expresión regular <TT>Regexp::Grammars</TT></A>
</H4>
  

<P>
Las expresiones regulares <A NAME="tex2html306"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A> aumentan las regexp Perl 5.10. La sintáxis
se expande y se modifica:

<P>
<BLOCKQUOTE><I>A <A NAME="tex2html304"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A> specification consists of a pattern (which may include both standard Perl 5.10 regex syntax, as well as special
<A NAME="tex2html305"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
directives), followed by one or more rule or token definitions.
</I></BLOCKQUOTE>

<P>
Sigue un ejemplo:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n balanced_brackets.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        (&lt;pp&gt;)
    10
    11        &lt;rule: pp&gt;   \( (?: [^()]*+ | &lt;escape&gt; | &lt;pp&gt; )* \)
    12
    13        &lt;token: escape&gt; \\.
    14
    15      }xs;
    16  };
    17
    18  while (my $input = &lt;&gt;) {
    19      while ($input =~ m{$rbb}g) {
    20          say("matches: &lt;$&amp;&gt;");
    21          say Dumper \%/;
    22      }
    23  }
</PRE>

<P>
<BLOCKQUOTE><I>Note that there is no need to explicitly place <code>\s*</code> 
subpatterns throughout the rules; that is taken care of automatically.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The initial pattern (<code>(&lt;pp&gt;)</code>) acts like the <SPAN  CLASS="textbf">top</SPAN> rule of the grammar, and must
be matched completely for the grammar to match.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The rules and tokens are declarations only and they are not directly
matched.  Instead, they act like subroutines, and are invoked by name
from the initial pattern (or from within a rule or token).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Each rule or token extends from the directive that introduces it up to
either the next rule or token directive, or (in the case of the final
rule or token) to the end of the grammar.  
</I></BLOCKQUOTE>
<P>

<P>

<H4><A NAME="SECTION043111040000000000000">
El hash <TT>%/</TT>: Una representación del AST</A>
</H4>
  

Al ejecutar el programa anterior con entrada <code>(2*(3+5))*4+(2-3)</code> produce:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 balanced_brackets.pl
(2*(3+5))*4+(2-3)
matches: &lt;(2*(3+5))&gt;
$VAR1 = {
          '' =&gt; '(2*(3+5))',
          'pp' =&gt; {
                    '' =&gt; '(2*(3+5))',
                    'pp' =&gt; '(3+5)'
                  }
        };

matches: &lt;(2-3)&gt;
$VAR1 = {
          '' =&gt; '(2-3)',
          'pp' =&gt; '(2-3)'
        };
</PRE>

<P>
<BLOCKQUOTE><I>Each rule calls the
subrules specified within it, and then return a hash containing whatever
result each of those subrules returned, with each result indexed by the
subrule’s name.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>In this way, each level of the hierarchical regex can generate hashes
recording everything its own subrules matched, so when the entire pattern
matches, it produces a tree of nested hashes that represent the structured
data the pattern matched.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>In addition each result-hash has one extra key: the empty string. The
value for this key is whatever string the entire subrule call matched.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION043111050000000000000">
Diferencias entre <TT>token</TT> y <TT>rule</TT></A>
</H4>
  

<P>
<BLOCKQUOTE><I>The difference between a token and a rule is that a token treats any
whitespace within it exactly as a normal Perl regular expression would.
That is, a sequence of whitespace in a token is ignored if the <code>/x</code>
modifier is in effect, or else matches the same literal sequence of
whitespace characters (if <code>/x</code> is not in effect).
</I></BLOCKQUOTE>
<P>

<P>
En el ejemplo anterior el comportamiento es el mismo si se reescribe la regla 
para el token <code>escape</code> como:
<PRE>
    13        &lt;rule: escape&gt; \\.
</PRE>
En este otro ejemplo mostramos que la diferencia entre token y rule
es significativa:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsrule.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        &lt;s&gt;
    10
    11        &lt;rule: s&gt; &lt;a&gt; &lt;c&gt;
    12
    13        &lt;rule: c&gt;  c d
    14
    15        &lt;token: a&gt;  a b
    16
    17      }xs;
    18  };
    19
    20  while (my $input = &lt;&gt;) {
    21      if ($input =~ m{$rbb}) {
    22          say("matches: &lt;$&amp;&gt;");
    23          say Dumper \%/;
    24      }
    25      else {
    26          say "Does not match";
    27      }
    28  }
</PRE>

<P>
Al ejecutar este programa vemos la diferencia en la interpretación de los blancos:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 tokenvsrule.pl
ab c d
matches: &lt;ab c d&gt;
$VAR1 = {
          '' =&gt; 'ab c d',
          's' =&gt; {
                   '' =&gt; 'ab c d',
                   'c' =&gt; 'c d',
                   'a' =&gt; 'ab'
                 }
        };

a b c d
Does not match
ab cd
matches: &lt;ab cd&gt;
$VAR1 = {
          '' =&gt; 'ab cd',
          's' =&gt; {
                   '' =&gt; 'ab cd',
                   'c' =&gt; 'cd',
                   'a' =&gt; 'ab'
                 }
        };
</PRE>
Obsérvese como la entrada <code>a b c d</code> es rechazada mientras
que la entrada <code>ab c d</code> es aceptada.

<P>

<H4><A NAME="SECTION043111060000000000000">
Redefinición de los espacios en blanco</A>
</H4>
  

<P>
<BLOCKQUOTE><I>In a rule, any sequence of whitespace (except those at the very start
and the very end of the rule) is treated as matching the implicit subrule
<code>&lt;.ws&gt;</code>, which is automatically predefined to match optional whitespace 
(i.e. <code>\s*</code>).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>You can explicitly define a <code>&lt;ws&gt;</code> token to change that default
behaviour. For example, you could alter the definition of whitespace
to include Perlish comments, by adding an explicit <code>&lt;token: ws&gt;</code>:
</I></BLOCKQUOTE>
<P><PRE>
                      &lt;token: ws&gt;
                         (?: \s+ | #[^\n]* )*
</PRE>
<P>
<BLOCKQUOTE><I>But be careful not to define <code>&lt;ws&gt;</code> as a rule, as this will lead
to all kinds of infinitely recursive unpleasantness.
</I></BLOCKQUOTE>
El siguiente ejemplo ilustra como redefinir <code>&lt;ws&gt;</code>:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsruleandws.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      no warnings 'uninitialized';
 9      qr{
10        &lt;s&gt;
11
12        &lt;token: ws&gt; (?: \s+ | /\* .*? \*/)*+
13
14        &lt;rule: s&gt; &lt;a&gt; &lt;c&gt;
15
16        &lt;rule: c&gt;  c d
17
18        &lt;token: a&gt;  a b
19
20      }xs;
21  };
22
23  while (my $input = &lt;&gt;) {
24      if ($input =~ m{$rbb}) {
25          say Dumper \%/;
26      }
27      else {
28          say "Does not match";
29      }
30  }
</PRE>
Ahora podemos introducir comentarios en la entrada:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 -w tokenvsruleandws.pl
ab /* 1 */ c d
$VAR1 = {
          '' =&gt; 'ab /* 1 */ c d',
          's' =&gt; {
                   '' =&gt; 'ab /* 1 */ c d',
                   'c' =&gt; 'c d',
                   'a' =&gt; 'ab'
                 }
        };
</PRE>

<P>

<H4><A NAME="SECTION043111070000000000000">
Llamando a las subreglas</A>
</H4>
  

<P>
<BLOCKQUOTE><I>To invoke a rule to match at any point, just enclose the rule’s name
in angle brackets (like in <A NAME="tex2html307"
  HREF="http://en.wikipedia.org/wiki/Perl_6">Perl 6</A>). There must be no space between the
opening bracket and the rulename. For example:
</I></BLOCKQUOTE>
<P><PRE>
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               &lt;name&gt;            # Call &lt;rule: name&gt;
               &lt;options&gt;?        # Call &lt;rule: options&gt; (it's okay if it fails)

               &lt;rule: name&gt;
                   # etc.
           }x;
</PRE>
<P>
<BLOCKQUOTE><I>If you need to match a literal pattern that would otherwise look like a subrule call, just backslash-escape the leading angle:
</I></BLOCKQUOTE>
<P><PRE>
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               \&lt;name&gt;           # Match literal sequence '&lt;' 'n' 'a' 'm' 'e' '&gt;'
               &lt;options&gt;?        # Call &lt;rule: options&gt; (it's okay if it fails)

               &lt;rule: name&gt;
                   # etc.
           }x;
</PRE>

<P>
El siguiente programa ilustra algunos puntos discutidos en la cita anterior:
<PRE>
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n badbracket.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        (&lt;pp&gt;)
10
11        &lt;rule: pp&gt;   \( (?: &lt;b  &gt; | \&lt; | &lt; escape&gt; | &lt;pp&gt; )* \)
12
13        &lt;token: b  &gt; b
14
15        &lt;token: escape&gt; \\.
16
17      }xs;
18  };
19
20  while (my $input = &lt;&gt;) {
21      while ($input =~ m{$rbb}g) {
22          say("matches: &lt;$&amp;&gt;");
23          say Dumper \%/;
24      }
25  }
</PRE>

<P>
Obsérvense los blancos en <code>&lt; escape&gt;</code> y en <code>&lt;token: b  &gt; b</code>.
Pese a ello el programa funciona:

<P>
<PRE>
casiano@millo:~/src/perl/regexp-grammar-examples$ perl5.10.1 badbracket.pl
(\(\))
matches: &lt;(\(\))&gt;
$VAR1 = {
          '' =&gt; '(\\(\\))',
          'pp' =&gt; {
                    '' =&gt; '(\\(\\))',
                    'escape' =&gt; '\\)'
                  }
        };

(b)
matches: &lt;(b)&gt;
$VAR1 = {
          '' =&gt; '(b)',
          'pp' =&gt; {
                    '' =&gt; '(b)',
                    'b' =&gt; 'b'
                  }
        };

(&lt;)
matches: &lt;(&lt;)&gt;
$VAR1 = {
          '' =&gt; '(&lt;)',
          'pp' =&gt; '(&lt;)'
        };

(c)

casiano@millo:
</PRE>

<P>

<H4><A NAME="SECTION043111080000000000000">
Eliminación del anidamiento de ramas unarias en <TT>%/</TT></A>
</H4>
  

<P>
<BLOCKQUOTE><I>...Note, however, that if the result-hash at any level contains only the
empty-string key (i.e. the subrule did not call any sub-subrules or
save any of their nested result-hashes), then the hash is <I>unpacked</I>
and just the matched substring itself if returned.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>For example, if <code>&lt;rule: sentence&gt;</code> had been defined:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sentence&gt;
        I see dead people
</PRE>
<P>
<BLOCKQUOTE><I>then a successful call to the rule would only add:
</I></BLOCKQUOTE>
<P><PRE>
    sentence =&gt; 'I see dead people'
</PRE>
<P>
<BLOCKQUOTE><I>to the current result-hash.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This is a useful feature because it prevents a series of nested subrule
calls from producing very unwieldy data structures. For example, without
this automatic unpacking, even the simple earlier example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sentence&gt;
        &lt;noun&gt; &lt;verb&gt; &lt;object&gt;
</PRE>
<P>
<BLOCKQUOTE><I>would produce something needlessly complex, such as:
</I></BLOCKQUOTE>
<P><PRE>
    sentence =&gt; {
        ""     =&gt; 'I saw a dog',
        noun   =&gt; {
            "" =&gt; 'I',
        },
        verb   =&gt; {
            "" =&gt; 'saw',
        },
        object =&gt; {
            ""      =&gt; 'a dog',
            article =&gt; {
                "" =&gt; 'a',
            },
            noun    =&gt; {
                "" =&gt; 'dog',
            },
        },
    }
</PRE>

<P>
El siguiente ejemplo ilustra este punto:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n unaryproductions.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        &lt;s&gt;
10
11        &lt;rule: s&gt; &lt;noun&gt; &lt;verb&gt; &lt;object&gt;
12
13        &lt;token: noun&gt; he | she | Peter | Jane
14
15        &lt;token: verb&gt; saw | sees
16
17        &lt;token: object&gt; a\s+dog | a\s+cat
18
19      }x;
20  };
21
22  while (my $input = &lt;&gt;) {
23      while ($input =~ m{$rbb}g) {
24          say("matches: &lt;$&amp;&gt;");
25          say Dumper \%/;
26      }
27  }
</PRE>

<P>
Sigue una ejecución del programa anterior:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 unaryproductions.pl
he saw a dog
matches: &lt;he saw a dog&gt;
$VAR1 = {
          '' =&gt; 'he saw a dog',
          's' =&gt; {
                   '' =&gt; 'he saw a dog',
                   'object' =&gt; 'a dog',
                   'verb' =&gt; 'saw',
                   'noun' =&gt; 'he'
                 }
        };

Jane sees a cat
matches: &lt;Jane sees a cat&gt;
$VAR1 = {
          '' =&gt; 'Jane sees a cat',
          's' =&gt; {
                   '' =&gt; 'Jane sees a cat',
                   'object' =&gt; 'a cat',
                   'verb' =&gt; 'sees',
                   'noun' =&gt; 'Jane'
                 }
        };
</PRE>

<P>

<H4><A NAME="SECTION043111090000000000000">
Ámbito de uso de <TT>Regexp::Grammars</TT></A>
</H4>
  

<P>
Cuando se usa <A NAME="tex2html308"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
como parte de 
un programa que utiliza otras regexes hay que evitar 
que <A NAME="tex2html309"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
procese las mismas. <A NAME="tex2html310"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
reescribe las expresiones regulares durante la fase de preproceso. Esta por ello 
presenta las mismas limitaciones que cualquier otra forma de 
'source filtering' (véase <A NAME="tex2html311"
  HREF="http://search.cpan.org/perldoc/?perlfilter"><TT>perlfilter</TT></A>). Por ello es una buena idea declarar
la gramática en un bloque <code>do</code> restringiendo de esta forma el ámbito de 
acción del módulo.

<P>
<PRE>
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 .          ........
28      }xms
29  };
</PRE>

<P>

<H2><A NAME="SECTION043112000000000000000">
Objetos</A>
</H2>

<P>
<BLOCKQUOTE><I>When a grammar has parsed successfully, the <code>%/</code> variable will contain
a series of nested hashes (and possibly arrays) representing the
hierarchical structure of the parsed data.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Typically, the next step is to walk that tree, extracting or converting
or otherwise processing that information. If the tree has nodes of many
different types, it can be difficult to build a recursive subroutine
that can navigate it easily.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>A much cleaner solution is possible if the nodes of the tree are proper
objects. In that case, you just define a <code>trasnlate()</code> method
for each of the classes, and have every node call that method on each
of its children.  The chain of <code>translate()</code> calls would cascade down the
nodes of the tree, each one invoking the appropriate <code>translate()</code> method
according to the type of node encountered.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The only problem is that, by default, <A NAME="tex2html312"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
returns a tree
of plain-old hashes, not <code>Class::Whatever</code> objects. Fortunately, it's
easy to request that the result hashes be automatically blessed into
the appropriate classes, using the <code>&lt;objrule:...&gt;</code> and <code>&lt;objtoken:...&gt;</code>
directives.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>These directives are identical to the <code>&lt;rule:...&gt;</code> and <code>&lt;token:...&gt;</code>
directives (respectively), except that the rule or token they create will
also bless the hash it normally returns, converting it to an object of
a class whose name is the same as the rule or token itself.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;objrule: Element&gt;
        # ...Defines a rule that can be called as &lt;Element&gt;
        # ...and which returns a hash-based Element object
</PRE>
<P>
<BLOCKQUOTE><I>The <code>IDENTIFIER</code> of the rule or token may also be fully qualified. In
such cases, the rule or token is defined using only the final <SPAN  CLASS="textbf">short
name</SPAN>, but the result object is blessed using the fully qualified <SPAN  CLASS="textbf">long
name</SPAN>. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;objrule: LaTeX::Element&gt; 
        # ...Defines a rule that can be called as &lt;Element&gt;
        # ...and which returns a hash-based LaTeX::Element object
</PRE>
<P>
<BLOCKQUOTE><I>This can be useful to ensure that returned objects don't collide with
other namespaces in your program.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Note that you can freely mix object-returning and plain-old-hash-returning
rules and tokens within a single grammar, though you have to be careful
not to subsequently try to call a method on any of the unblessed nodes.
</I></BLOCKQUOTE>
<P>

<P>

<H2><A NAME="SECTION043113000000000000000">
Renombrando los resultados de una subregla</A>
</H2>

<P>

<H4><A NAME="SECTION043113010000000000000">
Nombre de la regla versus Nombre del Resultado</A>
</H4>
  

<P>
No siempre el nombre de la regla es el mas apropiado
para ser el nombre del resultado:

<P>
<BLOCKQUOTE><I>It is not always convenient to have subrule results stored under the same
name as the rule itself. Rule names should be optimized for understanding
the behaviour of the parser, whereas result names should be optimized
for understanding the structure of the data. Often those two goals are
identical, but not always; sometimes rule names need to describe what the
data looks like, while result names need to describe what the data means.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION043113020000000000000">
Colisión de nombres de reglas</A>
</H4>
  

<P>
<BLOCKQUOTE><I>For example, sometimes you need to call the same rule twice, to match two
syntactically identical components whose positions give then semantically
distinct meanings:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: copy_cmd&gt;
        copy &lt;file&gt; &lt;file&gt;
</PRE>
<P>
<BLOCKQUOTE><I>The problem here is that, if the second call to <code>&lt;file&gt;</code> succeeds, its
result-hash will be stored under the key <code>file</code>, clobbering the data
that was returned from the first call to <code>&lt;file&gt;</code>.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION043113030000000000000">
Aliasing</A>
</H4>
  

<P>
<BLOCKQUOTE><I>To avoid such problems, <A NAME="tex2html313"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
allows you to alias any
subrule call, so that it is still invoked by the original name, but its
result-hash is stored under a different key. The syntax for that is:
<code>&lt;alias=rulename&gt;</code>. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt; &lt;to=file&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Here, <code>&lt;rule: file&gt;</code> is called twice, with the first result-hash
being stored under the key <code>from</code>, and the second result-hash being
stored under the key <code>to</code>.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Note, however, that the alias before the <code>=</code> must be a proper identifier
(i.e. a letter or underscore, followed by letters, digits, and/or
underscores). Aliases that start with an underscore and aliases named
<code>MATCH</code> have special meaning.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION043113040000000000000">
Normalización de los resultados mediante aliasing</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Aliases can also be useful for normalizing data that may appear in
different formats and sequences. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt;        &lt;to=file&gt;
      | dup    &lt;to=file&gt;  as  &lt;from=file&gt;
      |      &lt;from=file&gt;  -&gt;    &lt;to=file&gt;
      |        &lt;to=file&gt;  &lt;-  &lt;from=file&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Here, regardless of which order the old and new files are specified,
the result-hash always gets:
</I></BLOCKQUOTE>
<P><PRE>
    copy_cmd =&gt; {
        from =&gt; 'oldfile',
          to =&gt; 'newfile',
    }
</PRE>

<P>

<H4><A NAME="SECTION043113050000000000000">
Ejemplo</A>
</H4>
  

<P>
El siguiente programa ilustra los comentarios de la documentación:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n copygrammar.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        &lt;copy_cmd&gt;
    10
    11        &lt;rule: copy_cmd&gt;
    12              copy &lt;from=file&gt; &lt;to=file&gt;
    13          |   &lt;from=file&gt; -&gt;   &lt;to=file&gt;
    14          |   &lt;to=file&gt;   &lt;- &lt;from=file&gt;
    15
    16        &lt;token: file&gt; [\w./\\]+
    17      }x;
    18  };
    19
    20  while (my $input = &lt;&gt;) {
    21      while ($input =~ m{$rbb}g) {
    22          say("matches: &lt;$&amp;&gt;");
    23          say Dumper \%/;
    24      }
    25  }
</PRE>
Cuando lo ejecutamos obtenemos:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 copygrammar.pl
copy a b
matches: &lt;copy a b&gt;
$VAR1 = {
          '' =&gt; 'copy a b',
          'copy_cmd' =&gt; {
                          '' =&gt; 'copy a b',
                          'to' =&gt; 'b',
                          'from' =&gt; 'a'
                        }
        };

b &lt;- a
matches: &lt;b &lt;- a&gt;
$VAR1 = {
          '' =&gt; 'b &lt;- a',
          'copy_cmd' =&gt; {
                          '' =&gt; 'b &lt;- a',
                          'to' =&gt; 'b',
                          'from' =&gt; 'a'
                        }
        };

a -&gt; b
matches: &lt;a -&gt; b&gt;
$VAR1 = {
          '' =&gt; 'a -&gt; b',
          'copy_cmd' =&gt; {
                          '' =&gt; 'a -&gt; b',
                          'to' =&gt; 'b',
                          'from' =&gt; 'a'
                        }
        };
</PRE>

<P>

<H2><A NAME="SECTION043114000000000000000">
Listas</A>
</H2>

<P>

<H4><A NAME="SECTION043114010000000000000">
El operador de cierre positivo</A>
</H4>
  

<P>
<BLOCKQUOTE><I>If a subrule call is quantified with a repetition specifier:
</I></BLOCKQUOTE>
<P><PRE>
           &lt;rule: file_sequence&gt;
               &lt;file&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>then each repeated match overwrites the corresponding entry in the
surrounding rule’s result-hash, so only the result of the final
repetition will be
retained. That is, if the above example matched the string  <code>foo.pl bar.py baz.php</code>, 
then the result-hash would contain:
</I></BLOCKQUOTE>
<P><PRE>
           file_sequence {
               ""   =&gt; 'foo.pl bar.py baz.php',
               file =&gt; 'baz.php',
           }
</PRE>

<P>

<H4><A NAME="SECTION043114020000000000000">
Operadores de listas y espacios en blanco</A>
</H4>
  

<P>
Existe un caveat con el uso de los operadores de repetición
y el manejo de los blancos. Véase el siguiente programa:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers3.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;numbers&gt;
11
12        &lt;rule: numbers&gt;
13          (&lt;number&gt;)+
14
15        &lt;token: number&gt; \s*\d+
16      }xms;
17  };
18
19  while (my $input = &lt;&gt;) {
20      if ($input =~ m{$rbb}) {
21          say("matches: &lt;$&amp;&gt;");
22          say Dumper \%/;
23      }
24  }
</PRE>
Obsérvese el uso explícito 
de espacios <code>\s*\d+</code> en la definición de <code>number</code>.

<P>
Sigue un ejemplo de ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers3.pl
1 2 3 4
matches: &lt;1 2 3 4&gt;
$VAR1 = {
          '' =&gt; '1 2 3 4',
          'numbers' =&gt; {
                         '' =&gt; '1 2 3 4',
                         'number' =&gt; ' 4'
                       }
        };
</PRE>

<P>
Si se eliminan los blancos de la definición de 
<code>number</code>: 
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        &lt;numbers&gt;
    11  
    12        &lt;rule: numbers&gt; 
    13          (&lt;number&gt;)+
    14  
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: &lt;$&amp;&gt;");
    22          say Dumper \%/;
    23      }
    24  }
</PRE>
se obtiene una conducta que puede sorprender:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers.pl 
12 34 56
matches: &lt;12&gt;
$VAR1 = {
          '' =&gt; '12',
          'numbers' =&gt; {
                         '' =&gt; '12',
                         'number' =&gt; '12'
                       }
        };
</PRE>

<P>
La explicación está en la documentación: véase la sección <A NAME="tex2html314"
  HREF="http://search.cpan.org/~dconway/Regexp-Grammars/lib/Regexp/Grammars.pm#Grammar_syntax">Grammar Syntax</A>:
<BLOCKQUOTE><I><code>&lt;rule: IDENTIFIER&gt;</code>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Define a rule whose name is specified by the supplied identifier.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Everything following the <code>&lt;rule:...&gt;</code> directive (up to the next <code>&lt;rule:...&gt;</code> or <code>&lt;token:...&gt;</code> directive) 
is treated as part of the rule being defined.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><SPAN  CLASS="textbf">Any whitespace in the rule is replaced by a call to the</SPAN> <code>&lt;.ws&gt;</code> subrule (which defaults to matching <code>\s*</code>, but may be explicitly redefined).
</I></BLOCKQUOTE>
<P>
También podríamos haber resuelto el problema introduciendo un
blanco explícito dentro del cierre positivo:

<P>
<PRE>
      &lt;rule: numbers&gt;
        (&lt;number&gt; )+

      &lt;token: number&gt; \d+
</PRE>

<P>

<H4><A NAME="SECTION043114030000000000000">
Una Solución al problema de recordar los resultados de una lista: El uso de brackets</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Usually, that’s not the desired outcome, so <A NAME="tex2html315"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
provides
another mechanism by which to call a subrule; one that saves all
repetitions of its results.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>A regular subrule call consists of the rule’s name surrounded by angle
brackets. If, instead, you surround the rule’s name with  <code>&lt;[...]&gt;</code>
(angle and square brackets) like so:
</I></BLOCKQUOTE>
<P><PRE>
           &lt;rule: file_sequence&gt;
               &lt;[file]&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>then the rule is invoked in exactly the same way, but the result of that
submatch is pushed onto an array nested inside the appropriate result-hash
entry. In other words, if the above example matched the same  
<code>foo.pl bar.py baz.php</code> string, the result-hash would contain:
</I></BLOCKQUOTE>
<P><PRE>
           file_sequence {
               ""   =&gt; 'foo.pl bar.py baz.php',
               file =&gt; [ 'foo.pl', 'bar.py', 'baz.php' ],
           }
</PRE>

<P>
Teniendo en cuenta lo dicho anteriormente sobre los blancos
dentro de los cuantificadores, es necesario introducir
blancos dentro del operador de repetición:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers4.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8
     9      qr{
    10        &lt;numbers&gt;
    11
    12        &lt;rule: numbers&gt;
    13          (?:  &lt;[number]&gt; )+
    14
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: &lt;$&amp;&gt;");
    22          say Dumper \%/;
    23      }
    24  }
</PRE>
Al ejecutar este programa obtenemos:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers4.pl
1 2 3 4
matches: &lt;1 2 3 4
&gt;
$VAR1 = {
          '' =&gt; '1 2 3 4
',
          'numbers' =&gt; {
                         '' =&gt; '1 2 3 4
',
                         'number' =&gt; [ '1', '2', '3', '4' ]
                       }
        };
</PRE>

<P>

<H4><A NAME="SECTION043114040000000000000">
Otra forma de resolver las colisiones de nombres: salvarlos en una lista</A>
</H4>
  

<P>
<BLOCKQUOTE><I>This <SPAN  CLASS="textbf">listifying subrule call</SPAN> can also be useful for non-repeated
subrule calls, if the same subrule is invoked in several places in a
grammar. For example if a cmdline option could be given either one or
two values, you might parse it:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: size_option&gt;   
        -size &lt;[size]&gt; (?: x &lt;[size]&gt; )?
</PRE>
<P>
<BLOCKQUOTE><I>The result-hash entry for <code>size</code> would then always contain an array,
with either one or two elements, depending on the input being parsed.
</I></BLOCKQUOTE>
Sigue un ejemplo:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n sizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;command&gt;
11
12        &lt;rule: command&gt; ls &lt;size_option&gt;
13
14        &lt;rule: size_option&gt;
15            -size &lt;[size]&gt; (?: x &lt;[size]&gt; )?
16
17        &lt;token: size&gt; \d+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: &lt;$&amp;&gt;");
24          say Dumper \%/;
25      }
26  }
</PRE>
Veamos su comportamiento con diferentes entradas:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 sizes.pl
ls -size 4
matches: &lt;ls -size 4
&gt;
$VAR1 = {
          '' =&gt; 'ls -size 4
',
          'command' =&gt; {
                         'size_option' =&gt; {
                                            '' =&gt; '-size 4
',
                                            'size' =&gt; [ '4' ]
                                          },
                         '' =&gt; 'ls -size 4
'
                       }
        };

ls -size 2x8
matches: &lt;ls -size 2x8
&gt;
$VAR1 = {
          '' =&gt; 'ls -size 2x8
',
          'command' =&gt; {
                         'size_option' =&gt; {
                                            '' =&gt; '-size 2x8
',
                                            'size' =&gt; [ '2', '8' ]
                                          },
                         '' =&gt; 'ls -size 2x8
'
                       }
        };
</PRE>

<P>

<H4><A NAME="SECTION043114050000000000000">
Aliasing de listas</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Listifying subrules can also be given aliases, just like ordinary
subrules. The alias is always specified inside the square brackets:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: size_option&gt;   
        -size &lt;[size=pos_integer]&gt; (?: x &lt;[size=pos_integer]&gt; )?
</PRE>
<P>
<BLOCKQUOTE><I>Here, the sizes are parsed using the <code>pos_integer</code> rule, 
but saved in the result-hash in an array under the key <code>size</code>.
</I></BLOCKQUOTE>

<P>
Sigue un ejemplo:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedsizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;command&gt;
11
12        &lt;rule: command&gt; ls &lt;size_option&gt;
13
14        &lt;rule: size_option&gt;
15            -size &lt;[size=int]&gt; (?: x &lt;[size=int]&gt; )?
16
17        &lt;token: int&gt; \d+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: &lt;$&amp;&gt;");
24          say Dumper \%/;
25      }
26  }
</PRE>
Veamos el resultado de una ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedsizes.pl
ls -size 2x4
matches: &lt;ls -size 2x4
&gt;
$VAR1 = {
          '' =&gt; 'ls -size 2x4
',
          'command' =&gt; {
                         'size_option' =&gt; {
                                            '' =&gt; '-size 2x4
',
                                            'size' =&gt; [
                                                        '2',
                                                        '4'
                                                      ]
                                          },
                         '' =&gt; 'ls -size 2x4
'
                       }
        };
</PRE>

<P>

<H4><A NAME="SECTION043114060000000000000">
Caveat: Cierres y Warnings</A>
</H4>
  

<P>
En este ejemplo aparece <code>&lt;number&gt;+</code> sin 
corchetes ni paréntesis:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers5.pl 
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        &lt;numbers&gt;
    11  
    12        &lt;rule: numbers&gt; 
    13          &lt;number&gt;+
    14  
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: &lt;$&amp;&gt;");
    22          say Dumper \%/;
    23      }
    24  }
</PRE>
Este programa produce un mensaje de advertencia:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers5.pl 
  warn | Repeated subrule &lt;number&gt;+ will only capture its final match
       | (Did you mean &lt;[number]&gt;+ instead?)
       |
</PRE>

<P>
Si se quiere evitar el mensaje y se está dispuesto a asumir la pérdida
de los valores asociados con los elementos de la lista se deberán poner 
el operando entre paréntesis (con o sin memoria).

<P>
Esto es lo que dice la documentación sobre este warning:

<P>
<BLOCKQUOTE><I><code>Repeated subrule &lt;rule&gt; will only capture its final match</code>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>You specified a subrule call with a repetition qualifier, such as:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;ListElem&gt;*
</PRE>
<P>
<BLOCKQUOTE><I>or:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;ListElem&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>Because each subrule call saves its result in a hash entry of the
same name, each repeated match will overwrite the previous ones,
so only the last match will ultimately be saved. If you want to
save all the matches, you need to tell <A NAME="tex2html316"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
to save the
sequence of results as a nested array within the hash entry, like so:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;[ListElem]&gt;*
</PRE>
<P>
<BLOCKQUOTE><I>or:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;[ListElem]&gt;+
</PRE>
<P>
<BLOCKQUOTE><I>If you really did intend to throw away every result but the final
one, you can silence the warning by placing the subrule call inside
any kind of parentheses. For example:
</I></BLOCKQUOTE>
<P><PRE>
        (&lt;ListElem&gt;)*
</PRE>
<P>
<BLOCKQUOTE><I>or:
</I></BLOCKQUOTE>
<P><PRE>
        (?: &lt;ListElem&gt; )+
</PRE>
<P>

<P>

<H2><A NAME="SECTION043115000000000000000">
Pseudo sub-reglas</A>
</H2>

<P>

<H4><A NAME="SECTION043115010000000000000">
Subpatrones</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Aliases can also be given to standard Perl subpatterns, as well as to
code blocks within a regex. The syntax for subpatterns is:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;ALIAS= (SUBPATTERN) &gt;
</PRE>
<P>
<BLOCKQUOTE><I>In other words, the syntax is exactly like an aliased subrule call, except
that the rule name is replaced with a set of parentheses containing the
subpattern. Any parentheses-capturing or non-capturing-will do.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The effect of aliasing a standard subpattern is to cause whatever that
subpattern matches to be saved in the result-hash, using the alias as
its key. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: file_command&gt;

        &lt;cmd=(mv|cp|ln)&gt;  &lt;from=file&gt;  &lt;to=file&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Here, the <code>&lt;cmd=(mv|cp|ln)&gt;</code> is treated exactly like a regular <code>(mv|cp|ln)</code>,
but whatever substring it matches is saved in the result-hash under the
key <code>'cmd'</code>.
</I></BLOCKQUOTE>
Sigue un ejemplo:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n subpattern.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10          &lt;file_command&gt;
11
12          &lt;rule: file_command&gt;
13
14          &lt;cmd=(mv|cp|ln)&gt;  &lt;from=([\w./]+)&gt;  &lt;to=([\w./]+)&gt;
15
16      }x;
17  };
18
19  while (my $input = &lt;&gt;) {
20      while ($input =~ m{$rbb}g) {
21          say("matches: &lt;$&amp;&gt;");
22          say Dumper \%/;
23      }
24  }
</PRE>
y una ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 subpattern.pl
mv a b
matches: &lt;mv a b&gt;
$VAR1 = {
          '' =&gt; 'mv a b',
          'file_command' =&gt; {
                              '' =&gt; 'mv a b',
                              'to' =&gt; 'b',
                              'cmd' =&gt; 'mv',
                              'from' =&gt; 'a'
                            }
        };

cp c d
matches: &lt;cp c d&gt;
$VAR1 = {
          '' =&gt; 'cp c d',
          'file_command' =&gt; {
                              '' =&gt; 'cp c d',
                              'to' =&gt; 'd',
                              'cmd' =&gt; 'cp',
                              'from' =&gt; 'c'
                            }
        }
</PRE>

<P>

<H4><A NAME="SECTION043115020000000000000">
Bloques de código</A>
</H4>
  

<P>
<BLOCKQUOTE><I>The syntax for aliasing code blocks is:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;ALIAS= (?{ your($code-&gt;here) }) &gt;
</PRE>
<P>
<BLOCKQUOTE><I>Note, however, that the code block must be specified in the standard
Perl 5.10 regex notation: <code>(?{...})</code>. A common mistake is to write:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;ALIAS= { your($code-&gt;here } &gt;
</PRE>
<P>
<BLOCKQUOTE><I>instead, which will attempt to interpolate <code>$code</code> before the
regex is even compiled, as such variables are only <SPAN  CLASS="textbf">protected</SPAN> from
interpolation inside a <code>(?{...})</code>.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>When correctly specified, this construct executes the code in the block
and saves the result of that execution in the result-hash, using the
alias as its key. Aliased code blocks are useful for adding semantic
information based on which branch of a rule is executed. For example,
consider the <code>copy_cmd</code> alternatives shown earlier:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt;        &lt;to=file&gt;
      | dup    &lt;to=file&gt;  as  &lt;from=file&gt;
      |      &lt;from=file&gt;  -&gt;    &lt;to=file&gt;
      |        &lt;to=file&gt;  &lt;-  &lt;from=file&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Using aliased code blocks, you could add an extra field to the result-
hash to describe which form of the command was detected, like so:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt;        &lt;to=file&gt;  &lt;type=(?{ 'std' })&gt; 
      | dup    &lt;to=file&gt;  as  &lt;from=file&gt;  &lt;type=(?{ 'rev' })&gt; 
      |      &lt;from=file&gt;  -&gt;    &lt;to=file&gt;  &lt;type=(?{ 'fwd' })&gt; 
      |        &lt;to=file&gt;  &lt;-  &lt;from=file&gt;  &lt;type=(?{ 'bwd' })&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Now, if the rule matched, the result-hash would contain something like:
</I></BLOCKQUOTE>
<P><PRE>
    copy_cmd =&gt; {
        from =&gt; 'oldfile',
          to =&gt; 'newfile',
        type =&gt; 'fwd',
    }
</PRE>

<P>
El siguiente ejemplo ilustra lo dicho en la documentación.
En la línea 15 hemos introducido una regla para el control de 
errores<A NAME="tex2html317"
  HREF="footnode.html#foot8603"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN></SUP></A>:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedcodeblock2.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        &lt;copy_cmd&gt;
10
11        &lt;rule: copy_cmd&gt;
12              copy (&lt;from=file&gt;) (&lt;to=file&gt;) &lt;type=(?{ 'std' })&gt;
13          |   &lt;from=file&gt; -&gt;   &lt;to=file&gt; &lt;type=(?{ 'fwd' })&gt;
14          |   &lt;to=file&gt;   &lt;- &lt;from=file&gt; &lt;type=(?{ 'bwd' })&gt;
15          |   .+ (?{ die "Syntax error!\n" })
16
17        &lt;token: file&gt; [\w./\\]+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: &lt;$&amp;&gt;");
24          say Dumper \%/;
25      }
26  }
</PRE>

<P>
La ejecución muestra el comportamiento del programa con tres entradas válidas
y una errónea:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedcodeblock2.pl
copy a b
matches: &lt;copy a b
&gt;
$VAR1 = {
          '' =&gt; 'copy a b
',
          'copy_cmd' =&gt; {
                          '' =&gt; 'copy a b
',
                          'to' =&gt; 'b',
                          'from' =&gt; 'a',
                          'type' =&gt; 'std'
                        }
        };

b &lt;- a
matches: &lt;b &lt;- a
&gt;
$VAR1 = {
          '' =&gt; 'b &lt;- a
',
          'copy_cmd' =&gt; {
                          '' =&gt; 'b &lt;- a
',
                          'to' =&gt; 'b',
                          'from' =&gt; 'a',
                          'type' =&gt; 'bwd'
                        }
        };

a -&gt; b
matches: &lt;a -&gt; b
&gt;
$VAR1 = {
          '' =&gt; 'a -&gt; b
',
          'copy_cmd' =&gt; {
                          '' =&gt; 'a -&gt; b
',
                          'to' =&gt; 'b',
                          'from' =&gt; 'a',
                          'type' =&gt; 'fwd'
                        }
        };

cp a b
Syntax error!
</PRE>

<P>

<H4><A NAME="SECTION043115030000000000000">
Pseudo subreglas y depuración</A>
</H4>
  

<P>
<BLOCKQUOTE><I>Note that, in addition to the semantics described above, aliased
subpatterns and code blocks also become visible to <A NAME="tex2html318"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
integrated debugger (see <A NAME="tex2html319"
  HREF="http://search.cpan.org/~dconway/Regexp-Grammars/lib/Regexp/Grammars.pm#Debugging">Debugging</A>).
</I></BLOCKQUOTE>

<P>

<H2><A NAME="SECTION043116000000000000000">
Llamadas a subreglas desmemoriadas</A>
</H2>

<P>
<BLOCKQUOTE><I>By default, every subrule call saves its result into the result-hash,
either under its own name, or under an alias.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>However, sometimes you may want to refactor some literal part of a rule
into one or more subrules, without having those submatches added to the
result-hash. The syntax for calling a subrule, but ignoring its return
value is:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;.SUBRULE&gt;
</PRE>
<P>
<BLOCKQUOTE><I>(which is stolen directly from Perl 6).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>For example, you may prefer to rewrite a rule such as:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: paren_pair&gt; 

        \( 
            (?: &lt;escape&gt; | &lt;paren_pair&gt; | &lt;brace_pair&gt; | [^()] )*
        \)
</PRE>
<P>
<BLOCKQUOTE><I>without any literal matching, like so:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: paren_pair&gt; 

        &lt;.left_paren&gt;
            (?: &lt;escape&gt; | &lt;paren_pair&gt; | &lt;brace_pair&gt; | &lt;.non_paren&gt; )*
        &lt;.right_paren&gt;
    
    &lt;token: left_paren&gt;   \(
    &lt;token: right_paren&gt;  \)
    &lt;token: non_paren&gt;    [^()]
</PRE>
<P>
<BLOCKQUOTE><I>Moreover, as the individual components inside the parentheses probably
aren't being captured for any useful purpose either, you could further
optimize that to:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: paren_pair&gt; 

        &lt;.left_paren&gt;
            (?: &lt;.escape&gt; | &lt;.paren_pair&gt; | &lt;.brace_pair&gt; | &lt;.non_paren&gt; )*
        &lt;.right_paren&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Note that you can also use the dot modifier on an aliased subpattern:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;.Alias= (SUBPATTERN) &gt;
</PRE>
<P>
<BLOCKQUOTE><I>This seemingly contradictory behaviour (of giving a subpattern a name,
then deliberately ignoring that name) actually does make sense in
one situation. Providing the alias makes the subpattern visible to the
debugger, while using the dot stops it from affecting the result-hash. See
<SPAN  CLASS="textbf">Debugging non-grammars</SPAN> for an example of this usage.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION043116010000000000000">
Ejemplo: Números entre comas</A>
</H4>
  

<P>
Por ejemplo, queremos reconocer listas de números separados por comas.
Supongamos también que queremos
darle un nombre a la expresión regular de separación.
Quizá, aunque no es el caso, porque la expresión
regular de separación sea suficientemente compleja.
Si no usamos la notación <SPAN  CLASS="textbf">punto</SPAN> la coma aparecerá en la estructura:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n numberscomma.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        &lt;numbers&gt;
    12
    13        &lt;objrule: numbers&gt;
    14          &lt;[number]&gt; (&lt;comma&gt; &lt;[number]&gt;)*
    15
    16        &lt;objtoken: number&gt; \s*\d+
    17        &lt;token: comma&gt;  \s*,
    18      }xms;
    19  };
    20
    21  while (my $input = &lt;&gt;) {
    22      if ($input =~ m{$rbb}) {
    23          say("matches: &lt;$&amp;&gt;");
    24          say Dumper \%/;
    25      }
    26  }
</PRE>
En efecto, aparece la clave <code>comma</code>:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma.pl
2, 3, 4
matches: &lt;2, 3, 4&gt;
$VAR1 = {
  '' =&gt; '2, 3, 4',
  'numbers' =&gt; bless( {
    '' =&gt; '2, 3, 4',
    'number' =&gt; [
      bless( { '' =&gt; '2' }, 'number' ),
      bless( { '' =&gt; '3' }, 'number' ),
      bless( { '' =&gt; '4' }, 'number' )
    ],
    'comma' =&gt; ','
  }, 'numbers' )
};
</PRE>
Si cambiamos la llamada a la regla <code>&lt;comma&gt;</code> por 
<code>&lt;.comma&gt;</code> 

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ diff numberscomma.pl numberscomma2.pl
14c14
&lt;         &lt;[number]&gt; (&lt;comma&gt; &lt;[number]&gt;)*
---
&gt;         &lt;[number]&gt; (&lt;.comma&gt; &lt;[number]&gt;)*
</PRE>
eliminamos la aparición de la innecesaria clave:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma2.pl
2, 3, 4
matches: &lt;2, 3, 4&gt;
$VAR1 = {
  '' =&gt; '2, 3, 4',
  'numbers' =&gt; bless( {
    '' =&gt; '2, 3, 4',
    'number' =&gt; [
      bless( { '' =&gt; '2' }, 'number' ),
      bless( { '' =&gt; '3' }, 'number' ),
      bless( { '' =&gt; '4' }, 'number' )
    ]
  }, 'numbers' )
};
</PRE>

<P>

<H2><A NAME="SECTION043117000000000000000">
Destilación del resultado</A>
</H2>

<P>

<H4><A NAME="SECTION043117010000000000000">
Destilación manual</A>
</H4>
  

<P>
<BLOCKQUOTE><I><A NAME="tex2html320"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
also offers full manual control over the distillation
process. If you use the reserved word <code>MATCH</code> as the alias for a subrule
call:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;MATCH=filename&gt;
</PRE>
<P>
<BLOCKQUOTE><I>or a subpattern match:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;MATCH=( \w+ )&gt;
</PRE>
<P>
<BLOCKQUOTE><I>or a code block:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;MATCH=(?{ 42 })&gt;
</PRE>
<P>
<BLOCKQUOTE><I>then the current rule will treat the return value of that subrule,
pattern, or code block as its complete result, and return that value
instead of the usual result-hash it constructs. This is the case even
if the result has other entries that would normally also be returned.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>For example, in a rule like:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: term&gt;
          &lt;MATCH=literal&gt;
        | &lt;left_paren&gt; &lt;MATCH=expr&gt; &lt;right_paren&gt;
</PRE>
<P>
<BLOCKQUOTE><I>The use of <code>MATCH</code> aliases causes the rule to return either whatever
<code>&lt;literal&gt;</code> returns, or whatever <code>&lt;expr&gt;</code> returns (provided it's between
left and right parentheses).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Note that, in this second case, even though <code>&lt;left_paren&gt;</code> and <code>&lt;right_paren&gt;</code>
are captured to the result-hash, they are not returned, because the
<code>MATCH</code> alias overrides the normal <SPAN  CLASS="textbf">return the result-hash</SPAN> semantics and
returns only what its associated subrule (i.e. <code>&lt;expr&gt;</code>) produces.
</I></BLOCKQUOTE>

<P>
El siguiente ejemplo ilustra el uso del alias <code>MATCH</code>:

<P>
<PRE>
$ cat -n demo_calc.pl
 1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 8          &lt;Answer&gt;
 9
10          &lt;rule: Answer&gt;
11              &lt;X=Mult&gt; &lt;Op=([+-])&gt; &lt;Y=Answer&gt;
12            | &lt;MATCH=Mult&gt;
13
14          &lt;rule: Mult&gt;
15              &lt;X=Pow&gt; &lt;Op=([*/%])&gt; &lt;Y=Mult&gt;
16            | &lt;MATCH=Pow&gt;
17
18          &lt;rule: Pow&gt;
19              &lt;X=Term&gt; &lt;Op=(\^)&gt; &lt;Y=Pow&gt;
20            | &lt;MATCH=Term&gt;
21
22          &lt;rule: Term&gt;
23                 &lt;MATCH=Literal&gt;
24            | \( &lt;MATCH=Answer&gt; \)
25
26          &lt;token: Literal&gt;
27              &lt;MATCH=( [+-]? \d++ (?: \. \d++ )?+ )&gt;
28      }xms
29  };
30
31  while (my $input = &lt;&gt;) {
32      if ($input =~ $calculator) {
33          use Data::Dumper 'Dumper';
34          warn Dumper \%/;
35      }
36  }
</PRE>

<P>
Veamos una ejecución:

<P>
<PRE>
$ ./demo_calc.pl
2+3*5
$VAR1 = {
          '' =&gt; '2+3*5',
          'Answer' =&gt; {
                        '' =&gt; '2+3*5',
                        'Op' =&gt; '+',
                        'X' =&gt; '2',
                        'Y' =&gt; {
                                 '' =&gt; '3*5',
                                 'Op' =&gt; '*',
                                 'X' =&gt; '3',
                                 'Y' =&gt; '5'
                               }
                      }
        };
4-5-2
$VAR1 = {
          '' =&gt; '4-5-2',
          'Answer' =&gt; {
                        '' =&gt; '4-5-2',
                        'Op' =&gt; '-',
                        'X' =&gt; '4',
                        'Y' =&gt; {
                                 '' =&gt; '5-2',
                                 'Op' =&gt; '-',
                                 'X' =&gt; '5',
                                 'Y' =&gt; '2'
                               }
                      }
        };
</PRE>
Obsérvese como el árbol construido para la expresión <code>4-5-2</code> 
se hunde a derechas dando lugar a una jerarquía errónea.
Para arreglar el problema sería necesario eliminar la 
recursividad por la izquierda en las reglas correspondientes.

<P>

<H4><A NAME="SECTION043117020000000000000">
Destilación en el programa</A>
</H4>
  

<P>
<BLOCKQUOTE><I>It's also possible to control what a rule returns from within a code
block. <A NAME="tex2html321"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
provides a set of reserved variables that give
direct access to the result-hash.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The result-hash itself can be accessed as <code>%MATCH</code> within any code block
inside a rule. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sum&gt; 
        &lt;X=product&gt; \+ &lt;Y=product&gt;
            &lt;MATCH=(?{ $MATCH{X} + $MATCH{Y} })&gt;
</PRE>
<P>
<BLOCKQUOTE><I>Here, the rule matches a product (aliased <code>'X'</code> in the result-hash), then a
literal <code>'+'</code>, then another product (aliased to <code>'Y'</code> in the result-hash). The
rule then executes the code block, which accesses the two saved values
(as <code>$MATCH{X}</code> and <code>$MATCH{Y}</code>), adding them together. Because the block
is itself aliased to <code>MATCH</code>, the sum produced by the block becomes the
(only) result of the rule.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>It is also possible to set the rule result from within a code block
(instead of aliasing it). The special <SPAN  CLASS="textbf">override</SPAN> return value is
represented by the special variable <code>$MATCH</code>. So the previous example
could be rewritten:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sum&gt; 
        &lt;X=product&gt; \+ &lt;Y=product&gt;
            (?{ $MATCH = $MATCH{X} + $MATCH{Y} })
</PRE><BLOCKQUOTE><I>
Both forms are identical in effect. Any assignment to <code>$MATCH</code> overrides
the normal <SPAN  CLASS="textbf">return all subrule results</SPAN> behaviour.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Assigning to <code>$MATCH</code> directly is particularly handy if the result may
not always be <SPAN  CLASS="textbf">distillable</SPAN>, for example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: sum&gt; 
        &lt;X=product&gt; \+ &lt;Y=product&gt;
            (?{ if (!ref $MATCH{X} &amp;&amp; !ref $MATCH{Y}) {
                    # Reduce to sum, if both terms are simple scalars...
                    $MATCH = $MATCH{X} + $MATCH{Y};
                }
                else {
                    # Return full syntax tree for non-simple case...
                    $MATCH{op} = '+';
                }
            })
</PRE>
<P>
<BLOCKQUOTE><I>Note that you can also partially override the subrule return
behaviour. Normally, the subrule returns the complete text it matched
under the <SPAN  CLASS="textbf">empty key</SPAN> of its result-hash. That is, of course, 
<code>$MATCH{""}</code>,
so you can override just that behaviour by directly assigning to that
entry.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>For example, if you have a rule that matches key/value pairs from a
configuration file, you might prefer that any trailing comments not
be included in the <I>matched text</I> entry of the rule's result-hash. You
could hide such comments like so:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: config_line&gt;
        &lt;key&gt; : &lt;value&gt;  &lt;comment&gt;?
            (?{
                # Edit trailing comments out of "matched text" entry...
                $MATCH = "$MATCH{key} : $MATCH{value}";
            })
</PRE>
<P>
<BLOCKQUOTE><I>Some more examples of the uses of <code>$MATCH</code>:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: FuncDecl&gt;
      # Keyword  Name               Keep return the name (as a string)...
        func     &lt;Identifier&gt; ;     (?{ $MATCH = $MATCH{'Identifier'} })


    &lt;rule: NumList&gt;
      # Numbers in square brackets...
        \[ 
            ( \d+ (?: , \d+)* )
        \]

      # Return only the numbers...
        (?{ $MATCH = $CAPTURE })


    &lt;token: Cmd&gt;
      # Match standard variants then standardize the keyword...
        (?: mv | move | rename )      (?{ $MATCH = 'mv'; })
</PRE>
<P>
<BLOCKQUOTE><I><code>$CAPTURE</code> and <code>$CONTEXT</code>
    are both aliases for the built-in read-only <code>$^N </code>variable, 
which always contains the substring matched by 
the nearest preceding <code>(...)</code> capture. 
<code>$^N</code> still works perfectly well, but these are provided 
to improve the readability of code blocks and error messages respectively.
</I></BLOCKQUOTE>

<P>
El siguiente código implementa una calculadora
usando destilación en  el código:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_calc_inline.pl
 1  use v5.10;
 2  use warnings;
 3
 4  my $calculator = do{
 5      use Regexp::Grammars;
 6      qr{
 7          &lt;Answer&gt;
 8
 9          &lt;rule: Answer&gt;
10              &lt;X=Mult&gt; \+ &lt;Y=Answer&gt;
11                  (?{ $MATCH = $MATCH{X} + $MATCH{Y}; })
12            | &lt;X=Mult&gt; - &lt;Y=Answer&gt;
13                  (?{ $MATCH = $MATCH{X} - $MATCH{Y}; })
14            | &lt;MATCH=Mult&gt;
15
16          &lt;rule: Mult&gt;
17              &lt;X=Pow&gt; \* &lt;Y=Mult&gt;
18                  (?{ $MATCH = $MATCH{X} * $MATCH{Y}; })
19            | &lt;X=Pow&gt;  / &lt;Y=Mult&gt;
20                  (?{ $MATCH = $MATCH{X} / $MATCH{Y}; })
21            | &lt;X=Pow&gt;  % &lt;Y=Mult&gt;
22                  (?{ $MATCH = $MATCH{X} % $MATCH{Y}; })
23            | &lt;MATCH=Pow&gt;
24
25          &lt;rule: Pow&gt;
26              &lt;X=Term&gt; \^ &lt;Y=Pow&gt;
27                  (?{ $MATCH = $MATCH{X} ** $MATCH{Y}; })
28            | &lt;MATCH=Term&gt;
29
30          &lt;rule: Term&gt;
31                 &lt;MATCH=Literal&gt;
32            | \( &lt;MATCH=Answer&gt; \)
33
34          &lt;token: Literal&gt;
35              &lt;MATCH=( [+-]? \d++ (?: \. \d++ )?+ )&gt;
36      }xms
37  };
38
39  while (my $input = &lt;&gt;) {
40      if ($input =~ $calculator) {
41          say '--&gt; ', $/{Answer};
42      }
43  }
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Cual es la salida del programa anterior para las entradas:
</I>
<UL>
<LI><code>4-2-2</code>
</LI>
<LI><code>8/4/2</code>
</LI>
<LI><code>2^2^3</code>
</LI>
</UL></DIV><P></P>

<P>

<H2><A NAME="SECTION043118000000000000000">
Llamadas privadas a subreglas y subreglas privadas</A>
</H2>

<P>
<BLOCKQUOTE><I>If a rule name (or an alias) begins with an underscore:
</I></BLOCKQUOTE>
<P><PRE>
     &lt;_RULENAME&gt;       &lt;_ALIAS=RULENAME&gt;  
    &lt;[_RULENAME]&gt;     &lt;[_ALIAS=RULENAME]&gt;
</PRE>
<P>
<BLOCKQUOTE><I>then matching proceeds as normal, and any result that is returned is
stored in the current result-hash in the usual way.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>However, when any rule finishes (and just before it returns) it first
filters its result-hash, removing any entries whose keys begin with an
underscore. This means that any subrule with an underscored name (or with
an underscored alias) remembers its result, but only until the end of
the current rule. Its results are effectively private to the current rule.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This is especially useful in conjunction with result distillation.
</I></BLOCKQUOTE>

<P>

<H2><A NAME="SECTION043119000000000000000">
Mas sobre listas</A>
</H2>

<P>

<H4><A NAME="SECTION043119010000000000000">
Reconocimiento manual de listas</A>
</H4>
  

<P>

<H4><A NAME="SECTION043119020000000000000">
Analizando listas manualmente</A>
</H4>
  

<P>
El siguiente ejemplo muestra como construir un reconocedor de 
listas (posiblemente vacías) de números:
<PRE>
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      &lt;List&gt;
     8
     9      &lt;rule: List&gt;
    10           &lt;digit&gt; &lt;List&gt;
    11         | # empty
    12
    13      &lt;rule: digit&gt;
    14          &lt;MATCH=(\d+)&gt;
    15
    16  }xms;
    17
    18  while (my $input = &lt;&gt;) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn "Does not match\n"
    26      }
    27  }
</PRE>
Sigue una ejecución:
<PRE>
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list.pl
2 3 4
$VAR1 = {
          '' =&gt; '2 3 4',
          'List' =&gt; {
                      '' =&gt; '2 3 4',
                      'digit' =&gt; '2'
                      'List' =&gt; {
                                  '' =&gt; '3 4',
                                  'digit' =&gt; '3'
                                  'List' =&gt; {
                                              '' =&gt; '4',
                                              'digit' =&gt; '4'
                                              'List' =&gt; '',
                                            },
                                },
                    }
        };
</PRE>

<P>

<H4><A NAME="SECTION043119030000000000000">
Influencia del orden en el lenguaje reconocido</A>
</H4>
  

<P>
Tenga en cuenta que el orden de las reglas
influye en el lenguaje reconocido. Véase lo que ocurre si cambiamos 
en el ejemplo anterior el orden de las reglas:
<PRE>
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_empty_first.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      &lt;List&gt;
     8
     9      &lt;rule: List&gt;
    10           # empty
    11         | &lt;digit&gt; &lt;List&gt;
    12
    13      &lt;rule: digit&gt;
    14          &lt;MATCH=(\d+)&gt;
    15
    16  }xms;
    17
    18  while (my $input = &lt;&gt;) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn "Does not match\n"
    26      }
    27  }
</PRE>
Al ejecutar se obtiene:
<PRE>
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list_empty_first.pl
2 3 4
$VAR1 = {
          '' =&gt; '',
          'List' =&gt; ''
        };
</PRE>

<P>
Por supuesto basta poner anclas en el patrón a buscar para forzar a que se reconozca
la lista completa:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ diff simple_list_empty_first.pl simple_list_empty_first_with_anchors.pl
7c7
&lt;     &lt;List&gt;
---
&gt;     ^&lt;List&gt;$
</PRE>
En efecto, la nueva versión reconoce la lista:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_anchors.pl
2 3 4
$VAR1 = {
          '' =&gt; '2 3 4',
          'List' =&gt; {
                      'List' =&gt; {
                                  'List' =&gt; {
                                              'List' =&gt; '',
                                              '' =&gt; '4',
                                              'digit' =&gt; '4'
                                            },
                                  '' =&gt; '3 4',
                                  'digit' =&gt; '3'
                                },
                      '' =&gt; '2 3 4',
                      'digit' =&gt; '2'
                    }
        };
</PRE>

<P>
Si se quiere mantener la producción vacía en primer lugar 
pero forzar el reconocimiento de la lista completa, se puede
hacer uso de un lookahead negativo:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_empty_first_with_lookahead.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use strict;
     5  use Regexp::Grammars;
     6
     7  my $list = qr{
     8      &lt;List&gt;
     9
    10      &lt;rule: List&gt;
    11           (?! &lt;digit&gt; ) # still empty production
    12         | &lt;digit&gt; &lt;List&gt;
    13
    14      &lt;rule: digit&gt;
    15          &lt;MATCH=(\d+)&gt;
    16
    17  }xms;
    18
    19  while (my $input = &lt;&gt;) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn "Does not match\n"
    27      }
    28  }
</PRE>
Así, sólo se reducirá por la regla vacía si el siguiente token no es un
número. Sigue un ejemplo de ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_lookahead.pl
2 3 4
$VAR1 = {
          '' =&gt; '2 3 4',
          'List' =&gt; {
                      'List' =&gt; {
                                  'List' =&gt; {
                                              'List' =&gt; '',
                                              '' =&gt; '4',
                                              'digit' =&gt; '4'
                                            },
                                  '' =&gt; '3 4',
                                  'digit' =&gt; '3'
                                },
                      '' =&gt; '2 3 4',
                      'digit' =&gt; '2'
                    }
        };
</PRE>

<P>

<H4><A NAME="SECTION043119040000000000000">
Aplanamiento manual de listas</A>
</H4>
  

<P>
¿Cómo podemos hacer que la estructura retornada por el reconocedor 
sea una lista?. Podemos añadir acciones como sigue:

<P>
<PRE>
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_action.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      &lt;List&gt;
     8
     9      &lt;rule: List&gt;
    10           &lt;digit&gt; &lt;X=List&gt; &lt;MATCH= (?{ unshift @{$MATCH{X}}, $MATCH{digit}; $MATCH{X} })&gt;
    11         | # empty
    12           &lt;MATCH= (?{ [] })&gt;
    13
    14      &lt;rule: digit&gt;
    15          &lt;MATCH=(\d+)&gt;
    16
    17  }xms;
    18
    19  while (my $input = &lt;&gt;) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn "Does not match\n"
    27      }
    28  }
</PRE>

<P>
Al ejecutarse este programa produce una salida como:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_action.pl
2 3 4
$VAR1 = {
          '' =&gt; '2 3 4',
          'List' =&gt; [ '2', '3', '4' ]
        };
</PRE>

<P>

<H4><A NAME="SECTION043119050000000000000">
Los operadores de repetición</A>
</H4>
  

<P>
Los operadores de repetición como <code>*</code>, <code>+</code>, etc. 
permiten simplificar el análisis de lenguajes de listas:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_star.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list = qr{
 7      &lt;List&gt;
 8
 9      &lt;rule: List&gt;
10          (?: &lt;[digit]&gt;)*
11
12      &lt;rule: digit&gt;
13          &lt;MATCH=(\d+)&gt;
14
15  }xms;
16
17  while (my $input = &lt;&gt;) {
18      chomp $input;
19      if ($input =~ $list) {
20          use Data::Dumper 'Dumper';
21          warn Dumper \%/;
22      }
23      else {
24        warn "Does not match\n"
25      }
26  }
</PRE>
Los corchetes alrededor de <code>digit</code> hacen 
que el valor asociado con el patrón sea la lista de números.
Si no los ponemos el valor asociado sería el último valor de la lista.

<P>

<H4><A NAME="SECTION043119060000000000000">
Listas separadas por Algo</A>
</H4>
  

<P>
<BLOCKQUOTE><I>One of the commonest tasks in text parsing is to match a list of
unspecified length, in which items are separated by a fixed token. Things
like:
</I></BLOCKQUOTE>
<P><PRE>
    1, 2, 3 , 4 ,13, 91        # Numbers separated by commas and spaces

    g-c-a-g-t-t-a-c-a          # Bases separated by dashes

    /usr/local/bin             # Names separated by directory markers

    /usr:/usr/local:bin        # Directories separated by colons
</PRE>
<P>
<BLOCKQUOTE><I>The usual construct required to parse these kinds of structures is either:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: list&gt;

        &lt;item&gt; &lt;separator&gt; &lt;list               # recursive definition
      | &lt;item&gt;                                 # base case
</PRE>
<P>
<BLOCKQUOTE><I>Or, more efficiently, but less prettily:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: list&gt;

        &lt;[item]&gt; (?: &lt;separator&gt; &lt;[item]&gt; )*   # iterative definition
</PRE>
<P>
<BLOCKQUOTE><I>Because this is such a common requirement, <A NAME="tex2html322"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
provides a
cleaner way to specify the iterative version. The syntax is taken from
Perl 6:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: list&gt;

        &lt;[item]&gt; ** &lt;separator&gt;                # iterative definition
</PRE>
<P>
<BLOCKQUOTE><I>This is a repetition specifier on the first subrule (hence the use of <code>**</code>
as the marker, to reflect the repetitive behaviour of <code>*</code>). However, the
number of repetitions is controlled by the second subrule: the first
subrule will be repeatedly matched for as long as the second subrule
matches immediately after it.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>So, for example, you can match a sequence of numbers separated by
commas with:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;[number]&gt; ** &lt;comma&gt;

    &lt;token: number&gt;  \d+
    &lt;token: comma&gt;   \s* , \s*
</PRE>
<P>
<BLOCKQUOTE><I>Note that it's important to use the <code>&lt;[...]&gt;</code> form for the items being
matched, so that all of them are saved in the result hash. You can also
save all the separators (if that's important):
</I></BLOCKQUOTE>
<P><PRE>
    &lt;[number]&gt; ** &lt;[comma]&gt;
</PRE>
<P>
<BLOCKQUOTE><I>The repeated item must be specified as a subrule call fo some kind,
but the separators may be specified either as a subrule or a bracketed
pattern. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;[number]&gt; ** ( , )
</PRE>
<P>
<BLOCKQUOTE><I>The separator must always be specified in matched delimiters of some kind:
either matching <code>&lt;...&gt;</code> or matching <code>(...)</code>. 
A common error is to write:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;[number]&gt; ** ,
</PRE>
<P>
<BLOCKQUOTE><I>You can also use a pattern as the item matcher, but it must be aliased
into a subrule:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;[item=(\d+)]&gt; ** ( , )
</PRE>

<P>

<H4><A NAME="SECTION043119070000000000000">
Ejemplo: Listas de números separados por comas</A>
</H4>
  

<P>
Veamos un ejemplo sencillo:

<P>
<PRE>
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n demo_list.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list_nonempty = qr{
 7      &lt;List&gt;
 8
 9      &lt;rule: List&gt;
10          \(  &lt;[Value]&gt; ** (,)  \)
11
12      &lt;token: Value&gt;
13          \d+
14  }xms;
15
16  my $list_empty = qr{
17      &lt;List&gt;
18
19      &lt;rule: List&gt;
20          \(  (?: &lt;[Value]&gt; ** &lt;_Sep=(,)&gt; )?  \)
21
22      &lt;token: Value&gt;
23          \d+
24  }xms;
25
26  use Smart::Comments;
27
28
29  while (my $input = &lt;&gt;) {
30      my $input2 = $input;
31      if ($input =~ $list_nonempty) {
32          ### nonempty: $/{List}
33      }
34      if ($input2 =~ $list_empty) {
35          ### empty: $/{List}
36      }
37  }
</PRE>
Sigue un ejemplo de ejecución:

<P>
<PRE>
casiano@millo:~/src/perl/regexp-grammar-examples$ ./demo_list.pl
(3,4,5)

### nonempty: {
###             '' =&gt; '(3,4,5)',
###             Value =&gt; [
###                        '3',
###                        '4',
###                        '5'
###                      ]
###           }

### empty: {
###          '' =&gt; '(3,4,5)',
###          Value =&gt; [
###                     '3',
###                     '4',
###                     '5'
###                   ]
###        }
()

### empty: '()'
</PRE>

<P>

<H4><A NAME="SECTION043119080000000000000">
Ejemplo: AST para las expresiones aritméticas</A>
</H4>
  

<P>
Las expresiones aritméticas
puede definirse como una jerarquía de listas como
sigue:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n calcaslist.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5  $Data::Dumper::Indent = 1;
 6
 7  my $rbb = do {
 8      use Regexp::Grammars;
 9
10      qr{
11        \A&lt;expr&gt;\z
12
13        &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
14
15        &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
16
17        &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
18
19        &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
20
21        &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
22
23        &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
24                           | \( &lt;MATCH=expr&gt; \)
25
26        &lt;token: addop&gt;        [+-]
27
28        &lt;token: mulop&gt;        [*/]
29
30        &lt;token: powerop&gt;      \*\*|\^
31
32        &lt;token: minus&gt;        - &lt;MATCH=(?{ 'NEG' })&gt;
33
34      }x;
35  };
36
37  while (my $input = &lt;&gt;) {
38      chomp($input);
39      if ($input =~ m{$rbb}) {
40          my $tree = $/{expr};
41          say Dumper $tree;
42
43      }
44      else {
45          say("does not match");
46      }
47  }
</PRE>

<P>
Obsérvese el árbol generado para la expresión <code>4-2-2</code>:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 calcaslist.pl
4-2-2
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '4', 'val' =&gt; '4' }, 'factor' )
                  ],
                  '' =&gt; '4'
                }, 'factorial' )
              ],
              '' =&gt; '4'
            }, 'power' )
          ],
          '' =&gt; '4'
        }, 'uneg' )
      ],
      '' =&gt; '4'
    }, 'term' ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '2', 'val' =&gt; '2' }, 'factor' )
                  ],
                  '' =&gt; '2'
                }, 'factorial' )
              ],
              '' =&gt; '2'
            }, 'power' )
          ],
          '' =&gt; '2'
        }, 'uneg' )
      ],
      '' =&gt; '2'
    }, 'term' ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '2', 'val' =&gt; '2' }, 'factor' )
                  ],
                  '' =&gt; '2'
                }, 'factorial' )
              ],
              '' =&gt; '2'
            }, 'power' )
          ],
          '' =&gt; '2'
        }, 'uneg' )
      ],
      '' =&gt; '2'
    }, 'term' )
  ],
  '' =&gt; '4-2-2',
  'operators' =&gt; [
    '-',
    '-'
  ]
}, 'expr' );
</PRE>

<P>

<H2><A NAME="SECTION0431110000000000000000">
La directiva <TT>require</TT></A>
</H2>

<P>
La directiva <code>require</code> es similar 
en su funcionamiento al paréntesis 5.10 <code>(??{ Código Perl })</code>
el cuál hace que el <code>Código Perl</code> sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular con la que deberá
casarse.
(véase la sección <A HREF="node23.html#subsection:tiempodematching">3.2.9</A>
para mas detalles).

<P>
La sintáxis de la directiva <code>&lt;require:&gt;</code> es

<P><PRE>
                        &lt;require: (?{ CODE }) &gt;
</PRE>
<P>
<BLOCKQUOTE><I>The code block is executed and if its final value is true, matching
continues from the same position. If the block's final value is false,
the match fails at that point and starts backtracking.
</I></BLOCKQUOTE>

<P>
<BLOCKQUOTE><I>The <code>&lt;require:...&gt;</code> directive is useful for testing conditions that it's
not easy (or even possible) to check within the syntax of the the regex
itself. For example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: IPV4_Octet_Decimal&gt;
        # Up three digits...
        &lt;MATCH= ( \d{1,3}+ )&gt;
        
        # ...but less that 256...
        &lt;require: (?{ $MATCH &lt;= 255 })&gt;
</PRE>
<P>
<BLOCKQUOTE><I>A require expects a regex codeblock as its argument and succeeds if
the final value of that codeblock is true. If the final value is false,
the directive fails and the rule starts backtracking.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Note, in this example that the digits are matched with <code>\d{1,3}+</code> . <SPAN  CLASS="textbf">The
trailing</SPAN> <code>+</code> prevents the <code>{1,3}</code> repetition from backtracking to a smaller
number of digits if the <code>&lt;require:...&gt;</code> fails.
</I></BLOCKQUOTE>

<P>
El programa <code>demo_IP4.pl</code> ilustra el uso de la directiva:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n ./demo_IP4.pl
 1  #!/usr//bin/env perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  use Regexp::Grammars;
 6
 7  my $grammar = qr{
 8      \A &lt;IP4_addr&gt; \Z
 9
10      &lt;token: quad&gt;
11          &lt;MATCH=(\d{1,3})&gt;
12          &lt;require: (?{ $MATCH &lt; 256 })&gt;
13
14      &lt;token: IP4_addr&gt;
15          &lt;[MATCH=quad]&gt;**(\.)
16          &lt;require: (?{ @$MATCH == 4 })&gt;
17  }xms;
18
19  while (my $line = &lt;&gt;) {
20      if ($line =~ $grammar) {
21          use Data::Dumper 'Dumper';
22          say Dumper \%/;
23      }
24      else {
25          say 'Does not match'
26      }
27  }
</PRE>
Las condiciones usadas en el <code>require</code> obligan a que cada 
quad<A NAME="tex2html323"
  HREF="footnode.html#foot8605"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN></SUP></A> sea menor que 256 y a que existan sólo cuatro quads.

<P>
Sigue un ejemplo de ejecución:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123 . 145 . 105 . 252
Does not match
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123.145.105.252
$VAR1 = {
          '' =&gt; '123.145.105.252',
          'IP4_addr' =&gt; [
                          123,
                          145,
                          105,
                          252
                        ]
        };
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
148.257.128.128
Does not match
0.0.0.299
Does not match
pl@nereida:~/Lregexpgrammars/demo$  ./demo_IP4.pl
123.145.105.242.193
Does not match
</PRE>
Obsérvese como no se aceptan blancos entre los puntos en esta versión.
¿Sabría explicar la causa?

<P>

<H2><A NAME="SECTION0431111000000000000000">
Casando con las claves de un hash</A>
</H2>

<P>
<BLOCKQUOTE><I>In some situations a grammar may need a rule that matches dozens,
hundreds, or even thousands of one-word alternatives. For example, when
matching command names, or valid userids, or English words. In such
cases it is often impractical (and always inefficient) to list all the
alternatives between <code>|</code> alterators:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: shell_cmd&gt;
        a2p | ac | apply | ar | automake | awk | ...
        # ...and 400 lines later
        ... | zdiff | zgrep | zip | zmore | zsh

    &lt;rule: valid_word&gt;
        a | aa | aal | aalii | aam | aardvark | aardwolf | aba | ...
        # ...and 40,000 lines later... 
        ... | zymotize | zymotoxic | zymurgy | zythem | zythum
</PRE>
<P>
<BLOCKQUOTE><I>To simplify such cases, <A NAME="tex2html324"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
provides a special construct
that allows you to specify all the alternatives as the keys of a normal
hash. The syntax for that construct is simply to put the hash name inside
angle brackets (with no space between the angles and the hash name).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Which means that the rules in the previous example could also be written:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: shell_cmd&gt;
        &lt;%cmds&gt;

    &lt;rule: valid_word&gt;
        &lt;%dict&gt;
</PRE>
<P>
<BLOCKQUOTE><I>provided that the two hashes (<code>%cmds</code> and <code>%dict</code>) 
are visible in the scope where the grammar is created.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Internally, the construct is converted to something equivalent to:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: shell_cmd&gt;
        (&lt;.hk&gt;)  &lt;require: exists $cmds{$CAPTURE}&gt;

    &lt;rule: valid_word&gt;
        (&lt;.hk&gt;)  &lt;require: exists $dict{$CAPTURE}&gt;
</PRE>
<P>
<BLOCKQUOTE><I>The special <code>&lt;hk&gt;</code> rule is created automatically, and defaults to <code>\S+</code>,
but you can also define it explicitly to handle other kinds of keys. For
example:
</I></BLOCKQUOTE>
<P><PRE>
    &lt;rule: hk&gt;
        .+            # Key may be any number of chars on a single line

    &lt;rule: hk&gt;
        [ACGT]{10,}   # Key is a base sequence of at least 10 pairs
</PRE>
<P>
<BLOCKQUOTE><I>Matching a hash key in this way is typically significantly faster than
matching a full set of alternations. Specifically, it is O(length of
longest potential key), instead of O(number of keys).
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION0431111010000000000000">
Ejemplo de uso de la directiva hash</A>
</H4>
  

<P>
Sigue un ejemplo:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n hash.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Data::Dumper;
 6  $Data::Dumper::Deparse = 1;
 7
 8  my %cmd = map { ($_ =&gt; undef ) } qw( uname pwd date );
 9
10  my $rbb = do {
11      use Regexp::Grammars;
12
13      qr{
14        ^&lt;command&gt;$
15
16        &lt;rule: command&gt;
17          &lt;cmd=%cmd&gt; (?: &lt;[arg]&gt; )*
18
19        &lt;token: arg&gt; [^\s&lt;&gt;`&amp;]+
20      }xms;
21  };
22
23  while (my $input = &lt;&gt;) {
24      chomp($input);
25      if ($input =~ m{$rbb}) {
26          say("matches: &lt;$&amp;&gt;");
27          say Dumper \%/;
28          system $/{''}
29      }
30      else {
31          say("does not match");
32      }
33  }
</PRE>

<P>
Sigue un ejemplo de ejecución:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 hash.pl
a2p f1 f2
matches: &lt;a2p f1 f2&gt;
$VAR1 = {
          '' =&gt; 'a2p f1 f2',
          'command' =&gt; {
                         '' =&gt; 'a2p f1 f2',
                         'cmd' =&gt; 'a2p',
                         'arg' =&gt; [
                                    'f1',
                                    'f2'
                                  ]
                       }
        };

pocho 2 5
does not match
</PRE>

<P>

<H2><A NAME="SECTION0431112000000000000000">
Depuración</A>
</H2>

<P>
<BLOCKQUOTE><I><A NAME="tex2html326"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
provides a number of features specifically designed to
help debug both grammars and the data they parse.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>All debugging messages are written to a log file (which, by default, is
    just <code>STDERR</code>). However, you can specify a disk file explicitly by placing
    a <code>"&lt;logfile:...&gt;"</code> directive <SPAN  CLASS="textbf">at the start of your grammar</SPAN><A NAME="tex2html325"
  HREF="footnode.html#foot8443"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN></SUP></A>:
</I></BLOCKQUOTE>
<P><PRE>
        $grammar = qr{

            &lt;logfile: LaTeX_parser_log &gt;

            \A &lt;LaTeX_file&gt; \Z    # Pattern to match

            &lt;rule: LaTeX_file&gt;
                # etc.
        }x;
</PRE>
<P>
<BLOCKQUOTE><I>You can also explicitly specify that messages go to the terminal:
</I></BLOCKQUOTE>
<P><PRE>
            &lt;logfile: - &gt;
</PRE>
<P>
<H4><A NAME="SECTION0431112010000000000000">
Debugging grammar creation</A>
</H4>
  

<P>
Whenever a log file has been directly specified, <A NAME="tex2html328"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
automatically does verbose static analysis of your grammar. That is,
whenever it compiles a grammar containing an explicit <code>"&lt;logfile:...&gt;"</code>
directive it logs a series of messages explaining how it has interpreted
the various components of that grammar. For example, the following
grammar:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n log.pl
     1  #!/usr/bin/env perl5.10.1
     2  use strict;
     3  use warnings;
     4  use 5.010;
     5  use Data::Dumper;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        &lt;logfile: -&gt;
    12
    13        &lt;numbers&gt;
    14
    15        &lt;rule: numbers&gt;
    16          &lt;number&gt; ** &lt;.comma&gt;
    17
    18        &lt;token: number&gt; \d+
    19
    20        &lt;token: comma&gt;   ,
    21      }xms;
    22  };
    23
    24  while (my $input = &lt;&gt;) {
    25      if ($input =~ m{$rbb}) {
    26          say("matches: &lt;$&amp;&gt;");
    27          say Dumper \%/;
    28      }
    29  }
</PRE>

<P>
would produce the following analysis in the terminal:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ ./log.pl
  warn | Repeated subrule &lt;number&gt;* will only capture its final match
       | (Did you mean &lt;[number]&gt;* instead?)
       |
  info | Processing the main regex before any rule definitions
       |    |
       |    |...Treating &lt;numbers&gt; as:
       |    |      |  match the subrule &lt;numbers&gt;
       |    |       \ saving the match in $MATCH{'numbers'}
       |    |
       |     \___End of main regex
       |
       | Defining a rule: &lt;numbers&gt;
       |    |...Returns: a hash
       |    |
       |    |...Treating &lt;number&gt; as:
       |    |      |  match the subrule &lt;number&gt;
       |    |       \ saving the match in $MATCH{'number'}
       |    |
       |    |...Treating &lt;.comma&gt; as:
       |    |      |  match the subrule &lt;comma&gt;
       |    |       \ but don't save anything
       |    |
       |    |...Treating &lt;number&gt; ** &lt;.comma&gt; as:
       |    |      |  repeatedly match the subrule &lt;number&gt;
       |    |       \ as long as the matches are separated by matches of &lt;.comma&gt;
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: &lt;number&gt;
       |    |...Returns: a hash
       |    |
       |    |...Treating '\d' as:
       |    |       \ normal Perl regex syntax
       |    |
       |    |...Treating '+ ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: &lt;comma&gt;
       |    |...Returns: a hash
       |    |
       |    |...Treating ', ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
2, 3, 4
matches: &lt;2, 3, 4&gt;
$VAR1 = {
          '' =&gt; '2, 3, 4',
          'numbers' =&gt; {
                         '' =&gt; '2, 3, 4',
                         'number' =&gt; '4'
                       }
        };
</PRE>

<P>
This kind of static analysis is a useful starting point in debugging a
<A NAME="9166"></A><SPAN  CLASS="textbf">miscreant grammar</SPAN><A NAME="tex2html327"
  HREF="footnode.html#foot8606"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN></SUP></A>, because it enables you to see what you actually
specified (as opposed to what you <SPAN  CLASS="textbf">thought</SPAN> you'd specified).

<P>

<H4><A NAME="SECTION0431112020000000000000">
Debugging grammar execution</A>
</H4>
  

<P>
<A NAME="tex2html329"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
also provides a simple interactive debugger, with which
you can observe the process of parsing and the data being collected in
any result-hash.

<P>
To initiate debugging, place a <code>&lt;debug:...&gt;</code> directive anywhere in your
grammar. When parsing reaches that directive the debugger will be
activated, and the command specified in the directive immediately
executed. The available commands are:

<P>
<PRE>
        &lt;debug: on&gt;    - Enable debugging, stop when entire grammar matches
        &lt;debug: match&gt; - Enable debugging, stope when a rule matches
        &lt;debug: try&gt;   - Enable debugging, stope when a rule is tried
        &lt;debug: off&gt;   - Disable debugging and continue parsing silently

        &lt;debug: continue&gt; - Synonym for &lt;debug: on&gt;
        &lt;debug: run&gt;      - Synonym for &lt;debug: on&gt;
        &lt;debug: step&gt;     - Synonym for &lt;debug: try&gt;
</PRE>

<P>
These directives can be placed anywhere within a grammar and take effect
    when that point is reached in the parsing. Hence, adding a
    <code>&lt;debug:step&gt;</code> directive is very much like setting a breakpoint at that
    point in the grammar. Indeed, a common debugging strategy is to turn
    debugging on and off only around a suspect part of the grammar:

<P>
<PRE>
        &lt;rule: tricky&gt;   # This is where we think the problem is...
            &lt;debug:step&gt;
            &lt;preamble&gt; &lt;text&gt; &lt;postscript&gt;
            &lt;debug:off&gt;
</PRE>

<P>
Once the debugger is active, it steps through the parse, reporting rules
that are tried, matches and failures, backtracking and restarts, and the
parser's location within both the grammar and the text being matched.
That report looks like this:

<P>
<PRE>
        ===============&gt; Trying &lt;grammar&gt; from position 0
        &gt; cp file1 file2 |...Trying &lt;cmd&gt;
                         |   |...Trying &lt;cmd=(cp)&gt;
                         |   |    \FAIL &lt;cmd=(cp)&gt;
                         |    \FAIL &lt;cmd&gt;
                          \FAIL &lt;grammar&gt;
        ===============&gt; Trying &lt;grammar&gt; from position 1
         cp file1 file2  |...Trying &lt;cmd&gt;
                         |   |...Trying &lt;cmd=(cp)&gt;
         file1 file2     |   |    \_____&lt;cmd=(cp)&gt; matched 'cp'
        file1 file2      |   |...Trying &lt;[file]&gt;+
         file2           |   |    \_____&lt;[file]&gt;+ matched 'file1'
                         |   |...Trying &lt;[file]&gt;+
        [eos]            |   |    \_____&lt;[file]&gt;+ matched ' file2'
                         |   |...Trying &lt;[file]&gt;+
                         |   |    \FAIL &lt;[file]&gt;+
                         |   |...Trying &lt;target&gt;
                         |   |   |...Trying &lt;file&gt;
                         |   |   |    \FAIL &lt;file&gt;
                         |   |    \FAIL &lt;target&gt;
         &lt;~~~~~~~~~~~~~~ |   |...Backtracking 5 chars and trying new match
        file2            |   |...Trying &lt;target&gt;
                         |   |   |...Trying &lt;file&gt;
                         |   |   |    \____ &lt;file&gt; matched 'file2'
        [eos]            |   |    \_____&lt;target&gt; matched 'file2'
                         |    \_____&lt;cmd&gt; matched ' cp file1 file2'
                          \_____&lt;grammar&gt; matched ' cp file1 file2'
</PRE>

<P>
The first column indicates the point in the input at which the parser is
trying to match, as well as any backtracking or forward searching it may
need to do. The remainder of the columns track the parser's hierarchical
traversal of the grammar, indicating which rules are tried, which
succeed, and what they match.

<P>
Provided the logfile is a terminal (as it is by default), the debugger
also pauses at various points in the parsing process-before trying a
rule, after a rule succeeds, or at the end of the parse-according to
the most recent command issued. When it pauses, you can issue a new
command by entering a single letter:

<P>
<PRE>
        m       - to continue until the next subrule matches
        t or s  - to continue until the next subrule is tried
        r or c  - to continue to the end of the grammar
        o       - to switch off debugging
</PRE>

<P>
Note that these are the first letters of the corresponding <code>&lt;debug:...&gt;</code>
commands, listed earlier. Just hitting ENTER while the debugger is
paused repeats the previous command.

<P>
While the debugger is paused you can also type a <code>d</code>, which will display
the result-hash for the current rule. This can be useful for detecting
which rule isn't returning the data you expected.

<P>
Veamos un ejemplo. El siguiente programa activa el depurador:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_debug.pl
     1  #!/usr/bin/env perl5.10.1
     2  use 5.010;
     3  use warnings;
     4
     5      use Regexp::Grammars;
     6
     7      my $balanced_brackets = qr{
     8          &lt;debug:on&gt;
     9
    10          &lt;left_delim=(  \( )&gt;
    11          (?:
    12              &lt;[escape=(  \\ )]&gt;
    13          |   &lt;recurse=( (?R) )&gt;
    14          |   &lt;[simple=(  .  )]&gt;
    15          )*
    16          &lt;right_delim=( \) )&gt;
    17      }xms;
    18
    19      while (&lt;&gt;) {
    20          if (/$balanced_brackets/) {
    21              say 'matched:';
    22              use Data::Dumper 'Dumper';
    23              warn Dumper \%/;
    24          }
    25      }
</PRE>
Al ejecutar obtenemos

<PRE>
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
<span class="lightblue">(a)</span>
=====&gt; Trying &lt;grammar&gt; from position 0
(a)\n  |...Trying &lt;left_delim=(  \( )&gt;

a)\n   |    _____&lt;left_delim=(  \( )&gt; matched '('      <span class="lightblue">c</span>
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 1
a)\n   |   |...Trying &lt;left_delim=(  \( )&gt;

       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
)\n    |    _____&lt;[simple=(  .  )]&gt; matched 'a'
       |...Trying &lt;[escape=(  \ )]&gt;

       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 2
)\n    |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;

        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
\n     |    _____&lt;[simple=(  .  )]&gt; matched ')'
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;

       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 3
\n     |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;

       |...Trying &lt;[simple=(  .  )]&gt;
[eos]  |    _____&lt;[simple=(  .  )]&gt; matched ''
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;

=====&gt; Trying &lt;grammar&gt; from position 4
[eos]  |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;

       |    \FAIL &lt;[simple=(  .  )]&gt;
       |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;
 &lt;~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;

 &lt;~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying &lt;right_delim=( \) )&gt;
\n     |    _____&lt;right_delim=( \) )&gt; matched ')'
        _____&lt;grammar&gt; matched '(a)'   <span class="lightblue">d</span>
              :         {
              :           '' =&gt; '(a)',
              :           'left_delim' =&gt; '(',
              :           'simple' =&gt; [
              :                         'a'
              :                       ],
              :           'right_delim' =&gt; ')'
              :         };      <span class="lightblue">o</span>
matched:
$VAR1 = {
          '' =&gt; '(a)',
          'left_delim' =&gt; '(',
          'simple' =&gt; [
                        'a'
                      ],
          'right_delim' =&gt; ')'
        };

</PRE>

<P>

<H2><A NAME="SECTION0431113000000000000000">
Mensajes de <TT>log</TT> del usuario</A>
</H2>

<P>
<BLOCKQUOTE><I>Both static and interactive debugging send a series of predefined log
    messages to whatever log file you have specified. It is also possible to
    send additional, user-defined messages to the log, using the <code>"&lt;log:...&gt;"</code>
    directive.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This directive expects either a simple text or a codeblock as its single
    argument. If the argument is a code block, that code is expected to
    return the text of the message; if the argument is anything else, that
    something else <SPAN  CLASS="textbf">is</SPAN> the literal message. For example:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;rule: ListElem&gt;

            &lt;Elem=   ( [a-z]\d+) &gt;
                &lt;log: Checking for a suffix, too...&gt;

            &lt;Suffix= ( : \d+   ) &gt;?
                &lt;log: (?{ "ListElem: $MATCH{Elem} and $MATCH{Suffix}" })&gt;
</PRE>
<P>
<BLOCKQUOTE><I>User-defined log messages implemented using a codeblock can also specify
    a severity level. If the codeblock of a <code>&lt;log:...&gt;</code> directive returns
    two or more values, the first is treated as a log message severity
    indicator, and the remaining values as separate lines of text to be
    logged. For example:
</I></BLOCKQUOTE>
<P><PRE>
        &lt;rule: ListElem&gt;
            &lt;Elem=   ( [a-z]\d+) &gt;
            &lt;Suffix= ( : \d+   ) &gt;?

                &lt;log: (?{
                    warn =&gt; "Elem was: $MATCH{Elem}",
                            "Suffix was $MATCH{Suffix}",
                })&gt;
</PRE>
<P>
<BLOCKQUOTE><I>When they are encountered, user-defined log messages are interspersed
    between any automatic log messages (i.e. from the debugger), at the
    correct level of nesting for the current rule.
</I></BLOCKQUOTE>

<P>

<H2><A NAME="SECTION0431114000000000000000">
Depuración de Regexps</A>
</H2>

<P>
<BLOCKQUOTE><I>It is possible to use <A NAME="tex2html330"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>
without creating <SPAN  CLASS="textbf">any</SPAN> subrule
    definitions, simply to debug a recalcitrant regex. For example, if the
    following regex wasn't working as expected:
</I></BLOCKQUOTE>
<P><PRE>
        my $balanced_brackets = qr{
            \(             # left delim
            (?:
                \\         # escape or
            |   (?R)       # recurse or
            |   .          # whatever
            )*
            \)             # right delim
        }xms;
</PRE>
<P>
<BLOCKQUOTE><I>you could instrument it with aliased subpatterns and then debug it
    step-by-step, using <A NAME="tex2html331"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>:
</I></BLOCKQUOTE>
<P><PRE>
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            &lt;debug:step&gt;

            &lt;.left_delim=  (  \(  )&gt;
            (?:
                &lt;.escape=  (  \\  )&gt;
            |   &lt;.recurse= ( (?R) )&gt;
            |   &lt;.whatever=(  .   )&gt;
            )*
            &lt;.right_delim= (  \)  )&gt;
        }xms;

        while (&lt;&gt;) {
            say 'matched' if /$balanced_brackets/;
        }
</PRE>
<P>
<BLOCKQUOTE><I>Note the use of amnesiac aliased subpatterns to avoid needlessly
    building a result-hash. Alternatively, you could use listifying aliases
    to preserve the matching structure as an additional debugging aid:
</I></BLOCKQUOTE>
<P><PRE>
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            &lt;debug:step&gt;

            &lt;[left_delim=  (  \(  )]&gt;
            (?:
                &lt;[escape=  (  \\  )]&gt;
            |   &lt;[recurse= ( (?R) )]&gt;
            |   &lt;[whatever=(  .   )]&gt;
            )*
            &lt;[right_delim= (  \)  )]&gt;
        }xms;

        if ( '(a(bc)d)' =~ /$balanced_brackets/) {
            use Data::Dumper 'Dumper';
            warn Dumper \%/;
        }
</PRE>

<P>

<H2><A NAME="SECTION0431115000000000000000">
Manejo y recuperación de errores</A>
</H2>

<P>
En este punto debo decir que no he podido reproducir el comportamiento
de las directivas <code>&lt;error:&gt;</code> y <code>&lt;warning:&gt;</code> tal y como las describe 
Conway en el manual de <A NAME="tex2html332"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>. 

<P>
El siguiente ejemplo ilustra un conjunto de técnicas de gestión de errores
que son independientes del soprote dado por <A NAME="tex2html333"
  HREF="http://search.cpan.org/perldoc?Regexp::Grammars"><TT>Regexp::Grammars</TT></A>.

<P>
Se trata de la misma calculadora explicada en la sección
<A HREF="#subsection:recicla">3.10.18</A>.

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculatorwitherrmanagement.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Lingua::EN::Inflect qw(PL);
 6  use Scalar::Util qw{blessed};
 7
 8  my $rbb = do {
 9      my ($warnings, $errors);    # closure
10      sub warnings { $warnings }  # accessor
11      sub errors { $errors }      # accessor
12
13      use Regexp::Grammars;
14      qr{
15        (?{
16            $warnings = 0;
17            $errors = 0;
18        })
19        \A&lt;expr&gt;
20        (?:   \z
21             |
22               (.*) (?{
23                        # Accept the string but emit a warning
24                        $warnings++;
25                        local our $expr = \$MATCH{expr}{''};
26                        local our $endlegal = length($$expr) &gt; 4? "... ".substr($$expr, -4) : $$expr;
27                        warn "Warning: Unexpected '". substr($^N, 0, 10)."' after '$endlegal'\n";
28                     })
29        )
30
31        &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
32
33        &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
34
35        &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
36
37        &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
38
39        &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
40
41        &lt;objrule: factor&gt;    (&lt;val=([+-]?\d+(?:\.\d*)?)&gt;)
42                           | \( &lt;MATCH=expr&gt; \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
46                                            $warnings++;
47                                            $errors++;
48                                        }) &lt;MATCH=factor&gt;
49
50        &lt;token: addop&gt;        [+-]
51
52        &lt;token: mulop&gt;        [*/]
53
54        &lt;token: powerop&gt;      \*\*|\^
55
56        &lt;token: minus&gt;        - &lt;MATCH=(?{ 'NEG' })&gt;
57
58      }x;
59  };
60
61  sub test_calc {
62    my $prompt = shift;
63
64    print $prompt;
65    while (my $input = &lt;&gt;) {
66        chomp($input);
67
68        local %/;
69        $input =~ m{$rbb};
70
71        say warnings." ".PL('warning',warnings) if warnings;
72        say errors." ".PL('error',errors)       if errors;
73
74        my $tree = $/{expr};
75        if (blessed($tree)) {
76            do "PostfixCalc.pm";
77            say "postfix: ".$tree-&gt;ceval;
78
79            do "EvalCalc.pm";
80            say "result: ".$tree-&gt;ceval;
81        }
82        print $prompt;
83    }
84    say "Bye!"
85  }
86
87  ########## main
88  test_calc(
89    'Parsing infix arithmetic expressions (CTRL-D to end in unix) ',
90  );
</PRE>

<P>
Veamos algunas ejecuciones que incluyen entradas erróneas:
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+3
postfix: 2 3 +
result: 5
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
Error: expecting a number or a open parenthesis, found: '#'
Error: expecting a number or a open parenthesis, found: ')'
Warning: Unexpected '*(3+#)' after '2'
4 warnings
3 errors
postfix: 2
result: 2
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+#*4
Error: expecting a number or a open parenthesis, found: '#*'
1 warning
1 error
postfix: 2 4 +
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
</PRE>
Obsérvese los mensajes de error repetidos para la entrada 
<code>2*(3+#)</code>. Ellos son debidos a los reiterados intentos de
casar <code>&lt;factor&gt;</code> en la regla de recuperación de errores:
<PRE>
41        &lt;objrule: factor&gt;    (&lt;val=([+-]?\d+(?:\.\d*)?)&gt;)
42                           | \( &lt;MATCH=expr&gt; \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
46                                            $warnings++;
47                                            $errors++;
48                                        }) &lt;MATCH=factor&gt;
</PRE>
en este caso resulta imposible encontrar un factor.
Se puede cambiar la conducta indicando un <code>(* COMMIT)</code> antes de la
llamada a <code>&lt;MATCH=factor&gt;</code>:
<PRE>
 41       &lt;objrule: factor&gt;    (&lt;val=([+-]?\d+(?:\.\d*)?)&gt;)
 42                          | \( &lt;MATCH=expr&gt; \)
 43                          | ([^-+(0-9]+) (?{
 44                                           # is + and not * to avoid infinite recursion
 45                                           warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
 46                                           $warnings++;
 47                                           $errors++;
 48                                       }) (*COMMIT) &lt;MATCH=factor&gt;
</PRE>

<P>
en este caso la conducta es abandonar en el caso de que no se pueda encontrar un <code>&lt;factor&gt;</code>:
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*3
postfix: 2 3 *
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) @
Error: expecting a number or a open parenthesis, found: '@'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
</PRE>

<P>

<H2><A NAME="SECTION0431116000000000000000">
Mensajes de Warning</A>
</H2>

<P>
<BLOCKQUOTE><I>Sometimes, you want to detect problems, but not invalidate the entire
   parse as a result. For those occasions, the module provides a <SPAN  CLASS="textbf">less
   stringent</SPAN> form of error reporting: the <code>&lt;warning:...&gt;</code> directive.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This directive is exactly the same as an <code>&lt;error:...&gt;</code> in every respect
   except that it does not induce a failure to match at the point it
   appears.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The directive is, therefore, useful for reporting <SPAN  CLASS="textbf">non-fatal</SPAN> problems
   in a parse. For example:
</I></BLOCKQUOTE>
<P><PRE>
       qr{ \A            # ...Match only at start of input
           &lt;ArithExpr&gt;   # ...Match a valid arithmetic expression

           (?:
               # Should be at end of input...
               \s* \Z
             |
               # If not, report the fact but don't fail...
               &lt;warning: Expected end-of-input&gt;
               &lt;warning: (?{ "Extra junk at index $INDEX: $CONTEXT" })&gt;
           )

           # Rule definitions here...
       }xms;
</PRE>
<P>
<BLOCKQUOTE><I>Note that, because they do not induce failure, two or more
   <code>&lt;warning:...&gt;</code> directives can be "stacked" in sequence, as in the
   previous example.
</I></BLOCKQUOTE>
<P>

<P>

<H2><A NAME="SECTION0431117000000000000000">
Simplificando el AST</A>
</H2>

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n exprdamian.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        \A&lt;expr&gt;\z
    12
    13        &lt;objrule: expr&gt;    &lt;MATCH=term&gt; (?! &lt;addop&gt; )                  # bypass
    14                         | &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
    15
    16        &lt;objrule: term&gt;    &lt;MATCH=factor&gt; (?! &lt;mulop&gt; )                # bypass
    17                         | &lt;[operands=factor]&gt; ** &lt;[operators=mulop]&gt;
    18
    19        &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
    20                         | \( &lt;MATCH=expr&gt; \)
    21
    22        &lt;token: addop&gt; [+-]
    23
    24        &lt;token: mulop&gt; [*/]
    25
    26      }x;
    27  };
    28
    29  while (my $input = &lt;&gt;) {
    30      chomp($input);
    31      if ($input =~ m{$rbb}) {
    32          my $tree = $/{expr};
    33          say Dumper $tree;
    34          say $tree-&gt;ceval;
    35
    36      }
    37      else {
    38          say("does not match");
    39      }
    40  }
    41
    42  BEGIN {
    43
    44    package LeftBinaryOp;
    45    use strict;
    46    use base qw(Class::Accessor);
    47
    48    LeftBinaryOp-&gt;mk_accessors(qw{operators operands});
    49
    50    my %f = (
    51      '+' =&gt; sub { shift() + shift() },
    52      '-' =&gt; sub { shift() - shift() },
    53      '*' =&gt; sub { shift() * shift() },
    54      '/' =&gt; sub { shift() / shift() },
    55    );
    56
    57    sub ceval {
    58      my $self = shift;
    59
    60      # recursively evaluate the children first
    61      my @operands = map { $_-&gt;ceval } @{$self-&gt;operands};
    62
    63      # then combine them
    64      my $s = shift @operands;
    65      for (@{$self-&gt;operators}) {
    66        $s = $f{$_}-&gt;($s, shift @operands);
    67      }
    68      return $s;
    69    }
    70
    71    package term;
    72    use base qw{LeftBinaryOp};
    73
    74    package expr;
    75    use base qw{LeftBinaryOp};
    76
    77    package factor;
    78
    79    sub ceval {
    80      my $self = shift;
    81
    82      return $self-&gt;{val};
    83    }
    84
    85    1;
    86  }
</PRE>

<P>
Ejecuciones:
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 exprdamian.pl
4-2-2
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      '' =&gt; '4',
      'val' =&gt; '4'
    }, 'factor' ),
    bless( {
      '' =&gt; '2',
      'val' =&gt; '2'
    }, 'factor' ),
    bless( {
      '' =&gt; '2',
      'val' =&gt; '2'
    }, 'factor' )
  ],
  '' =&gt; '4-2-2',
  'operators' =&gt; [
    '-',
    '-'
  ]
}, 'expr' );

0
8/4/2
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      '' =&gt; '8',
      'val' =&gt; '8'
    }, 'factor' ),
    bless( {
      '' =&gt; '4',
      'val' =&gt; '4'
    }, 'factor' ),
    bless( {
      '' =&gt; '2',
      'val' =&gt; '2'
    }, 'factor' )
  ],
  '' =&gt; '8/4/2',
  'operators' =&gt; [
    '/',
    '/'
  ]
}, 'term' );

1
3
$VAR1 = bless( {
  '' =&gt; '3',
  'val' =&gt; '3'
}, 'factor' );

3
2*(3+4)
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      '' =&gt; '2',
      'val' =&gt; '2'
    }, 'factor' ),
    bless( {
      'operands' =&gt; [
        bless( {
          '' =&gt; '3',
          'val' =&gt; '3'
        }, 'factor' ),
        bless( {
          '' =&gt; '4',
          'val' =&gt; '4'
        }, 'factor' )
      ],
      '' =&gt; '3+4',
      'operators' =&gt; [
        '+'
      ]
    }, 'expr' )
  ],
  '' =&gt; '2*(3+4)',
  'operators' =&gt; [
    '*'
  ]
}, 'term' );

14
</PRE>

<P>

<H2><A NAME="SECTION0431118000000000000000"></A>
<A NAME="subsection:recicla"></A>
<BR>
Reciclando una <TT>Regexp::Grammar</TT>
</H2>

<P>

<H4><A NAME="SECTION0431118010000000000000">
Ejecución</A>
</H4>
  

<P>
El siguiente programa <code>calculator.pl</code>
recibe como entrada una expresión en infijo.

<P>
La ejecución consta de dos bucles.
En la primera parte se inyecta a la jerarquía de
clases de los AST generados para las expresiones en infijo
una semántica que permite 
evaluar la expresión:
<PRE>
    58  require EvalCalc;
    59
    60  test_calc(
    61    'Evaluating infix arithmetic expressions (CTRL-D to end in unix) ',
    62    sub { print &amp;Data::Dumper::Dumper(shift()) },
    63  );
</PRE>
En esta primera parte mostraremos además el AST
construido para la expresión infija de entrada.

<pre>
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
<span class='lightblue'>8-4-2</span>
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '8', 'val' =&gt; '8' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '8'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '8'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '8'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '8'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '4', 'val' =&gt; '4' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '4'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '4'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '4'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '4'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '2', 'val' =&gt; '2' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '2'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '2'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '2'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '2'
    }, <span class='lightblue'>'term'</span> )
  ],
  '' =&gt; '8-4-2',
  <span class='red'>'operators' =&gt; [
    '-',
    '-'
  ]</span>
}, <span class='lightblue'>'expr'</span> );
2
</pre>
Observamos que la asociatividad es la correcta.
El <code>2</code> final es el resultado de la evaluación de
<code>8-4-2</code>.

<P>
La estructura del árbol se corresponde con la de la gramática:
<PRE>
 8  my $rbb = do {
 9      use Regexp::Grammars;
10
11      qr{
12        \A&lt;expr&gt;\z
13
14        &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
15
16        &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
17
18        &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
19
20        &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
21
22        &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
23
24        &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
25                           | \( &lt;MATCH=expr&gt; \)
26
27        &lt;token: addop&gt;        [+-]
28
29        &lt;token: mulop&gt;        [*/]
30
31        &lt;token: powerop&gt;      \*\*|\^
32
33        &lt;token: minus&gt;        - &lt;MATCH=(?{ 'NEG' })&gt;
34
35      }x;
36  };
</PRE>

<P>
Ahora, en una segunda parte sobreescribimos los métodos
<code>sem</code> que describen la semántica para producir una traducción
de infijo a postfijo:
<PRE>
 66  require PostfixCalc;
 67  test_calc('Translating expressions to postfix (CTRL-D to end in unix) ');
</PRE>
Ahora al proporcionar la entrada <code>6--3!</code> obtenemos:
<PRE>
Translating expressions to postfix (CTRL-D to end in unix)
6--3!
6 3 ! ~ -
</PRE>
Aquí <code>~</code> es el operador de negación unaria y <code>!</code> es el operador
factorial.

<P>

<H4><A NAME="SECTION0431118020000000000000">
Estructura de la aplicación</A>
</H4>
  

<P>
Estos son los ficheros que integran la aplicación:

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ tree
.
|-- EvalCalc.pm            # Soporte para la evaluación de la expresión: sem
|-- Operator.pm            # Soporte a las clases nodo: recorridos
|-- PostfixCalc.pm         # Soporte para la traducción a postfijo: sem
`-- calculator.pl          # programa principal
</PRE>

<P>

<H4><A NAME="SECTION0431118030000000000000">
Programa principal</A>
</H4>
  

<P>
En el programa principal definimos la gramática
y escribimos una subrutina <code>test_calc</code>
que realiza el parsing. 

<P>

<pre>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/env perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use </span><span class="synConstant">5.010</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">use </span>Data::Dumper;
<span class="synLinenum">    6</span>   <span class="synIdentifier">$</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Indent</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rbb</span> = <span class="synStatement">do</span> {
<span class="synLinenum">    9</span>       <span class="synStatement">use </span>Regexp::Grammars;
<span class="synLinenum">   10</span> 
<span class="synLinenum">   11</span>       <span class="synConstant">qr{</span>
<span class="synLinenum">   12</span> <span class="synConstant">        </span><span class="synSpecial">\A</span><span class="synConstant">&lt;expr&gt;</span><span class="synSpecial">\z</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">        &lt;objrule: expr&gt;      &lt;</span><span class="synSpecial">[operands=term]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=addop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span> <span class="synConstant">        &lt;objrule: term&gt;      &lt;</span><span class="synSpecial">[operands=uneg]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=mulop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span> <span class="synConstant">        &lt;objrule: uneg&gt;      &lt;</span><span class="synSpecial">[operators=minus]</span><span class="synConstant">&gt;</span><span class="synSpecial">*</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operands=power]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">        &lt;objrule: power&gt;     &lt;</span><span class="synSpecial">[operands=factorial]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=powerop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synConstant">        &lt;objrule: factorial&gt; &lt;</span><span class="synSpecial">[operands=factor]</span><span class="synConstant">&gt;  &lt;</span><span class="synSpecial">[operators=(!)]</span><span class="synConstant">&gt;</span><span class="synSpecial">*</span>
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span> <span class="synConstant">        &lt;objrule: factor&gt;    &lt;val=</span><span class="synSpecial">([+-]?\d+(?:\.\d*)?)</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   25</span> <span class="synConstant">                           | </span><span class="synSpecial">\(</span><span class="synConstant"> &lt;MATCH=expr&gt; </span><span class="synSpecial">\)</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">        &lt;token: addop&gt;        </span><span class="synSpecial">[+-]</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        &lt;token: mulop&gt;        </span><span class="synSpecial">[*/]</span>
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span> <span class="synConstant">        &lt;token: powerop&gt;      </span><span class="synSpecial">\*\*</span><span class="synConstant">|</span><span class="synSpecial">^</span>
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span> <span class="synConstant">        &lt;token: minus&gt;        - &lt;MATCH=</span><span class="synSpecial">(?</span><span class="synConstant">{ 'NEG' </span>}<span class="synSpecial">)</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span> <span class="synConstant">      }x</span>;
<span class="synLinenum">   36</span>   };
<span class="synLinenum">   37</span> 
<span class="synLinenum">   38</span>   <span class="synStatement">sub </span><span class="synIdentifier">test_calc </span>{
<span class="synLinenum">   39</span>     <span class="synStatement">my</span> <span class="synIdentifier">$prompt</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   40</span>     <span class="synStatement">my</span> <span class="synIdentifier">$handler</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>     <span class="synStatement">say</span> <span class="synIdentifier">$prompt</span>;
<span class="synLinenum">   43</span>     <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;) {
<span class="synLinenum">   44</span>         <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   45</span>         <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rbb</span><span class="synStatement">}</span>) {
<span class="synLinenum">   46</span>             <span class="synStatement">my</span> <span class="synIdentifier">$tree</span> = <span class="synIdentifier">$/</span>{expr};
<span class="synLinenum">   47</span>             <span class="synIdentifier">$handler</span>-&gt;(<span class="synIdentifier">$tree</span>) <span class="synStatement">if</span> <span class="synIdentifier">$handler</span>;
<span class="synLinenum">   48</span> 
<span class="synLinenum">   49</span>             <span class="synStatement">say</span> <span class="synIdentifier">$tree-&gt;ceval</span>;
<span class="synLinenum">   50</span> 
<span class="synLinenum">   51</span>         }
<span class="synLinenum">   52</span>         <span class="synStatement">else</span> {
<span class="synLinenum">   53</span>             <span class="synStatement">say</span>(<span class="synConstant">"does not match"</span>);
<span class="synLinenum">   54</span>         }
<span class="synLinenum">   55</span>     }
<span class="synLinenum">   56</span>   }
<span class="synLinenum">   57</span> 
<span class="synLinenum">   58</span>   <span class="synStatement">require</span> EvalCalc;
<span class="synLinenum">   59</span> 
<span class="synLinenum">   60</span>   test_calc(
<span class="synLinenum">   61</span>     <span class="synConstant">'Evaluating infix arithmetic expressions (CTRL-D to end in unix) '</span>,
<span class="synLinenum">   62</span>     <span class="synStatement">sub </span>{ <span class="synStatement">print</span> <span class="synIdentifier">&amp;</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Dumper</span>(<span class="synStatement">shift</span>()) },
<span class="synLinenum">   63</span>   );
<span class="synLinenum">   64</span> 
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>   <span class="synStatement">require</span> PostfixCalc;
<span class="synLinenum">   67</span>   test_calc(<span class="synConstant">'Translating expressions to postfix (CTRL-D to end in unix) '</span>);
</pre>

<P>
Los nodos del AST poseen un método <code>ceval</code> que se encarga de 
realizar la traducción del nodo.

<P>

<H4><A NAME="SECTION0431118040000000000000">
Las Clases de nodos del AST</A>
</H4>
  

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n Operator.pm
   1  #   Class hierarchy diagram:
   2  #  $ vgg -t 'Operator(LeftBinaryOp(expr,term),RightBinaryOp(power),PreUnaryOp(uneg),PostUnaryOp(factorial))'
   3  #                           +--------+
   4  #                           |Operator|
   5  #                           +--------+
   6  #          .---------------.----^--------.-------------.
   7  #    +------------+ +-------------+ +----------+ +-----------+
   8  #    |LeftBinaryOp| |RightBinaryOp| |PreUnaryOp| |PostUnaryOp|
   9  #    +------------+ +-------------+ +----------+ +-----------+
  10  #      .---^--.        |              |               |
  11  #    +----+ +----+  +-----+         +----+       +---------+
  12  #    |expr| |term|  |power|         |uneg|       |factorial|
  13  #    +----+ +----+  +-----+         +----+       +---------+
  14  #
  15  #
  16  # NOTE: package "factor" actually implements numbers and is
  17  #       outside this hierarchy
  18  #
  19  package Operator;
  20  use strict;
  21  use Carp;
  22
  23  sub Operands {
  24    my $self = shift;
  25
  26    return () unless exists $self-&gt;{operands};
  27    return @{$self-&gt;{operands}};
  28  }
  29
  30  sub Operators {
  31    my $self = shift;
  32
  33    return () unless exists $self-&gt;{operators};
  34    return @{$self-&gt;{operators}};
  35  }
  36
  37  sub sem {
  38    confess "not defined sem";
  39  }
  40
  41  sub make_sem {
  42    my $class = shift;
  43    my %semdesc = @_;
  44
  45    for my $class (keys %semdesc) {
  46      my %sem = %{$semdesc{$class}};
  47
  48      # Install 'sem' method in $class
  49      no strict 'refs';
  50      no warnings 'redefine';
  51      *{$class."::sem"} = sub {
  52        my ($self, $op) = @_;
  53        $sem{$op}
  54      };
  55    }
  56  }
  57
  58  package LeftBinaryOp;
  59  use base qw{Operator};
  60
  61  sub ceval {
  62    my $self = shift;
  63
  64    # recursively evaluate the children first
  65    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
  66
  67    # then combine them
  68    my $s = shift @operands;
  69    for ($self-&gt;Operators) {
  70      $s = $self-&gt;sem($_)-&gt;($s, shift @operands);
  71    }
  72    return $s;
  73  }
  74
  75  package RightBinaryOp;
  76  use base qw{Operator};
  77
  78  sub ceval {
  79    my $self = shift;
  80
  81    # recursively evaluate the children first
  82    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
  83
  84    # then combine them
  85    my $s = pop @operands;
  86    for (reverse $self-&gt;Operators) {
  87      $s = $self-&gt;sem($_)-&gt;(pop @operands, $s);
  88    }
  89    return $s;
  90  }
  91
  92  package PreUnaryOp;
  93  use base qw{Operator};
  94
  95  sub ceval {
  96    my $self = shift;
  97
  98    # recursively evaluate the children first
  99    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
 100
 101    # then combine them
 102    my $s = shift @operands;
 103    for (reverse $self-&gt;Operators) {
 104      $s = $self-&gt;sem($_)-&gt;($s);
 105    }
 106    return $s;
 107  }
 108
 109  package PostUnaryOp;
 110  use base qw{Operator};
 111
 112  sub ceval {
 113    my $self = shift;
 114
 115    # recursively evaluate the children first
 116    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
 117
 118    # then combine them
 119    my $s = shift @operands;
 120    for ($self-&gt;Operators) {
 121      $s = $self-&gt;sem($_)-&gt;($s);
 122    }
 123    return $s;
 124  }
 125
 126  package term;
 127  use base qw{LeftBinaryOp};
 128
 129  package expr;
 130  use base qw{LeftBinaryOp};
 131
 132  package power;
 133  use base qw{RightBinaryOp};
 134
 135  package uneg;
 136  use base qw{PreUnaryOp};
 137
 138  package factorial;
 139  use base qw{PostUnaryOp};
 140
 141  package factor;
 142
 143  sub ceval {
 144    my $self = shift;
 145
 146    return $self-&gt;{val};
 147  }
 148
 149  1;
</PRE>

<P>

<H4><A NAME="SECTION0431118050000000000000">
Definiendo <TT>sem</TT> para la evaluación de la expresión</A>
</H4>
  

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n EvalCalc.pm
 1  package EvalCalc;
 2  use strict;
 3  use Carp;
 4
 5  use Operator;
 6
 7  ####
 8  sub f {
 9    $_[0]&gt;1?$_[0]*f($_[0]-1):1;
10  }
11
12  sub fac {
13    my $n = shift;
14
15    confess "Not valid number" unless $n =~ /^\d+$/;
16    f($n);
17  };
18
19  my $s = sub { shift() **  shift() };
20
21  Operator-&gt;make_sem(
22     expr =&gt; {
23        '+' =&gt; sub { shift()  +  shift() },
24        '-' =&gt; sub { shift()  -  shift() },
25     },
26     term =&gt; {
27       '*' =&gt; sub { shift()  *  shift() },
28       '/' =&gt; sub { shift()  /  shift() },
29     },
30     power =&gt; {
31        '^'  =&gt; $s,
32        '**' =&gt; $s,
33     },
34     uneg =&gt; {
35        'NEG' =&gt; sub { -shift() },
36     },
37     factorial =&gt; {
38        '!' =&gt; \&amp;fac,
39     },
40  );
41
42  1;
</PRE>

<P>

<H4><A NAME="SECTION0431118060000000000000">
Definiendo <TT>sem</TT> para la traducción a postfijo</A>
</H4>
  

<P>
<PRE>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n PostfixCalc.pm
 1  package PostfixCalc;
 2  use strict;
 3
 4  use Operator;
 5
 6  # Modify semantics: now translate to postfix
 7  my $powers = sub { shift().' '.shift().' **' };
 8
 9  Operator-&gt;make_sem(
10     expr =&gt; {
11        '+' =&gt; sub { shift().' '.shift().' +'  },
12        '-' =&gt; sub { shift().' '.shift().' -' },
13      },
14      term =&gt; {
15        '*' =&gt; sub { shift().' '.shift().' *'  },
16        '/' =&gt; sub { shift().' '.shift().' /' },
17      },
18      power =&gt; {
19        '^'  =&gt; $powers,
20        '**' =&gt; $powers,
21      },
22      uneg =&gt; {
23         # use ~ for unary minus
24        'NEG' =&gt; sub { shift().' ~' },
25      },
26      factorial =&gt; {
27        '!' =&gt; sub { shift().' !'},
28      },
29  );
30
31  1;
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<UL>
<LI>Explique el significado de la primera línea del programa principal
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ cat -n calculator.pl
   1  #!/usr/bin/env perl5.10.1
</PRE>
</LI>
<LI>Explique el significado de <code>$handler</code> en <code>test_calc</code>:
<PRE>
  42  sub test_calc {
  43    my $prompt = shift;
  44    my $handler = shift;
  45
  46    say $prompt;
  47    while (my $input = &lt;&gt;) {
  48        chomp($input);
  49        if ($input =~ m{$rbb}) {
  50            my $tree = $/{expr};
  51            $handler-&gt;($tree) if $handler;
  52
  53            say $tree-&gt;ceval;
  54
  55        }
  56        else {
  57            say("does not match");
  58        }
  59    }
  60  }
</PRE>

<P>
</LI>
<LI>Aisle las funciones relacionadas con la creación de semántica
como <code>make_sem</code>, <code>fac</code> y las llamadas a <code>make_sem</code>
en un módulo <code>Calculator::Semantics</code> aparte. 

<P>
</LI>
<LI>Añada un traductor de infijo a prefijo al código presentado 
en esta sección. Una expresión como
<code>2*3+4</code>  se traducirá como <code>+ * 2 3 4</code>
</LI>
</UL></DIV><P></P>

<P>

<H2><A NAME="SECTION0431119000000000000000">
Práctica: Calculadora con <TT>Regexp::Grammars</TT></A>
</H2>
   <A NAME="9217"></A>

<P>

<UL>
<LI>Reforme la estructura del ejemplo para que tenga una jerarquía
de desarrollo de acuerdo a los estándares de Perl. Use <A NAME="tex2html334"
  HREF="http://search.cpan.org/perldoc/?h2xs"><TT>h2xs</TT></A>
o bien <A NAME="tex2html335"
  HREF="http://search.cpan.org/perldoc?Module::Starter"><TT>Module::Starter</TT></A>. Use el espacio de nombres <code>Calculator</code>.
Mueva el módulo <code>Operator</code> a <code>Calculator::Operator</code>.
Lea el capítulo <A NAME="tex2html336"
  HREF="http://nereida.deioc.ull.es/~lhp/perlexamples/node170.html">Modulos</A>
de los apuntes de LHP.

<P>
</LI>
<LI>Defina el conjunto de pruebas que deberá pasar su traductor.
Añádalas como pruebas <code>TODO</code>. Cuando la funcionalidad 
a comprobar esté operativa cambie su estatus.

<P>
</LI>
<LI>Añada variables y la expresión de asignación:

<P>
<PRE>
b = a = 4*2
</PRE>
que será traducida a postfijo como:

<P>
<PRE>
4 2 * a = b =
</PRE>
El operador de asignación es asociativo a derechas.
El valor devuelto por una expresión de asignación es el valor asignado.

<P>
Use un hash para implantar la relación nombre-valor
en el caso de la evaluación

<P>
</LI>
<LI>Introduzca la expresión bloque:

<P>
<PRE>
c = { a = 4; b = 2*a }
</PRE>

<P>
Los bloques son listas entre llaves de expresiones separadas por punto y coma.
El valor retornado por una expresión bloque es el último evaluado 
en el bloque.

<P>
El símbolo de arranque de la gramática (esto es, el patrón regular
contra el que hay que casar) será la expresión bloque.

<P>
</LI>
<LI>Introduzca las expresiones de comparación <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code> y <code>!=</code>
con la prioridad adecuada. Tenga en cuenta que una expresión como:
<PRE>
a = b+2 &gt; c*4
</PRE>
deberá entenderse como
<PRE>
a = ((b+2) &gt; (c*4))
</PRE>
Esto es, se traducirá como:
<PRE>
b 2 + c 4 * &gt; a =
</PRE>

<P>
</LI>
<LI>Introduzca la expresión <code>if ... then ... else</code>. La parte del <code>else</code>
será opcional:
<PRE>
c = if a &gt; 0 then { a = a -1; 2*a } else { b + 2 };
d = if a &gt; 0 then { a = b -1; 2*b };
</PRE>
un <code>else</code> casa con el <code>if</code> mas cercano. 
La sentencia:
<PRE>
if (a &gt; 0) then if (b &gt; 0) then {5} else {6}
</PRE>
se interpreta como:
<PRE>
if (a &gt; 0) then (if (b &gt; 0) then {5} else {6})
</PRE>
y no como:
<PRE>
if (a &gt; 0) then (if (b &gt; 0) then {5}) else {6}
</PRE>
Se traducirá como:
<PRE>
        a
        0
        &gt;
        jz endif124
        b
        0
        &gt;
        jz else125
        5
        j endif126
:else125
        6
:endif124
:endif125
        ...
</PRE>
</LI>
<LI>Escriba un intérprete de la máquina orientada a pila definida en los apartados anteriores.
El código generado debería poder ejecutarse correctamente en el intérprete.
</LI>
</UL>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2848"
  HREF="node33.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2842"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2838"
  HREF="node31.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2844"
  HREF="node227.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2846"
  HREF="node230.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2849"
  HREF="node33.html">Analizadores Descendentes Predictivos en</A>
<B>Sup:</B> <A NAME="tex2html2843"
  HREF="node21.html">Expresiones Regulares en Perl</A>
<B> Ant:</B> <A NAME="tex2html2839"
  HREF="node31.html">Práctica: Traducción de invitation</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-04-25</I>
</ADDRESS>
</BODY>
</HTML>
