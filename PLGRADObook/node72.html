<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Patrones Árbol y Transformaciones Árbol</TITLE>
<META NAME="description" CONTENT="Patrones Árbol y Transformaciones Árbol">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node73.html">
<LINK REL="previous" HREF="node71.html">
<LINK REL="up" HREF="node60.html">
<LINK REL="next" HREF="node73.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html3420"
  HREF="node73.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3414"
  HREF="node60.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html3408"
  HREF="node71.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3416"
  HREF="node232.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3418"
  HREF="node235.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html3421"
  HREF="node73.html">Asignación de Direcciones</A>
<B>Sup:</B> <A NAME="tex2html3415"
  HREF="node60.html">Análisis Sintáctico Descendente en</A>
<B> Ant:</B> <A NAME="tex2html3409"
  HREF="node71.html">Optimización Independiente de la</A>
<B> Con:</B> 
<A NAME="tex2html3416"
  HREF="node232.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html3418"
  HREF="node235.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html3422"
  HREF="node72.html#SECTION047121000000000000000">Práctica: Casando y Transformando Árboles</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION047120000000000000000"></A>
<A NAME="section:patronesarbol"></A>
<BR>
Patrones Árbol y Transformaciones Árbol
</H1>
En la fase de optimización presentada en la sección
<A HREF="node71.html#section:optimizacion">7.11</A> transformabamos el programa 
en su representación intermedia, como un AAA
decorado, para obtener otro AAA decorado.

<P>
Una transformación de un programa puede ser descrita
como un conjunto de <A NAME="11932"></A><SPAN  CLASS="textbf">reglas de transformación</SPAN> 
o <A NAME="11934"></A><SPAN  CLASS="textbf">esquema de traducción árbol</SPAN>
sobre el árbol abstracto que representa el programa.

<P>
Antes de seguir, es conveniente que repase los conceptos
en la sección 
<A HREF="node69.html#subsection:lenguajesarbol">7.9.1</A>
sobre lenguajes y gramáticas árbol.

<P>
En su forma mas sencilla, estas reglas de transformación
vienen definidas
por ternas <!-- MATH
 $(p, e, action)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="99" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img270.png"
 ALT="$ (p, e, action)$"></SPAN>, donde la primera componente de la
terna <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img196.png"
 ALT="$ p$"></SPAN> es un <A NAME="11936"></A><SPAN  CLASS="textbf">patrón árbol</SPAN> que dice que árboles
deben ser seleccionados. La segunda componente 
<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img271.png"
 ALT="$ e$"></SPAN> dice cómo debe transformarse el árbol que casa con el patrón
<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img196.png"
 ALT="$ p$"></SPAN>. La acción <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img272.png"
 ALT="$ action$"></SPAN> indica como deben
computarse los atributos del árbol transformado
a partir de los atributos 
del árbol que casa con el patrón <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img196.png"
 ALT="$ p$"></SPAN>.
Una forma de representar este esquema sería:

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $p \Longrightarrow e$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="59" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img273.png"
 ALT="$ p \Longrightarrow e$"></SPAN> <code>{ action }</code>

</DIV>

<P>
Por ejemplo:

<P>
<BR>
<BR>
<!-- MATH
 $PLUS(NUM_1, NUM_2) \Longrightarrow NUM_3$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="277" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img274.png"
 ALT="$ PLUS(NUM_1, NUM_2) \Longrightarrow NUM_3$"></SPAN> <code>{ $NUM_3{VAL} = $NUM_1{VAL} + $NUM_2{VAL} }</code>
<BR>
<BR>

<P>
cuyo significado es que dondequiera que haya un nódo del AAA que case 
con el <A NAME="11938"></A><SPAN  CLASS="textbf">patrón de entrada</SPAN> <!-- MATH
 $PLUS(NUM, NUM)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="173" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img275.png"
 ALT="$ PLUS(NUM, NUM)$"></SPAN> deberá sustituirse
el subárbol <!-- MATH
 $PLUS(NUM, NUM)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="173" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img275.png"
 ALT="$ PLUS(NUM, NUM)$"></SPAN> por el subárbol <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img140.png"
 ALT="$ NUM$"></SPAN>. Al igual que en los 
esquemas de traducción, enumeramos las apariciones de los símbolos,
para distinguirlos en la parte semántica. La acción indica 
como deben recomputarse los atributos para el nuevo árbol:
El atributo <code>VAL</code> del árbol resultante es la suma de los atributos
<code>VAL</code> de los operandos en el árbol que ha casado.
La transformación se repite hasta que se produce la <A NAME="11940"></A><SPAN  CLASS="textbf">normalización del árbol</SPAN>.

<P>
Las reglas de ``casamiento''  de árboles pueden ser mas complejas, 
haciendo alusión a propiedades de los atributos, por ejemplo

<P>
<BR>
<BR>
<!-- MATH
 $ASSIGN(LEFTVALUE, x)\ and$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="264" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img276.png"
 ALT="$ ASSIGN(LEFTVALUE, x) and$"></SPAN> <code>{ notlive($LEFTVALUE{VAL}) }</code> <!-- MATH
 $\Longrightarrow NIL$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img277.png"
 ALT="$ \Longrightarrow NIL$"></SPAN>
<BR>
<BR>

<P>
indica que se pueden eliminar aquellos árboles de tipo asignación
en los cuáles la variable asociada con el nodo <SPAN CLASS="MATH"><IMG
 WIDTH="123" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img231.png"
 ALT="$ LEFTVALUE$"></SPAN>
no se usa posteriormente. 

<P>
Otros ejemplos con variables <SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img278.png"
 ALT="$ S_1$"></SPAN> y <SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img279.png"
 ALT="$ S_2$"></SPAN>:

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $IFELSE(NUM, S_1, S_2)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="192" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img280.png"
 ALT="$ IFELSE(NUM, S_1, S_2)$"></SPAN> and <code>{ $NUM{VAL} != 0 }</code> <!-- MATH
 $\Longrightarrow S_1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img281.png"
 ALT="$ \Longrightarrow S_1$"></SPAN>
<BR><!-- MATH
 $IFELSE(NUM, S_1, S_2)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="192" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img280.png"
 ALT="$ IFELSE(NUM, S_1, S_2)$"></SPAN> and <code>{ $NUM{VAL} == 0 }</code> <!-- MATH
 $\Longrightarrow S_2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img282.png"
 ALT="$ \Longrightarrow S_2$"></SPAN>
</DIV>

<P>
Observe que en el patrón de entrada <!-- MATH
 $ASSIGN(LEFTVALUE, x)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="230" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img283.png"
 ALT="$ ASSIGN(LEFTVALUE, x)$"></SPAN> aparece un
``comodín'': la variable-árbol <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img69.png"
 ALT="$ x$"></SPAN>, que hace que el árbol
patrón <!-- MATH
 $ASSIGN(LEFTVALUE, x)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="230" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img283.png"
 ALT="$ ASSIGN(LEFTVALUE, x)$"></SPAN> case con cualquier árbol de asignación,
independientemente de la forma que tenga su subárbol derecho.

<P>
Las siguientes definiciones formalizan una aproximación simplificada 
al significado de los conceptos <A NAME="11942"></A><SPAN  CLASS="textbf">patrones árbol</SPAN> y
<A NAME="11944"></A><SPAN  CLASS="textbf">casamiento de árboles</SPAN>.

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Sea <!-- MATH
 $(\Sigma, \rho)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img162.png"
 ALT="$ (\Sigma, \rho)$"></SPAN> un alfabeto con función de aridad
y un conjunto (puede ser infinito) 
de variables <!-- MATH
 $V =\{ x_1, x_2, \ldots \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="130" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img284.png"
 ALT="$ V =\{ x_1, x_2, \ldots \}$"></SPAN>. 
Las variables tienen
aridad cero: 
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $\rho(x) = 0\ \forall x \in V$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="130" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img285.png"
 ALT="$ \rho(x) = 0 \forall x \in V$"></SPAN>. 
</I></DIV>
<P>
<I>Un elemento de <!-- MATH
 $B(V \cup \Sigma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="78" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img286.png"
 ALT="$ B(V \cup \Sigma)$"></SPAN>
se denomina <A NAME="11946"></A><SPAN  CLASS="textbf">patrón</SPAN> sobre <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img45.png"
 ALT="$ \Sigma$"></SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>Se dice que un
patrón es un <A NAME="11948"></A><SPAN  CLASS="textbf">patrón lineal</SPAN> si ninguna variable se repite.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>Se dice que un patrón es de tipo <!-- MATH
 $(x_1, \ldots x_k)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="85" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img287.png"
 ALT="$ (x_1, \ldots x_k)$"></SPAN> si las variables
que aparecen en el patrón leidas de izquierda a derecha en el árbol
son <!-- MATH
 $x_1, \ldots x_k$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img288.png"
 ALT="$ x_1, \ldots x_k$"></SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejemplo  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Sea <!-- MATH
 $\Sigma = \{A, CONS, NIL \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="178" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img172.png"
 ALT="$ \Sigma = \{A, CONS, NIL \}$"></SPAN> con <!-- MATH
 $\rho(A) = \rho(NIL) = 0, \rho(CONS) = 2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="272" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img173.png"
 ALT="$ \rho(A) = \rho(NIL) = 0, \rho(CONS) = 2$"></SPAN>
y sea <!-- MATH
 $V = \{ x \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="69" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img289.png"
 ALT="$ V = \{ x \}$"></SPAN>. Los siguientes árboles son ejemplos de 
patrones sobre <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img45.png"
 ALT="$ \Sigma$"></SPAN>:
</I>
<P>
<DIV ALIGN="CENTER"><I>{ <!-- MATH
 $x, CONS(A, x), CONS(A, CONS(x, NIL)), \ldots \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="379" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img290.png"
 ALT="$ x, CONS(A, x), CONS(A, CONS(x, NIL)), \ldots \}$"></SPAN></I></DIV>
<P>
<I>El patrón <!-- MATH
 $CONS(x, CONS(x, NIL))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="214" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img291.png"
 ALT="$ CONS(x, CONS(x, NIL))$"></SPAN> es un ejemplo de patrón no lineal.
La idea es que un patrón lineal como éste ``fuerza'' a que los árboles <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img191.png"
 ALT="$ t$"></SPAN>
que casen con el patrón deben tener iguales los dos correspondientes
subárboles <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img292.png"
 ALT="$ t/1$"></SPAN> y <!-- MATH
 $t/2 \ldotp 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img248.png"
 ALT="$ t/2\ldotp1$"></SPAN> situados en las posiciones de las variables
<A NAME="tex2html322"
  HREF="footnode.html#foot11487"><SUP><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></I>
<P></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Dado la gramática árbol:
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $S \rightarrow S_1(a, S, b)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="118" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img293.png"
 ALT="$ S \rightarrow S_1(a, S, b)$"></SPAN>
<BR><!-- MATH
 $S \rightarrow S_2(NIL)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="112" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img294.png"
 ALT="$ S \rightarrow S_2(NIL)$"></SPAN></I></DIV>
<P>
<I>la cuál genera los árboles concretos para la gramática
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $S \rightarrow aSb$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="72" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img295.png"
 ALT="$ S \rightarrow aSb$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$ \vert$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img42.png"
 ALT="$ \epsilon$"></SPAN></I></DIV>
<P>
<I>¿Es <!-- MATH
 $S_1(a, X(NIL), b)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="135" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img296.png"
 ALT="$ S_1(a, X(NIL), b)$"></SPAN> un patrón árbol sobre el conjunto de variables <SPAN CLASS="MATH"><IMG
 WIDTH="59" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img297.png"
 ALT="$ \{X, Y\}$"></SPAN>?
¿Lo es <!-- MATH
 $S_1(X, Y, a)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img298.png"
 ALT="$ S_1(X, Y, a)$"></SPAN>? ¿Es <!-- MATH
 $S_1(X, Y, Y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="92" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img299.png"
 ALT="$ S_1(X, Y, Y)$"></SPAN> un patrón árbol?</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejemplo  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>Ejemplos de patrones para el AAA definido en el ejemplo
<A HREF="node69.html#example:tutuast">7.9.2</A> para el lenguaje Tutu son:
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $x, y, PLUS(x, y), ASSIGN(x, TIMES(y,ID)), PRINT(y) \ldots$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="483" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img300.png"
 ALT="$ x, y, PLUS(x, y), ASSIGN(x, TIMES(y,ID)), PRINT(y) \ldots$"></SPAN></I></DIV>
<P>
<I>considerando el conjunto de variables <!-- MATH
 $V = \{ x, y \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="86" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img301.png"
 ALT="$ V = \{ x, y \}$"></SPAN>. El patrón 
<!-- MATH
 $ASSIGN(x, TIMES(y,ID))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="232" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img302.png"
 ALT="$ ASSIGN(x, TIMES(y,ID))$"></SPAN> es del tipo <SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img303.png"
 ALT="$ (x, y)$"></SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">4</SPAN></B> &nbsp; 
<I>Una <A NAME="11950"></A><SPAN  CLASS="textbf">sustitución</SPAN> es una aplicación <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img304.png"
 ALT="$ \theta$"></SPAN> que asigna variables
a patrones <!-- MATH
 $\theta: V \rightarrow B(V \cup \Sigma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="143" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img305.png"
 ALT="$ \theta: V \rightarrow B(V \cup \Sigma)$"></SPAN>.
</I>
<P>
<I>Tal función puede ser naturalmente extendida de las variables
a los árboles: los nodos (hoja) etiquetados con dichas variables son sustituidos
por los correspondientes subárboles.
</I>
<P>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><I>
<!-- MATH
 $\theta : B(V \cup \Sigma) \rightarrow B(V \cup \Sigma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="202" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img306.png"
 ALT="$ \theta : B(V \cup \Sigma) \rightarrow B(V \cup \Sigma)$"></SPAN></I></TD>
</TR>
<TR><TD ALIGN="LEFT"><I> 
<!-- MATH
 $t \theta = \left \{ \begin{array}{ll}
                         x \theta & \mbox{si $t = x \in V$}\\
                         a(t_1  \theta, \ldots, t_k \theta) & \mbox{si $t = a(t_1, \ldots, t_k)$} 
                      \end{array}
             \right.$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="334" HEIGHT="62" ALIGN="MIDDLE" BORDER="0"
 SRC="img307.png"
 ALT="$ t \theta = \left \{ \begin{array}{ll}
x \theta &amp; \mbox{si $t = x \in V$}\\
...
...ldots, t_k \theta) &amp; \mbox{si $t = a(t_1, \ldots, t_k)$}
\end{array} \right. $"></SPAN></I></TD>
</TR>
</TABLE></DIV>
<P>
<I>Obsérvese que, al revés de lo que es costumbre, la aplicación 
de la sustitución <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img304.png"
 ALT="$ \theta$"></SPAN> al patrón se escribe por detrás: <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img308.png"
 ALT="$ t \theta$"></SPAN>.
</I>
<P>
<I>También se escribe <!-- MATH
 $t \theta = t\{x_1/x_1 \theta, \ldots x_k/x_k \theta\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="204" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img309.png"
 ALT="$ t \theta = t\{x_1/x_1 \theta, \ldots x_k/x_k \theta\}$"></SPAN> si las variables
que aparecen en <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img191.png"
 ALT="$ t$"></SPAN> de izquierda a derecha son <!-- MATH
 $x_1, \ldots x_k$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img288.png"
 ALT="$ x_1, \ldots x_k$"></SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejemplo  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>Si aplicamos la sustitución  <!-- MATH
 $\theta = \{x/A, y/CONS(A, NIL)\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="237" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img310.png"
 ALT="$ \theta = \{x/A, y/CONS(A, NIL)\}$"></SPAN>
al patrón <!-- MATH
 $CONS(x, y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img311.png"
 ALT="$ CONS(x, y)$"></SPAN> obtenemos el árbol <!-- MATH
 $CONS(A, CONS(A, NIL))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="220" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img215.png"
 ALT="$ CONS(A, CONS(A,NIL))$"></SPAN>.
En efecto:
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $CONS(x, y)\theta = CONS(x\theta, y\theta) = CONS(A, CONS(A, NIL))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="484" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img312.png"
 ALT="$ CONS(x, y)\theta = CONS(x\theta, y\theta) = CONS(A, CONS(A, NIL))$"></SPAN></I></DIV>
<P></DIV><P></P>

<P>
<P>
<DIV><B>Ejemplo  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">4</SPAN></B> &nbsp; 
<I>Si aplicamos la sustitución  <!-- MATH
 $\theta = \{x/PLUS(NUM, x), y/TIMES(ID, NUM)\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="388" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img313.png"
 ALT="$ \theta = \{x/PLUS(NUM, x), y/TIMES(ID, NUM)\}$"></SPAN>
al patrón <!-- MATH
 $PLUS(x, y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="96" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img314.png"
 ALT="$ PLUS(x, y)$"></SPAN> obtenemos el árbol <!-- MATH
 $PLUS(PLUS(NUM,x), TIMES(ID, NUM))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="367" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img315.png"
 ALT="$ PLUS(PLUS(NUM,x), TIMES(ID, NUM))$"></SPAN>:
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $PLUS(x, y)\theta = PLUS(x\theta, y\theta) = PLUS(PLUS(NUM,x), TIMES(ID, NUM))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="622" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img316.png"
 ALT="$ PLUS(x, y)\theta = PLUS(x\theta, y\theta) = PLUS(PLUS(NUM,x), TIMES(ID, NUM))$"></SPAN></I></DIV>
<P></DIV><P></P>

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">5</SPAN></B> &nbsp; 
<I>Se dice que un patrón <!-- MATH
 $\tau \in B(V \cup \Sigma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="109" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img317.png"
 ALT="$ \tau \in B(V \cup \Sigma)$"></SPAN> con variables
<!-- MATH
 $x_1, \ldots x_k$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img288.png"
 ALT="$ x_1, \ldots x_k$"></SPAN> <A NAME="11952"></A><SPAN  CLASS="textbf">casa con un árbol</SPAN>
<!-- MATH
 $t \in B(\Sigma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="73" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img239.png"
 ALT="$ t \in B(\Sigma)$"></SPAN> si existe una sustitución de <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img318.png"
 ALT="$ \tau$"></SPAN> que produce <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img191.png"
 ALT="$ t$"></SPAN>, esto
es, si existen <!-- MATH
 $t_1, \ldots t_k \in B(\Sigma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img319.png"
 ALT="$ t_1, \ldots t_k \in B(\Sigma)$"></SPAN> tales que 
<!-- MATH
 $t = \tau \{x_1/t_1, \ldots x_k/t_k\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="174" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img320.png"
 ALT="$ t = \tau \{x_1/t_1, \ldots x_k/t_k\}$"></SPAN>. 
También se dice que <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img318.png"
 ALT="$ \tau$"></SPAN> <A NAME="11954"></A><SPAN  CLASS="textbf">casa con la sustitución</SPAN>
<!-- MATH
 $\{x_1/t_1, \ldots x_k/t_k\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="135" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img321.png"
 ALT="$ \{x_1/t_1, \ldots x_k/t_k\}$"></SPAN>.</I></DIV><P></P>

<P>
<P>
<DIV><B>Ejemplo  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">5</SPAN></B> &nbsp; 
<I>El patrón <!-- MATH
 $\tau = CONS(x, NIL)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="161" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img322.png"
 ALT="$ \tau = CONS(x, NIL)$"></SPAN> casa con el árbol <!-- MATH
 $t = CONS(CONS(A,NIL),NIL)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="274" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img323.png"
 ALT="$ t = CONS(CONS(A,NIL),NIL)$"></SPAN> 
y con el subárbol  <!-- MATH
 $t \ldotp 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img324.png"
 ALT="$ t \ldotp 1$"></SPAN>. Las respectivas sustituciones son <!-- MATH
 $t\{x/CONS(A,NIL)\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="173" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img325.png"
 ALT="$ t\{x/CONS(A,NIL)\}$"></SPAN> y 
<!-- MATH
 $t \ldotp 1 \{x/A\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="76" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img326.png"
 ALT="$ t \ldotp 1 \{x/A\}$"></SPAN>.
</I>
<P>
<DIV ALIGN="CENTER"><I><!-- MATH
 $t = \tau \{x/CONS(A,NIL)\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="206" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img327.png"
 ALT="$ t = \tau \{x/CONS(A,NIL)\}$"></SPAN>
<BR><!-- MATH
 $t \ldotp 1 = \tau \{x/A\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="109" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img328.png"
 ALT="$ t \ldotp 1 = \tau \{x/A\}$"></SPAN></I></DIV>
<P></DIV><P></P>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>Sea <!-- MATH
 $\tau = PLUS(x, y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="129" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img329.png"
 ALT="$ \tau = PLUS(x, y)$"></SPAN> y <!-- MATH
 $t = TIMES(PLUS(NUM, NUM), TIMES(ID, ID))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="425" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img330.png"
 ALT="$ t = TIMES(PLUS(NUM, NUM), TIMES(ID, ID))$"></SPAN>.
Calcule los subárboles <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$ t'$"></SPAN> de <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img191.png"
 ALT="$ t$"></SPAN> y las sustituciones <!-- MATH
 $\{x/t_1, y/t_2\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="94" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img331.png"
 ALT="$ \{x/t_1, y/t_2\}$"></SPAN> 
que hacen que <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img318.png"
 ALT="$ \tau$"></SPAN> case con <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$ t'$"></SPAN>.  
</I>
<P>
<I>Por ejemplo es obvio que para el árbol raíz <!-- MATH
 $t/\epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img246.png"
 ALT="$ t/\epsilon$"></SPAN> no existe sustitución
posible:
</I>
<P>
<I><!-- MATH
 $t = TIMES(PLUS(NUM, NUM), TIMES(ID, ID)) = \tau\{x/t_1, y/t_2\} =
PLUS(x, y)\{x/t_1, y/t_2\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="749" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img332.png"
 ALT="$ t = TIMES(PLUS(NUM, NUM), TIMES(ID, ID)) = \tau\{x/t_1, y/t_2\} =
PLUS(x, y)\{x/t_1, y/t_2\}$"></SPAN>
</I>
<P>
<I>ya que un término con raíz <SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img234.png"
 ALT="$ TIMES$"></SPAN> nunca podrá ser igual a un término con raíz 
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img232.png"
 ALT="$ PLUS$"></SPAN>.</I></DIV><P></P>

<P>
El problema aquí es equivalente al de las expresiones regulares
en el caso de los lenguajes lineales. En aquellos, los autómatas finitos 
nos proveen con un mecanismo para reconocer si una determinada cadena
``casa''' o no con la expresión regular. Existe un concepto análogo,
el de <A NAME="11956"></A><SPAN  CLASS="textbf">autómata árbol</SPAN> que resuelve el problema del ``casamiento''
de patrones árbol. Al igual que el concepto de autómata permite 
la construcción de software para la búsqueda de cadenas y su 
posterior modificación, el concepto de autómata árbol 
permite la construcción de software para la búsqueda de los
subárboles que casan con un patrón árbol dado.

<P>
Estamos ahora en condiciones de plantear una segunda aproximación
al problema de la optimización independiente de la máquina
utilizando una subrutina que busque por aquellos
árboles que queremos optimizar (en el caso del plegado 
los árboles de tipo operación) y los transforme 
adecuadamente. 

<P>
La función
<code>match_and_transform_list</code> recibe una lista
de árboles los cuales recorre sometiéndolos 
a las transformaciones especificadas. La llamada para
producir el plegado sería:

<P>
<PRE>
  Tree::Transform::match_and_transform_list(
    NODES =&gt; $tree-&gt;{STS}, # lista de sentencias
    PATTERN =&gt; sub {
       $_[0]-&gt;is_operation and $_[0]-&gt;LEFT-&gt;isa("NUM") 
       and $_[0]-&gt;RIGHT-&gt;isa("NUM") 
    },
    ACTION =&gt; sub { 
      $_[0] = Machine::Independent::Optimization::reduce_children($_[0]) 
    }
  );
</PRE>
Además de la lista de nodos le pasamos como argumentos una
referencia a la subrutina encargada de reconocer los patrónes
árbol (clave <code>PATTERN</code>) y una referencia a la
subrutina que describe la acción que se ejecutará  (clave <code>ACTION</code>) sobre 
el árbol que ha casado. Ambas subrutinas 
asumen que el primer argumento que se les pasa 
es la referencia a la raíz del árbol que está siendo explorado.

<P>
Los métodos <A NAME="11958"></A><SPAN  CLASS="textbf">isa</SPAN>, <A NAME="11960"></A><SPAN  CLASS="textbf">can</SPAN> y <A NAME="11962"></A><SPAN  CLASS="textbf">VERSION</SPAN> 
son proporcionados por una clase especial denominada clase <code>UNIVERSAL</code>,
de la cual implícitamente hereda toda clase. 
El método <code>isa</code>  nos permite saber si una clase hereda de otra.

<P>
La subrutina <code>match_and_transform_list</code>
recibe los argumentos y da valores por defecto a los mismos
en el caso de que no hayan sido establecidos.
Finalmente, llama a <code>match_and_transform</code>
sobre cada uno de los nodos ``sentencia'' del programa.

<P>
<PRE>
sub match_and_transform_list {
  my %arg = @_;
  my @statements = @{$arg{NODES}} or 
   Error::fatal("Internal error. match_and_transform_list ".
   "espera una lista anónima de nodos");
  local $pattern = ($arg{PATTERN} or sub { 1 });
  local @pattern_args = @{$arg{PATTERN_ARGS}} if defined $arg{PATTERN_ARGS};
  local $action = ($arg{ACTION} or sub { print ref($_[0]),"\n" }); 
  local @action_args = @{$arg{ACTION_ARGS}} if defined $arg{ACTION_ARGS};

  for (@statements) {
    match_and_transform($_);
  }
}
</PRE>

<P>
La subrutina <code>match_and_transform</code>
utiliza el método <code>can</code> para comprobar que el 
nodo actual dispone de un método
para calcular la lista con los hijos del nodo.
Una vez transformados los subárboles del nodo actual
procede a comprobar que el nodo casa con el patrón
y si es el caso le aplica la acción definida:

<P>
<PRE>
package Tree::Transform;

our $pattern;
our @pattern_args;
our $action;
our @action_args;
our @statements;

sub match_and_transform {
  my $node = $_[0] or Error::fatal("Error interno. match_and_transform necesita un nodo");
  Error::fatal("Error interno. El nodo de la clase",ref($node),
               " no dispone de método 'children'") unless $node-&gt;can("children");
  
  my %children = $node-&gt;children;

  for my $k (keys %children) {
    $node-&gt;{$k} = match_and_transform($children{$k});
  }

  if ($pattern-&gt;($node, @pattern_args)) {
    $action-&gt;( $node, @action_args); 
  }
  return $node;
}
</PRE>

<P>
Recordemos el esquema de herencia que presentamos en la sección anterior.
Las clases <code>Leaf</code> y <code>Binary</code> proveen versiones del método <code>children</code>.
Teníamos:
<PRE>
package Node;

sub is_operation {
  my $node = shift;

  return ref($node) =~ /^(TIMES)|(PLUS)$/;
}

package Leaf; # hoja del AAA
our @ISA = ("Node");
sub children {
  return ();
}

package Binary;
our @ISA = ("Node");
sub children {
  my $self = shift;

  return (LEFT =&gt; $self-&gt;{LEFT}, RIGHT =&gt; $self-&gt;{RIGHT});
}
</PRE>
Los objetos de la clase <code>Leaf</code> tienen acceso 
al método <code>is_operation</code>.

<P>
Las clases <code>PLUS</code> y <code>TIMES</code> 
heredan de la clase <code>BINARY</code>:
<PRE>
package PLUS;
our @ISA = ("Binary");

sub operator {
  my $self = shift;

  $_[0]+$_[1];
}

....

package TIMES;
our @ISA = ("Binary");

sub operator {
  my $self = shift;

  $_[0]*$_[1];
}

....
</PRE>

<P>
La subrutina <code>reduce_children</code> introducida en la
sección 
<A HREF="node71.html#section:optimizacion">7.11</A>
es la encargada 
de crear el nuevo nodo con el resultado de operar los
hijos izquierdo y derecho:

<P>
<PRE>
1 sub reduce_children {
2   my ($node) = @_;
3 
4   my $value = $node-&gt;operator($node-&gt;LEFT-&gt;VAL, $node-&gt;RIGHT-&gt;VAL);
5   NUM-&gt;new(VAL =&gt; $value, TYPE =&gt; $PL::Tutu::int_type);
6 }
</PRE>

<P>
En la línea 4 se usa el método <code>operator</code> asociado 
con un nodo operación. 

<P>

<H2><A NAME="SECTION047121000000000000000"></A>
   <A NAME="11965"></A>
  
<A NAME="practica:casandoytransformando"></A>
<BR>
Práctica: Casando y Transformando Árboles
</H2>
Complete su proyecto para el compilador de Tutu completando
las subrutinas <code>match_and_transform</code> tal y como se explicó en la sección
<A HREF="#section:patronesarbol">7.12</A>.

<P>
Ademas del plegado
de constantes use las nuevas subrutinas 
para aplicar simultáneamente 
las siguientes transformaciones algebraicas:

<P>
<BR>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><!-- MATH
 $PLUS(NUM, x)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="135" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img333.png"
 ALT="$ PLUS(NUM, x)$"></SPAN></TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img334.png"
 ALT="$ \wedge$"></SPAN> <code>{ $NUM{VAL} == 0 }</code></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Longrightarrow x$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img335.png"
 ALT="$ \Longrightarrow x$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $PLUS(x, NUM)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="136" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img336.png"
 ALT="$ PLUS(x, NUM)$"></SPAN></TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img334.png"
 ALT="$ \wedge$"></SPAN> <code>{ $NUM{VAL} == 0 }</code></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Longrightarrow x$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img335.png"
 ALT="$ \Longrightarrow x$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $TIMES(NUM, x)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="150" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img337.png"
 ALT="$ TIMES(NUM, x)$"></SPAN></TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img334.png"
 ALT="$ \wedge$"></SPAN> <code>{ $NUM{VAL} == 1 }</code></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Longrightarrow x$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img335.png"
 ALT="$ \Longrightarrow x$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $TIMES(x, NUM)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img338.png"
 ALT="$ TIMES(x, NUM)$"></SPAN></TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img334.png"
 ALT="$ \wedge$"></SPAN> <code>{ $NUM{VAL} == 1 }</code></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Longrightarrow x$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img335.png"
 ALT="$ \Longrightarrow x$"></SPAN></TD>
</TR>
</TABLE>
<BR>
<BR>

<P>

<OL>
<LI>Dado un programa como

<P>
<PRE>
int a; a = a * 4 * 5;
</PRE>
¿Será plegado el <code>4 * 5</code>?
Sin embargo si que se pliega si el programa es de la forma:
<PRE>
int a; a = a * (4 * 5);
</PRE>
No intente en esta práctica que programas como el primero  o como
<code>4*a*5*b</code> sean plegados.
Para lograrlo sería necesario introducir transformaciones adicionales
y esto no se requiere en esta práctica.
</LI>
<LI>¿Existe un orden óptimo en el que ejecutar las transformaciones?
</LI>
<LI>Ponga un ejemplo en el que sea beneficioso ejecutar el plegado primero.
</LI>
<LI>Ponga otro ejemplo en el que sea beneficioso ejecutar el plegado después.
</LI>
<LI>¿Es necesario  aplicar las transformaciones reiteradamente? 
</LI>
<LI><A NAME="item:parada"></A>¿Cuál es la condición de parada?
</LI>
<LI>Como es habitual la pregunta 
<A HREF="#item:parada">6</A> tiene 
una respuesta TIMTOWTDI: 
una posibilidad la da el módulo 
<A NAME="tex2html323"
  HREF="http://search.cpan.org/~dcantrell/Data-Compare-0.13/lib/Data/Compare.pm">Data::Compare</A>
el cual puede obtenerse desde CPAN y que permite comparar estructuras de datos, 
pero existe una solución mas sencilla. ¿Cuál?
</LI>
</OL>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html3420"
  HREF="node73.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3414"
  HREF="node60.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html3408"
  HREF="node71.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3416"
  HREF="node232.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3418"
  HREF="node235.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html3421"
  HREF="node73.html">Asignación de Direcciones</A>
<B>Sup:</B> <A NAME="tex2html3415"
  HREF="node60.html">Análisis Sintáctico Descendente en</A>
<B> Ant:</B> <A NAME="tex2html3409"
  HREF="node71.html">Optimización Independiente de la</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-06-10</I>
</ADDRESS>
</BODY>
</HTML>
