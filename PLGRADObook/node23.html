<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Análisis Sintáctico Predictivo Recursivo</TITLE>
<META NAME="description" CONTENT="Análisis Sintáctico Predictivo Recursivo">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node24.html">
<LINK REL="previous" HREF="node22.html">
<LINK REL="up" HREF="node21.html">
<LINK REL="next" HREF="node24.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html1163"
  HREF="node24.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1157"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1151"
  HREF="node22.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1159"
  HREF="node86.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html1161"
  HREF="node89.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html9"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html1164"
  HREF="node24.html">Esquemas de Traducción</A>
<B>Sup:</B> <A NAME="tex2html1158"
  HREF="node21.html">Análisis Descendente mediante Parsing</A>
<B> Ant:</B> <A NAME="tex2html1152"
  HREF="node22.html">Conceptos Básicos para el</A>
<B> Con:</B> 
<A NAME="tex2html1159"
  HREF="node86.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html1161"
  HREF="node89.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html1165"
  HREF="node23.html#SECTION04321000000000000000">Introducción</A>
<LI><A NAME="tex2html1166"
  HREF="node23.html#SECTION04322000000000000000">Ejercicio: Recorrido del árbol en un ADPR</A>
<LI><A NAME="tex2html1167"
  HREF="node23.html#SECTION04323000000000000000">Ejercicio: Factores Comunes</A>
<LI><A NAME="tex2html1168"
  HREF="node23.html#SECTION04324000000000000000">Derivaciones a vacío</A>
<LI><A NAME="tex2html1169"
  HREF="node23.html#SECTION04325000000000000000">Construcción de los conjuntos de Primeros y Siguientes</A>
<LI><A NAME="tex2html1170"
  HREF="node23.html#SECTION04326000000000000000">Ejercicio: Construir los <SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ FIRST$"></SPAN></A>
<LI><A NAME="tex2html1171"
  HREF="node23.html#SECTION04327000000000000000">Ejercicio: Calcular los <SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$ FOLLOW$"></SPAN></A>
<LI><A NAME="tex2html1172"
  HREF="node23.html#SECTION04328000000000000000">Práctica: Construcción de los FIRST y los FOLLOW</A>
<LI><A NAME="tex2html1173"
  HREF="node23.html#SECTION04329000000000000000">Gramáticas LL(1)</A>
<LI><A NAME="tex2html1174"
  HREF="node23.html#SECTION043210000000000000000">Ejercicio: Caracterización de una gramática LL(1) </A>
<LI><A NAME="tex2html1175"
  HREF="node23.html#SECTION043211000000000000000">Ejercicio: Ambiguedad y LL(1)</A>
<LI><A NAME="tex2html1176"
  HREF="node23.html#SECTION043212000000000000000">Práctica: Un analizador APDR</A>
<LI><A NAME="tex2html1177"
  HREF="node23.html#SECTION043213000000000000000">Práctica: Generación Automática de Analizadores Predictivos</A>
<UL>
<LI><A NAME="tex2html1178"
  HREF="node23.html#SECTION043213010000000000000">Objetivo</A>
<LI><A NAME="tex2html1179"
  HREF="node23.html#SECTION043213020000000000000">El Módulo <TT>Grammar</TT></A>
<LI><A NAME="tex2html1180"
  HREF="node23.html#SECTION043213030000000000000">Descripción del objetivo: La función <TT>gap</TT></A>
<LI><A NAME="tex2html1181"
  HREF="node23.html#SECTION043213040000000000000">Descripción del objetivo: La función <TT>parser</TT></A>
<LI><A NAME="tex2html1182"
  HREF="node23.html#SECTION043213050000000000000">Cálculo de los First y los Follow con <TT>PL::FirstFollow</TT></A>
<LI><A NAME="tex2html1183"
  HREF="node23.html#SECTION043213060000000000000">Uso de Templates</A>
<LI><A NAME="tex2html1184"
  HREF="node23.html#SECTION043213070000000000000">Concatenación y Documentos <TT>HERE</TT></A>
<LI><A NAME="tex2html1185"
  HREF="node23.html#SECTION043213080000000000000">Descarga de los Módulos Necesarios</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04320000000000000000"></A>
<A NAME="section:predictivo"></A>
<BR>
Análisis Sintáctico Predictivo Recursivo
</H1>
La siguiente fase en la construcción del analizador es la fase de 
análisis sintáctico. Esta toma como entrada el flujo de terminales
y construye como salida el árbol de análisis sintáctico abstracto.

<P>
El árbol de análisis sintáctico abstracto es una representación  compactada del árbol 
de análisis sintáctico concreto que contiene la misma información que éste.

<P>
Existen diferentes métodos de análisis sintáctico. La mayoría caen en una de dos categorías:
ascendentes y descendentes. Los ascendentes construyen el árbol desde las hojas
hacia la raíz. Los descendentes lo hacen en modo inverso. El que describiremos
aqui es uno de los mas sencillos: se denomina método de análisis predictivo descendente 
recursivo.

<P>

<H2><A NAME="SECTION04321000000000000000"></A>
<A NAME="subsection:introduccion"></A>
<BR>
Introducción
</H2>
En este método se asocia una subrutina con cada variable sintáctica <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ A \in V$"></SPAN>. Dicha subrutina 
(que llamaremos <code>A</code>) reconocerá el lenguaje generado desde la variable <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN>:

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $L_A(G) = \{ x \in \Sigma^* : A \stackrel{*}{\Longrightarrow} x \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="222" HEIGHT="45" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$ L_A(G) = \{ x \in \Sigma^* : A \stackrel{*}{\Longrightarrow} x \}$"></SPAN>
</DIV>

<P>
En este método se escribe una rutina <code>A</code> por variable sintáctica <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ A \in V$"></SPAN>. 
Se le da a la rutina asociada el mismo nombre que a la variable sintáctica
asociada. La función de la rutina <code>A</code> asociada con la variable
<SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ A \in V$"></SPAN> es reconocer el lenguaje <SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$ L(A)$"></SPAN> generado por <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN>.
La estrategia general que sigue la rutina <code>A</code> para reconocer
<SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$ L(A)$"></SPAN> es decidir en términos del terminal <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img43.png"
 ALT="$ a$"></SPAN> en la entrada
que regla de producción concreta <!-- MATH
 $A \rightarrow \alpha$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$ A \rightarrow \alpha$"></SPAN> se aplica para
a continuación comprobar que la entrada que sigue pertenece al lenguaje generado por 
<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$ \alpha$"></SPAN>. 
En un analizador predictivo descendente recursivo (APDR) se asume que el símbolo que actualmente 
esta siendo observado (denotado <code>lookahead</code>) permite determinar unívocamente
que producción de <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> hay que aplicar. 
Una vez que se ha determinado que la regla por la que continuar la derivación
es <!-- MATH
 $A \rightarrow \alpha$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$ A \rightarrow \alpha$"></SPAN> se procede a reconocer <!-- MATH
 $L_{\alpha}(G)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$ L_{\alpha}(G)$"></SPAN>,
el lenguaje generado por <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$ \alpha$"></SPAN>. Si <!-- MATH
 $\alpha = X_1 \ldots X_n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="111" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$ \alpha = X_1 \ldots X_n$"></SPAN>,
las apariciones de terminales <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$ X_i$"></SPAN> en <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$ \alpha$"></SPAN> son emparejadas
con los terminales en la entrada mientras que las apariciones de variables <SPAN CLASS="MATH"><IMG
 WIDTH="62" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="$ X_i = B$"></SPAN>
en <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$ \alpha$"></SPAN> se traducen en llamadas a la correspondiente subrutina asociada con <code>B</code>.

<P>
Para ilustrar el método,
simplificaremos la gramática presentada en el ejercicio
<A HREF="node38.html#ejercicio:tutugrammar">4.1.1</A> eliminando las declaraciones:

<P>
<BR>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">statements   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> statement  ';'  statements        <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> statement</TD>
</TR>
<TR><TD ALIGN="LEFT">statement    <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> ID '=' expression                 <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> P  expression</TD>
</TR>
<TR><TD ALIGN="LEFT">expression   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> term '+' expression               <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> term</TD>
</TR>
<TR><TD ALIGN="LEFT">term         <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> factor '*' term                   <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> factor</TD>
</TR>
<TR><TD ALIGN="LEFT">factor       <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> '(' expression ')' <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> ID <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> NUM</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
La secuencia de llamadas cuando se procesa la entrada mediante 
el siguiente programa construye ``implícitamente'' el árbol 
de análisis sintáctico concreto.

<P>
Dado que estamos usando <code>strict</code> se requiere prototipar las funciones
al comienzo del fichero:
<PRE>
sub parse();
sub statements();
sub statement();
sub expression();
sub term();
sub factor();
sub idlist();
sub declaration();
sub declarations();
</PRE>

<P>
Para saber mas sobre prototipos consulte <A HREF="#section:prototipos">
<IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> [<A
 HREF="node90.html#CasianoIntroAPerl">3</A>].

<P>
<P>
<DIV><A NAME="program:adrp"><B>Programa  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></B></A> &nbsp; <PRE>
 1 sub match {
 2   my $t = shift;
 3 
 4   if ($lookahead eq $t) {
 5     ($lookahead, $value) = splice @tokens,0,2; 
 6     if (defined($lookahead)) { 
 7       $lookahead = $value if ($lookahead eq 'PUN');
 8     } else { $lookahead = 'EOI'; }
 9   }
10   else { error("Se esperaba $t y se encontro $lookahead\n"); }
11 }
12 
13 sub statement {
14   if ($lookahead eq 'ID') { match('ID'); match('='); expression; }
15   elsif ($lookahead eq 'P') { match('P'); expression; }
16   else { error('Se esperaba un identificador'); }
17 }
18 
19 sub term() {
20   factor;
21   if ($lookahead eq '*') { match('*'); term; }
22 }
23 
24 sub expression() {
25   term;
26   if ($lookahead eq '+') { match('+'); expression; }
27 }
28 
29 sub factor() {
30   if ($lookahead eq 'NUM') { match('NUM'); }
31   elsif ($lookahead eq 'ID') { match('ID'); }
32   elsif ($lookahead eq '(') { match('('); expression; match(')'); }
33   else { error("Se esperaba (, NUM o ID"); }
34 }
35 
36 sub statements {
37   statement;
38   if ($lookahead eq ';') { match(';'); statements; }
39 }
40 
41 sub parser {
42   ($lookahead, $value) = splice @tokens,0,2; 
43   statements; match('EOI');
44 }
</PRE></DIV><P></P>

<P>
Como vemos en el ejemplo, el análisis predictivo confía en que, si estamos
ejecutando la entrada del procedimiento <code>A</code>,
el cuál está asociado con la variable <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ A \in V$"></SPAN>, el símbolo terminal
que esta en la entrada <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img43.png"
 ALT="$ a$"></SPAN> determine de manera unívoca la regla
de producción <!-- MATH
 $A \rightarrow a \alpha$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$ A \rightarrow a \alpha$"></SPAN> que debe ser procesada.

<P>
Si se piensa, esta condición requiere que todas las partes derechas <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$ \alpha$"></SPAN> de
las reglas <!-- MATH
 $A \rightarrow \alpha$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$ A \rightarrow \alpha$"></SPAN> de <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> ``comiencen'' por diferentes símbolos.
Para formalizar esta idea, introduciremos el concepto de
conjunto <!-- MATH
 $FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ FIRST(\alpha)$"></SPAN>:

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Dada una gramática 
<!-- MATH
 $G=(\Sigma,V,P,S)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$ G =(\Sigma,V,P,S)$"></SPAN> y un símbolo <!-- MATH
 $\alpha \in (V \cup \Sigma)^*$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="104" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$ \alpha \in (V \cup \Sigma)^*$"></SPAN> se define el conjunto 
<!-- MATH
 $FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ FIRST(\alpha)$"></SPAN> como:
</I>
<P>
<I><!-- MATH
 $FIRST(\alpha) = \left \{ b \in \Sigma :  \alpha  \stackrel{*}{\Longrightarrow}  b \beta \right \}
\cup N(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="319" HEIGHT="50" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$ FIRST(\alpha) = \left \{ b \in \Sigma : \alpha \stackrel{*}{\Longrightarrow} b \beta \right \}
\cup N(\alpha)$"></SPAN> 
</I>
<P>
<I>donde:
</I>
<P>
<I><!-- MATH
 $N(\alpha) = \left \{ \begin{array}{ll}
                         \left \{ \epsilon \right \}& \mbox{si $\alpha \stackrel{*}{\Longrightarrow} \epsilon$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right.$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="232" HEIGHT="63" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.png"
 ALT="$ N(\alpha) = \left \{ \begin{array}{ll}
\left \{ \epsilon \right \}&amp; \mbox{si ...
...htarrow} \epsilon$} \\
\emptyset &amp; \mbox{en otro caso}
\end{array} \right. $"></SPAN> 
</I>
<P></DIV><P></P>

<P>
Podemos reformular ahora nuestra afirmación anterior en estos términos:
Si <!-- MATH
 $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="129" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$ A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$"></SPAN> y los conjuntos <!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN> son 
disjuntos podemos construir el procedimiento para la variable <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> siguiendo
este seudocódigo:

<P>
<PRE>
sub A {
  if ($lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  elsif ($lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else ($lookahead in FIRST(gamma_n)) { imitar gamma_n }
}
</PRE>

<P>
Donde si <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$ \gamma_j$"></SPAN> es <!-- MATH
 $X_1 \ldots X_k$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="76" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.png"
 ALT="$ X_1 \ldots X_k$"></SPAN> el código <code>gamma_j</code> consiste
en una secuencia <!-- MATH
 $i = 1 \ldots k$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="79" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.png"
 ALT="$ i = 1 \ldots k$"></SPAN> de llamadas de uno de estos dos tipos:

<UL>
<LI>Llamar a la subrutina <code>X_i</code> si <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$ X_i$"></SPAN> es una variable sintáctica
</LI>
<LI>Hacer una llamada a <code>match(X_i)</code> si <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$ X_i$"></SPAN> es un terminal
</LI>
</UL>

<P>

<H2><A NAME="SECTION04322000000000000000"></A>
   <A NAME="3908"></A>
<BR>
Ejercicio: Recorrido del árbol en un ADPR
</H2>
  
¿En que forma es recorrido el árbol de análisis sintáctico concreto en un 
analizador descendente predictivo recursivo? ¿En que orden son visitados los nodos?

<P>

<H2><A NAME="SECTION04323000000000000000"></A>
   <A NAME="3910"></A>
<BR>
Ejercicio: Factores Comunes
</H2>
  
En el programa <A HREF="#program:adrp">3.2.1</A> el reconocimiento de las categorías gramáticales
statements, expression y term (líneas 19-27) difiere del resto. Observe las reglas:

<P>
<BR>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">statements   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> statement  ';'  statements        <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> statement</TD>
</TR>
<TR><TD ALIGN="LEFT">expression   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> term '+' expression               <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> term</TD>
</TR>
<TR><TD ALIGN="LEFT">term         <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> factor '*' term                   <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> factor</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
¿Son disjuntos los conjuntos <!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN> para las partes derechas de las reglas
de statements?
¿Son disjuntos los conjuntos <!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN> para las partes derechas de las reglas
de expression?
¿Son disjuntos los conjuntos <!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN> para las partes derechas de las reglas
de term?

<P>
Si se tiene una variable con producciones:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><!-- MATH
 $A   \rightarrow \alpha \beta \mid \alpha \gamma$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="103" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img59.png"
 ALT="$ A \rightarrow \alpha \beta \mid \alpha \gamma$"></SPAN></TD>
</TR>
</TABLE>

<P>
Las dos producciones tienen un <A NAME="3911"></A><SPAN  CLASS="textbf">máximo factor común</SPAN> en la izquierda
de su parte derecha <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$ \alpha$"></SPAN>. Asumimos que <!-- MATH
 $FIRST(\beta) \cap FIRST(\gamma) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="225" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.png"
 ALT="$ FIRST(\beta) \cap FIRST(\gamma) = \emptyset$"></SPAN>.

<OL>
<LI>¿Cómo puede modificarse la gramática para obtener una nueva gramática que cumpla la condición de que las partes derechas tienen conjuntos <!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN> disjuntos?
</LI>
<LI>¿Puede modificarse la técnica APDR para que funcione sobre gramáticas con este tipo 
de producciones?. Observe el código asociado con statements, expression  y term.
¿Cómo sería el esquema general?
</LI>
</OL>

<P>

<H2><A NAME="SECTION04324000000000000000">
Derivaciones a vacío</A>
</H2>
Surge un problema cuando <!-- MATH
 $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="129" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$ A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$"></SPAN>
y la palabra vacía está en alguno de los conjuntos
<!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN>. ¿Que hacer entonces? 

<P>
Nótese que si <!-- MATH
 $A \rightarrow \gamma$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$ A \rightarrow \gamma$"></SPAN> y <!-- MATH
 $\epsilon \in FIRST(\gamma)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="117" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$ \epsilon \in FIRST(\gamma)$"></SPAN> es porque existe una derivación
<!-- MATH
 $\gamma \stackrel{*}{\Longrightarrow} \epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="60" HEIGHT="45" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$ \gamma \stackrel{*}{\Longrightarrow} \epsilon$"></SPAN>. ¿Que terminales podemos 
legalmente encontrarnos cuando estamos en la subrutina <code>A</code>?
Consideremos una derivación desde el símbolo de arranque en la que se 
use la producción <!-- MATH
 $A \rightarrow \gamma$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$ A \rightarrow \gamma$"></SPAN>. Dicha derivación forzosamente
tendrá la forma:

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $S \stackrel{*}{\Longrightarrow} \beta A\ a \mu \Longrightarrow \beta \gamma\ a \mu \stackrel{*}{\Longrightarrow} \beta\ a \mu$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="262" HEIGHT="45" ALIGN="MIDDLE" BORDER="0"
 SRC="img63.png"
 ALT="$ S \stackrel{*}{\Longrightarrow} \beta A\ a \mu \Longrightarrow \beta \gamma\ a \mu \stackrel{*}{\Longrightarrow} \beta\ a \mu$"></SPAN>.

</DIV>

<P>
Cualquier terminal <!-- MATH
 $a \in \Sigma$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img64.png"
 ALT="$ a \in \Sigma$"></SPAN> que pueda aparecer en una derivación desde 
el símbolo de arranque inmediatamente a continuación  de la variable <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> 
es susceptible de ser visto
cuando se esta analizando <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> y se aplicó 
<!-- MATH
 $A \rightarrow \gamma$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$ A \rightarrow \gamma$"></SPAN> con <!-- MATH
 $\gamma \stackrel{*}{\Longrightarrow} \epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="60" HEIGHT="45" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$ \gamma \stackrel{*}{\Longrightarrow} \epsilon$"></SPAN>.
Esto nos lleva a la definición del conjunto <SPAN CLASS="MATH"><IMG
 WIDTH="115" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.png"
 ALT="$ FOLLOW(A)$"></SPAN> como conjunto
de terminales que pueden aparecer a continuación de <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> en una derivación 
desde el símbolo de arranque:

<P>
<P>
<DIV><B>Definición  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>Dada una gramática <!-- MATH
 $G=(\Sigma,V,P,S)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$ G =(\Sigma,V,P,S)$"></SPAN> y una variable <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ A \in V$"></SPAN> 
se define el conjunto <SPAN CLASS="MATH"><IMG
 WIDTH="115" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.png"
 ALT="$ FOLLOW(A)$"></SPAN> como: 
</I>
<P>
<I><!-- MATH
 $FOLLOW(A) = \left \{ b \in \Sigma :  \exists\ S  \stackrel{*}{\Longrightarrow}  \alpha A b \beta \right \} \cup E(A)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="385" HEIGHT="50" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$ FOLLOW(A) = \left \{ b \in \Sigma : \exists S \stackrel{*}{\Longrightarrow} \alpha A b \beta \right \} \cup E(A)$"></SPAN>
</I>
<P>
<I>donde
</I>
<P>
<I><!-- MATH
 $E(A) = \left \{ \begin{array}{ll}
                         \{ \$  \}& \mbox{si $S \stackrel{*}{\Longrightarrow} \alpha A$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right.$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="234" HEIGHT="63" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$ E(A) = \left \{ \begin{array}{ll}
\{ \$ \}&amp; \mbox{si $S \stackrel{*}{\Longrightarrow} \alpha A$} \\
\emptyset &amp; \mbox{en otro caso}
\end{array} \right. $"></SPAN> 
</I>
<P></DIV><P></P>
Aqui <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.png"
 ALT="$ \$$"></SPAN> denota el final de la entrada (que se corresponde en el código Perl anterior 
con el terminal <code>EOI</code>).

<P>
Si <!-- MATH
 $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="129" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$ A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$"></SPAN> dado que los conjuntos <!-- MATH
 $FIRST(\gamma_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$ FIRST(\gamma_i)$"></SPAN> 
han de ser disjuntos para que un analizador predictivo APDR funcione, sólo una parte derecha
puede contener la palabra vacía en su <SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ FIRST$"></SPAN>. Supongamos que es <SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$ \gamma_n$"></SPAN>.
Podemos reformular la construcción del procedimiento para la variable <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> siguiendo
este seudocódigo:

<P>
<PRE>
sub A {
  if ($lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  elsif ($lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else ($lookahead in FIRST(gamma_n) or $lookahead in FOLLOW(A)) { imitar gamma_n }
}
</PRE>

<P>
Un caso particular de <!-- MATH
 $\gamma_n \stackrel{*}{\Longrightarrow} \epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="68" HEIGHT="45" ALIGN="MIDDLE" BORDER="0"
 SRC="img70.png"
 ALT="$ \gamma_n \stackrel{*}{\Longrightarrow} \epsilon$"></SPAN> 
es que <!-- MATH
 $\gamma_n = \epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$ \gamma_n = \epsilon$"></SPAN>. En tal caso, y como
es obvio, el significado de <code>imitar gamma_n</code> 
es equivalente a ejecutar una sentencia vacía.

<P>

<H2><A NAME="SECTION04325000000000000000">
Construcción de los conjuntos de Primeros y Siguientes</A>
</H2>

<P>
<P>
<DIV><B>Algoritmo  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Construcción de los conjuntos <SPAN CLASS="MATH"><IMG
 WIDTH="94" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$ FIRST(X)$"></SPAN>
</I>
<P>
<I>Repita el siguiente conjunto de reglas hasta que no se puedan añadir mas símbolos terminales o  a ningún conjunto <SPAN CLASS="MATH"><IMG
 WIDTH="94" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$ FIRST(X)$"></SPAN>:
</I>
<OL>
<LI><!-- MATH
 $Si\ X \in \Sigma\ entonces\ FIRST(X) = {X}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="286" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img73.png"
 ALT="$ Si X \in \Sigma entonces FIRST(X) = {X}$"></SPAN>
</LI>
<LI><!-- MATH
 $Si\ X \rightarrow \epsilon\ entonces\ FIRST(X) =  FIRST(X) \cup \{ \epsilon \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="404" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img74.png"
 ALT="$ Si X \rightarrow \epsilon entonces FIRST(X) = FIRST(X) \cup \{ \epsilon \}$"></SPAN>
</LI>
<LI><!-- MATH
 $Si X \in V \ y\ X \rightarrow Y_1 Y_2 \cdots Y_k \in P\ entonces$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="325" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img75.png"
 ALT="$ Si X \in V  y X \rightarrow Y_1 Y_2 \cdots Y_k \in P entonces$"></SPAN>
<BR>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray}
&&i = 1; \nonumber\\
&&hacer \nonumber\\
&&\ \ FIRST(X) = FIRST(X) \cup FIRST^*(Y_i); \nonumber\\
&&\ \ i++; \nonumber\\
&&mientras\ (i \leq k\ y\ \epsilon \in FIRST(Y_i)) \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="48" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="$\displaystyle i = 1;$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="48" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img77.png"
 ALT="$\displaystyle hacer$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="340" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$\displaystyle \ \ FIRST(X) = FIRST(X) \cup FIRST^*(Y_i);$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="62" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$\displaystyle   i++;$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="273" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img80.png"
 ALT="$\displaystyle mientras\ (i \leq k\ y\ \epsilon \in FIRST(Y_i))$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL">

</LI>
<LI>Añadir <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="$ \epsilon$"></SPAN> a <SPAN CLASS="MATH"><IMG
 WIDTH="94" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$ FIRST(X)$"></SPAN> si <SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$ i \geq k$"></SPAN> y <!-- MATH
 $\epsilon \in FIRST(Y_k)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="125" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$ \epsilon \in FIRST(Y_k)$"></SPAN>
</LI>
</OL></DIV><P></P>
Aqui <!-- MATH
 $FIRST^*(Y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.png"
 ALT="$ FIRST^*(Y)$"></SPAN> denota al conjunto <!-- MATH
 $FIRST(Y) - \{ \epsilon \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="138" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$ FIRST(Y) - \{ \epsilon \}$"></SPAN>.

<P>
Este algoritmo puede ser extendido para calcular 
<!-- MATH
 $FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ FIRST(\alpha)$"></SPAN> para <!-- MATH
 $\alpha = X_1 X_2 \cdots X_n \in (V \cup \Sigma)^*$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="221" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$ \alpha = X_1 X_2 \cdots X_n \in (V \cup \Sigma)^*$"></SPAN>.
El esquema es anólogo al de un símbolo individual.

<P>
<P>
<DIV><B>Algoritmo  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>Construcción del conjunto <!-- MATH
 $FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ FIRST(\alpha)$"></SPAN> 
</I>
<P>
<I>Repita siguiente conjunto de reglas hasta que no se puedan añadir mas
símbolos terminales o  a ningún conjunto <!-- MATH
 $FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ FIRST(\alpha)$"></SPAN>:
</I>
<BR>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray}
&&i = 1; \nonumber\\
&&FIRST(\alpha) = \emptyset; \nonumber\\
&&hacer \nonumber\\
&&\ \ FIRST(\alpha) = FIRST(\alpha) \cup FIRST^*(X_i); \nonumber\\
&&\ \ i++; \nonumber\\
&&mientras\ (i \leq n\ y\ \epsilon \in FIRST(X_i)) \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="48" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="$\displaystyle i = 1;$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="127" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$\displaystyle FIRST(\alpha) = \emptyset;$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="48" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img77.png"
 ALT="$\displaystyle hacer$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="335" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$\displaystyle \ \ FIRST(\alpha) = FIRST(\alpha) \cup FIRST^*(X_i);$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="62" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$\displaystyle   i++;$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP WIDTH="50%" ALIGN="RIGHT">&nbsp;</TD>
<TD>&nbsp;</TD>
<TD ALIGN="LEFT" NOWRAP WIDTH="50%"><IMG
 WIDTH="279" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img88.png"
 ALT="$\displaystyle mientras\ (i \leq n\ y\ \epsilon \in FIRST(X_i))$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"></DIV><P></P>

<P>
<P>
<DIV><B>Algoritmo  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>Construcción de los conjuntos <!-- MATH
 $FOLLOW(A)\ \forall A \in V$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="179" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img89.png"
 ALT="$ FOLLOW(A)\ \forall A \in V$"></SPAN>: 
</I>
<P>
<I>Repetir los siguientes pasos hasta que ninguno de los conjuntos <SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$ FOLLOW$"></SPAN> cambie:
</I>
 
<OL>
<LI><!-- MATH
 $FOLLOW(S) = \{\$\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="163" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$ FOLLOW(S) = \{\$\} $"></SPAN> (<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.png"
 ALT="$ \$$"></SPAN> representa el final de la entrada)
</LI>
<LI><!-- MATH
 $Si\ A \rightarrow \alpha B \beta\ entonces$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="178" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img91.png"
 ALT="$ Si A \rightarrow \alpha B \beta entonces$"></SPAN>
<P><!-- MATH
 \begin{displaymath}
FOLLOW(B) =  FOLLOW(B) \cup (FIRST(\beta) - \{\epsilon\})
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<IMG
 WIDTH="414" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.png"
 ALT="$\displaystyle FOLLOW(B) = FOLLOW(B) \cup (FIRST(\beta) - \{\epsilon\})$">
</DIV><P></P>
</LI>
<LI><!-- MATH
 $Si\ A \rightarrow \alpha B\ o\ A \rightarrow \alpha B \beta\ y\ \epsilon \in FIRST(\beta)\  entonces$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="397" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img93.png"
 ALT="$ Si\ A \rightarrow \alpha B\ o\ A \rightarrow \alpha B \beta\ y\ \epsilon \in FIRST(\beta)\ entonces$"></SPAN>
<P><!-- MATH
 \begin{displaymath}
FOLLOW(B) = FOLLOW(B) \cup FOLLOW(A)
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<IMG
 WIDTH="381" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.png"
 ALT="$\displaystyle FOLLOW(B) = FOLLOW(B) \cup FOLLOW(A)$">
</DIV><P></P>
</LI>
</OL></DIV><P></P>

<P>

<H2><A NAME="SECTION04326000000000000000">
Ejercicio: Construir los <SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ FIRST$"></SPAN></A>
</H2>
   <A NAME="3914"></A>
  
Construya los conjuntos <SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ FIRST$"></SPAN> de las partes derechas de las reglas de 
producción de la gramática presentada en el ejercicio <A HREF="node38.html#ejercicio:tutugrammar">4.1.1</A>.

<P>

<H2><A NAME="SECTION04327000000000000000">
Ejercicio: Calcular los <SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$ FOLLOW$"></SPAN></A>
</H2>
   <A NAME="3916"></A>
  
Modificamos la gramática de la sección 
<A HREF="#subsection:introduccion">3.2.1</A>
para que admita la sentencia vacía:

<P>
<BR>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">statements   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> statement  ';'  statements        <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> statement</TD>
</TR>
<TR><TD ALIGN="LEFT">statement    <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> ID '=' expression                 <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> P  expression <!-- MATH
 $|\ \epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img95.png"
 ALT="$ \vert\ \epsilon$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">expression   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> term '+' expression               <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> term</TD>
</TR>
<TR><TD ALIGN="LEFT">term         <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> factor '*' term                   <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> factor</TD>
</TR>
<TR><TD ALIGN="LEFT">factor       <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> '(' expression ')' <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> ID <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> NUM</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Calcule los conjuntos <SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$ FOLLOW$"></SPAN>. ¿Es la nueva gramática susceptible
de ser analizada por un analizador predictivo descendente recursivo?
¿Cómo sería el código para la subrutina <code>statements</code>?. Escríbalo.

<P>

<H2><A NAME="SECTION04328000000000000000"></A>
   <A NAME="3918"></A>
  
<A NAME="practica:firstandfollow"></A>
<BR>
Práctica: Construcción de los FIRST y los FOLLOW
</H2>
He escrito un módulo llamado 
<A NAME="tex2html145"
  HREF="Grammar-0.02.tar.gz">Grammar</A>
que provee la función
<code>Grammar::Parse</code> la cual recibe una cadena conteniendo la
gramática en formato <code>yacc</code> o <code>eyapp</code> y devuelve una referencia a un
hash conteniendo la información pertinente para el tratamiento de 
la gramática. 
Para instalar el módulo tenga en cuenta que depende del módulo <code>Parse::Yapp</code>.

<P>
Para ilustrar el uso vea los ejemplos en el directorio <code>scripts</code>.
En concreto veamos el programa <code>grammar.pl</code>.
<PRE>
Grammar/scripts$ cat -n grammar.pl
 1  #!/usr/bin/perl -w -I../lib
 2  use strict;
 3  use Grammar;
 4  use Data::Dumper;
 5
 6  sub usage {
 7    print &lt;&lt;"EOI";
 8  usage:
 9  $0 input_grammar
10  EOI
11    die "\n";
12  }
13
14  usage() unless @ARGV;
15  my $filename = shift;
16
17  local $/ = undef;
18  open my $FILE, "$filename";
19  my $grammar = &lt;$FILE&gt;;
20  my $x = Grammar::Parse($grammar);
21
22  print Dumper($x);
</PRE>
Vamos a darle como entrada la gramática en el fichero <code>aSb.yp</code>
conteniendo una gramática:
<PRE>
Grammar/scripts$ cat -n aSb.yp
 1  %%
 2  S:
 3      |   'a' S 'b'
 4  ;
 5  %%
</PRE>

<P>
Las gramáticas aceptadas por <code>Grammar::Parse</code> se adaptan a la sintáxis de
las gramáticas reconocidas por <code>Parse::Yapp</code>.
Una gramática (normalmente con tipo  <code>.yp</code>) consta de tres partes: la cabeza, el cuerpo
y la cola. Cada una de las partes va separada de las otras por el
símbolo <code>%%</code> en una línea aparte. Así, el <code>%%</code> de la línea 1
separa la cabeza del cuerpo. En la cabecera se colocan 
las declaraciones de terminales (directiva <code>%token</code>), 
cual es el símbolo de arranque (directiva <code>%start</code>), etc.
El cuerpo contiene las reglas de la gramática y
las acciones asociadas. Por último, la cola  en nuestro caso no es
usada y es vacía. En general, la cola 
contiene las rutinas de soporte al código que aparece en las acciones 
asi como, posiblemente, rutinas para el análisis léxico 
y el tratamiento de errores. 

<P>
La salida de <code>Grammar::Parse</code> es una referencia a un hash cuyas entradas
vienen explicadas por los comentarios.
<PRE>
Grammar/scripts$ grammar.pl aSb.yp
$VAR1 = {
    'SYMS' =&gt; { 'S' =&gt; 2, '"b"' =&gt; 3, '"a"' =&gt; 3 }, # Símbolo =&gt; línea
    'NULL' =&gt; { 'S' =&gt; 1 }, # símbolos que se anulan
    'RULES' =&gt; [
                 [ 'S', [] ], # S produce vacío
                 [ 'S', [ '"a"', 'S', '"b"' ] ] # S -&gt; aSb
               ],
    'START' =&gt; 'S', # Símbolo de arranque
    'TERM' =&gt; [ '"b"', '"a"' ], # terminales /tokens
    'NTERM' =&gt; { 'S' =&gt; [ 0, 1 ] }  # índices de las reglas de las variables sintácticas
  };
</PRE>
Usando la estructura devuelta por la función <code>Grammar::Parse</code> escriba un módulo
que provea funciones para computar los <code>FIRST</code> y los <code>FOLLOW</code> de las variables
sintácticas de la gramática. No olvide escribir la documentación. 
Incluya una prueba por cada una de las gramáticas que figuran en el directorio <code>scripts</code>
del módulo <code>Grammar</code>.

<P>
Puede encontrar la práctica <SPAN  CLASS="textbf">casi hecha</SPAN> en
<A NAME="tex2html146"
  HREF="PL-FirstFollow-0.02.tar.gz">PL::FirstFollow</A>.
Asegúrese de entender el algoritmo usado.
Aumente el número de pruebas y haga un análisis de cubrimiento.

<P>

<H2><A NAME="SECTION04329000000000000000">
Gramáticas LL(1)</A>
</H2>
Una gramática <!-- MATH
 $G = (\Sigma, V, P, S)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$ G =(\Sigma,V,P,S)$"></SPAN> cuyo lenguaje generado 
<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$ L(G)$"></SPAN> puede ser analizado por un 
analizador sintáctico descendente recursivo predictivo
se denomina <A NAME="3919"></A><SPAN  CLASS="textbf">LL(1)</SPAN>. Una gramática es LL(1) si y sólo si 
para cualesquiera dos
producciones <!-- MATH
 $A \rightarrow \alpha$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$ A \rightarrow \alpha$"></SPAN> y <!-- MATH
 $A \rightarrow \beta$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img96.png"
 ALT="$ A \rightarrow \beta$"></SPAN> de
<SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="$ G$"></SPAN> se cumple:

<OL>
<LI><!-- MATH
 $FIRST(\alpha) \cap FIRST(\beta) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="226" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$ FIRST(\alpha) \cap FIRST(\beta) = \emptyset$"></SPAN>
</LI>
<LI>Si <!-- MATH
 $\epsilon \in FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="118" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.png"
 ALT="$ \epsilon \in FIRST(\alpha)$"></SPAN>, entonces <!-- MATH
 $FIRST(\alpha) \cap FOLLOW(A) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="252" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.png"
 ALT="$ FIRST(\alpha) \cap FOLLOW(A) = \emptyset$"></SPAN>
</LI>
</OL>

<P>
¿De donde viene el nombre LL(1)? La primera L hace alusión al hecho de que 
el flujo de terminales se lee de izquierda a derecha, accediendo a la entrada
por su izquierda (<SPAN  CLASS="textbf">Left</SPAN>). La segunda L se refiere a que el método
de análisis predictivo construye una derivación a izquierdas. El número
entre paréntesis indica el número de terminales que debemos consultar para
decidir que regla de producción se aplica. Asi, en una gramática LL(2) la decisión 
final de que producción elegir se hace consultando los dos terminales a la entrada.

<P>

<H2><A NAME="SECTION043210000000000000000"></A>
   <A NAME="3922"></A>
<BR>
Ejercicio: Caracterización de una gramática LL(1) 
</H2>
  
Cuando se dice que una gramática es LL(1) si, y sólo si:

<OL>
<LI><!-- MATH
 $FIRST(\alpha) \cap FIRST(\beta) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="226" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$ FIRST(\alpha) \cap FIRST(\beta) = \emptyset$"></SPAN>
</LI>
<LI>Si <!-- MATH
 $\epsilon \in FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="118" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.png"
 ALT="$ \epsilon \in FIRST(\alpha)$"></SPAN>, entonces <!-- MATH
 $FIRST(\alpha) \cap FOLLOW(A) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="252" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.png"
 ALT="$ FIRST(\alpha) \cap FOLLOW(A) = \emptyset$"></SPAN>
</LI>
</OL>
se asume que los conjuntos <!-- MATH
 $FIRST(\alpha)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ FIRST(\alpha)$"></SPAN> no son vacíos.

<UL>
<LI>¿Que se puede decir de la regla  <!-- MATH
 $A \rightarrow \alpha$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$ A \rightarrow \alpha$"></SPAN> si
<!-- MATH
 $FIRST(\alpha) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="122" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.png"
 ALT="$ FIRST(\alpha) = \emptyset$"></SPAN>?
</LI>
<LI>¿Que se puede decir de la variable <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$ A$"></SPAN> si <!-- MATH
 $FOLLOW(A) = \emptyset$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="147" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img101.png"
 ALT="$ FOLLOW(A) = \emptyset$"></SPAN>?
</LI>
</UL>

<P>

<H2><A NAME="SECTION043211000000000000000"></A>
   <A NAME="3924"></A>
<BR>
Ejercicio: Ambiguedad y LL(1)
</H2>
  
¿Puede una gramática LL(1) ser ambigua?.
Razone su respuesta.

<P>

<H2><A NAME="SECTION043212000000000000000"></A>
   <A NAME="3926"></A>
  
<A NAME="practica:APDR"></A>
<BR>
Práctica: Un analizador APDR
</H2>

<P>
Siguiendo con la construcción del compilador para el lenguaje Tutu, escriba un 
analizador APDR para la siguiente gramática. Reutilice el código de las
prácticas de las secciones anteriores 
(<A HREF="node63.html#section:analisislexico"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
y
<A HREF="node64.html#section:lexicomodular"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>).

<P>
<BR>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">program      <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> declarations  statements         <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> statements</TD>
</TR>
<TR><TD ALIGN="LEFT">declarations <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> declaration  ';'  declarations    <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> declaration ';'</TD>
</TR>
<TR><TD ALIGN="LEFT">declaration  <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> INT  idlist                       <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> STRING   idlist</TD>
</TR>
<TR><TD ALIGN="LEFT">statements   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> statement  ';'  statements        <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> statement</TD>
</TR>
<TR><TD ALIGN="LEFT">statement    <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> ID '=' expression                 <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> P  expression <!-- MATH
 $|\ \epsilon$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img95.png"
 ALT="$ \vert\ \epsilon$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">expression   <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> term '+' expression               <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> term</TD>
</TR>
<TR><TD ALIGN="LEFT">term         <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> factor '*' term                   <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> factor</TD>
</TR>
<TR><TD ALIGN="LEFT">factor       <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> '(' expression ')' <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> ID <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> NUM <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> STR</TD>
</TR>
<TR><TD ALIGN="LEFT">idlist       <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ \rightarrow$"></SPAN> ID ',' idlist <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ \vert$"></SPAN> ID</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>

<H2><A NAME="SECTION043213000000000000000"></A>
   <A NAME="3928"></A>
  
<A NAME="practica:GAP"></A>
<BR>
Práctica: Generación Automática de Analizadores Predictivos
</H2>

<P>

<H4><A NAME="SECTION043213010000000000000">
Objetivo</A>
</H4>
Escriba un módulo <code>GAP.pm</code> que provea una subrutina <code>gap</code> para
la generación automática de un APDR supuesto que la gramática de entrada es 
LL(1). 

<P>
La subrutina <code>gap</code> recibe como entrada la gramática según la estructura de
datos generada  por la función <code>Grammar::Parse</code> de la versión 0.3 del módulo
<A NAME="tex2html147"
  HREF="Grammar-0.03.tar.gz">Grammar</A>. 

<P>

<H4><A NAME="SECTION043213020000000000000">
El Módulo <TT>Grammar</TT></A>
</H4>

<P>
La estructura de datos generada  por la función <code>Grammar::Parse</code>
se explicó en la práctica  
<A HREF="#practica:firstandfollow">3.2.8</A>.
La estructura ha sido extendida
en esta versión para incluir el código que se sitúe en la zona de cola.
Por ejemplo, dada la gramática de entrada:

<P>
<PRE>
  Grammar/03/scripts$ cat -n aSb.yp
       1  %%
       2  S:
       3      |   'a' S 'b'
       4  ;
       5  %%
       6
       7  sub Lex {
       8    local $_ = shift; # input
       9    my @tokens;
      10
      11
      12    while ($_) {
      13      s/^\s*//; # fuera blancos
      14      push @tokens, $1, $1 if s/^(.)//s
      15    }
      16    @tokens;
      17  }
      18
      19  sub main {
      20    my $filename = shift;
      21    my $input;
      22
      23    if (defined($filename)) {
      24      local $/ = undef;
      25      open my $FILE, $filename or die "No se pudo abrir $filename\n";
      26      $input = &lt;$FILE&gt;;
      27      close($FILE);
      28    }
      29    else { $input = &lt;STDIN&gt; }
      30
      31    my @tokens = Lex($input);
      32    Parse(@tokens); # Llamada al analizador generado
      33    print "Sintácticamente correcto\n";
      34  }
</PRE>
se genera la siguiente estructura de datos:
<PRE>
{
  'SYMS' =&gt; { 'S' =&gt; 2, 'b' =&gt; 3, 'a' =&gt; 3 },  # Símbolo =&gt; línea de aparición
  'NULL' =&gt; { 'S' =&gt; 1 }, # Símbolos que se anulan
  'RULES' =&gt; [ # Reglas 
               [ 'S', [] ], # S produce vacío
               [ 'S', [ 'a', 'S', 'b' ] ] # S-&gt; a S b
             ],
  'START' =&gt; 'S', # Símbolo de arranque
  'TERM' =&gt; [ 'b', 'a' ], # Terminales
  'NTERM' =&gt; { 'S' =&gt; [ 0, 1 ] } # Variables sintácticas e índices de las reglas de esa variable
  'TAIL' =&gt; [ # [ 'Código de cola', línea en la que está el segundo %% ]
  '

  sub Lex {
    local $_ = shift; # input
    my @tokens;


    while ($_) {
      s/^\\s*//; # fuera blancos
      push @tokens, $1, $1 if s/^(.)//s
    }
    @tokens;
  }

  sub main {
    my $filename = shift;
    my $input;

    if (defined($filename)) {
      local $/ = undef;
      open my $FILE, $filename or die "No se pudo abrir $filename\\n";
      $input = &lt;$FILE&gt;;
      close($FILE);
    }
    else { $input = &lt;STDIN&gt; }

    my @tokens = Lex($input);
    my $ok = Parse(@tokens); # Llamada al analizador generado
    print "Sintácticamente correcto\\n" if $ok;
  }

  ', 5 ], # línea en la que está el segundo %%
 };
</PRE>

<P>
Asi pues la entrada con clave <code>TAIL</code> contiene el código auxiliar de
cola. Este código debe ser incluido por su programa dentro del texto del
paquete generado por <code>gap</code>.

<P>

<H4><A NAME="SECTION043213030000000000000">
Descripción del objetivo: La función <TT>gap</TT></A>
</H4>

<P>
La función <code>gap</code> también recibe como entrada el nombre 
del package:
<PRE>
$package_text = &amp;gap($grammar, 'Package_name');
</PRE>
La función <code>gap</code> retorna
una cadena conteniendo el <code>package</code> en el que estan las subrutinas del
analizador sintáctico. 

<P>
La idea es que dicha cadena se salvará en un fichero
con nombre <code>Package_name.pm</code> que podrá posteriormente ser usado 
(<code>use Package_name</code>) por un programa que necesite analizar entradas
que se conforman de acuerdo a la especificación de la gramática.

<P>

<H4><A NAME="SECTION043213040000000000000">
Descripción del objetivo: La función <TT>parser</TT></A>
</H4>
La rutina principal del paquete generado se ha de llamar
<code>parser</code> (esto es, su nombre completo es: <code>Package_name::parser</code>. 
Evidentemente <code>Package_name</code> debe ser un nombre Perl válido).
Ninguna subrutina deberá ser exportada sino que deberán ser llamadas
por su nombre completo.

<P>
La subrutina <code>parser</code> recibe como argumento el array de 
terminales, obtiene el primer terminal y llama a la subrutina
asociada con el símbolo de arranque. Los terminales están representados
como parejas <!-- MATH
 $(terminal, atributo)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="157" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img102.png"
 ALT="$ (terminal, atributo)$"></SPAN>.

<P>
Observe que, una vez que la cadena <code>$package_text</code> conteniendo el paquete ha sido 
generada y salvada en un fichero con nombre <code>Package_name.pm</code>, podemos escribir
un programa cliente:

<P>
<PRE>
use strict;
use Package_name;

&amp;Package_name::main;
</PRE>

<P>
Este programa espera una entrada desde fichero o <code>STDIN</code> e
informa si dicha entrada es sintácticamente correcta o no
para la gramática en cuestión.

<P>

<H4><A NAME="SECTION043213050000000000000">
Cálculo de los First y los Follow con <TT>PL::FirstFollow</TT></A>
</H4>

<P>
Para facilitar la escritura de <code>GAP.pm</code> pueden hacer uso 
del módulo <A NAME="tex2html148"
  HREF="PL-FirstFollow-0.02.tar.gz">PL::FirstFollow</A>
el cual calcula los <SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ FIRST$"></SPAN> y los <SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$ FOLLOW$"></SPAN>. El módulo  <TT>PL::FirstFollow</TT> 
depende de 
<A NAME="tex2html149"
  HREF="http://search.cpan.org/~jhi/Set-Scalar-1.20/lib/Set/Scalar.pm">Set::Scalar</A>
escrito por 
<A NAME="tex2html150"
  HREF="http://search.cpan.org/~jhi/">Jarkko Hietaniemi</A>: instálelo primero.

<P>
Deberá familiarizarse con <TT>PL::FirstFollow</TT>, rellenar la
documentación de todas las subrutinas (apariciones de <code>????</code> en el texto)
y escribir la documentación siguiendo el template que se provee. 
<SPAN  CLASS="textbf">Rellene los fragmentos de código que se han sustituido por 
signos de interrogación</SPAN>.
Haga un estudio de cubrimiento
y añada pruebas para mejorar el actual. El actual cubrimiento es:
<PRE>
---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...ammar-0.03/lib/Grammar.pm  100.0    n/a    n/a  100.0    0.0   75.3   97.2
blib/lib/PL/FirstFollow.pm    100.0   92.9   50.0  100.0    0.0   24.7   95.1
Total                         100.0   92.9   50.0  100.0    0.0  100.0   95.5
---------------------------- ------ ------ ------ ------ ------ ------ ------
</PRE>
Si observa un fallo en  <TT>PL::FirstFollow</TT>  háganoslo saber y
además de resolverlo escriba una prueba para detectar el fallo.

<P>
Haga un estudio de profiling de su aplicación.

<H4><A NAME="SECTION043213060000000000000">
Uso de Templates</A>
</H4>

<P>
Un módulo que puede facilitar la escritura de esta práctica 
es 
<A NAME="tex2html151"
  HREF="http://search.cpan.org/~mjd/Text-Template-1.44/lib/Text/Template.pm">Text::Template</A>
debido a 
<A NAME="tex2html152"
  HREF="http://search.cpan.org/~mjd/">Mark Jason Dominus</A>.
El siguiente ejemplo de uso es un fragmento de  un traductor - que nunca acabo de terminar
- que toma con fuente 
un fichero en el formato que usa Moodle para los cuestionarios (conocido como 
formato GIFT) y lo convierte en un cuestionario <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN>:

<P>
<PRE>
lhp@nereida:~/projects/Gift2LaTeX/Gift2LaTeX/lib$ cat -n Gift2LaTeX.pm
   1  package Gift2LaTeX;
   2
   3  use strict;
   4  use warnings;
   5  use Gift;
   6  use Text::Template;
   7  use HTML::Latex;
  ..    ......................................................
  49  package Gift::TRUEFALSE; # True-false questions belong to this class
  50
  51  { # closure
  52
  53    die "Can't find $TEMPLATE_DIR/TRUEFALSE_question.tep\n"
  54          unless -e "$TEMPLATE_DIR/TRUEFALSE_question.tep";
  55    my $tfq_tmpl = Text::Template-&gt;new( #tfq = true-false question
  56      DELIMITERS =&gt; ['%&lt;', '%&gt;'];
  57      SOURCE =&gt; "$TEMPLATE_DIR/TRUEFALSE_question.tep",
  58    );
  ..    ......................................................
  67    sub gen_latex {
  68      my $self = shift;
  69
  70      ########## Generate latex for question
  71      my $prefix  = $self-&gt;PREFIX;
  72
  73      my $sufix = $self-&gt;POSTSTATE;
  74
  75      $self-&gt;Error("Only HTML and PLAIN formats are supported\n")
  76          unless (!$self-&gt;FORMAT or ($self-&gt;FORMAT =~ m{html|plain}i));
  77
  78      my ($prefix_tex, $sufix_tex);
  79      if (defined($self-&gt;FORMAT) and $self-&gt;FORMAT =~ m{plain}i) {
  80        $prefix_tex = $prefix;
  81        $sufix_tex  = $sufix;
  82      }
  83      else { # HTML by default
  ..    ......................................................
  86      }
  87      my $params = {
  88        prefix  =&gt; $prefix_tex,
  89        sufix   =&gt; $sufix_tex,
  90        separator =&gt; $separator,
  91        label   =&gt; $label_prefix.$question_number,
  92        question_number =&gt; $question_number
  93      };
  94      my $question_tex = $tfq_tmpl-&gt;fill_in(HASH =&gt; $params);
  96      ########## Generate latex for answer
 ...      ....................................
 101    }
 102  }
</PRE>
En la línea 55 se crea el template. El template se lee desde el fichero
<code>"$TEMPLATE_DIR/TRUEFALSE_question.tep"</code> cuyo contenido es una mezcla
de texto (en este caso texto <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> y HTML) con código Perl:
El código Perl aparece acotado entre los delimitadores <code>'%&lt;'</code>
y <code>'%&gt;'</code>.

<P>
<PRE>
lhp@nereida:~/projects/Gift2LaTeX/Gift2LaTeX/etc/en$ cat -n TRUEFALSE_question.tep
 1  \ begin{latexonly}
 2    %&lt;$separator%&gt;
 3    \ label{question:%&lt;$label%&gt;}
 4    %&lt;$prefix%&gt;
 5
 6    \ begin{center}
 7      \ begin{tabular}{llll}
 8          $\ bigcirc$ &amp; TRUE &amp; $\ bigcirc$ &amp; FALSE
 9      \ end{tabular}
10
11      \noindent %&lt;$sufix%&gt;
12    \ end{center}
13  \ end{latexonly}
14
15  \ begin{htmlonly}
16  %&lt;$separator%&gt;
17  \ label{question:%&lt;$label%&gt;}
18  %&lt;$prefix%&gt;
19
20  \ begin{center}
21    \ begin{tabular}{llll}
22        \ htmlref{$\bigcirc$}{answer:%&lt;$label%&gt;} &amp; TRUE &amp;
23        \ htmlref{$\bigcirc$}{answer:%&lt;$label%&gt;} &amp; FALSE
24    \ end{tabular}
25
26    \ noindent %&lt;$sufix%&gt;
27  \ end{center}
28  \ end{htmlonly}
</PRE>

<P>
El template se rellena en las líneas 87-94. En esa llamada
se ejecuta el código Perl incrustado en el esqueleto
y su resultado se inserta en la posición que ocupa en el texto.

<P>

<H4><A NAME="SECTION043213070000000000000">
Concatenación y Documentos <TT>HERE</TT></A>
</H4>
Cuando concatene sangre adecuadamente las concatenaciones:
<PRE>
my $usage = "Usage: $0 &lt;file&gt; [-full] [-o] [-beans]\n"
            . "Options:\n"
            . "    -full  : produce a full dump\n"
            . "    -o     : dump in octal\n"
            . "    -beans : source is Java\n"
            ;
</PRE>
ponga el punto al principio de la siguiente línea, no al final.

<P>
Pero cuando el número de líneas es grande 
es mejor
usar un <A NAME="3931"></A><SPAN  CLASS="textbf">here document</SPAN>
o <A NAME="3933"></A><SPAN  CLASS="textbf">documento aqui</SPAN>. Veamos un ejemplo:
<PRE>
print &lt;&lt;"EOI";
El programa se deberá ejecutar con:

$0 numfiles $opciones initialvalue
EOI
</PRE>
Para definir un ``documento aqui'' 
se escribe la etiqueta entrecomillada y precedida de <code>&lt;&lt;</code> y 
sigue el texto que consituye el <SPAN  CLASS="textbf">here document</SPAN>
que se delimita por una línea en blanco que empieza por la etiqueta.
Al documento aquí se le trata como una cadena de doble comilla si
la etiqueta aparece en doble comilla y como de comilla simple
si la etiqueta esta  entre comillas simples.
Observe que el punto y coma se escribe despues 
de la primera aparición 
de la etiqueta.

<P>
Un problema con el uso de los heredoc es que rompen la estructura normal
del sangrado:
<PRE>
if ($usage_error) {
    warn &lt;&lt;'END_USAGE';
Usage: qdump &lt;file&gt; [-full] [-o] [-beans]
Options:
    -full  : produce a full dump
    -o     : dump in octal
    -beans : source is Java
END_USAGE
}
</PRE>
Es mejor que cada heredoc se aisle en una subrutina y se parametrice con
las variables que van a ser interpoladas:
<PRE>
sub build_usage {
    my ($prog_name, $file_name) = @_;

    return &lt;&lt;"END_USAGE";
Usage: $prog_name $file_name [-full] [-o] [-beans]
Options:
    -full  : produce a full dump
    -o     : dump in octal
    -beans : source is Java
END_USAGE
}
</PRE>

<P>
que mas tarde puede ser llamado con los valores de interpolación adecuados:

<P>
<PRE>
if ($usage_error) {
    warn build_usage($PROGRAM_NAME, $requested_file);
}
</PRE>
Véase  el libro de Conway  Perl Best Practices
[]
para mas detalles sobre buenas prácticas de programación con heredocs.

<P>

<H4><A NAME="SECTION043213080000000000000">
Descarga de los Módulos Necesarios</A>
</H4>

<UL>
<LI>El módulo  <TT>Grammar</TT> : 
<A NAME="tex2html153"
  HREF="http://nereida.deioc.ull.es/~pl/perlexamples/Grammar-0.03.tar.gz">http://nereida.deioc.ull.es/&#732;pl/perlexamples/Grammar-0.03.tar.gz</A>
<P>
</LI>
<LI>El módulo  <TT>PL::FirstFollow</TT> :
<A NAME="tex2html154"
  HREF="http://nereida.deioc.ull.es/~pl/perlexamples/PL-FirstFollow-0.02.tar.gz">http://nereida.deioc.ull.es/&#732;pl/perlexamples/PL-FirstFollow-0.02.tar.gz</A>
</LI>
</UL>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html1163"
  HREF="node24.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1157"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1151"
  HREF="node22.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1159"
  HREF="node86.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html1161"
  HREF="node89.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html9"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html1164"
  HREF="node24.html">Esquemas de Traducción</A>
<B>Sup:</B> <A NAME="tex2html1158"
  HREF="node21.html">Análisis Descendente mediante Parsing</A>
<B> Ant:</B> <A NAME="tex2html1152"
  HREF="node22.html">Conceptos Básicos para el</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-02-27</I>
</ADDRESS>
</BODY>
</HTML>
