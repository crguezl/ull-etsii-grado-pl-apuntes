<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Algunas Extensiones</TITLE>
<META NAME="description" CONTENT="Algunas Extensiones">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node24.html">
<LINK REL="previous" HREF="node22.html">
<LINK REL="up" HREF="node21.html">
<LINK REL="next" HREF="node24.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2059"
  HREF="node24.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2053"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2047"
  HREF="node22.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2055"
  HREF="node126.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2057"
  HREF="node129.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2060"
  HREF="node24.html">Unicode</A>
<B>Sup:</B> <A NAME="tex2html2054"
  HREF="node21.html">Expresiones Regulares en Perl</A>
<B> Ant:</B> <A NAME="tex2html2048"
  HREF="node22.html">Introducción</A>
<B> Con:</B> 
<A NAME="tex2html2055"
  HREF="node126.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html2057"
  HREF="node129.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2061"
  HREF="node23.html#SECTION04321000000000000000">Comentarios</A>
<LI><A NAME="tex2html2062"
  HREF="node23.html#SECTION04322000000000000000">Modificadores locales</A>
<LI><A NAME="tex2html2063"
  HREF="node23.html#SECTION04323000000000000000">Mirando hacia adetrás y hacia adelante</A>
<UL>
<LI><A NAME="tex2html2064"
  HREF="node23.html#SECTION04323010000000000000">Las zero-width assertions como caso particular de mirar atrás-adelante</A>
<LI><A NAME="tex2html2065"
  HREF="node23.html#SECTION04323020000000000000">Lookahead assertion</A>
<LI><A NAME="tex2html2066"
  HREF="node23.html#SECTION04323030000000000000">A hard RegEx problem</A>
<LI><A NAME="tex2html2067"
  HREF="node23.html#SECTION04323040000000000000">Los paréntesis looakehaed and lookbehind no capturan</A>
<LI><A NAME="tex2html2068"
  HREF="node23.html#SECTION04323050000000000000">Limitaciones del lookbehind</A>
<LI><A NAME="tex2html2069"
  HREF="node23.html#SECTION04323060000000000000">Negación de los operadores de lookahead y lookbehind</A>
<LI><A NAME="tex2html2070"
  HREF="node23.html#SECTION04323070000000000000">Ejemplo: split con lookahead y lookbehind</A>
<LI><A NAME="tex2html2071"
  HREF="node23.html#SECTION04323080000000000000">Look Around en perlre</A>
<LI><A NAME="tex2html2072"
  HREF="node23.html#SECTION04323090000000000000">Operador de predicción negativo: Última ocurrencia</A>
<LI><A NAME="tex2html2073"
  HREF="node23.html#SECTION043230100000000000000">Diferencias entre mirar adelante negativo y mirar adelante con clase negada</A>
<LI><A NAME="tex2html2074"
  HREF="node23.html#SECTION043230110000000000000">AND y AND NOT</A>
<LI><A NAME="tex2html2075"
  HREF="node23.html#SECTION043230120000000000000">Lookahead negativo versus lookbehind</A>
<LI><A NAME="tex2html2076"
  HREF="node23.html#SECTION043230130000000000000">Ejercicios</A>
</UL>
<BR>
<LI><A NAME="tex2html2077"
  HREF="node23.html#SECTION04324000000000000000">Definición de Nombres de Patrones</A>
<UL>
<LI><A NAME="tex2html2078"
  HREF="node23.html#SECTION04324010000000000000">Lo que dice <TT>perlretut</TT> sobre la definición de nombres de patrones</A>
<LI><A NAME="tex2html2079"
  HREF="node23.html#SECTION04324020000000000000">Lo que dice <TT>perlre</TT> sobre la definición de patrones</A>
<LI><A NAME="tex2html2080"
  HREF="node23.html#SECTION04324030000000000000">Lo que dice <TT>perlvar</TT> sobre patrones con nombre</A>
</UL>
<BR>
<LI><A NAME="tex2html2081"
  HREF="node23.html#SECTION04325000000000000000">Patrones Recursivos</A>
<UL>
<LI><A NAME="tex2html2082"
  HREF="node23.html#SECTION04325010000000000000">Palíndromos</A>
<LI><A NAME="tex2html2083"
  HREF="node23.html#SECTION04325020000000000000">Lo que dice <TT>perlre</TT> sobre recursividad</A>
<LI><A NAME="tex2html2084"
  HREF="node23.html#SECTION04325030000000000000">Paréntesis Equilibrados</A>
<LI><A NAME="tex2html2085"
  HREF="node23.html#SECTION04325040000000000000">Capturando los bloques de un programa</A>
<LI><A NAME="tex2html2086"
  HREF="node23.html#SECTION04325050000000000000">Reconocimiento de Lenguajes Recursivos: Un subconjunto de <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN></A>
<LI><A NAME="tex2html2087"
  HREF="node23.html#SECTION04325060000000000000">Reconocimiento de Expresiones Aritméticas</A>
</UL>
<BR>
<LI><A NAME="tex2html2088"
  HREF="node23.html#SECTION04326000000000000000">Cuantificadores Posesivos</A>
<UL>
<LI><A NAME="tex2html2089"
  HREF="node23.html#SECTION04326010000000000000">Cadenas Delimitadas por Comillas Dobles</A>
<LI><A NAME="tex2html2090"
  HREF="node23.html#SECTION04326020000000000000">Paréntesis Posesivos</A>
<LI><A NAME="tex2html2091"
  HREF="node23.html#SECTION04326030000000000000">Paréntesis Balanceados</A>
<LI><A NAME="tex2html2092"
  HREF="node23.html#SECTION04326040000000000000">Encontrando los bloques de un programa</A>
<LI><A NAME="tex2html2093"
  HREF="node23.html#SECTION04326050000000000000">Véase también</A>
</UL>
<BR>
<LI><A NAME="tex2html2094"
  HREF="node23.html#SECTION04327000000000000000">Perl 5.10: Numeración de los Grupos en Alternativas</A>
<LI><A NAME="tex2html2095"
  HREF="node23.html#SECTION04328000000000000000">Ejecución de Código dentro de una Expresión Regular</A>
<UL>
<LI><A NAME="tex2html2096"
  HREF="node23.html#SECTION04328010000000000000">Resultado de la última ejecución</A>
<LI><A NAME="tex2html2097"
  HREF="node23.html#SECTION04328020000000000000">El Código empotrado no es interpolado</A>
<LI><A NAME="tex2html2098"
  HREF="node23.html#SECTION04328030000000000000">Contenido del último paréntesis y la variable por defecto en acciones empotradas</A>
<LI><A NAME="tex2html2099"
  HREF="node23.html#SECTION04328040000000000000">Los cuantificadores y el código empotrado</A>
<LI><A NAME="tex2html2100"
  HREF="node23.html#SECTION04328050000000000000">Ámbito</A>
<LI><A NAME="tex2html2101"
  HREF="node23.html#SECTION04328060000000000000">Caveats</A>
<LI><A NAME="tex2html2102"
  HREF="node23.html#SECTION04328070000000000000">Depurando con código empotrado Colisiones en los Nombres de las Subexpresiones Regulares</A>
</UL>
<BR>
<LI><A NAME="tex2html2103"
  HREF="node23.html#SECTION04329000000000000000">Expresiones Regulares en tiempo de matching</A>
<UL>
<LI><A NAME="tex2html2104"
  HREF="node23.html#SECTION04329010000000000000">Paréntesis con memoria dentro de una <I>pattern code expression</I></A>
<LI><A NAME="tex2html2105"
  HREF="node23.html#SECTION04329020000000000000">Ejemplo: Secuencias de dígitos de longitud especificada por el primer dígito</A>
<LI><A NAME="tex2html2106"
  HREF="node23.html#SECTION04329030000000000000">Ejemplo: Secuencias de dígitos no repetidos</A>
<LI><A NAME="tex2html2107"
  HREF="node23.html#SECTION04329040000000000000">Palíndromos con independencia del acento</A>
<LI><A NAME="tex2html2108"
  HREF="node23.html#SECTION04329050000000000000">Postponiendo para conseguir recursividad</A>
<LI><A NAME="tex2html2109"
  HREF="node23.html#SECTION04329060000000000000">Caveats</A>
</UL>
<BR>
<LI><A NAME="tex2html2110"
  HREF="node23.html#SECTION043210000000000000000">Expresiones Condicionales</A>
<UL>
<LI><A NAME="tex2html2111"
  HREF="node23.html#SECTION043210010000000000000">Condiciones: número de paréntesis</A>
<LI><A NAME="tex2html2112"
  HREF="node23.html#SECTION043210020000000000000">Ejemplo: cadenas de la forma <I>una</I>-otra-otra-<I>una</I></A>
<LI><A NAME="tex2html2113"
  HREF="node23.html#SECTION043210030000000000000">Condiciones: Código</A>
<LI><A NAME="tex2html2114"
  HREF="node23.html#SECTION043210040000000000000">Ejemplo: Cadenas con posible paréntesis inicial (no anidados)</A>
<LI><A NAME="tex2html2115"
  HREF="node23.html#SECTION043210050000000000000">Expresiones Condicionales con <TT>(R)</TT></A>
<LI><A NAME="tex2html2116"
  HREF="node23.html#SECTION043210060000000000000">Ejemplo: Palíndromos con Equivalencia de Acentos Españoles</A>
</UL>
<BR>
<LI><A NAME="tex2html2117"
  HREF="node23.html#SECTION043211000000000000000">Verbos que controlan el retroceso</A>
<UL>
<LI><A NAME="tex2html2118"
  HREF="node23.html#SECTION043211010000000000000">El verbo de control <TT>(*FAIL)</TT></A>
<LI><A NAME="tex2html2119"
  HREF="node23.html#SECTION043211020000000000000">El verbo de control <TT>(*ACCEPT)</TT></A>
<LI><A NAME="tex2html2120"
  HREF="node23.html#SECTION043211030000000000000">El verbo <TT>SKIP</TT></A>
<LI><A NAME="tex2html2121"
  HREF="node23.html#SECTION043211040000000000000">Marcas</A>
<LI><A NAME="tex2html2122"
  HREF="node23.html#SECTION043211050000000000000">Poniendo un espacio después de cada signo de puntuación</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04320000000000000000">
Algunas Extensiones</A>
</H1>

<P>

<H2><A NAME="SECTION04321000000000000000">
Comentarios</A>
</H2>
<code>(?#text)</code> Un comentario. Se ignora <code>text</code>. 
Si se usa la opción <code>x</code> basta con poner <code>#</code>.

<P>

<H2><A NAME="SECTION04322000000000000000">
Modificadores locales</A>
</H2>

<P>
Los modificadores de la conducta de una expresión regular pueden ser 
empotrados en una subexpresión usando el formato <code>(?pimsx-imsx)</code>.

<P>
Véase el correspondiente texto <I>Extended Patterns</I> de 
la sección 'Extended-Patterns' en <A NAME="tex2html191"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>:
<BLOCKQUOTE><I>One or more embedded pattern-match modifiers, to be turned on (or turned
off, if preceded by '<code>-</code>' ) for the remainder of the pattern or the remainder
of the enclosing pattern group (if any). This is particularly useful
for dynamic patterns, such as those read in from a configuration file,
taken from an argument, or specified in a table somewhere. Consider
the case where some patterns want to be case sensitive and some do not:
The case insensitive ones merely need to include (?i) at the front of
the pattern. For example:
</I></BLOCKQUOTE>
<P><PRE>
   1. $pattern = "foobar";
   2. if ( /$pattern/i ) { }
   3.
   4. # more flexible:
   5.
   6. $pattern = "(?i)foobar";
   7. if ( /$pattern/ ) { }
</PRE>
<P>
<BLOCKQUOTE><I>These modifiers are restored at the end of the enclosing group. For example,
</I></BLOCKQUOTE>
<P><PRE>
   1. ( (?i) blah ) \s+ \1
</PRE>
<P>
<BLOCKQUOTE><I>will match <code>blah</code> in any case, some spaces, and an exact (including the
case!) repetition of the previous word, assuming the <code>/x</code> modifier, and
no <code>/i</code> modifier outside this group.
</I></BLOCKQUOTE>

<P>
El siguiente ejemplo extiende el ejemplo visto en
la sección
<A HREF="node22.html#parrfo:comments">3.1.1</A>
eliminando los comentarios <code>/* ... */</code> y <code>// ... </code>
de un programa C. En dicho ejemplo se usaba el modificador <code>s</code> 
para hacer que el punto casara con cualquier carácter:

<P>

<pre>
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">"Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">"</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">"&lt;</span><span class="synIdentifier">$progname</span><span class="synConstant">"</span>) || <span class="synStatement">die</span> <span class="synConstant">"can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">"</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = &lt;<span class="synIdentifier">$PROGRAM</span>&gt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span><span class="synSpecial">(?xs)</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">    |</span>
<span class="synLinenum">   16</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">-s</span><span class="synSpecial">)</span><span class="synConstant">//</span><span class="synSpecial">.*</span><span class="synConstant"> # C</span><span class="synSpecial">++</span><span class="synConstant"> // comments</span><span class="synSpecial">.</span><span class="synConstant"> No s modifier</span>
<span class="synLinenum">   17</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]g;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>
Sigue un ejemplo de ejecución. Usaremos como entrada el programa C:
<PRE>
casiano@tonga:~/Lperltesting$ cat -n ehello.c
     1  #include &lt;stdio.h&gt;
     2  /* first
     3  comment
     4  */
     5  main() { // A C++ comment
     6    printf("hello world!\n"); /* second comment */
     7  } // final comment
</PRE>
Al ejecutar el programa eliminamos los comentarios:
<PRE>
casiano@tonga:~/Lperltesting$ extendedcomments.pl ehello.c | cat -n
     1  #include &lt;stdio.h&gt;
     2
     3  main() {
     4    printf("hello world!\n");
     5  }
</PRE>

<P>

<H2><A NAME="SECTION04323000000000000000"></A>
<A NAME="subsection:lookaheadlookbehind"></A>
<BR>
Mirando hacia adetrás y hacia adelante
</H2>

<P>
El siguiente fragmento esta 'casi' literalmente tomado
de la sección 'Looking-ahead-and-looking-behind' en <A NAME="tex2html192"
  HREF="http://perldoc.perl.org/perlretut.html#Looking-ahead-and-looking-behind"><TT>perlretut</TT></A>:

<P>
<P>
<H4><A NAME="SECTION04323010000000000000">
Las zero-width assertions como caso particular de mirar atrás-adelante</A>
</H4>
  

<P>
In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match. For instance, the regexp element
<code>[abc}]</code> eats up one character of the string when it matches, in the sense
that Perl moves to the next character position in the string after the
match. There are some elements, however, that don't eat up characters
(advance the character position) if they match. 

<P>
The examples we have seen
so far are the anchors. The anchor <code>^</code> matches the beginning of the line,
but doesn't eat any characters. 

<P>
Similarly, the word boundary anchor
<code>\b</code> matches wherever a character matching <code>\w</code> is next to a character that
doesn't, but it doesn't eat up any characters itself. 

<P>
Anchors are examples
of <A NAME="5407"></A><SPAN  CLASS="textit">zero-width assertions</SPAN>. Zero-width, because they consume no characters,
and assertions, because they test some property of the string. 

<P>
In the
context of our walk in the woods analogy to regexp matching, most regexp
elements move us along a trail, but anchors have us stop a moment and
check our surroundings. If the local environment checks out, we can
proceed forward. But if the local environment doesn't satisfy us, we
must backtrack.

<P>
Checking the environment entails either looking ahead on the trail,
looking behind, or both. 

<P>

<UL>
<LI><code>^</code> looks behind, to see that there are no
characters before. 
</LI>
<LI><code>$</code> looks ahead, to see that there are no characters
after. 
</LI>
<LI><code>\b</code> looks both ahead and behind, to see if the characters on either
side differ in their "word-ness".
</LI>
</UL>

<P>
The lookahead and lookbehind assertions are generalizations of the anchor
concept. 
Lookahead and lookbehind are zero-width assertions that let us
specify which characters we want to test for. 

<P>

<H4><A NAME="SECTION04323020000000000000">
Lookahead assertion</A>
</H4>
  

<P>
The lookahead assertion
is denoted by <code>(?=regexp)</code> and the lookbehind assertion is denoted by
<code>(?&lt;=fixed-regexp)</code>. 

<P>
En español, operador de ``trailing'' o ``mirar-adelante'' positivo. 
Por ejemplo, <code>/\w+(?=\t)/</code> solo casa una palabra si va seguida de un tabulador, pero el tabulador no formará parte de <code>$&amp;</code>.
Ejemplo:

<pre>
> cat -n lookahead.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span> 
<span class="synLinenum">    3</span>  <span class="synIdentifier">$a</span> = <span class="synConstant">"bugs the rabbit"</span>;
<span class="synLinenum">    4</span>  <span class="synIdentifier">$b</span> = <span class="synConstant">"bugs the frog"</span>;
<span class="synLinenum">    5</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$a</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">"</span><span class="synIdentifier">$a</span><span class="synConstant"> matches. </span><span class="synSpecial">$</span><span class="synConstant">&amp; = </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">"</span>; }
<span class="synLinenum">    6</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">"</span><span class="synIdentifier">$a</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">"</span>; }
<span class="synLinenum">    7</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$b</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">"</span><span class="synIdentifier">$b</span><span class="synConstant"> matches. </span><span class="synSpecial">$</span><span class="synConstant">&amp; = </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">"</span>; }
<span class="synLinenum">    8</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">"</span><span class="synIdentifier">$b</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">"</span>; }
</pre>
Al ejecutar el programa obtenemos:
<PRE>
&gt; lookahead.pl
bugs the rabbit matches. $&amp; = bugs
bugs the frog does not match
&gt;
</PRE>

<P>
Some examples using the debugger<A NAME="tex2html193"
  HREF="footnode.html#foot4550"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN></SUP></A>:

<P>

<pre>
  DB<1>  <span class="dbuser">     #012345678901234567890</span>
  DB<2>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<3>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x  =~ /cat(?=\s)/g</span>
(cat) (20)                    # matches 'cat' in 'housecat'

  DB<5>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip" # To reset pos</span>
  DB<6>  <span class="dbuser">x @catwords = ($x =~ /(?<=\s)cat\w+/g)</span>
0  'catch'
1  'catnip'

  DB<7>  <span class="dbuser">     #012345678901234567890123456789</span>
  DB<8>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<9>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x =~ /\bcat\b/g</span>
(cat) (29) # matches 'cat' in 'Tom-cat'

  DB<10>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<11>  <span class="dbuser">x  $x =~ /(?<=\s)cat(?=\s)/</span>
  empty array
  DB<12>  <span class="dbuser"># doesn't match; no isolated 'cat' in middle of $x</span>
</pre>

<P>

<H4><A NAME="SECTION04323030000000000000">
A hard RegEx problem</A>
</H4>
  

<P>
Véase el nodo <I>A hard RegEx problem</I> en <A NAME="tex2html194"
  HREF="http://www.perlmonks.org/?node_id=645882">PerlMonks</A>. 
Un monje solicita:

<P>
<BLOCKQUOTE><I>Hi Monks,
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>I wanna to match this issues:
</I></BLOCKQUOTE>
<P>
<OL>
<LI>The string length is between 3 and 10
</LI>
<LI>The string ONLY contains [0-9] or [a-z] or [A-Z], but
</LI>
<LI>The string must contain a number AND a letter at least 
</LI>
</OL>
<P>
<BLOCKQUOTE><I>Pls help me check. Thanks
</I></BLOCKQUOTE>

<P>
Solución:

<P>
<PRE>
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x 'aaa2a1' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
  DB&lt;2&gt; x 'aaaaaa' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB&lt;3&gt; x '1111111' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB&lt;4&gt; x '1111111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB&lt;5&gt; x '111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
</PRE>

<P>

<H4><A NAME="SECTION04323040000000000000">
Los paréntesis looakehaed and lookbehind no capturan</A>
</H4>
  

<P>
Note that the parentheses in <code>(?=regexp)</code> and <code>(?&lt;=regexp)</code>
are non-capturing, since these are zero-width assertions. 

<P>

<H4><A NAME="SECTION04323050000000000000">
Limitaciones del lookbehind</A>
</H4>
  

<P>
Lookahead
<code>(?=regexp)</code> can match arbitrary regexps, but lookbehind 
<code>(?&lt;=fixed-regexp)</code>
only works for regexps of fixed width, i.e., a fixed number of characters
long. 

<P>
Thus <code>(?&lt;=(ab|bc))</code> is fine, but <code>(?&lt;=(ab)*)</code> is not. 

<P>

<H4><A NAME="SECTION04323060000000000000">
Negación de los operadores de lookahead y lookbehind</A>
</H4>
  

<P>
The negated
versions of the lookahead and lookbehind assertions are denoted by
<code>(?!regexp)</code> and <code>(?&lt;!fixed-regexp)</code> respectively. 
They evaluate true if
the regexps do not match:
<PRE>
    $x = "foobar";
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?&lt;!\s)foo/;  # matches, there is no \s before 'foo'
</PRE>

<P>

<H4><A NAME="SECTION04323070000000000000">
Ejemplo: split con lookahead y lookbehind</A>
</H4>
  

<P>
Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components. 

<P>
Using <code>/\s+/</code>
alone won't work, because spaces are not required between dashes, or a
word or a dash. Additional places for a split are established by looking
ahead and behind:
<PRE>
casiano@tonga:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; $str = "one two - --6-8"
  DB&lt;2&gt; x @toks = split / \s+ | (?&lt;=\S) (?=-) | (?&lt;=-)  (?=\S)/x, $str
0  'one'
1  'two'
2  '-'
3  '-'
4  '-'
5  6
6  '-'
7  8
</PRE>

<P>

<H4><A NAME="SECTION04323080000000000000">
Look Around en perlre</A>
</H4>
  

<P>
El siguiente párrafo ha sido extraído la sección 'Look-Around-Assertions' en <A NAME="tex2html195"
  HREF="http://perldoc.perl.org/pelre.html#Look-Around-Assertions"><TT>pelre</TT></A>.
Usémoslo como texto de repaso:
<BLOCKQUOTE><I>Look-around assertions are zero width patterns which match a specific
pattern without including it in <code>$&amp;</code>. Positive assertions match when their
subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.
</I></BLOCKQUOTE>
<P>
<UL>
<LI><code>(?=pattern)</code>

<P>
A zero-width positive look-ahead assertion. For example, <code>/\w+(?=\t)/</code> 
matches a word followed by a tab, without including the tab in <code>$&amp;</code>.

<P>
</LI>
<LI><code>(?!pattern)</code>

<P>
A zero-width negative look-ahead assertion. For example <code>/foo(?!bar)/</code> 
matches any occurrence of <code>foo</code> that isn't followed by <code>bar</code>. 

<P>
Note however that look-ahead and look-behind are NOT the same thing. 
You cannot use this for look-behind.

<P>
If you are looking for a <code>bar</code> that isn't preceded by a <code>foo</code>,
<code>/(?!foo)bar/</code> will not do what you want. 

<P>
That's because the 
<code>(?!foo)</code> is just saying that the next thing cannot be <code>foo</code>
-and it's not, it's a <code>bar</code>, so <code>foobar</code> will match. 

<P>
You would have to do something like <code>/(?!foo)...bar/</code> for that. 

<P>
We say "like" because there's the case of your <code>bar</code> not having
three characters before it. 

<P>
You could cover that this way:
<code>/(?:(?!foo)...|^.{0,2})bar/</code>. Sometimes it's still easier just to say:

<P>
<PRE>
    if (/bar/ &amp;&amp; $` !~ /foo$/)
</PRE>

<P>
For look-behind see below.

<P>
</LI>
<LI><code>(?&lt;=pattern)</code>

<P>
A zero-width positive look-behind assertion. 

<P>
For example, <code>/(?&lt;=\t)\w+/</code>
matches a word that follows a tab, without including the tab in <code>$&amp;</code>. 
Works only for fixed-width look-behind.

<P>
</LI>
<LI><code>\K</code> 

<P>
There is a special form of this construct, called <code>\K</code> , which causes
the regex engine to 'keep' everything it had matched prior to the <code>\K</code>
and not include it in <code>$&amp;</code>. This effectively provides variable length
look-behind. The use of <code>\K</code> inside of another look-around assertion is
allowed, but the behaviour is currently not well defined.

<P>
For various reasons <code>\K</code> may be significantly more efficient than the
equivalent <code>(?&lt;=...)</code> construct, and it is especially useful in situations
where you want to efficiently remove something following something else
in a string. For instance
<PRE>
  s/(foo)bar/$1/g;
</PRE>

<P>
can be rewritten as the much more efficient
<PRE>
  s/foo\Kbar//g;
</PRE>

<P>
Sigue una sesión con el depurador que ilustra la semántica
del operador:

<P>
<PRE>
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; print "&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])[a-z]/
&amp; = &lt;phab&gt; 1 = &lt;pha&gt;
  DB&lt;2&gt; print "&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n" if "alphabet" =~ /\K([^aeiou][a-z][aeiou])[a-z]/
&amp; = &lt;phab&gt; 1 = &lt;pha&gt;
  DB&lt;3&gt; print "&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n" if "alphabet" =~ /([^aeiou]\K[a-z][aeiou])[a-z]/
&amp; = &lt;hab&gt; 1 = &lt;pha&gt;
  DB&lt;4&gt; print "&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n" if "alphabet" =~ /([^aeiou][a-z]\K[aeiou])[a-z]/
&amp; = &lt;ab&gt; 1 = &lt;pha&gt;
  DB&lt;5&gt; print "&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])\K[a-z]/
&amp; = &lt;b&gt; 1 = &lt;pha&gt;
  DB&lt;6&gt; print "&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])[a-z]\K/
&amp; = &lt;&gt; 1 = &lt;pha&gt;
  DB&lt;7&gt; @a = "alphabet" =~ /([aeiou]\K[^aeiou])/g; print "$&amp;\n"
t
  DB&lt;8&gt; x @a
0  'al'
1  'ab'
2  'et'
</PRE>

<P>
Otro ejemplo: eliminamos los blancos del final en una cadena:
<PRE>
  DB&lt;23&gt; $x = '  cadena entre blancos  '
  DB&lt;24&gt; ($y = $x) =~ s/.*\b\K.*//g
  DB&lt;25&gt; p "&lt;$y&gt;"
&lt;  cadena entre blancos&gt;
</PRE>

<P>
</LI>
<LI><code>(?&lt;!pattern)</code> 

<P>
A zero-width negative look-behind assertion. 

<P>
For example <code>/(?&lt;!bar)foo/</code> matches any occurrence of 
 <code>foo</code> that does not follow <code>bar</code>. Works only for fixed-width look-behind.
</LI>
</UL>
<P>

<P>
Veamos un ejemplo de uso. Se quiere
sustituir las extensiones <code>.something</code> por <code>.txt</code>
en cadenas que contienen una ruta a un fichero:

<P>
<PRE>
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; ($b = $a = 'abc/xyz.something') =~ s{\.[^.]*$}{.txt}
  DB&lt;2&gt; p $b
abc/xyz.txt
  DB&lt;3&gt; ($b = $a = 'abc/xyz.something') =~ s/\.\K[^.]*$/txt/;
  DB&lt;4&gt; p $b
abc/xyz.txt
  DB&lt;5&gt; p $a
abc/xyz.something
</PRE>

<P>
Véase también:

<UL>
<LI><A NAME="tex2html196"
  HREF="http://search.cpan.org/perldoc?Regexp::Keep"><TT>Regexp::Keep</TT></A>
por Jeff Pinyan 
</LI>
<LI>El nodo <I>positive look behind regexp mystery</I> en <A NAME="tex2html197"
  HREF="http://www.perlmonks.org/?node_id=701618">PerlMonks</A>
</LI>
</UL>

<P>

<H4><A NAME="SECTION04323090000000000000">
Operador de predicción negativo: Última ocurrencia</A>
</H4>
  

<P>
Escriba una expresión regular que encuentre la última aparición de la cadena <code>foo</code>
en una cadena dada.
<PRE>
  DB&lt;6&gt; x ($a = 'foo foo bar bar foo bar bar') =~ /foo(?!.*foo)/g; print pos($a)."\n"
19
  DB&lt;7&gt; x ($a = 'foo foo bar bar foo bar bar') =~ s/foo(?!.*foo)/\U$&amp;/
0  1
  DB&lt;8&gt; x $a
0  'foo foo bar bar FOO bar bar'
</PRE>

<P>

<H4><A NAME="SECTION043230100000000000000">
Diferencias entre mirar adelante negativo y mirar adelante con clase negada</A>
</H4>
  

<P>
Aparentemente el operador ``mirar-adelante'' negativo es parecido a usar el operador ``mirar-adelante'' positivo
con la negación de una clase. 

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><PRE>
/regexp(?![abc])/
</PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><PRE>
/regexp(?=[^abc])/
</PRE></TD>
</TR>
</TABLE>
</DIV>

<P>
Sin embargo existen al menos dos diferencias:

<P>

<UL>
<LI>Una negación de una clase debe casar algo para tener éxito. Un `mirar-adelante'' negativo
tiene éxito si, en particular no logra casar con algo. 
Por ejemplo:

<P>
<code>\d+(?!\.)</code> casa con <code>$a = '452'</code>, mientras que <code>\d+(?=[^.])</code> lo hace, pero porque 
<code>452</code> es <code>45</code> seguido de un carácter que no es el punto:
<PRE>
&gt; cat lookaheadneg.pl
#!/usr/bin/perl

 $a = "452";
 if ($a =~ m{\d+(?=[^.])}i) { print "$a casa clase negada. \$&amp; = $&amp;\n"; }
 else { print "$a no casa\n"; }
 if ($a =~ m{\d+(?!\.)}i) { print "$a casa predicción negativa. \$&amp; = $&amp;\n"; }
 else { print "$b no casa\n"; }
nereida:~/perl/src&gt; lookaheadneg.pl
452 casa clase negada. $&amp; = 45
452 casa predicción negativa. $&amp; = 452
</PRE>
</LI>
<LI>Una clase negada casa un único carácter. Un `mirar-adelante'' negativo
puede tener longitud arbitraria.
</LI>
</UL>

<P>

<H4><A NAME="SECTION043230110000000000000">
AND y AND NOT</A>
</H4>
  

<P>
Otros dos ejemplos: 

<P>

<UL>
<LI><code>^(?![A-Z]*$)[a-zA-Z]*$</code> 

<P>
casa con líneas formadas por secuencias de
letras tales que no todas son mayúsculas.
(Obsérvese el uso de las anclas).

<P>
</LI>
<LI><code>^(?=.*?esto)(?=.*?eso)</code> 

<P>
casan con cualquier línea en la que aparezcan 
<code>esto</code> y <code>eso</code>. Ejemplo:
<PRE>
&gt; cat estoyeso.pl
#!/usr/bin/perl

 my $a = shift;

 if ($a =~ m{^(?=.*?esto)(?=.*?eso)}i) { print "$a matches.\n"; }
 else { print "$a does not match\n"; }

&gt;estoyeso.pl 'hola eso y esto'
hola eso y esto matches.
&gt; estoyeso.pl 'hola esto y eso'
hola esto y eso matches.
&gt; estoyeso.pl 'hola aquello y eso'
hola aquello y eso does not match
&gt; estoyeso.pl 'hola esto y aquello'
hola esto y aquello does not match
</PRE>
El ejemplo muestra que la interpretación es que cada 
operador mirar-adelante se interpreta siempre a partir de
la posición actual de búsqueda. La expresión regular anterior
es básicamente equivalente a <code>(/esto/ &amp;&amp; /eso/)</code>.
</LI>
<LI><code>(?!000)(\d\d\d)</code> 

<P>
casa con cualquier cadena de tres dígitos que no
sea la cadena <code>000</code>.
</LI>
</UL>

<P>

<H4><A NAME="SECTION043230120000000000000">
Lookahead negativo versus lookbehind</A>
</H4>
  

<P>
Nótese que el ``mirar-adelante'' negativo
no puede usarse fácilmente para imitar un ``mirar-atrás'',
esto es, que no se puede imitar la conducta de
<code>(?&lt;!foo)bar</code> mediante
algo como <code>(/?!foo)bar</code>. Tenga en cuenta que:

<P>

<UL>
<LI>Lo que 
dice <code>(?!foo)</code> es que los tres caracteres que siguen no puede ser <code>foo</code>.  

<P>
</LI>
<LI>Así, <code>foo</code> no pertenece a <code>/(?!foo)bar/</code>, pero
<code>foobar</code> pertenece a  <code>(?!foo)bar/</code> porque <code>bar</code> es una cadena
cuyos tres siguientes caracteres son <code>bar</code> y no son <code>foo</code>.

<P>
</LI>
<LI>Si quisieramos conseguir algo parecido a <code>(?&lt;!foo)bar</code> usando un lookahead negativo
tendríamos que escribir algo asi como
<code>/(?!foo)...bar/</code> que casa con una cadena de tres caracteres que no sea <code>foo</code> seguida de 
<code>bar</code> (pero que tampoco es exactamente equivalente):
<PRE>
pl@nereida:~/Lperltesting$ cat -n foobar.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $a = shift;
     5
     6  for my $r (q{(?&lt;!foo)bar}, q{(?!foo)bar}, q{(?!foo)...bar}) {
     7    if ($a =~ /$r/) {
     8      say "$a casa con $r"
     9    }
    10    else {
    11      say "$a no casa con $r"
    12    }
    13  }
</PRE>

<P>
</LI>
<LI>Al ejecutar con diferentes entradas el programa anterior vemos que la solución 
<code>q{(?!foo)...bar}</code> se apróxima mas a <code>(q{(?&lt;!foo)bar}</code>:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl foobar
foobar no casa con (?&lt;!foo)bar
foobar casa con (?!foo)bar
foobar no casa con (?!foo)...bar

pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl bar
bar casa con (?&lt;!foo)bar
bar casa con (?!foo)bar
bar no casa con (?!foo)...bar
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Explique porqué <code>bar</code> casa con <code>(?&lt;!foo)bar</code> pero no con <code>(?!foo)...bar</code>.
¿Sabría encontrar una expresión regular mas apropiada usando lookahead negativo?</I></DIV><P></P>

<P>
</LI>
<LI>En realidad, posiblemente sea mas legible una solución como:
<PRE>
        if (/bar/ and $` !~ /foo$/)
</PRE>
o aún mejor (véase <A HREF="node22.html#parrafo:prematch">3.1.4</A>):
<PRE>
        if (/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/)
</PRE>
El siguiente programa puede ser utilizado para ilustrar la equivalencia:
<PRE>
pl@nereida:~/Lperltesting$ cat -n foobarprematch.pl
 1  use v5.10;
 2  use strict;
 3
 4  $_ = shift;
 5
 6  if (/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/) {
 7    say "$_ no cumple ".q{/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/};
 8  }
 9  else {
10    say "$_ cumple ".q{/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/};
11  }
12  if (/(?&lt;!foo)bar/) {
13    say "$_ casa con (?&lt;!foo)bar"
14  }
15  else {
16    say "$_ no casa con (?&lt;!foo)bar"
17  }
</PRE>
Siguen dos ejecuciones:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl bar
bar cumple /bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/
bar casa con (?&lt;!foo)bar
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl foobar
foobar no cumple /bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/
foobar no casa con (?&lt;!foo)bar
</PRE>
</LI>
</UL>

<P>

<H4><A NAME="SECTION043230130000000000000">
Ejercicios</A>
</H4>
  

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<UL>
<LI>Escriba una sustitución que reemplaze todas las apariciones
de <code>foo</code> por <code>foo,</code> usando <code>\K</code> o lookbehind
</LI>
<LI>Escriba una sustitución que reemplaze todas las apariciones
de <code>lookahead</code> por <code>look-ahead</code> usando lookaheads y lookbehinds
</LI>
<LI>Escriba una expresión regular que capture todo lo que hay 
entre las cadenas <code>foo</code> y <code>bar</code> siempre que no se incluya la
palabra <code>baz</code>
</LI>
<LI>¿Cuál es la salida?
<PRE>
  DB&lt;1&gt; x 'abc' =~ /(?=(.)(.)(.))a(b)/
</PRE>
</LI>
<LI>Se quiere poner un espacio en blanco después de la aparición de cada coma:
<PRE>
s/,/, /g;
</PRE>
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos.
</LI>
<LI>Se quiere poner un espacio en blanco después de la aparición de cada coma:
<PRE>
s/,/, /g;
</PRE>
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique

<P>
</LI>
<LI>¿Cuál es la salida?

<pre>
pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n ABC123</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  use warnings;</span>
<span class="synConstant">     2  use strict;</span>
<span class="synConstant">     3</span>
<span class="synConstant">     4  my </span><span class="synIdentifier">$c</span><span class="synConstant"> = 0;</span>
<span class="synConstant">     5  my </span><span class="synIdentifier">@p</span><span class="synConstant"> = </span><span class="synSpecial">(</span><span class="synConstant">'^</span><span class="synSpecial">(</span><span class="synConstant">ABC</span><span class="synSpecial">)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">', '^</span><span class="synSpecial">(\D*)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">',</span><span class="synSpecial">)</span><span class="synConstant">;</span>
<span class="synConstant">     6</span>
<span class="synConstant">     7  for my </span><span class="synIdentifier">$r</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@p</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     8    for my </span><span class="synIdentifier">$s</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synConstant">qw{ABC123 ABC445}</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     9      </span><span class="synIdentifier">$c</span><span class="synSpecial">++</span><span class="synConstant">;</span>
<span class="synConstant">    10      print "</span><span class="synIdentifier">$c</span><span class="synConstant">: '</span><span class="synIdentifier">$s</span><span class="synConstant">' =~ </span><span class="synStatement">/</span><span class="synIdentifier">$r</span>/ : <span class="synConstant">";</span>
<span class="synConstant">    11      &lt;&gt;;</span>
<span class="synConstant">    12      if (</span><span class="synIdentifier">$s</span><span class="synConstant"> =~ /</span><span class="synIdentifier">$r</span><span class="synConstant">/) {</span>
<span class="synConstant">    13        print "</span> YES (<span class="synIdentifier">$1</span>)\n<span class="synConstant">";</span>
<span class="synConstant">    14      }</span>
<span class="synConstant">    15      else {</span>
<span class="synConstant">    16        print "</span> NO\n<span class="synConstant">";</span>
<span class="synConstant">    17      }</span>
<span class="synConstant">    18    }</span>
<span class="synConstant">    19  }</span>
</pre>
</LI>
</UL></DIV><P></P>

<P>

<H2><A NAME="SECTION04324000000000000000">
Definición de Nombres de Patrones</A>
</H2>
Perl 5.10 introduce la posibilidad de definir 
subpatrones en una sección del patrón. 

<P>

<H4><A NAME="SECTION04324010000000000000">
Lo que dice <TT>perlretut</TT> sobre la definición de nombres de patrones</A>
</H4>
  

<P>
Citando la sección <I>Defining named patterns</I>
en el documento la sección 'Defining-named-patterns' en <A NAME="tex2html198"
  HREF="http://perldoc.perl.org/perlretut.html#Defining-named-patterns"><TT>perlretut</TT></A>
para
perl5.10:

<P>
<BLOCKQUOTE><I>Some regular expressions use identical subpatterns in several
places. Starting with Perl 5.10, it is possible to define named
subpatterns in a section of the pattern so that they can be called up by
name anywhere in the pattern. 
This syntactic pattern for this definition group is
<code>"(?(DEFINE)(?&lt;name&gt;pattern)...)"</code>  
An
insertion of a named pattern is written as <code>(?&amp;name)</code>.
</I></BLOCKQUOTE>

<P>
Veamos un ejemplo que define el lenguaje de los números en punto flotante:
<PRE>
pl@nereida:~/Lperltesting$ cat -n definingnamedpatterns.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3
 4  my $regexp = qr{
 5     ^ (?&lt;num&gt;
 6               (?&amp;osg)[\t\ ]* (?: (?&amp;int)(?&amp;dec)? | (?&amp;dec) )
 7       )
 8       (?: [eE]
 9       (?&lt;exp&gt; (?&amp;osg)(?&amp;int)) )?
10     $
11        (?(DEFINE)
12         (?&lt;osg&gt;[-+]?)         # optional sign
13         (?&lt;int&gt;\d++)          # integer
14         (?&lt;dec&gt;\.(?&amp;int))     # decimal fraction
15        )
16  }x;
17
18  my $input = &lt;&gt;;
19  chomp($input);
20  my @r;
21  if (@r = $input =~ $regexp) {
22    my $exp = $+{exp} || '';
23    say "$input matches: (num =&gt; '$+{num}', exp =&gt; '$exp')";
24  }
25  else {
26    say "does not match";
27  }
</PRE>
<A NAME="tex2html199"
  HREF="http://search.cpan.org/perldoc/?perlretut"><TT>perlretut</TT></A>
comenta sobre este ejemplo:
<BLOCKQUOTE><I>The example above illustrates this feature.
The three subpatterns that
are used more than once are the optional sign, 
the digit sequence for
an integer 
and the decimal fraction. The <code>DEFINE</code> 
group at the end of
the pattern contains their definition. Notice that the decimal fraction
pattern is the first place where we can reuse the integer pattern.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION04324020000000000000">
Lo que dice <TT>perlre</TT> sobre la definición de patrones</A>
</H4>
  

<P>
Curiosamente, <code>(DEFINE)</code> se considera un caso particular de 
las expresiones regulares condicionales de la forma <code>(?(condition)yes-pattern)</code>
(véase la sección <A HREF="#subsection:regexpcondicionales">3.2.10</A>).
Esto es lo que dice la sección 'Extended-Patterns' en <A NAME="tex2html200"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>
al respecto:
<BLOCKQUOTE><I>A special form is the <code>(DEFINE)</code>  predicate, which never executes
directly its yes-pattern, and does not allow a no-pattern. This allows
to define subpatterns which will be executed only by using the recursion
mechanism. This way, you can define a set of regular expression rules
that can be bundled into any pattern you choose.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>It is recommended that for this usage you put the <code>DEFINE</code> block at the
end of the pattern, and that you name any subpatterns defined within it.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Also, it's worth noting that patterns defined this way probably will not
be as efficient, as the optimiser is not very clever about handling them.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>An example of how this might be used is as follows:
</I></BLOCKQUOTE>
<P><PRE>
   1. /(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
   2.        (?(DEFINE)
   3.          (?&lt;NAME_PAT&gt;....)
   4.          (?&lt;ADRESS_PAT&gt;....)
   5. )/x
</PRE>
<P>
<BLOCKQUOTE><I>Note that <B>capture buffers matched inside of recursion are not accessible
after the recursion returns</B>, so the extra layer of capturing buffers is
necessary. Thus <code>$+{NAME_PAT}</code> would not be defined even though 
<code>$+{NAME}</code>
would be.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION04324030000000000000">
Lo que dice <TT>perlvar</TT> sobre patrones con nombre</A>
</H4>
  

Esto es lo que dice <A NAME="tex2html202"
  HREF="http://search.cpan.org/perldoc/?perlvar"><TT>perlvar</TT></A>
respecto a las variables implicadas <code>%+</code>
y <code>%-</code>. Con respecto a el hash <code>%+</code>:

<P>
<UL>
<LI><code>%LAST_PAREN_MATCH</code>, <code>%+</code>

<P>
Similar to <code>@+</code> , the <code>%+</code> hash allows access to the named capture buffers,
should they exist, in the last successful match in the currently active
dynamic scope.

<P>
For example, <code>$+{foo}</code> is equivalent to <code>$1</code> after the following match:

<P>
<PRE>
   1. 'foo' =~ /(?&lt;foo&gt;foo)/;
</PRE>

<P>
The keys of the <code>%+</code> hash list only the names of buffers that have
captured (and that are thus associated to defined values).

<P>
The underlying behaviour of <code>%+</code> is provided by the <A NAME="tex2html201"
  HREF="http://search.cpan.org/perldoc?Tie::Hash::NamedCapture"><TT>Tie::Hash::NamedCapture</TT></A>
module.

<P>
Note: <code>%-</code> and <code>%+</code> are tied views into a common internal
hash associated with the last successful regular expression. Therefore
mixing iterative access to them via <code>each</code> may have unpredictable
results. Likewise, if the last successful match changes, then the results
may be surprising.

<P>
</LI>
<LI><code>%-</code>

<P>
Similar to <code>%+</code> , this variable allows access to the named capture
buffers in the last successful match in the currently active dynamic
scope. <B>To each capture buffer name found in the regular expression,
it associates a reference to an array containing the list of values
captured by all buffers with that name (should there be several of them),
in the order where they appear</B>.

<P>
Here's an example:

<P>
<PRE>
   1. if ('1234' =~ /(?&lt;A&gt;1)(?&lt;B&gt;2)(?&lt;A&gt;3)(?&lt;B&gt;4)/) {
   2.   foreach my $bufname (sort keys %-) {
   3.     my $ary = $-{$bufname};
   4.     foreach my $idx (0..$#$ary) {
   5.       print "\$-{$bufname}[$idx] : ",
   6.             (defined($ary-&gt;[$idx]) ? "'$ary-&gt;[$idx]'" : "undef"),
   7.             "\n";
   8.     }
   9.   }
  10. }
</PRE>

<P>
would print out:

<P>
<PRE>
   1. $-{A}[0] : '1'
   2. $-{A}[1] : '3'
   3. $-{B}[0] : '2'
   4. $-{B}[1] : '4'
</PRE>

<P>
The keys of the <code>%-</code> hash correspond to all buffer names found in
the regular expression.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION04325000000000000000">
Patrones Recursivos</A>
</H2>

<P>
Perl 5.10 introduce la posibilidad de definir 
subpatrones en una sección del patrón. 
Citando la versión del documento <A NAME="tex2html203"
  HREF="http://search.cpan.org/perldoc/?perlretut"><TT>perlretut</TT></A>
para
perl5.10:

<P>
<BLOCKQUOTE><I>This feature (introduced in Perl 5.10) significantly extends the power
of Perl’s pattern matching.  By referring to some other capture group
anywhere in the
pattern with the construct <code>(?group-ref)</code>, the pattern within the
referenced group is used as an independent subpattern in place of the
group reference itself.
Because the group reference may be contained within the group it refers
to, it is now possible to apply pattern matching to tasks that hitherto
required a
recursive parser.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>In <code>(?...)</code> both absolute and relative backreferences may be used.  
The entire pattern can be reinserted with <code>(?R)</code> or <code>(?0)</code>.  If you prefer to name your
buffers, you can use <code>(?&amp;name)</code> to recurse into that buffer.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION04325010000000000000">
Palíndromos</A>
</H4>
  

<A NAME="parrafo:palabrapalindromos"></A>
<P>
Véase un ejemplo que reconoce los palabra-palíndromos (esto es, 
la lectura directa y la inversa  de la cadena
pueden diferir en los signos de puntuación):

<P>

<pre>
casiano<span class="synIdentifier">@millo</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n palindromos</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
     <span class="synConstant">3</span>
     <span class="synConstant">4</span>  <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span>
<span class="synConstant">     5                       </span><span class="synSpecial">(?:</span>
<span class="synConstant">     6                             </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\g</span><span class="synConstant">{-1}  # palindromo estricto</span>
<span class="synConstant">     7                           |</span>
<span class="synConstant">     8                             </span><span class="synSpecial">\w?</span><span class="synConstant">               # no recursiva</span>
<span class="synConstant">     9                       </span><span class="synSpecial">)</span>
<span class="synConstant">    10                    </span><span class="synSpecial">\W*)</span><span class="synConstant">$/ix</span>;
    <span class="synConstant">11</span>
    <span class="synConstant">12</span>  <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
    <span class="synConstant">13</span>  <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
    <span class="synConstant">14</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
    <span class="synConstant">15</span>    say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome"</span>;
    <span class="synConstant">16</span>  }
    <span class="synConstant">17</span>  <span class="synStatement">else</span> {
    <span class="synConstant">18</span>    say <span class="synConstant">"does not match"</span>;
    <span class="synConstant">19</span>  }
</pre>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>¿Cuál es el efecto del modificador <code>i</code>
en la regexp <code>qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix</code>?</I></DIV><P></P>

<P>
Siguen algunos ejemplos de ejecución<A NAME="tex2html204"
  HREF="footnode.html#foot5048"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN></SUP></A>
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a canal: Panama!</span>
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cam, a yak, a yam, a canal – Panama!</span>
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!</span>
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">saippuakauppias</span>
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">dfghjgfd</span>
does not match
<span class="dbuser">pl@nereida:~/Lperltesting$ ./palindromos.pl</span>
<span class="dbuser">...,;;;;</span>
...,;;;; is a palindrome
</pre>

<P>

<H4><A NAME="SECTION04325020000000000000">
Lo que dice <TT>perlre</TT> sobre recursividad</A>
</H4>
  

<P>
<BLOCKQUOTE><I><code>(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)</code>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Similar to <code>(??{ code })</code> (véase la sección
<A HREF="#subsection:tiempodematching">3.2.9</A>)
except it does not involve compiling any code,
instead it treats the contents of a capture buffer as an independent
pattern that must match at the current position. Capture buffers
contained by the pattern will have the value as determined by the
outermost recursion.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><code>PARNO</code> is a sequence of digits (not starting with 0) whose value
reflects the paren-number of the capture buffer to recurse to. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><code>(?R)</code>
recurses to the beginning of the whole pattern. <code>(?0)</code> is an alternate
syntax for <code>(?R)</code>. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>If <code>PARNO</code> is preceded by a plus or minus sign then it
is assumed to be relative, with negative numbers indicating preceding
capture buffers and positive ones following. Thus (?-1) refers to the
most recently declared buffer, and (?+1) indicates the next buffer to
be declared. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Note that the counting for relative recursion differs from
that of relative backreferences, in that with recursion unclosed buffers
are included.
</I></BLOCKQUOTE>
Hay una diferencia fundamental entre <code>\g{-1}</code> y <code>(?-1)</code>.
El primero significa <I>lo que casó con el último paréntesis</I>.
El segundo significa que se debe <I>llamar a la expresión regular 
que define el último paréntesis</I>. Véase un ejemplo:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt;  x ($a = "12 aAbB 34") =~ s/([aA])(?-1)(?+1)([bB])/-\1\2-/g
0  1
  DB&lt;2&gt; p $a
12 -aB- 34
</PRE>

<P>
En <A NAME="tex2html205"
  HREF="http://search.cpan.org/perldoc/?perlre"><TT>perlre</TT></A>
también se comenta sobre este punto:
<BLOCKQUOTE><I>If there is no corresponding capture buffer defined, then it is a fatal
error. Recursing deeper than 50 times without consuming any input string
will also result in a fatal error. The maximum depth is compiled into
perl, so changing it requires a custom build.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION04325030000000000000">
Paréntesis Equilibrados</A>
</H4>
  

<P>
El siguiente programa (inspirado en uno
que aparece en <A NAME="tex2html206"
  HREF="http://search.cpan.org/perldoc/?perlre"><TT>perlre</TT></A>)
reconoce una llamada a una función <code>foo()</code>
que puede contener una secuencia de expresiones con paréntesis equilibrados
como argumento:

<P>

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat perlrebalancedpar</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span>  <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(</span><span class="synConstant">                      # paren group 1 </span><span class="synSpecial">(</span><span class="synConstant">full function</span><span class="synSpecial">)</span>
<span class="synLinenum">    7</span> <span class="synConstant">                foo</span>
<span class="synLinenum">    8</span> <span class="synConstant">                   </span><span class="synSpecial">(</span><span class="synConstant">                    # paren group 2 </span><span class="synSpecial">(</span><span class="synConstant">parens</span><span class="synSpecial">)</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">\(</span>
<span class="synLinenum">   10</span> <span class="synConstant">                        </span><span class="synSpecial">(</span><span class="synConstant">               # paren group 3 </span><span class="synSpecial">(</span><span class="synConstant">contents of parens</span><span class="synSpecial">)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                </span><span class="synSpecial">[^()]+</span><span class="synConstant">  # Non-parens</span>
<span class="synLinenum">   13</span> <span class="synConstant">                              |</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                </span><span class="synSpecial">(?</span><span class="synConstant">2</span><span class="synSpecial">)</span><span class="synConstant"> # Recurse to start of paren group 2</span>
<span class="synLinenum">   15</span> <span class="synConstant">                           </span><span class="synSpecial">)*</span>
<span class="synLinenum">   16</span> <span class="synConstant">                        </span><span class="synSpecial">)</span><span class="synConstant">               # 3</span>
<span class="synLinenum">   17</span> <span class="synConstant">                     </span><span class="synSpecial">\)</span>
<span class="synLinenum">   18</span> <span class="synConstant">                    </span><span class="synSpecial">)</span><span class="synConstant">                   # 2</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span><span class="synConstant">                         # 1</span>
<span class="synLinenum">   20</span> <span class="synConstant">    }x</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">my</span> <span class="synIdentifier">@res</span> = (<span class="synIdentifier">$input</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$regexp</span><span class="synStatement">/</span>);
<span class="synLinenum">   25</span> <span class="synStatement">if</span> (<span class="synIdentifier">@res</span>) {
<span class="synLinenum">   26</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; is balanced</span><span class="synSpecial">\n</span><span class="synConstant">Paren: (</span><span class="synIdentifier">@res</span><span class="synConstant">)"</span>;
<span class="synLinenum">   27</span> }
<span class="synLinenum">   28</span> <span class="synStatement">else</span> {
<span class="synLinenum">   29</span>   say <span class="synConstant">"does not match"</span>;
<span class="synLinenum">   30</span> }
</pre>
Al ejecutar obtenemos:

<P>

<pre>
pl@nereida:~/Lperltesting$  <span class="dbuser">./perlrebalancedpar.pl</span>
<span class="dbuser">foo(bar(baz)+baz(bop))</span>
&lt;foo(bar(baz)+baz(bop))&gt; is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
</pre>

<P>
Como se comenta en <A NAME="tex2html207"
  HREF="http://search.cpan.org/perldoc/?perlre"><TT>perlre</TT></A>
es conveniente usar 
índices relativos si se quiere tener una expresión regular reciclable:

<P>
<BLOCKQUOTE><I>The following shows how using negative indexing can make it easier to
embed recursive patterns inside of a <code>qr//</code> construct for later use:
</I></BLOCKQUOTE>
<P><PRE>
   1. my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
   2. if (/foo $parens \s+ + \s+ bar $parens/x) {
   3.   # do something here...
   4. }
</PRE>
Véase la sección 
<A HREF="#subsection:cuantificadoresposesivos">3.2.6</A>
para comprender el uso de los operadores posesivos como <code>++</code>.

<P>

<H4><A NAME="SECTION04325040000000000000">
Capturando los bloques de un programa</A>
</H4>
  

<A NAME="parrafo:bloquesanidados"></A>
<P>
El siguiente programa presenta una heurística 
para determinar los bloques de un programa:

<P>

<pre>
<span class="synLinenum">    1</span>   pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocks</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span>   <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span>   
<span class="synLinenum">    7</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">      </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">        </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">               </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">           |</span>
<span class="synLinenum">   13</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   14</span> <span class="synConstant">                </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">     # recursivo</span>
<span class="synLinenum">   15</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   16</span> <span class="synConstant">           </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   17</span> <span class="synConstant">         </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">    }</span>;
<span class="synLinenum">   20</span>   
<span class="synLinenum">   21</span>   <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   25</span>   say(<span class="synIdentifier">$i</span>++.<span class="synConstant">":</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">==="</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>

<P>
Veamos una ejecución. Le daremos como entrada el siguiente programa:
Al ejecutar el programa con esta entrada obtenemos:

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><PRE>
pl@nereida:~/Lperltesting$ cat -n blocks.c
     1  main() { /* 1 */
     2    { /* 2 */ }
     3    { /* 3 */ }
     4  }
     5
     6  f(){  /* 4 */
     7    {   /* 5 */
     8      { /* 6 */ }
     9    }
    10    {   /* 7 */
    11      { /* 8 */ }
    12    }
    13  }
    14
    15  g(){ /* 9 */
    16  }
    17
    18  h() {
    19  {{{}}}
    20  }
    21  /* end h */
</PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 blocks.pl blocks.c
0:
{ /* 1 */
  { /* 2 */ }
  { /* 3 */ }
}
===
1:
{  /* 4 */
  {   /* 5 */
    { /* 6 */ }
  }
  {   /* 7 */
    { /* 8 */ }
  }
}
===
2:
{ /* 9 */
}
===
3:
{
{{{}}}
}
===
</PRE></TD>
</TR>
</TABLE>

<P>

<H4><A NAME="SECTION04325050000000000000">
Reconocimiento de Lenguajes Recursivos: Un subconjunto de <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN></A>
</H4>
  

<A NAME="subsection:regexp510lenrec"></A>
<P>
La posibilidad de combinar en las expresiones regulares Perl 5.10 
la recursividad con los constructos <code>(?&lt;name&gt;...)</code> 
y <code>?&amp;name)</code> así como las secciones <code>(?(DEFINE) ...)</code>
permiten la escritura de expresiones regulares que reconocen lenguajes recursivos. 
El siguiente 
ejemplo muestra un reconocedor de un subconjunto del lenguaje 
<SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> (véase <A NAME="tex2html209"
  HREF="http://en.wikipedia.org/wiki/LaTeX">la entrada LaTeX en la wikipedia</A>):

<P>

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat latex5_10</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    7</span> <span class="synConstant">    </span><span class="synSpecial">\A(?</span><span class="synConstant">&amp;File</span><span class="synSpecial">)\z</span>
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synConstant">    </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;File&gt;     </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Element</span><span class="synSpecial">)*+\s*</span>
<span class="synLinenum">   11</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> 
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Element&gt;  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Command</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                  |  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Literal</span><span class="synSpecial">)</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Command&gt;  </span><span class="synSpecial">\\</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;L&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Literal</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Op&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Options</span><span class="synSpecial">)?)</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;A&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Args</span><span class="synSpecial">))</span>
<span class="synLinenum">   18</span> <span class="synConstant">           </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   19</span> <span class="synConstant">              say "command: &lt;</span><span class="synIdentifier">$+</span><span class="synConstant">{L}</span>&gt; options: &lt;<span class="synIdentifier">$+</span>{Op}&gt; args: &lt;<span class="synIdentifier">$+</span>{A}&gt;<span class="synConstant">"</span>
<span class="synLinenum">   20</span> <span class="synConstant">           })</span>
<span class="synLinenum">   21</span> <span class="synConstant">        )</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span> <span class="synConstant">        (?&lt;Options&gt;  </span><span class="synSpecial">\[</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?:(?&amp;Option) (?:</span><span class="synSpecial">\s</span><span class="synConstant">*,</span><span class="synSpecial">\s</span><span class="synConstant">* (?&amp;Option) )*)? </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">\]</span>
<span class="synLinenum">   24</span> <span class="synConstant">        )</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">        (?&lt;Args&gt;     (?: </span><span class="synSpecial">&#92;{</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?&amp;Element)* </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">&#92;}</span><span class="synConstant"> )*</span>
<span class="synLinenum">   27</span> <span class="synConstant">        )</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        (?&lt;Option&gt;   </span><span class="synSpecial">\s</span><span class="synConstant">* [^][</span><span class="synSpecial">$</span><span class="synConstant">&amp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">,]+</span>
<span class="synLinenum">   30</span> <span class="synConstant">        )</span>
<span class="synLinenum">   31</span> 
<span class="synLinenum">   32</span> <span class="synConstant">        (?&lt;Literal&gt;  </span><span class="synSpecial">\s</span><span class="synConstant">* ([^][</span><span class="synSpecial">$</span><span class="synConstant">&amp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">]+)</span>
<span class="synLinenum">   33</span> <span class="synConstant">        )</span>
<span class="synLinenum">   34</span> <span class="synConstant">    )</span>
<span class="synLinenum">   35</span> <span class="synConstant">}xms;</span>
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span> <span class="synConstant">my </span><span class="synIdentifier">$input</span><span class="synConstant"> = do{ local </span><span class="synIdentifier">$/</span><span class="synConstant">; &lt;&gt;};</span>
<span class="synLinenum">   38</span> <span class="synConstant">if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$regexp</span><span class="synConstant">) {</span>
<span class="synLinenum">   39</span> <span class="synConstant">  say "</span><span class="synIdentifier">$@</span>: matches:\n<span class="synIdentifier">$&amp;</span><span class="synConstant">";</span>
<span class="synLinenum">   40</span> <span class="synConstant">}</span>
<span class="synLinenum">   41</span> <span class="synConstant">else {</span>
<span class="synLinenum">   42</span> <span class="synConstant">  say "</span>does <span class="synStatement">not</span> match<span class="synConstant">";</span>
<span class="synLinenum">   43</span> <span class="synConstant">}</span>
</pre>

<P>
Añadimos una acción semántica al final de la aceptación de un <code>&lt;Command&gt;</code>.

<P>
<PRE>
         (?&lt;Command&gt;  \\ \s* (?&lt;L&gt;(?&amp;Literal)) \s* (?&lt;Op&gt;(?&amp;Options)?) \s* (?&lt;A&gt;(?&amp;Args)?)
            (?{
               say "command: &lt;$+{L}&gt; options: &lt;$+{Op}&gt; args: &lt;$+{A}&gt;"
            })
         )
</PRE>
Esta acción es ejecutada pero no afecta al proceso de análisis.
(véase la sección
<A HREF="#subsection:codigoenregexp">3.2.8</A> para mas información sobre las acciones semánticas
en medio de una regexp).
La acción se limita a mostrar que ha casado con cada una de las tres componentes:
el comando, las opciones y los argumentos.

<P>
Los paréntesis adicionales, como en <code>(?&lt;L&gt;(?&amp;Literal))</code> son necesarios 
para guardar lo que casó.

<P>
Cuando se ejecuta produce la siguiente salida<A NAME="tex2html208"
  HREF="footnode.html#foot5052"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN></SUP></A>: <PRE>
pl@nereida:~/Lperltesting$ cat prueba.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba.tex
command: &lt;documentclass&gt; options: &lt;[a4paper,11pt]&gt; args: &lt;{article}&gt;
command: &lt;usepackage&gt; options: &lt;&gt; args: &lt;{latexsym}&gt;
command: &lt;author&gt; options: &lt;&gt; args: &lt;{D. Conway}&gt;
command: &lt;LaTeX&gt; options: &lt;&gt; args: &lt;{}&gt;
command: &lt;title&gt; options: &lt;&gt; args: &lt;{Parsing \LaTeX{}}&gt;
command: &lt;begin&gt; options: &lt;&gt; args: &lt;{document}&gt;
command: &lt;maketitle&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;tableofcontents&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;section&gt; options: &lt;&gt; args: &lt;{Description}&gt;
command: &lt;emph&gt; options: &lt;&gt; args: &lt;{necessarily}&gt;
command: &lt;footnote&gt; options: &lt;&gt; args: &lt;{But not\\ \emph{necessarily} simple}&gt;
command: &lt;end&gt; options: &lt;&gt; args: &lt;{document}&gt;
: matches:
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}
</PRE>
La siguiente entrada <code>prueba3.tex</code> no pertenece
al lenguaje definido por el patrón regular,
debido a la presencia de la cadena <code>$In$</code>
en la última línea:
<PRE>
pl@nereida:~/Lperltesting$ cat prueba3.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
\comm{a}{b}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
$In$ fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba3.tex
command: &lt;documentclass&gt; options: &lt;[a4paper,11pt]&gt; args: &lt;{article}&gt;
command: &lt;usepackage&gt; options: &lt;&gt; args: &lt;{latexsym}&gt;
command: &lt;author&gt; options: &lt;&gt; args: &lt;{D. Conway}&gt;
command: &lt;LaTeX&gt; options: &lt;&gt; args: &lt;{}&gt;
command: &lt;title&gt; options: &lt;&gt; args: &lt;{Parsing \LaTeX{}}&gt;
command: &lt;begin&gt; options: &lt;&gt; args: &lt;{document}&gt;
command: &lt;maketitle&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;tableofcontents&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;section&gt; options: &lt;&gt; args: &lt;{Description}&gt;
command: &lt;comm&gt; options: &lt;&gt; args: &lt;{a}{b}&gt;
command: &lt;emph&gt; options: &lt;&gt; args: &lt;{necessarily}&gt;
command: &lt;footnote&gt; options: &lt;&gt; args: &lt;{But not\\ \emph{necessarily} simple}&gt;
does not match
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN></B> &nbsp; 
<I>Obsérvese el uso del cuantificador posesivo en:
</I><PRE>
 10          (?&lt;File&gt;     (?&amp;Element)*+\s*
 11          )
</PRE><I>
¿Que ocurrre si se quita el posesivo 
y se vuelve a ejecutar <code>$ ./latex5_10.pl prueba3.tex</code>?</I></DIV><P></P>

<P>

<H4><A NAME="SECTION04325060000000000000">
Reconocimiento de Expresiones Aritméticas</A>
</H4>
  

<P>
Véase el nodo <A NAME="tex2html210"
  HREF="http://www.perlmonks.org/?node_id=585167">Complex regex for maths formulas</A>
en perlmonks
para la formulación del problema. Un monje pregunta:

<P>
<BLOCKQUOTE><I>Hiya monks,
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than <code>a-z,A-Z,0-9,+,-,*,/,(,)</code> can be used
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Can anyone offer a hand on how best to tackle this problem?
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>many thanks 
</I></BLOCKQUOTE> 

<P>
La solución parte de que una <I>expresión</I> es o bien un <I>término</I> o bien 
un <I>término</I> seguido de una operador y un <I>término</I>, esto es:

<P>

<UL>
<LI><code>termino</code>
</LI>
<LI><code>termino op termino op termino</code> ...
</LI>
</UL>
que puede ser unificado como <code>termino (op termino)*</code>.

<P>
Un <I>término</I> es un número o un identificador o una <I>expresión</I>
entre paréntesis, esto es:

<P>

<UL>
<LI><code>numero</code>
</LI>
<LI><code>identificador</code>
</LI>
<LI><code> ( expresión ) </code>
</LI>
</UL>

<P>
La siguiente expresión regular recursiva sigue esta idea:

<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    7</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;EXPR&gt;</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">&lt;TERM&gt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;ID&gt;</span><span class="synSpecial">[a-zA-Z]+)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;INT&gt;</span><span class="synSpecial">[1-9]\d*)</span>
<span class="synLinenum">   12</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\(</span>
<span class="synLinenum">   13</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">&amp;EXPR</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\)</span>
<span class="synLinenum">   15</span> <span class="synConstant">                     </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant">           # possibly followed by a sequence of </span><span class="synSpecial">...</span>
<span class="synLinenum">   16</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">&lt;OP&gt;</span><span class="synSpecial">[-+*/])</span>
<span class="synLinenum">   17</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">&amp;TERM</span><span class="synSpecial">)</span><span class="synConstant">        # </span><span class="synSpecial">...</span><span class="synConstant"> operand TERM pairs</span>
<span class="synLinenum">   18</span> <span class="synConstant">                       </span><span class="synSpecial">)*</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   20</span> <span class="synConstant">            }x</span>;
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   22</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   25</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   26</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   28</span>               );
<span class="synLinenum">   29</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   30</span>     say(<span class="synConstant">"</span><span class="synIdentifier">$_</span><span class="synConstant">:"</span>);
<span class="synLinenum">   31</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">"</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is valid"</span> : <span class="synConstant">"</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is not valid"</span>)
<span class="synLinenum">   32</span>   }
</pre>
Podemos usar acciones semánticas empotradas para 
ver la forma en la que trabaja la expresión regular
(véase la sección
<A HREF="#subsection:codigoenregexp">3.2.8</A>):

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">   10</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;EXPR&gt;</span>
<span class="synLinenum">   11</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">&lt;TERM&gt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   12</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;ID&gt;</span><span class="synSpecial">[a-zA-Z]+)</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">{ print "</span><span class="synSpecial">[ID $+{ID}]</span><span class="synConstant"> "  }</span>)
<span class="synLinenum">   13</span>                           | <span class="synIdentifier">$skip</span> (?<span class="synIdentifier">&lt;INT&gt;</span>[<span class="synConstant">1-9</span>]\d*)  (?{ <span class="synStatement">print</span> <span class="synConstant">"[INT </span><span class="synIdentifier">$+</span><span class="synConstant">{INT}] "</span> })
<span class="synLinenum">   14</span>                           | <span class="synIdentifier">$skip</span> \(                (?{ <span class="synStatement">print</span> <span class="synConstant">"[(] "</span> })
<span class="synLinenum">   15</span>                             <span class="synIdentifier">$skip</span>  (?<span class="synIdentifier">&amp;EXPR</span>)
<span class="synLinenum">   16</span>                             <span class="synIdentifier">$skip</span> \)                (?{ <span class="synStatement">print</span> <span class="synConstant">"[)] "</span> })
<span class="synLinenum">   17</span>                      ) (?: <span class="synIdentifier">$skip</span>           <span class="synComment"># possibly followed by a sequence of ...</span>
<span class="synLinenum">   18</span>                            (?<span class="synIdentifier">&lt;OP&gt;</span>[-+*/])            (?{ <span class="synStatement">print</span> <span class="synConstant">"[OP </span><span class="synIdentifier">$+</span><span class="synConstant">{OP}] "</span> })
<span class="synLinenum">   19</span>                            (?<span class="synIdentifier">&amp;TERM</span>)        <span class="synComment"># ... operand TERM pairs</span>
<span class="synLinenum">   20</span>                        )*
<span class="synLinenum">   21</span>               )
<span class="synLinenum">   22</span>             }x;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   24</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   28</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   29</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   30</span>               );
<span class="synLinenum">   31</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   32</span>     say(<span class="synConstant">"</span><span class="synIdentifier">$_</span><span class="synConstant">:"</span>);
<span class="synLinenum">   33</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">"</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is valid"</span> : <span class="synConstant">"</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is not valid"</span>)
<span class="synLinenum">   34</span>   }
</pre>

<P>
Ejecución:

<P>
<PRE>
pl@nereida:~/Lperltesting$ ./simpleexpressions.pl
(a + 3):
[(] [ID a] [OP +] [INT 3] [)]
&lt;(a + 3)&gt; is valid
(3 * 4)+(b + x):
[(] [INT 3] [OP *] [INT 4] [)] [OP +] [(] [ID b] [OP +] [ID x] [)]
&lt;(3 * 4)+(b + x)&gt; is valid
(5 - a)*z:
[(] [INT 5] [OP -] [ID a] [)] [OP *] [ID z]
&lt;(5 - a)*z&gt; is valid
((5 - a))*((((z)))+2):
[(] [(] [INT 5] [OP -] [ID a] [)] [)] [OP *] [(] [(] [(] [(] [ID z] [)] [)] [)] [OP +] [INT 2] [)]
&lt;((5 - a))*((((z)))+2)&gt; is valid
3 + 2:
[INT 3] [OP +] [INT 2]
&lt;3 + 2&gt; is valid
!3 + 2:

&lt;!3 + 2&gt; is not valid
3 + 2!:
[INT 3] [OP +] [INT 2]
&lt;3 + 2!&gt; is not valid
3 a:
[INT 3]
&lt;3 a&gt; is not valid
3 3:
[INT 3]
&lt;3 3&gt; is not valid
3 * * 3:
[INT 3] [OP *]
&lt;3 * * 3&gt; is not valid
2 - 3 * 4:
[INT 2] [OP -] [INT 3] [OP *] [INT 4]
&lt;2 - 3 * 4&gt; is valid
2 - 3 + 4:
[INT 2] [OP -] [INT 3] [OP +] [INT 4]
&lt;2 - 3 + 4&gt; is valid
</PRE>

<P>

<H2><A NAME="SECTION04326000000000000000"></A>
<A NAME="subsection:cuantificadoresposesivos"></A>
<BR>
Cuantificadores Posesivos
</H2>

<P>
Por defecto, cuando un subpatrón con un cuantificador impide que 
el patrón global tenga éxito, se produce un backtrack.
Hay ocasiones en las que esta conducta 
da lugar a ineficiencia.

<P>
Perl 5.10 provee los cuantificadores posesivos:
Un cuantificador posesivo actúa como un cuantificador greedy
pero no se produce backtracking.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>*+</code></TD>
<TD ALIGN="LEFT">Casar 0 o mas veces y no retroceder</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>++</code></TD>
<TD ALIGN="LEFT">Casar 1 o mas veces y no retroceder</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>?+</code></TD>
<TD ALIGN="LEFT">Casar 0 o 1 veces y no retroceder</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>{n}+</code></TD>
<TD ALIGN="LEFT">Casar exactamente n veces y no retroceder (redundante)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>{n,}+</code></TD>
<TD ALIGN="LEFT">Casar al menos n veces y no retroceder</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><code>{n,m}+</code></TD>
<TD ALIGN="LEFT">Casar al menos n veces y no mas de m veces y no retroceder</TD>
</TR>
</TABLE>
Por ejemplo, la cadena <code>'aaaa'</code> no casa con <code>/(a++a)/</code> porque no 
hay retroceso después de leer las 4 aes:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x 'aaaa' =~ /(a+a)/
0  'aaaa'
  DB&lt;2&gt; x 'aaaa' =~ /(a++a)/
  empty array
</PRE>

<P>

<H4><A NAME="SECTION04326010000000000000">
Cadenas Delimitadas por Comillas Dobles</A>
</H4>
  

<P>
Los operadores posesivos sirven para poder escribir expresiones regulares mas eficientes
en aquellos casos en los que sabemos que el retroceso no conducirá a nuevas soluciones, como
es el caso del reconocimiento de las cadenas delimitadas por 
comillas dobles:

<P>
<PRE>
pl@nereida:~/Lperltesting$ cat -n ./quotedstrings.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
     2  use v5.10;
     3
     4  my $regexp = qr/
     5    "             # double quote
     6    (?:           # no memory
     7        [^"\\]++  # no " or escape: Don't backtrack
     8      | \\.       # escaped character
     9    )*+
    10    "             # end double quote
    11  /x;
    12
    13  my $input = &lt;&gt;;
    14  chomp($input);
    15  if ($input =~ $regexp) {
    16    say "$&amp; is a string";
    17  }
    18  else {
    19    say "does not match";
    20  }
</PRE>

<P>

<H4><A NAME="SECTION04326020000000000000">
Paréntesis Posesivos</A>
</H4>
  

<P>
Los paréntesis posesivos <code>(?&gt; ...)</code> dan lugar a un reconocedor 
que rechaza las demandas de retroceso. 
De hecho, los operadores posesivos pueden ser reescritos 
en términos de los paréntesis posesivos:
La notación <code>X++</code> es equivalente a <code>(?&gt;X+)</code>.

<P>

<H4><A NAME="SECTION04326030000000000000">
Paréntesis Balanceados</A>
</H4>
  

<P>
El siguiente ejemplo reconoce el lenguaje de los paréntesis balanceados:
<PRE>
pl@nereida:~/Lperltesting$ cat -n ./balancedparenthesis.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3
 4  my $regexp =
 5      qr/^(
 6             [^()]*+ # no hay paréntesis, no backtrack
 7            \(
 8                (?&gt;        # subgrupo posesivo
 9                   [^()]++ # no hay paréntesis, + posesivo, no backtrack
10                  |(?1)    # o es un paréntesis equilibrado
11                )*
12             \)
13             [^()]*+ # no hay paréntesis
14           )$/x;
15
16  my $input = &lt;&gt;;
17  chomp($input);
18  if ($input =~ $regexp) {
19    say "$&amp; is a balanced parenthesis";
20  }
21  else {
22    say "does not match";
23  }
</PRE>
Cuando se ejecuta produce una salida como:
<PRE>
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5)*2
(2*(3+4)-5)*2 is a balanced parenthesis
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5))*2
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
2*(3+4
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
4*(2*(3+4)-5)*2
4*(2*(3+4)-5)*2 is a balanced parenthesis
</PRE>

<P>

<H4><A NAME="SECTION04326040000000000000">
Encontrando los bloques de un programa</A>
</H4>
  

<P>
El uso de los operadores posesivos nos permite reescribir 
la solución al problema de encontrar los bloques maximales
de un código dada en la
sección
<A HREF="#parrafo:bloquesanidados">3.2.5</A>
de la siguiente manera:

<P>

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocksopti</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">    </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">      </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">         </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">         |</span>
<span class="synLinenum">   13</span> <span class="synConstant">             </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">      # recursivo</span>
<span class="synLinenum">   14</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   15</span> <span class="synConstant">         </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   16</span> <span class="synConstant">       </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   17</span> <span class="synConstant">    </span><span class="synSpecial">)</span>
<span class="synLinenum">   18</span> <span class="synConstant">  }</span>;
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   21</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   22</span> <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   23</span> <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   24</span> say(<span class="synIdentifier">$i</span>++.<span class="synConstant">":</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">==="</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>

<P>

<H4><A NAME="SECTION04326050000000000000">
Véase también</A>
</H4>
  

<P>

<UL>
<LI><A NAME="tex2html211"
  HREF="http://www.regular-expressions.info/possessive.html">Possessive Quantifiers</A>
en 
<A NAME="tex2html212"
  HREF="http://www.regular-expressions.info/tutorial.html">http://www.regular-expressions.info/</A>
</LI>
<LI>Nodo <SPAN  CLASS="textit">Possessive Quantifiers in Perl 5.10 regexps</SPAN> en <A NAME="tex2html213"
  HREF="http://www.perlmonks.org/?node_id=793521">PerlMonks</A>
</LI>
<LI>perldoc <A NAME="tex2html214"
  HREF="http://search.cpan.org/perldoc/?perlre"><TT>perlre</TT></A>
</LI>
</UL>

<P>

<H2><A NAME="SECTION04327000000000000000">
Perl 5.10: Numeración de los Grupos en Alternativas</A>
</H2>

<P>
A veces conviene tener una forma de acceso 
uniforme a la lista proporcionada por los paréntesis con memoria.
Por ejemplo, la siguiente expresión regular reconoce el 
lenguaje de las horas en notaciones civil y militar:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; '23:12' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print "1-&gt;$1 2-&gt;$2\n"
1-&gt;23 2-&gt;12

  DB&lt;2&gt; '2312' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print "3-&gt;$3 4-&gt;$4\n"
3-&gt;23 4-&gt;12
</PRE>
Parece inconveniente tener los resultados en variables distintas.
El constructo <code>(?| ...)</code> hace que los paréntesis se enumeren
relativos a las alternativas:

<P>
<PRE>
  DB&lt;3&gt; '2312' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print "1-&gt;$1 2-&gt;$2\n"
1-&gt;23 2-&gt;12

  DB&lt;4&gt; '23:12' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print "1-&gt;$1 2-&gt;$2\n"
1-&gt;23 2-&gt;12
</PRE>
Ahora en ambos casos <code>$1</code> y <code>$2</code> contienen las horas y minutos.

<P>

<H2><A NAME="SECTION04328000000000000000"></A>
<A NAME="subsection:codigoenregexp"></A>
<BR>
Ejecución de Código dentro de una Expresión Regular
</H2>

<P>
Es posible introducir código Perl dentro de una expresión regular.
Para ello se usa la notación <code>(?{code})</code>.

<P>
El siguiente texto esta tomado de la sección 'A-bit-of-magic:-executing-Perl-code-in-a-regular-expression' en <A NAME="tex2html215"
  HREF="http://perldoc.perl.org/perlretut.html#A-bit-of-magic:-executing-Perl-code-in-a-regular-expression"><TT>perlretut</TT></A>:

<P>
<BLOCKQUOTE><I>Normally, regexps are a part of Perl expressions. Code evaluation
expressions turn that around by allowing arbitrary Perl code to be a
part of a regexp. A code evaluation expression is denoted (?code),
with code a string of Perl statements.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Be warned that this feature is considered experimental, and may be
changed without notice.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Code expressions are zero-width assertions, and the value they return
depends on their environment. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>There are two possibilities: either the
code expression is used as a conditional in a conditional expression
<code>(?(condition)...)</code>, or it is not. 
</I></BLOCKQUOTE>
<UL>
<LI><BLOCKQUOTE>
If the code expression is a conditional,
the code is evaluated and the result (i.e., the result of the last
statement) is used to determine truth or falsehood. 
</BLOCKQUOTE>
<P>
</LI>
<LI><BLOCKQUOTE>
If the code expression
is not used as a conditional, the assertion always evaluates true and
the result is put into the special variable <code>$^R</code> . The variable <code>$^R</code> can
then be used in code expressions later in the regexp

</BLOCKQUOTE>
</LI>
</UL> 

<P>

<H4><A NAME="SECTION04328010000000000000">
Resultado de la última ejecución</A>
</H4>
  

<P>
Las expresiones de código son <A NAME="5571"></A><SPAN  CLASS="textit">zero-width assertions</SPAN>: no consumen entrada.
El resultado de la ejecución se salva en la variable especial <code>$^R</code>.

<P>
Veamos un ejemplo:

<P>
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; $x = "abcdef"
  DB&lt;2&gt; $x =~ /abc(?{ "Hi mom\n" })def(?{ print $^R })$/
Hi mom
  DB&lt;3&gt; $x =~ /abc(?{ print "Hi mom\n"; 4 })def(?{ print "$^R\n" })/
Hi mom
4
  DB&lt;4&gt; $x =~ /abc(?{ print "Hi mom\n"; 4 })ddd(?{ print "$^R\n" })/ # does not match
  DB&lt;5&gt;
</PRE>
En el último ejemplo (línea <code>DB&lt;4&gt;</code>) ninguno de los <code>print</code> se ejecuta dado que no hay matching.

<P>

<H4><A NAME="SECTION04328020000000000000">
El Código empotrado no es interpolado</A>
</H4>
  

<P>
Tomado de la sección 'Extended-Patterns' en <A NAME="tex2html216"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>:

<P>
<BLOCKQUOTE><I>This zero-width assertion evaluates any embedded Perl code. It always
succeeds, and its code  is not interpolated. Currently, the rules to
determine where the code  ends are somewhat convoluted.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION04328030000000000000">
Contenido del último paréntesis y la variable por defecto en acciones empotradas</A>
</H4>
  

<P>
Tomado de la sección 'Extended-Patterns' en <A NAME="tex2html217"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>:
<BLOCKQUOTE><I>... can be used with the special variable <code>$^N</code> to
capture the results of submatches in variables without having to keep
track of the number of nested parentheses. For example:
</I></BLOCKQUOTE>
<P><PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; $x = "The brown fox jumps over the lazy dog"
  DB&lt;2&gt; x $x =~ /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i
0  'brown'
1  'fox'
  DB&lt;3&gt; p "color=$color animal=$animal\n"
color=brown animal=fox
  DB&lt;4&gt; $x =~ /the (\S+)(?{ print (substr($_,0,pos($_)))."\n" }) (\S+)/i
The brown
</PRE>
<P>
<BLOCKQUOTE><I>Inside the <code>(?{...})</code> block, <code>$_</code> refers to the string the
regular expression is matching against. You can also use <code>pos()</code> to know
what is the current position of matching within this string.
</I></BLOCKQUOTE>

<P>

<H4><A NAME="SECTION04328040000000000000">
Los cuantificadores y el código empotrado</A>
</H4>
  

<P>
Si se usa un cuantificador sobre un código empotrado,
actúa como un bucle:

<P>
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; $x = "aaaa"
  DB&lt;2&gt;  $x =~ /(a(?{ $c++ }))*/
  DB&lt;3&gt; p $c
4
  DB&lt;4&gt; $y = "abcd"
  DB&lt;5&gt; $y =~ /(?:(.)(?{ print "-$1-\n" }))*/
-a-
-b-
-c-
-d-
</PRE>

<P>

<H4><A NAME="SECTION04328050000000000000">
Ámbito</A>
</H4>
  

<P>
Tomado (y modificado el ejemplo) de la sección 'Extended-Patterns' en <A NAME="tex2html219"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>:

<P>
<BLOCKQUOTE><I>...The code  is properly scoped in the following sense: If the
assertion is backtracked (compare la sección 'Backtracking' en <A NAME="tex2html218"
  HREF="http://perldoc.perl.org/perlre.html#Backtracking"><TT>perlre</TT></A>), all changes introduced
after localization are undone, so that
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>
<pre>
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  <span class="synStatement">use strict</span>;

  <span class="synStatement">our</span> (<span class="synIdentifier">$cnt</span>, <span class="synIdentifier">$res</span>);

<span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> echo </span>{
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$pre</span> = <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">0</span>,<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>));
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$post</span> = (<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>) &lt; <span class="synStatement">length</span>)? (<span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">1</span>+<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>))) : <span class="synConstant">''</span>;

    <span class="synStatement">print</span>(<span class="synConstant">"</span><span class="synIdentifier">$pre</span><span class="synConstant">(count = </span><span class="synIdentifier">$cnt</span><span class="synConstant">)</span><span class="synIdentifier">$post</span><span class="synSpecial">\n</span><span class="synConstant">"</span>);
  }

  <span class="synIdentifier">$_</span> = <span class="synConstant">'a'</span> x <span class="synConstant">8</span>;
  m&lt;
    (?{ <span class="synIdentifier">$cnt</span> = <span class="synConstant">0</span> }) <span class="synComment"># Initialize $cnt.</span>
    (
      a
      (?{
        <span class="synStatement">local</span> <span class="synIdentifier">$cnt</span> = <span class="synIdentifier">$cnt</span> + <span class="synConstant">1</span>; <span class="synComment"># Update $cnt, backtracking-safe.</span>
        echo();
      })
    )*
    aaaa
    (?{ <span class="synIdentifier">$res</span> = <span class="synIdentifier">$cnt</span> }) <span class="synComment"># On success copy to non-localized</span>
    <span class="synComment"># location.</span>
  &gt;x;

  <span class="synStatement">print</span> <span class="synConstant">"FINAL RESULT: cnt = </span><span class="synIdentifier">$cnt</span><span class="synConstant"> res =</span><span class="synIdentifier">$res</span><span class="synSpecial">\n</span><span class="synConstant">"</span>;
</pre>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>will set <code>$res = 4</code> . Note that after the match, <code>$cnt</code> returns to the
globally introduced value, because the scopes that restrict local
operators are unwound.
</I></BLOCKQUOTE><PRE>
pl@nereida:~/Lperltesting$ perl5.8.8 -w embededcodescope.pl
a(count = 1)aaaaaa
aa(count = 2)aaaaa
aaa(count = 3)aaaa
aaaa(count = 4)aaa
aaaaa(count = 5)aa
aaaaaa(count = 6)a
aaaaaaa(count = 7)
aaaaaaaa(count = 8)
FINAL RESULT: cnt = 0 res =4
</PRE>

<P>

<H4><A NAME="SECTION04328060000000000000">
Caveats</A>
</H4>
  

<P>

<UL>
<LI>
<BLOCKQUOTE><I>Due to an unfortunate implementation issue, the Perl code contained
in these blocks is treated as a compile time <A NAME="tex2html220"
  HREF="http://en.wikipedia.org/wiki//Closure_(computer_science)">closure</A>
that can have
seemingly bizarre consequences when used with <A NAME="tex2html221"
  HREF="http://en.wikipedia.org/wiki/Static_scoping_.28also_known_as_lexical_scoping.29">lexically scoped variables</A>
inside of subroutines or loops. There are various workarounds for this,
including simply using global variables instead. If you are using this
construct and strange results occur then check for the use of lexically
scoped variables.
</I></BLOCKQUOTE>
</LI>
<LI>
<BLOCKQUOTE><I>For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous <code>use re 'eval'</code> pragma has been used (see <A NAME="tex2html222"
  HREF="http://search.cpan.org/perldoc?re"><TT>re</TT></A>),
or the variables
contain results of <code>qr//</code> operator (see <code>"qr/STRING/imosx"</code> in 
<A NAME="tex2html223"
  HREF="http://search.cpan.org/perldoc/?perlop"><TT>perlop</TT></A>).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This restriction is due to the wide-spread and remarkably convenient
custom of using run-time determined strings as patterns. For example:
</I></BLOCKQUOTE>
<P><PRE>
   1. $re = &lt;&gt;;
   2. chomp $re;
   3. $string =~ /$re/;
</PRE>
<P>
<BLOCKQUOTE><I>Before Perl knew how to execute interpolated code within a pattern, this
operation was completely safe from a security point of view, although
it could raise an exception from an illegal pattern. If you turn on the
<code>use re 'eval'</code> , though, it is no longer secure, so you should only do
so if you are also using <A NAME="tex2html224"
  HREF="http://en.wikipedia.org/wiki/Taint_checking">taint</A>
checking. Better yet, use the carefully
constrained evaluation within a <A NAME="tex2html225"
  HREF="http://search.cpan.org/perldoc?Safe"><TT>Safe</TT></A>
compartment. See perlsec for details
about both these mechanisms. (Véase la sección 'Taint-mode' en <A NAME="tex2html226"
  HREF="http://perldoc.perl.org/perlsec.html#Taint-mode"><TT>perlsec</TT></A>)
</I></BLOCKQUOTE> 

<P>
</LI>
<LI>
<BLOCKQUOTE><I>Because Perl's regex engine is currently <SPAN  CLASS="textbf">not re-entrant</SPAN>, interpolated
code may not invoke the regex engine either directly with <code>m//</code> or 
<code>s///</code>, or indirectly with functions such as <A NAME="tex2html227"
  HREF="http://www.ayni.com/perldoc/functions/split.html"><TT>split</TT></A>.
</I></BLOCKQUOTE>
</LI>
</UL>

<P>

<H4><A NAME="SECTION04328070000000000000">
Depurando con código empotrado Colisiones en los Nombres de las Subexpresiones Regulares</A>
</H4>
  

<P>
Las acciones empotradas pueden utilizarse como mecanismo de 
depuración y de descubrimiento del comportamiento de nuestras expresiones 
regulares.

<P>
En el siguiente programa se produce una colisión
entre los nombres <code>&lt;i&gt;</code> y <code>&lt;j&gt;</code> de los patrones 
que ocurren en el patrón <code>&lt;expr&gt;</code>
y en el patrón principal:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$"</span> = <span class="synConstant">", "</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;i&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;j&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say "main </span><span class="synSpecial">$+</span><span class="synConstant"> hash:";</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say " </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =&gt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">" for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?&lt;expr&gt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?&lt;i&gt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?&lt;j&gt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say "</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">";</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say "</span> (<span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">" for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = &lt;&gt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say "</span>matches: (<span class="synIdentifier">$&amp;</span>)<span class="synConstant">";</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>
La colisión hace que la salida sea esta:
<PRE>
pl@nereida:~/Lperltesting$ ./clashofnamedofssets.pl
abab
expr $+ hash:
 (i =&gt; a)
 (j =&gt; b)
expr $+ hash:
 (i =&gt; ab)
 (j =&gt; b)
main $+ hash:
 (i =&gt; ab)
 (j =&gt; ab)
matches: (abab)
</PRE>
Si se evitan las colisiones, 
se evita la pérdida de información:

<pre>
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$"</span> = <span class="synConstant">", "</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;i&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;j&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say "main </span><span class="synSpecial">$+</span><span class="synConstant"> hash:";</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say " </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =&gt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">" for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?&lt;expr&gt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?&lt;i_e&gt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?&lt;j_e&gt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say "</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">";</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say "</span> (<span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">" for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = &lt;&gt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say "</span>matches: (<span class="synIdentifier">$&amp;</span>)<span class="synConstant">";</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>

<P>
que al ejecutarse produce:

<P>
<PRE>
pl@nereida:~/Lperltesting$ ./namedoffsets.pl
abab
expr $+ hash:
 (i_e =&gt; a)
 (j_e =&gt; b)
expr $+ hash:
 (i =&gt; ab)
 (i_e =&gt; a)
 (j_e =&gt; b)
main $+ hash:
 (i =&gt; ab)
 (j =&gt; ab)
matches: (abab)
</PRE>

<P>

<H2><A NAME="SECTION04329000000000000000"></A>
<A NAME="subsection:tiempodematching"></A>
<BR>
Expresiones Regulares en tiempo de matching
</H2>

<P>
Los paréntesis especiales:
<PRE>
                (??{ Código Perl })
</PRE>
hacen que el <code>Código Perl</code> sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular. El match continuará 
intentando casar con la expresión regular retornada.

<P>

<H4><A NAME="SECTION04329010000000000000">
Paréntesis con memoria dentro de una <I>pattern code expression</I></A>
</H4>
  

<P>
Los paréntesis en la expresión regular retornada no cuentan
en el patrón exterior. Véase el siguiente 
ejemplo:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              </span><span class="synSpecial">([ab])</span><span class="synConstant">             # save 'a' or 'b' in </span><span class="synSpecial">$</span><span class="synConstant">1</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(??</span><span class="synConstant">{ "</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant">"x3 }</span>)  <span class="synComment"># 3 more of the same as in $1</span>
<span class="synLinenum">    8</span>             };
<span class="synLinenum">    9</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-"</span> <span class="synStatement">if</span> <span class="synConstant">'bbbb'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   10</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-"</span> <span class="synStatement">if</span> <span class="synConstant">'aaaa'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   11</span>   say <span class="synConstant">"&lt;abab&gt; didn't match"</span> <span class="synStatement">unless</span> <span class="synConstant">'abab'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   12</span>   say <span class="synConstant">"&lt;aaab&gt; didn't match"</span> <span class="synStatement">unless</span> <span class="synConstant">'aaab'</span> =~ <span class="synIdentifier">$r</span>;
</pre>
<P>
Como se ve, hemos accedido desde el código interior 
al último paréntesis usando <code>$^N</code>.
Sigue una ejecución:
<PRE>
pl@nereida:~/Lperltesting$ ./postponedregexp.pl
&lt;bbbb&gt; lastpar = 1
&lt;aaaa&gt; lastpar = 1
&lt;abab&gt; didn't match
&lt;aaab&gt; didn't match
</PRE>

<P>

<H4><A NAME="SECTION04329020000000000000">
Ejemplo: Secuencias de dígitos de longitud especificada por el primer dígito</A>
</H4>
  

<P>
Consideremos el problema de escribir una expresión regular
que reconoce secuencias no vacías de dígitos tales que la longitud 
de la secuencia restante viene
determinada por el primer dígito.
Esta es una solución:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n intints.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">           </span><span class="synSpecial">(\d)</span><span class="synConstant">                # a digit</span>
<span class="synLinenum">    7</span> <span class="synConstant">           </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">(??</span><span class="synConstant">{</span>
<span class="synLinenum">    8</span> <span class="synConstant">               "</span><span class="synSpecial">\\</span><span class="synConstant">d{</span><span class="synIdentifier">$^</span><span class="synConstant">N}"      # as many as the former</span>
<span class="synLinenum">    9</span> <span class="synConstant">             })                # digit says</span>
<span class="synLinenum">   10</span> <span class="synConstant">           )</span>
<span class="synLinenum">   11</span> <span class="synConstant">          };</span>
<span class="synLinenum">   12</span> <span class="synConstant">say "</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">" if '3428' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   13</span> <span class="synConstant">say "</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">" if '228' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   14</span> <span class="synConstant">say "</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">" if '14' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   15</span> <span class="synConstant">say "24</span> does <span class="synStatement">not</span> match<span class="synConstant">" unless '24' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   16</span> <span class="synConstant">say "4324</span> does <span class="synStatement">not</span> match<span class="synConstant">" unless '4324' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
</pre>
<P>
Cuando se ejecuta se obtiene:
<PRE>
pl@nereida:~/Lperltesting$ ./intints.pl
&lt;3428&gt; &lt;3&gt; &lt;428&gt;
&lt;228&gt; &lt;2&gt; &lt;28&gt;
&lt;14&gt; &lt;1&gt; &lt;4&gt;
24 does not match
4324 does not match
</PRE>

<P>

<H4><A NAME="SECTION04329030000000000000">
Ejemplo: Secuencias de dígitos no repetidos</A>
</H4>
  

<P>
Otro ejemplo: queremos escribir una expresión regular que reconozca secuencias
de  <code>$n</code> dígitos en las que no todos los dígitos se repiten. Donde quizá <code>$n</code> es capturado
de un paréntesis anterior en la expresión regular. Para simplificar la ilustración
de la técnica supongamos que <code>$n = 7</code>:

<pre>
pl@nereida:~$  <span class="dbuser">perl5.10.1 -wdE 0</span>
main::(-e:1):   0
  DB&lt;1&gt;  <span class="dbuser">x join '', map { "(?!".$_."{7})" } 0..9</span>
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB&lt;2&gt;  <span class="dbuser">x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;3&gt;  <span class="dbuser">x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  7777778
  DB&lt;4&gt;  <span class="dbuser">x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;5&gt;  <span class="dbuser">x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  4422444
</pre>

<P>

<H4><A NAME="SECTION04329040000000000000">
Palíndromos con independencia del acento</A>
</H4>
  

<A NAME="parrafo:palindromospostregexp"></A>
<P>
Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
<A HREF="#parrafo:palabrapalindromos">3.2.5</A>
para reconocer los palabra-palíndromos. 

<P>
Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo <I>dábale arroz a la zorra 
el abad</I>). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion:

<P>

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat actionspanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl </span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>;
<span class="synLinenum">    7</span> <span class="synStatement">use </span>Switch;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synStatement">sub</span><span class="synIdentifier"> f </span>{
<span class="synLinenum">   10</span>   <span class="synStatement">my</span> <span class="synIdentifier">$char</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synStatement">switch</span>(<span class="synIdentifier">$char</span>) {
<span class="synLinenum">   13</span>     case [ <span class="synConstant">qw{a á}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[aá]'</span> }
<span class="synLinenum">   14</span>     case [ <span class="synConstant">qw{e é}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[eé]'</span> }
<span class="synLinenum">   15</span>     case [ <span class="synConstant">qw{i í}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[ií]'</span> }
<span class="synLinenum">   16</span>     case [ <span class="synConstant">qw{o ó}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[oó]'</span> }
<span class="synLinenum">   17</span>     case [ <span class="synConstant">qw{u ú}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[uú]'</span> }
<span class="synLinenum">   18</span>     <span class="synStatement">else</span>             { <span class="synStatement">return</span> <span class="synIdentifier">$char</span>  };
<span class="synLinenum">   19</span>   }
<span class="synLinenum">   20</span> }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">   23</span> <span class="synConstant">                            </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">-2</span><span class="synSpecial">)(??</span><span class="synConstant">{ f</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant"> }</span><span class="synSpecial">)</span>
<span class="synLinenum">   24</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant"> </span>
<span class="synLinenum">   25</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span>
<span class="synLinenum">   26</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">                $</span>
<span class="synLinenum">   28</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   31</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   32</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   33</span>   say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome"</span>;
<span class="synLinenum">   34</span> }
<span class="synLinenum">   35</span> <span class="synStatement">else</span> {
<span class="synLinenum">   36</span>   say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match"</span>;
<span class="synLinenum">   37</span> }
</pre>

<P>
Sigue un ejemplo de ejecución:

<P>

<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$<span class="dbuser"> ./actionspanishpalin.pl </span>
<span class="dbuser">éoíúaáuioé</span>
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dáed</span>
dáed does not match
</pre>

<P>

<H4><A NAME="SECTION04329050000000000000">
Postponiendo para conseguir recursividad</A>
</H4>
  

<P>
Véase el nodo <A NAME="tex2html228"
  HREF="http://www.perlmonks.org/?node_id=585167">Complex regex for maths formulas</A>
para la formulación del problema:

<P>
<BLOCKQUOTE><I>Hiya monks,
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than <code>a-z,A-Z,0-9,+,-,*,/,(,)</code> can be used
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Can anyone offer a hand on how best to tackle this problem?
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>many thanks 
</I></BLOCKQUOTE> 

<P>
La respuesta dada por <A NAME="tex2html229"
  HREF="http://www.perlmonks.org/?node_id=381608">ikegami</A>
usa <code>(?{{ ... })</code>
para conseguir una conducta recursiva en versiones de perl anteriores a la 5.10:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid_expr </span>{
<span class="synLinenum">    6</span>      <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>      <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>      <span class="synIdentifier">$skip</span> = qr! \s* !x;
<span class="synLinenum">   10</span>      <span class="synIdentifier">$term</span> = qr! <span class="synIdentifier">$skip</span> [a-zA-Z]+              <span class="synComment"># A term is an identifier</span>
<span class="synLinenum">   11</span>                | <span class="synIdentifier">$skip</span> [<span class="synConstant">1-9</span>][<span class="synConstant">0-9</span>]*            <span class="synComment"># or a number</span>
<span class="synLinenum">   12</span>                | <span class="synIdentifier">$skip</span> \( (??{ <span class="synIdentifier">$expr</span> }) <span class="synIdentifier">$skip</span> <span class="synComment"># or an expression</span>
<span class="synLinenum">   13</span>                        \)
<span class="synLinenum">   14</span>                !x;
<span class="synLinenum">   15</span>      <span class="synIdentifier">$expr</span> = qr! <span class="synIdentifier">$term</span>                         <span class="synComment"># A expr is a term</span>
<span class="synLinenum">   16</span>                  (?: <span class="synIdentifier">$skip</span> [-+*/] <span class="synIdentifier">$term</span> )*     <span class="synComment"># or a term + a term ...</span>
<span class="synLinenum">   17</span>                !x;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>      <span class="synStatement">return</span> <span class="synIdentifier">$_</span>[<span class="synConstant">0</span>] =~<span class="synStatement"> /</span><span class="synConstant"> ^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant"> </span><span class="synStatement">/x</span>;
<span class="synLinenum">   20</span>   }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">print</span>(is_valid_expr(<span class="synIdentifier">$_</span>) ? <span class="synConstant">"</span><span class="synIdentifier">$_</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">"</span> : <span class="synConstant">"</span><span class="synIdentifier">$_</span><span class="synConstant"> is not valid</span><span class="synSpecial">\n</span><span class="synConstant">"</span>) <span class="synStatement">foreach</span> (
<span class="synLinenum">   23</span>    <span class="synConstant">'(a + 3)'</span>,
<span class="synLinenum">   24</span>    <span class="synConstant">'(3 * 4)+(b + x)'</span>,
<span class="synLinenum">   25</span>    <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   26</span>    <span class="synConstant">'3 + 2'</span>,
<span class="synLinenum">   27</span> 
<span class="synLinenum">   28</span>    <span class="synConstant">'!3 + 2'</span>,
<span class="synLinenum">   29</span>    <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>    <span class="synConstant">'3 a'</span>,
<span class="synLinenum">   32</span>    <span class="synConstant">'3 3'</span>,
<span class="synLinenum">   33</span>    <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span>    <span class="synConstant">'2 - 3 * 4'</span>,
<span class="synLinenum">   36</span>    <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   37</span>   );
</pre>

<P>
Sigue el resultado de la ejecución:
<PRE>
pl@nereida:~/Lperltesting$ perl complexformula.pl
(a + 3) is valid
(3 * 4)+(b + x) is valid
(5 - a)*z is valid
3 + 2 is valid
!3 + 2 is not valid
3 + 2! is not valid
3 a is not valid
3 3 is not valid
3 * * 3 is not valid
2 - 3 * 4 is valid
2 - 3 + 4 is valid
</PRE>

<P>

<H4><A NAME="SECTION04329060000000000000">
Caveats</A>
</H4>
  

<P>
Estos son algunos puntos a tener en cuenta cuando se usan patrones postpuestos.
Véase la entrada <code>(??{ code })</code> en la sección 'Extended-Patterns' en <A NAME="tex2html232"
  HREF="http://perldoc.perl.org/perlre.html#Extended-Patterns"><TT>perlre</TT></A>:

<P>
<BLOCKQUOTE><I>WARNING: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that has
side effects may not perform identically from version to version due to
the effect of future optimisations in the regex engine.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This is a <A NAME="5662"></A><SPAN  CLASS="textbf">postponed regular subexpression</SPAN>. The code is evaluated at
run time, at the moment this subexpression may match. The result of
evaluation is considered as a regular expression and matched as if it
were inserted instead of this construct. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The code <I>is not interpolated</I>. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>As before, the rules to determine where the code ends are currently somewhat convoluted.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>Because perl's regex engine is not currently <A NAME="tex2html230"
  HREF="http://en.wikipedia.org/wiki/Reentrant_(subroutine)">re-entrant</A>, delayed code
may not invoke the regex engine either directly with <code>m//</code> or <code>s///</code>),
or indirectly with functions such as <A NAME="tex2html231"
  HREF="http://www.ayni.com/perldoc/functions/split.html"><TT>split</TT></A>.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><I>Recursing</I> deeper than 50 times without consuming any input string will
result in a fatal error. The maximum depth is compiled into perl, so
changing it requires a custom build.
</I></BLOCKQUOTE>

<P>

<H2><A NAME="SECTION043210000000000000000"></A>
<A NAME="subsection:regexpcondicionales"></A>
<BR>
Expresiones Condicionales
</H2>

<P>
Citando a <A NAME="tex2html233"
  HREF="http://search.cpan.org/perldoc/?perlre"><TT>perlre</TT></A>:

<P>
<BLOCKQUOTE><I>A conditional expression is a form of if-then-else
statement that allows one to choose which patterns are
to be matched, based on some condition. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>There are two
types of conditional expression: <code>(?(condition)yes-regexp)</code> and
<code>(?(condition)yes-regexp|no-regexp)</code>. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><code>(?(condition)yes-regexp)</code> is like an
<code>if () {}</code> statement in Perl. 
If the condition is true, the yes-regexp
will be matched. If the condition is false, the yes-regexp will be
skipped and Perl will move onto the next regexp element. 
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The second form
is like an <code>if () {} else {}</code> statement in Perl. If the condition is true,
the yes-regexp will be matched, otherwise the no-regexp will be matched.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The condition can have several forms. 
</I></BLOCKQUOTE>
<UL>
<LI>The first form is simply an
integer in parentheses (integer). It is true if the corresponding
backreference <code>\integer</code> matched earlier in the regexp. The same thing
can be done with a name associated with a capture buffer, written as
<code>(&lt;name&gt;)</code> or <code>('name')</code>. 
</LI>
<LI>The second form is a bare zero width assertion
<code>(?...)</code>, either a lookahead, a lookbehind, or a code assertion. 

<P>
</LI>
<LI>The third set of forms provides tests that return
true if the expression is executed within a recursion <code>(R)</code> or is being
called from some capturing group, referenced either by number <code>(R1</code>,
or by name <code>(R&amp;name)</code>.
</LI>
</UL>

<P>

<H4><A NAME="SECTION043210010000000000000">
Condiciones: número de paréntesis</A>
</H4>
  

<P>
Una expresión condicional puede adoptar diversas formas.
La mas simple es un entero en paréntesis. 
Es cierta si la correspondiente referencia 
<code>\integer</code> casó (también se puede usar un nombre
si se trata de un paréntesis con nombre). 

<P>
En la expresión regular <code>/^(.)(..)?(?(2)a|b)/</code> si el segundo paréntesis
casa, la cadena debe ir seguida de una <code>a</code>, si no casa deberá ir seguida de 
una <code>b</code>: 

<P>
<PRE>
  DB&lt;1&gt; x 'hola' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  'ol'
  DB&lt;2&gt; x 'ha' =~ /^(.)(..)?(?(2)a|b)/
  empty array
  DB&lt;3&gt; x 'hb' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  undef
</PRE>

<P>

<H4><A NAME="SECTION043210020000000000000">
Ejemplo: cadenas de la forma <I>una</I>-otra-otra-<I>una</I></A>
</H4>
  

<P>
La siguiente búsqueda casa con patrones de la forma 
<code>$x$x</code> o <code>$x$y$y$x</code>:

<P>
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x 'aa' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  undef
  DB&lt;2&gt; x 'abba' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  'b'
  DB&lt;3&gt; x 'abbc' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
  empty array
  DB&lt;4&gt; x 'juanpedropedrojuan' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'juan'
1  'pedro'
</PRE>

<P>

<H4><A NAME="SECTION043210030000000000000">
Condiciones: Código</A>
</H4>
  

<P>
Una expresión condicional también puede ser un código:
<PRE>
  DB&lt;1&gt; $a = 0; print "$&amp;" if 'hola' =~ m{(?(?{$a})hola|adios)} # No hay matching

  DB&lt;2&gt; $a = 1; print "$&amp;" if 'hola' =~ m{(?(?{$a})hola|adios)}
hola
</PRE>

<P>

<H4><A NAME="SECTION043210040000000000000">
Ejemplo: Cadenas con posible paréntesis inicial (no anidados)</A>
</H4>
  

<P>
La siguiente expresión regular utiliza un condicional
para forzar a que si una cadena comienza por un paréntesis
abrir termina con un paréntesis cerrar. Si la cadena 
no comienza por paréntesis abrir no debe existir un paréntesis
final de cierre:

<P>

<pre>
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              ^</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">\(</span><span class="synConstant"> </span><span class="synSpecial">)?</span><span class="synConstant">            # may be it comes an open par</span>
<span class="synLinenum">    8</span> <span class="synConstant">              </span><span class="synSpecial">[^()]+</span><span class="synConstant">             # no parenthesis</span>
<span class="synLinenum">    9</span> <span class="synConstant">              </span><span class="synSpecial">(?(</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">              # did we sart with par</span><span class="synSpecial">?</span>
<span class="synLinenum">   10</span> <span class="synConstant">                </span><span class="synSpecial">\)</span><span class="synConstant">               # if yes then close par</span>
<span class="synLinenum">   11</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> <span class="synConstant">              $</span>
<span class="synLinenum">   13</span> <span class="synConstant">            }</span>;
<span class="synLinenum">   14</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt;"</span> <span class="synStatement">if</span> <span class="synConstant">'(abcd)'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   15</span>   say <span class="synConstant">"&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt;"</span> <span class="synStatement">if</span> <span class="synConstant">'abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   16</span>   say <span class="synConstant">"&lt;(abc&gt; does not match"</span> <span class="synStatement">unless</span> <span class="synConstant">'(abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   17</span>   say <span class="synConstant">"&lt;abc)&gt; does not match"</span> <span class="synStatement">unless</span> <span class="synConstant">'abc)'</span> =~ <span class="synIdentifier">$r</span>;
</pre>
<P>
Al ejecutar este programa se obtiene:
<PRE>
pl@nereida:~/Lperltesting$ ./conditionalregexp.pl
&lt;(abcd)&gt;
&lt;abc&gt;
&lt;(abc&gt; does not match
&lt;abc)&gt; does not match
</PRE>

<P>

<H4><A NAME="SECTION043210050000000000000">
Expresiones Condicionales con <TT>(R)</TT></A>
</H4>
  

<P>
El siguiente ejemplo muestra el uso de la condición <code>(R)</code>, la cual comprueba 
si la expresión ha sido evaluada dentro de una recursión:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; x 'bbaaaabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbaaaabb'
  DB&lt;2&gt; x 'bb' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB&lt;3&gt; x 'bab' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB&lt;4&gt; x 'bbabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbabb'
</PRE>
La sub-expresión regular <code>(?(R)a+|(?0))</code> dice:
si  esta siendo evaluada recursivamente admite <code>a+</code>
si no, evalúa la regexp completa recursivamente.

<P>

<H4><A NAME="SECTION043210060000000000000">
Ejemplo: Palíndromos con Equivalencia de Acentos Españoles</A>
</H4>
  

<P>
Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
<A HREF="#parrafo:palabrapalindromos">3.2.5</A>
para reconocer los palabra-palíndromos<A NAME="tex2html234"
  HREF="footnode.html#foot4968"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN></SUP></A>. Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo <I>dábale arroz a la zorra 
el abad</I>). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion parcial (por
consideraciones de legibilidad sólo se consideran las vocales <code>a</code>
y <code>o</code>:

<P>

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat spanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(?</span><span class="synConstant">&lt;pal&gt;</span><span class="synSpecial">\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">    8</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">&lt;L&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&lt;a&gt;</span><span class="synSpecial">[áa])</span><span class="synConstant">|</span><span class="synSpecial">(?</span><span class="synConstant">&lt;e&gt;</span><span class="synSpecial">[ée])</span><span class="synConstant">|</span><span class="synSpecial">\w)</span><span class="synConstant"> # letter</span>
<span class="synLinenum">    9</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">&amp;pal</span><span class="synSpecial">)</span><span class="synConstant">                        # nested palindrome</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synSpecial">(?(</span><span class="synConstant">&lt;a&gt;</span><span class="synSpecial">)[áa]</span><span class="synConstant">                    # if is an "a" group</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                  |</span><span class="synSpecial">(?:((?</span><span class="synConstant">&lt;e&gt;</span><span class="synSpecial">)[ée]</span><span class="synConstant">          # if is an "e" group</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                            |</span><span class="synSpecial">\g</span><span class="synConstant">{L}         # exact match</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">)</span><span class="synConstant">                    # end if </span><span class="synSpecial">[ée]</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   </span><span class="synSpecial">)</span><span class="synConstant">                       # end group</span>
<span class="synLinenum">   15</span> <span class="synConstant">                            </span><span class="synSpecial">)</span><span class="synConstant">                              # end if </span><span class="synSpecial">[áa]</span>
<span class="synLinenum">   16</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant">                            # non rec</span><span class="synSpecial">.</span><span class="synConstant"> case</span>
<span class="synLinenum">   17</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span><span class="synConstant">                                # punctuation symbols</span>
<span class="synLinenum">   18</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">                $</span>
<span class="synLinenum">   20</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   25</span>   say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome"</span>;
<span class="synLinenum">   26</span> }
<span class="synLinenum">   27</span> <span class="synStatement">else</span> {
<span class="synLinenum">   28</span>   say <span class="synConstant">"</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match"</span>;
<span class="synLinenum">   29</span> }
</pre>

<P>
Ejecución:

<P>

<pre>
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">óuuo</span>
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">éaáe</span>
éaáe is a palindrome
</pre>

<P>
Hemos usado la opción <code>-CIOEioA</code> para asegurarnos
que los ficheros de entrada/saldia y error y la línea de
comandos estan en modo UTF-8.
(Véase la sección <A HREF="node24.html#section:unicode"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>)

<P>
Esto es lo que dice la documentación de <A NAME="tex2html235"
  HREF="http://search.cpan.org/perldoc/?perlrun "><TT>perlrun </TT></A>
al respecto:

<P>
<BLOCKQUOTE><I>The <code>-C</code> flag controls some of the Perl Unicode features.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>As of 5.8.1, the <code>-C</code> can be followed either by a number or a list of option
letters. The letters, their numeric values, and effects are as follows;
listing the letters is equal to summing the numbers.
</I></BLOCKQUOTE>
<P><PRE>
  1   I 1 STDIN is assumed to be in UTF-8
  2   O 2 STDOUT will be in UTF-8
  3   E 4 STDERR will be in UTF-8
  4   S 7 I + O + E
  5   i 8 UTF-8 is the default PerlIO layer for input streams
  6   o 16 UTF-8 is the default PerlIO layer for output streams
  7   D 24 i + o
  8   A 32 the @ARGV elements are expected to be strings encoded
  9   in UTF-8
 10   L 64 normally the "IOEioA" are unconditional,
 11   the L makes them conditional on the locale environment
 12   variables (the LC_ALL, LC_TYPE, and LANG, in the order
 13   of decreasing precedence) -- if the variables indicate
 14   UTF-8, then the selected "IOEioA" are in effect
 15   a 256 Set ${^UTF8CACHE} to -1, to run the UTF-8 caching code in
 16   debugging mode.
</PRE>
<P>
<BLOCKQUOTE><I>For example, <code>-COE</code> and <code>-C6</code> will both turn on UTF-8-ness
on both <code>STDOUT</code> and <code>STDERR</code>. Repeating letters is just redundant, not
cumulative nor toggling.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The io options mean that any subsequent <code>open()</code> (or similar I/O operations)
will have the <code>:utf8</code> PerlIO layer implicitly applied to them, in other
words, <code>UTF-8</code> is expected from any input stream, and <code>UTF-8</code> is produced
to any output stream. This is just the default, with explicit layers in
<code>open()</code> and with <code>binmode()</code> one can manipulate streams as usual.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I><code>-C</code> on its own (not followed by any number or option list), or the empty string 
<code>""</code> for the <code>PERL_UNICODE</code> environment variable, has the same effect as <code>-CSDL</code> . 
In other words, the standard I/O handles and the default<code>open()</code> layer are 
UTF-8-fied but only if the locale environment variables indicate a
UTF-8 locale. This behaviour follows the implicit (and problematic)
UTF-8 behaviour of Perl 5.8.0.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>You can use <code>-C0</code> (or <code>0</code> for <code>PERL_UNICODE</code> ) to explicitly disable all
the above Unicode features.
</I></BLOCKQUOTE>

<P>
El pragma <code>use utf8</code> hace que se utilice una semántica de
carácteres (por ejemplo, la regexp <code>/./</code> casará con un carácter unicode), el
pragma <code>use bytes</code> cambia de semántica de caracteres
a semántica de bytes (la regexp <code>.</code> casará con un byte).

<P>

<pre>
lhp<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperl</span><span class="synStatement">/s</span>rc/testing$ cat -n dot_utf8_2.pl
     <span class="synConstant">1</span>  <span class="synComment">#!/usr/local/bin/perl -w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use strict</span>;
     <span class="synConstant">3</span>  <span class="synStatement">use utf8</span>;
     <span class="synConstant">4</span>  <span class="synStatement">use </span>charnames <span class="synConstant">qw{greek}</span>;
     <span class="synConstant">5</span>
     <span class="synConstant">6</span>  <span class="synStatement">binmode</span>(<span class="synIdentifier">STDOUT</span>, <span class="synConstant">':utf8'</span>);
     <span class="synConstant">7</span>
     <span class="synConstant">8</span>  <span class="synStatement">my</span> <span class="synIdentifier">$x</span> = <span class="synConstant">'αβγδεφ'</span>;
     <span class="synConstant">9</span>
    <span class="synConstant">10</span>  <span class="synStatement">my</span> <span class="synIdentifier">@w</span> = <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">11</span>  <span class="synStatement">print</span> <span class="synConstant">"</span><span class="synIdentifier">@w</span><span class="synSpecial">\n</span><span class="synConstant">"</span>;
    <span class="synConstant">12</span>
    <span class="synConstant">13</span>  {
    <span class="synConstant">14</span>    <span class="synStatement">use </span>bytes;
    <span class="synConstant">15</span>    <span class="synStatement">my</span> <span class="synIdentifier">@v</span> = <span class="synStatement">map</span> { <span class="synStatement">ord</span> } <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">16</span>    <span class="synStatement">print</span> <span class="synConstant">"</span><span class="synIdentifier">@v</span><span class="synSpecial">\n</span><span class="synConstant">"</span>;
    <span class="synConstant">17</span>  }
</pre>

Al ejcutar el programa obtenemos la salida:
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">perl dot_utf8_2.pl</span>
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134

</pre>

<P>

<H2><A NAME="SECTION043211000000000000000">
Verbos que controlan el retroceso</A>
</H2>

<P>

<H4><A NAME="SECTION043211010000000000000">
El verbo de control <TT>(*FAIL)</TT></A>
</H4>
  

<P>
Tomado de la sección 'Backtracking-control-verbs' en <A NAME="tex2html236"
  HREF="http://perldoc.perl.org/perlretut.html#Backtracking-control-verbs"><TT>perlretut</TT></A>:

<P>
<BLOCKQUOTE><I>The control verb <code>(*FAIL)</code> may be abbreviated as <code>(*F)</code>. 
If this is inserted in a regexp it
will cause to fail, just like at some mismatch between the pattern and
the string. Processing of the regexp continues like after any "normal"
failure, so that the next position in the string or
another alternative will be tried. As failing to match doesn't preserve
capture buffers or produce results, it may be necessary to use this in
combination with embedded code.
</I></BLOCKQUOTE>

<P>
<PRE>
pl@nereida:~/Lperltesting$ cat -n vowelcount.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
     2  use strict;
     3
     4  my $input = shift() || &lt;STDIN&gt;;
     5  my %count = ();
     6  $input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
     7  printf("'%s' =&gt; %3d\n", $_, $count{$_})  for (sort keys %count);
</PRE>
Al ejecutarse con entrada <code>supercalifragilistico</code> produce la salida:
<PRE>
pl@nereida:~/Lperltesting$ ./vowelcount.pl
supercalifragilistico
'a' =&gt;   2
'e' =&gt;   1
'i' =&gt;   4
'o' =&gt;   1
'u' =&gt;   1
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN></B> &nbsp; 
<I>¿Que queda en <code>$1</code> depués de ejecutado el matching 
<code>$input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;</code>?</I></DIV><P></P>

<P>
Véase  también:

<UL>
<LI>El nodo en <A NAME="tex2html237"
  HREF="http://www.perlmonks.org/?node_id=796576">PerlMonks</A>
<SPAN  CLASS="textbf">The Oldest Plays the Piano</SPAN>
</LI>
<LI>Véase el ejercicio <I>Las tres hijas</I> en la sección
<A HREF="node26.html#parrfo:lastreshijas">3.4.4</A>
</LI>
</UL>

<P>

<H4><A NAME="SECTION043211020000000000000">
El verbo de control <TT>(*ACCEPT)</TT></A>
</H4>
  

<P>
Tomado de <A NAME="tex2html238"
  HREF="http://search.cpan.org/perldoc/?perlretut"><TT>perlretut</TT></A>:

<P>
<BLOCKQUOTE><I>This pattern matches nothing and causes the end of successful matching
at the point at which the <code>(*ACCEPT)</code> pattern was encountered, regardless
of whether there is actually more to match in the string. When inside
of a nested pattern, such as recursion, or in a subpattern dynamically
generated via <code>(??{})</code>, only the innermost pattern is ended immediately.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>If the <code>(*ACCEPT)</code> is inside of capturing buffers then the buffers are
marked as ended at the point at which the <code>(*ACCEPT)</code> was encountered. For
instance:
</I></BLOCKQUOTE>
<P><PRE>
  DB&lt;1&gt; x 'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'AB'
1  'B'
2  undef
  DB&lt;2&gt; x 'ACDE'  =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'ACD'
1  'C'
2  'E'
</PRE>
<P>

<P>

<H4><A NAME="SECTION043211030000000000000">
El verbo <TT>SKIP</TT></A>
</H4>
  

<P>
<BLOCKQUOTE><I>This zero-width pattern 
prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern <code>A (*SKIP) B</code>,
where <code>A</code> and <code>B</code> are complex patterns. Until the <code>(*SKIP)</code> verb is reached,
<code>A</code> may backtrack as necessary to match. Once it is reached, matching
continues in <code>B</code>, which may also backtrack as necessary; however, should <code>B</code>
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>It also signifies that whatever text that was matched leading up to the
<code>(*SKIP)</code>  pattern being executed cannot be part of any match of this
pattern. This effectively means that the regex engine <code>skips</code> forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>The name of the <code>(*SKIP:NAME)</code> pattern has special significance. If a
<code>(*MARK:NAME)</code> was encountered while matching, then it is that position
which is used as the "skip point". If no <code>(*MARK)</code> of that name was
encountered, then the <code>(*SKIP)</code> operator has no effect. When used without
a name the "skip point" is where the match point was when executing the
<code>(*SKIP)</code> pattern.
</I></BLOCKQUOTE>

<P>
Ejemplo:

<P>
<PRE>
pl@nereida:~/Lperltesting$ cat -n SKIP.pl
     1  #!/soft/perl5lib/bin/perl5.10.1 -w
     2  use strict;
     3  use v5.10;
     4
     5  say "NO SKIP: /a+b?(*FAIL)/";
     6  our $count = 0;
     7  'aaab' =~ /a+b?(?{print "$&amp;\n"; $count++})(*FAIL)/;
     8  say "Count=$count\n";
     9
    10  say "WITH SKIP: a+b?(*SKIP)(*FAIL)/";
    11  $count = 0;
    12  'aaab' =~ /a+b?(*SKIP)(?{print "$&amp;\n"; $count++})(*FAIL)/;
    13  say "WITH SKIP: Count=$count\n";
    14
    15  say "WITH SKIP /a+(*SKIP)b?(*FAIL)/:";
    16  $count = 0;
    17  'aaab' =~ /a+(*SKIP)b?(?{print "$&amp;\n"; $count++})(*FAIL)/;
    18  say "Count=$count\n";
    19
    20  say "WITH SKIP /(*SKIP)a+b?(*FAIL): ";
    21  $count = 0;
    22  'aaab' =~ /(*SKIP)a+b?(?{print "$&amp;\n"; $count++})(*FAIL)/;
    23  say "Count=$count\n";
</PRE>

<P>
Ejecución:

<P>
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 SKIP.pl
NO SKIP: /a+b?(*FAIL)/
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9

WITH SKIP: a+b?(*SKIP)(*FAIL)/
aaab
WITH SKIP: Count=1

WITH SKIP /a+(*SKIP)b?(*FAIL)/:
aaab
aaa
Count=2

WITH SKIP /(*SKIP)a+b?(*FAIL):
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9
</PRE>

<P>

<H4><A NAME="SECTION043211040000000000000">
Marcas</A>
</H4>
  

<P>
Tomado de la sección 'Backtracking-control-verbs' en <A NAME="tex2html239"
  HREF="http://perldoc.perl.org/perlretut.html#Backtracking-control-verbs"><TT>perlretut</TT></A>:

<P>
<BLOCKQUOTE><I><code>(*MARK:NAME) (*:NAME)</code>
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later <code>(*SKIP)</code> pattern will then skip
forward to that point if backtracked into on failure. Any number of
<code>(*MARK)</code> patterns are allowed, and the <code>NAME</code> portion is optional and may
be duplicated.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>In addition to interacting with the <code>(*SKIP)</code> pattern, <code>(*MARK:NAME)</code> can
be used to <code>label</code> a pattern branch, so that after matching, the program
can determine which branches of the pattern were involved in the match.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>When a match is successful, the <code>$REGMARK</code> variable will be set to the name
of the most recently executed <code>(*MARK:NAME)</code> that was involved in the match.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>This can be used to determine which branch of a pattern was
matched without using a separate capture buffer for each branch,
which in turn can result in a performance improvement.
</I></BLOCKQUOTE>
<P>
<BLOCKQUOTE><I>When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the <code>$REGERROR</code>
variable will be set to the name of the most recently executed
<code>(*MARK:NAME)</code>.
</I></BLOCKQUOTE>

<P>
<PRE>
pl@nereida:~/Lperltesting$ cat -n mark.pl
 1  use v5.10;
 2  use strict;
 3
 4  our $REGMARK;
 5
 6  $_ = shift;
 7  say $REGMARK if /(?:x(*MARK:mx)|y(*MARK:my)|z(*MARK:mz))/;
 8  say $REGMARK if /(?:x(*:xx)|y(*:yy)|z(*:zz))/;
</PRE>
Cuando se ejecuta produce:
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl y
my
yy
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl z
mz
zz
</PRE>

<P>

<H4><A NAME="SECTION043211050000000000000">
Poniendo un espacio después de cada signo de puntuación</A>
</H4>
  

<P>
Se quiere poner un espacio en blanco después de la aparición de cada coma:

<P>
<PRE>
s/,/, /g;
</PRE>

<P>
pero se quiere que la sustitución no tenga lugar si la coma esta
incrustada entre dos dígitos. Además se pide que si hay ya un espacio
después de la coma, no se duplique. Sigue una solución que
usa marcas:

<P>
<PRE>
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; $a = 'ab,cd, ef,12,34,efg,56,78,df, ef,'
  DB&lt;2&gt; x ($b = $a) =~ s/\d,\d(*:d)|,(?!\s)/($REGMARK eq 'd')? $&amp; : ', '/ge
0  8
  DB&lt;3&gt; p "&lt;$b&gt;"
&lt;ab, cd, ef, 12,34, efg, 56,78, df, ef, &gt;
</PRE>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2059"
  HREF="node24.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2053"
  HREF="node21.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2047"
  HREF="node22.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2055"
  HREF="node126.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2057"
  HREF="node129.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2060"
  HREF="node24.html">Unicode</A>
<B>Sup:</B> <A NAME="tex2html2054"
  HREF="node21.html">Expresiones Regulares en Perl</A>
<B> Ant:</B> <A NAME="tex2html2048"
  HREF="node22.html">Introducción</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-03-28</I>
</ADDRESS>
</BODY>
</HTML>
