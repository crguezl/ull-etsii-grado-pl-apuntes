<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Transformaciones de Árboles con Parse::Eyapp::Treeregexp</TITLE>
<META NAME="description" CONTENT="Transformaciones de Árboles con Parse::Eyapp::Treeregexp">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node91.html">
<LINK REL="previous" HREF="node89.html">
<LINK REL="up" HREF="node84.html">
<LINK REL="next" HREF="node91.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html4019"
  HREF="node91.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4013"
  HREF="node84.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4007"
  HREF="node89.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4015"
  HREF="node229.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4017"
  HREF="node232.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html4020"
  HREF="node91.html">La opción SEVERITY</A>
<B>Sup:</B> <A NAME="tex2html4014"
  HREF="node84.html">Transformaciones Árbol</A>
<B> Ant:</B> <A NAME="tex2html4008"
  HREF="node89.html">Transformaciones Arbol con treereg</A>
<B> Con:</B> 
<A NAME="tex2html4015"
  HREF="node229.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html4017"
  HREF="node232.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html4021"
  HREF="node90.html#SECTION04960010000000000000">Optimización del Traductor de Infijo a Postfijo</A>
<LI><A NAME="tex2html4022"
  HREF="node90.html#SECTION04960020000000000000">La Estructura de un Programa <TT>Treeregexp</TT></A>
<LI><A NAME="tex2html4023"
  HREF="node90.html#SECTION04960030000000000000">Las Reglas Treeregexp</A>
<LI><A NAME="tex2html4024"
  HREF="node90.html#SECTION04960040000000000000">Escalares</A>
<LI><A NAME="tex2html4025"
  HREF="node90.html#SECTION04960050000000000000">El Punto</A>
<LI><A NAME="tex2html4026"
  HREF="node90.html#SECTION04960060000000000000">Condiciones Semánticas</A>
<LI><A NAME="tex2html4027"
  HREF="node90.html#SECTION04960070000000000000">Referenciado de los Nodos del Arbol</A>
<LI><A NAME="tex2html4028"
  HREF="node90.html#SECTION04960080000000000000">Código de Transformación</A>
<LI><A NAME="tex2html4029"
  HREF="node90.html#SECTION04960090000000000000">Expresiones Regulares</A>
<LI><A NAME="tex2html4030"
  HREF="node90.html#SECTION049600100000000000000">Familias de Transformaciones</A>
<LI><A NAME="tex2html4031"
  HREF="node90.html#SECTION049600110000000000000">Codigo de Apoyo</A>
<LI><A NAME="tex2html4032"
  HREF="node90.html#SECTION049600120000000000000">El método <TT>delete</TT> de los objetos <TT>YATW</TT></A>
<LI><A NAME="tex2html4033"
  HREF="node90.html#SECTION049600130000000000000">Fases en la Ejecución de un Programa <TT>Treeregexp</TT></A>
<LI><A NAME="tex2html4034"
  HREF="node90.html#SECTION049600140000000000000">Ejecución del Ejemplo</A>
<LI><A NAME="tex2html4035"
  HREF="node90.html#SECTION049600150000000000000">Expresiones Regulares Arbol Array</A>
<LI><A NAME="tex2html4036"
  HREF="node90.html#SECTION049600160000000000000">Expresión regular árbol estrella</A>
<LI><A NAME="tex2html4037"
  HREF="node90.html#SECTION049600170000000000000">Parámetros Pasados a una Subrutina de Transformación Árbol</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04960000000000000000">
Transformaciones de Árboles con <TT>Parse::Eyapp::Treeregexp</TT></A>
</H1>
El
módulo <code>Parse::Eyapp::Treeregexp</code> permite la transformación de
árboles mediante el uso de <A NAME="16218"></A><SPAN  CLASS="textbf">Expresiones Regulares Arbol</SPAN>.
Las expresiones regulares árbol serán introducidas en mas detalle en la 
sección 
<A HREF="node69.html#section:aat"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.

<P>

<H4><A NAME="SECTION04960010000000000000">
Optimización del Traductor de Infijo a Postfijo</A>
</H4>
  

<P>
El siguiente ejemplo modifica el anterior esquema de traducción
de infijo a postfijo para producir un código de postfijo
mas eficiente. Para ello se transforma el árbol generado 
durante la fase  <I>Tree Construction Time</I> y antes de la fase 
<I>Execution Time</I>. El código <A NAME="16224"></A><SPAN  CLASS="textbf">Treeregexp</SPAN> 
que define el conjunto de transformaciones
se encuentra en las líneas 74-103.

<P>
Las transformaciones consisten en

<OL>
<LI>Compactar los árboles <code>UMINUS</code> a un número negativo
</LI>
<LI>Realizar <A NAME="16226"></A><SPAN  CLASS="textbf">plegado de constantes</SPAN>: sustituir 
los árboles de constantes por su evaluación
</LI>
<LI>Sustituir los árboles producto en los que uno de los factores es cero
por el número cero.
</LI>
</OL>

<P>
Después de ello se realiza la traducción quedando la misma
como el atributo <code>t</code> del 
nodo raíz (línea 120). 

<P>
A partir de este momento, 
si el traductor tuviera un mayor número de fases
de posterior tratamiento del árbol, 
los nodos de tipo código y los nodos hoja cuya funcionalidad es
puramente sintáctica como los terminales <code>=</code>, <code>*</code> etc.
pueden ser eliminados. Es por eso que los suprimimos en las
líneas 122-123.

<P>
Veamos primero el código y luego lo discutiremos en mas detalle:

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n TSwithtreetransformations.eyp
   1  # File TSwithtreetransformations.eyp
   2  %right  '='
   3  %left   '-' '+'
   4  %left   '*' '/'
   5  %left   NEG
   6
   7  %{
   8    # Treeregexp is the engine for tree transformations
   9    use Parse::Eyapp::Treeregexp;
  10    use Data::Dumper;
  11    $Data::Dumper::Indent = 1;
  12    $Data::Dumper::Deepcopy = 1;
  13    $Data::Dumper::Deparse = 1;
  14  %}
  15
  16  %metatree
  17
  18  %defaultaction {
  19    if (@_==4) { # binary operations: 4 = lhs, left, operand, right
  20      $lhs-&gt;{t} = "$_[1]-&gt;{t} $_[3]-&gt;{t} $_[2]-&gt;{attr}";
  21      return
  22    }
  23    die "Fatal Error. Unexpected input\n".Dumper(@_);
  24  }
  25
  26  %%
  27  line: %name PROG
  28         exp &lt;%name EXP + ';'&gt;
  29           { @{$lhs-&gt;{t}} = map { $_-&gt;{t}} ($lhs-&gt;child(0)-&gt;Children()); }
  30
  31  ;
  32
  33  exp:      %name NUM     NUM         { $lhs-&gt;{t} = $_[1]-&gt;{attr}; }
  34          | %name VAR     VAR         { $lhs-&gt;{t} = $_[1]-&gt;{attr}; }
  35          | %name ASSIGN  VAR '=' exp { $lhs-&gt;{t} = "$_[1]-&gt;{attr} $_[3]-&gt;{t} =" }
  36          | %name PLUS    exp '+' exp
  37          | %name MINUS   exp '-' exp
  38          | %name TIMES   exp '*' exp
  39          | %name DIV     exp '/' exp
  40          | %name UMINUS  '-' exp %prec NEG { $_[0]-&gt;{t} = "$_[2]-&gt;{t} NEG" }
  41          |               '(' exp ')' %begin { $_[2] } /* skip parenthesis */
  42  ;
  43
  44  %%
  45
  46  # subroutines  _Error and _Lexer
  ..  ................................
  66
  67  sub Run {
  68      my($self)=shift;
  69      print "input: "; $x = &lt;&gt;;
  70      my $tree = $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
  71        #yydebug =&gt; 0xFF
  72      );
  73
  74      my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  75
  76        delete_code : CODE =&gt; { $delete_code-&gt;delete() }
  77
  78        {
  79          sub not_semantic {
  80            my $self = shift;
  81            return  1 if $self-&gt;{token} eq $self-&gt;{attr};
  82            return 0;
  83          }
  84        }
  85
  86        delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =&gt; { $delete_tokens-&gt;delete() }
  87
  88        delete = delete_code delete_tokens;
  89
  90        uminus: UMINUS(., NUM($x), .) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
  91
  92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
  93           =&gt; {
  94          $x-&gt;{attr} = eval  "$x-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}";
  95          $_[0] = $NUM[0];
  96        }
  97
  98        zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
  99        times_zero: TIMES(., ., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
 100
 101        algebraic_transformations = constantfold zero_times times_zero;
 102
 103      },
 104      PACKAGE =&gt; 'TSwithtreetransformations',
 105      OUTPUTFILE =&gt; 'main.pm',
 106      SEVERITY =&gt; 0,
 107      NUMBERS =&gt; 0,
 108      );
 109
 110      # Create the transformer
 111      $transform-&gt;generate();
 112      # Get the AST
 113
 114      our ($uminus);
 115      $uminus-&gt;s($tree);
 116
 117      our (@algebraic_transformations);
 118      $tree-&gt;s(@algebraic_transformations);
 119
 120      $tree-&gt;translation_scheme();
 121
 122      our (@delete);
 123      $tree-&gt;s(@delete);
 124      print Dumper($tree);
 125  }
</PRE>

<P>

<H4><A NAME="SECTION04960020000000000000">
La Estructura de un Programa <TT>Treeregexp</TT></A>
</H4>
  

<P>
La estructura de un programa  <TT>Treeregexp</TT>  es sencilla. Consiste en la repetición
de tres tipos de expresiones regulares árbol: las <A NAME="16234"></A><SPAN  CLASS="textbf">treeregexp</SPAN> propiamente
dichas, <A NAME="16236"></A><SPAN  CLASS="textbf">código auxiliar para las transformaciones</SPAN> y 
<A NAME="16238"></A><SPAN  CLASS="textbf">definiciones de familias de transformaciones</SPAN>.

<P>
<PRE>
treeregexplist:  
    treeregexp* 
;

treeregexp: 
    IDENT ':' treereg ('=&gt;' CODE)?  # Treeregexp 
  | CODE                            # Código auxiliar
  | IDENT '=' IDENT + ';'           # Familia de transformaciones
;
</PRE>

<P>
Las expresiones regulares árbol propiamente dichas siguen la regla 

<P>
<PRE>
                  IDENT ':' treereg ('=&gt;' CODE)?
</PRE>

<P>
Podemos ver ejemplos de instancias de esta regla en las líneas 
76, 86, 90, 92-96, 98 y 99. El identificador <code>IDENT</code> da el nombre
a la regla. Actualmente (2006) existen estos tipos de  <TT>treereg</TT> :

<P>
<PRE>
treereg: 
      /* patrones con hijos */
    IDENT '(' childlist ')' ('and' CODE)? 
  | REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)? 
  | SCALAR '(' childlist ')' ('and' CODE)?  
  | '.' '(' childlist ')' ('and' CODE)? 
        /* hojas */
  | IDENT ('and' CODE)? 
  | REGEXP (':' IDENT)? ('and' CODE)? 
  | '.' ('and' CODE)? 
  | SCALAR ('and' CODE)? 
  | ARRAY 
  | '*'
</PRE>

<P>

<H4><A NAME="SECTION04960030000000000000">
Las Reglas Treeregexp</A>
</H4>
  

<P>
Una regla como
<PRE>
            zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</PRE>
crea un objeto transformación (concretamente un objeto de la clase  <TT>Parse::Eyapp:YATW</TT> )
que puede ser referido a través de la variable escalar <code>$zero_times</code>.
La primera parte de la regla <code>zero_times</code> indica que 
para que se produzca el emparejamiento es necesario que el nodo visitado sea
del tipo <code>TIMES</code> y su primer
hijo es de tipo <code>NUM</code>. Una referencia al nodo hijo de <code>NUM</code> será automáticamente
guardada en la variable <SPAN ID="txt15903">léxica</SPAN> <code>$x</code>. 

<P>

<H4><A NAME="SECTION04960040000000000000">
Escalares</A>
</H4>
  

<P>
El efecto de un escalar en una treeregexp 
es casar con cualquier nodo y almacenar su referencia en la variable.

<P>
La aparición de <code>$x</code> en la treeregexp anterior 
casará con cualquier nodo. La referencia al nodo que ha casado queda en <code>$x</code>.
Asi <code>$x</code> podrá ser usado en el <A NAME="16250"></A><SPAN  CLASS="textbf">patrón árbol semántico</SPAN> 
o <A NAME="16252"></A><SPAN  CLASS="textbf">condición semántica</SPAN>(esto es,
en el código opcional que va precedido de la palabra reservada <code>and</code>) 
y en la <A NAME="16254"></A><SPAN  CLASS="textbf">acción de transformación árbol</SPAN> (el código opcional que va precedido de la 
flecha gorda <code>=&gt;</code>).

<P>

<H4><A NAME="SECTION04960050000000000000">
El Punto</A>
</H4>
  

<P>
Un punto también casa con cualquier nodo. Puede verse como una abreviación de 
la expresión regular árbol escalar. Una referencia al nodo que casa
queda almacenada en la variable
léxica especial  <TT>$W</TT> . Si la expresión regular árbol tiene
varios puntos sus referencias quedan almacenadas en la variable array <code>@W</code>.
Es un error usar el identificador <code>W</code> en una expresión regular escalar 
escalar. Por ejemplo, una treeregexp como:

<P>
<PRE>
constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($W), ., NUM($y))
</PRE>

<P>
da lugar al error:

<P>
<PRE>
*Error* Can't use $W to identify an scalar treeregexp at line 100.
</PRE>

<P>

<H4><A NAME="SECTION04960060000000000000">
Condiciones Semánticas</A>
</H4>
  

<P>
<SPAN  CLASS="textbf">La segunda parte de la regla</SPAN> es opcional y comienza con la palabra reservada <code>and</code>
seguida de un código que <SPAN  CLASS="textbf">explicita las condiciones semánticas que debe cumplir el nodo
para que se produzca el casamiento</SPAN>. En el ejemplo se explicita que el attributo del nodo 
(forzosamente del tipo <code>TERMINAL</code> en este caso) referenciado por <code>$x</code> debe ser cero.

<P>

<H4><A NAME="SECTION04960070000000000000">
Referenciado de los Nodos del Arbol</A>
</H4>
  

<P>
Es posible dentro de las partes de código referirse a los nodos del árbol.
Cuando la rutina de transformación generada por el compilador para una 
treeregexp es llamada, el primer argumento <code>$_[0]</code> contiene la referencia al nodo 
que esta siendo visitado. 

<P>
<code>Parse::Eyapp::Treeregexp</code> crea variables léxicas con nombres
los tipos de los nodos a los que referencian. 
Así la subrutina generada para la transformación <code>zero_times</code> 

<P>
<PRE>
     zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</PRE>

<P>
guarda en la variable lexica <code>$TIMES</code> una copia de <code>$_[0]</code> y en 
la variable léxica <code>$NUM</code> una referencia al nodo <code>$TIMES-&gt;child(0)</code> .

<P>
Si un tipo de nodo se repite en la treeregexp la variable léxica
asociada con dicho tipo se autodeclara como un array. Este es el caso de 
la transformación <code>constantfold</code>
en la cual aparecen dos nodos de tipo <code>NUM</code>:
<PRE>
92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
93           =&gt; {
94          $x-&gt;{attr} = eval  "$x-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}";
95          $_[0] = $NUM[0];
96        }
</PRE>
La variable <code>@NUM</code> es automáticamente declarada: <code>$NUM[0]</code> es una
referencia al primer nodo <code>NUM</code> y <code>$NUM[1]</code> es una referencia
al segundo.

<P>

<H4><A NAME="SECTION04960080000000000000">
Código de Transformación</A>
</H4>
  

<P>
<SPAN  CLASS="textbf">La tercera parte de la regla</SPAN> es también opcional y viene precedida de la <A NAME="16273"></A><SPAN  CLASS="textbf">flecha gorda</SPAN>.
Habitualmente contiene el código que transforma el árbol.
Para lograr la modificación del nodo del árbol visitado el programador
<code>Treeregexp</code> deberá usar <code>$_[0]</code>. Recuerde que
los elementos en <code>@_</code> son alias de los argumentos. Si el código 
de la tercera parte fuera reescrito como:
<PRE>
                            { $TIMES = $NUM }
</PRE>
no funcionaría ya que estaríamos modificando la variable léxica que referencia al
nodo raíz del subarbol que ha casado.

<P>

<H4><A NAME="SECTION04960090000000000000">
Expresiones Regulares</A>
</H4>
  

<P>
Es posible usar una <A NAME="16279"></A><SPAN  CLASS="textbf">expresión regular lineal</SPAN> 
alias <A NAME="16281"></A><SPAN  CLASS="textbf">expresión regular clásica</SPAN> alias <A NAME="16283"></A><SPAN  CLASS="textbf">regexp</SPAN> para 
explicitar el tipo de un nodo como indica la regla de producción:

<P>
<PRE>
      treereg: REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)?
</PRE>

<P>
La treeregexp para el plegado de constantes constituye un ejemplo:

<P>
<PRE>
  92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
  93           =&gt; {
  94                $x-&gt;{attr} = eval  "$x-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}";
  95                $_[0] = $NUM[0];
  96              }
</PRE>

<P>
La expresión regular deberá especificarse entre barras de división (<code>/</code>)
y es posible especificar opciones después del segundo slash (<code>e</code>, <code>i</code>, etc.).
El identificador opcional después de la regexp indica el nombre para la
variable léxica que almacenará una copia de la referencia al nodo del árbol.
En el ejemplo <code>$bin</code> podría usarse para referenciar al nodo apuntado por <code>$_[0]</code>.
Si no se especifica identificador quedará almacenado en la variable léxica
especial <code>$W</code>.  Si la expresión regular árbol tiene
varias regexp (y/o puntos) sus referencias quedan almacenadas en la variable array <code>@W</code>.

<P>
La semántica de las <A NAME="16285"></A><SPAN  CLASS="textbf">expresiones regulares lineales</SPAN>
es modificada ligéramente por <TT>Parse::Eyapp::Treeregexp</TT>.
<SPAN  CLASS="textbf">Por defecto se asume la opción</SPAN>  <TT>x</TT> . El compilador de expresiones regulares árbol
procede a la <A NAME="16288"></A><SPAN  CLASS="textbf">inserción automática de la opción x</SPAN>.
Use la <A NAME="16290"></A><SPAN  CLASS="textbf">nueva opción X</SPAN> ((<code>X</code> mayúscula)
para evitar esta conducta.
<SPAN  CLASS="textbf">Tampoco es necesario añadir anclas de frontera
de palabra</SPAN> <code>\b</code> a los identificadores que aparecen en la expresión
regular lineal: el compilador de expresiones regulares árbol
las insertará. Use la nueva opción  <TT>B</TT>  (<code>B</code> mayúscula) para negar esta conducta.

<P>
El siguiente ejemplo tomado del análisis de tipos en el compilador
de Simple C muestra como no es encesario usar <code>x</code>:
<PRE>
67 # Binary Operations
68 bin: / PLUS
69       |MINUS
70       |TIMES
71       |DIV
72       |MOD
73       |GT
74       |GE
75       |LE
76       |EQ
77       |NE
78       |LT
79       |AND
80       |EXP
81       |OR
82      /($x, $y)
83   =&gt; {
84     $x = char2int($_[0], 0);
85     $y = char2int($_[0], 1);
86
87     if (($x-&gt;{t} == $INT) and ( $y-&gt;{t} == $INT)) {
88       $_[0]-&gt;{t} = $INT;
89       return 1;
90     }
91     type_error("Incompatible types with operator '".($_[0]-&gt;lexeme)."'", $_[0]-&gt;line);
92   }
</PRE>
Con la semántica habitual de las regexp la palabra reservada
<code>WHILE</code> casaría con la subexpresión <code>LE</code> en la línea 76
provocando un análisis de tipos erróneo para esta clase de nodos. 
La <A NAME="16293"></A><SPAN  CLASS="textbf">inserción automática de anclas</SPAN> por parte de <code>Parse::Eyapp::Treeregexp</code>
evita este - normalmente indeseable - efecto.

<P>

<H4><A NAME="SECTION049600100000000000000">
Familias de Transformaciones</A>
</H4>
  

<P>
Las transformaciones creadas por <code>Parse::Eyapp::Treeregexp</code> pueden agruparse por familias.
Esta es la función de la regla de producción:
<PRE>
              treeregexp: IDENT '=' IDENT + ';'
</PRE>
En el ejemplo creamos una nueva familia denominada <code>algebraic_transformations</code>
mediante la asignación de la línea 101:
<PRE>
algebraic_transformations = constantfold zero_times times_zero;
</PRE>
Las transformaciones en esa familia pueden ser accedidas posteriormente
para su aplicación mediante la
variable de paquete <code>@algebraic_transformations</code> (véanse las líneas 
117-118).

<P>

<H4><A NAME="SECTION049600110000000000000">
Codigo de Apoyo</A>
</H4>
  

<P>
En medio de la definición de cualquier regla treeregexp es posible insertar 
código de apoyo siempre que se sitúe entre llaves:

<P>
<PRE>
  78        {
  79          sub not_semantic {
  80            my $self = shift;
  81            return  1 if $self-&gt;{token} eq $self-&gt;{attr};
  82            return 0;
  83          }
  84        }
  85
  86        delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =&gt; { $delete_tokens-&gt;delete() }
</PRE>

<P>

<H4><A NAME="SECTION049600120000000000000">
El método <TT>delete</TT> de los objetos <TT>YATW</TT></A>
</H4>
  

<P>
Los objetos de la clase  <TT>Parse::Eyapp::YATW</TT>  como <code>$delete_tokens</code> disponen
de un método  <TT>delete</TT>  que permite eliminar con seguridad un hijo de la raíz del 
subárbol que ha casado. En este caso los nodos que casan son los de la clase <code>TERMINAL</code> 
en los que el valor de la clave <code>token</code> coincide con el valor de la clave <code>attr</code>.

<P>

<H4><A NAME="SECTION049600130000000000000">
Fases en la Ejecución de un Programa <TT>Treeregexp</TT></A>
</H4>
  

<P>
Un programa <TT>Treeregexp</TT> puede - como en el ejemplo - proporcionarse como una
cadena de entrada al método <code>new</code> de la clase <code>Parse::Eyapp::Treeregexp</code>
o bien escribirse en un fichero separado (la extensión <code>.trg</code> es usada por
defecto) y compilado con el script  <TT>treereg</TT>  que acompaña a la distribución de
<code>Parse::Eyapp</code>.

<P>
La primera fase en la ejecución de un programa  <TT>Treeregexp</TT> 
es la <A NAME="16321"></A><SPAN  CLASS="textbf">fase de creación del paquete <TT>Treeregexp</TT></SPAN>
que contendrá las subrutinas
de reconocimiento de los patrones árbol definidos en el programa <TT>Treeregexp</TT>.
En el ejemplo esta fase tiene lugar en las líneas
74-111 con las llamadas a <code>new</code> (que crea el objeto programa <TT>Treeregexp</TT>)
y  <TT>generate</TT>  (que crea el paquete conteniendo las subrutinas reconocedoras).
<PRE>
  74      my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  75
  76        delete_code : CODE =&gt; { $delete_code-&gt;delete() }
 ...        ................................................
 103      },
 104      PACKAGE =&gt; 'TSwithtreetransformations',
 105      OUTPUTFILE =&gt; 'main.pm',
 106      SEVERITY =&gt; 0,
 107      NUMBERS =&gt; 0,
 108      );
 109
 110      # Create the transformer
 111      $transform-&gt;generate();
</PRE>

<P>
Durante esta fase se crea un <A NAME="16326"></A><SPAN  CLASS="textbf">objeto transformación</SPAN> i(perteneciente a la clase  <TT>Parse::Eyapp::YATW</TT> )
por cada expresión regular árbol que aparece en el programa <TT>Treeregexp</TT>.
Las variables contenedor de cada uno de esos objetos tienen por nombre el que se
les dió a las correspondientes expresiones regulares árbol. En nuestro ejemplo, y después
de esta fase habrán sido creadas variables escalares de paquete 
<code>$delete_tokens</code>, <code>$delete</code>, <code>$uminus</code>, <code>$constantfold</code>, <code>$zero_times</code> 
y <code>$times_zero</code>
asociadas con cada una de las expresiones regulares árbol definidas.
También se crearán variables array para cada una de las
familias de transformaciones especificadas: Asi  la variable
<code>@delete</code> contiene <code>($delete_tokens, $delete)</code> y la variable
<code>@algebraic_transformations</code>
es igual a <code>($constantfold, $zero_times, $times_zero)</code>. La variable de paquete especial
<code>@all</code> es un array que contiene todas las transformaciones definidas en el programa.

<P>
Una vez creados los objetos transformación y las familias de transformaciones
<code>Parse::Eyapp::YATW</code> podemos proceder a transformar el árbol
mediante su uso.
Esto puede hacerse mediante el método  <TT>s</TT>  el cual procede 
a modificar el árbol pasado como parámetro.
<PRE>
 114      our ($uminus);
 115      $uminus-&gt;s($tree);
</PRE>
En el ejemplo la llamada <code>$uminus-&gt;s($tree)</code> da lugar al 
recorrido  primero-profundo de <code>$tree</code>. Cada vez que un nodo 
casa con la regla:
<PRE>
UMINUS(., NUM($x), .) # first child is '-', second the number and third the code
</PRE>
se le aplica la transformación:
<PRE>
{ $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
</PRE>
Esta transformación hace que el nodo <code>UMINUS</code> visitado sea sustituido 
por un nodo de tipo <code>NUM</code> cuyo atributo sea el número de su hijo
<code>NUM</code> cambiado de signo.

<P>
Las líneas 117-118 nos muestran como someter un árbol a un conjunto 
de transformaciones:
<PRE>
 117      our (@algebraic_transformations);
 118      $tree-&gt;s(@algebraic_transformations);
</PRE>
Los objetos nodo (esto es, los que pertenecen a la clase  <TT>Parse::Eyapp::Node</TT> )
disponen del método  <TT>s</TT>  que recibe como argumentos una familia de 
transformaciones. La familia de transformaciones es aplicada iterativamente
al árbol hasta que este no cambia. 

<P>
Nótese que consecuencia de esta definición es que es posible escribir transformaciones
que dan lugar a bucles infinitos. Por ejemplo si en <code>@algebraic_transformations</code>
incluimos una transformación que aplique las propiedades conmutativas de la 
suma:
<PRE>
 commutative_add: PLUS($x, ., $y, .)
        =&gt; { my $t = $x; $_[0]-&gt;child(0, $y); $_[0]-&gt;child(2, $t)}
</PRE>
el programa podría caer en un bucle infinito ya que la transformación es
susceptible de ser aplicada indefinidamente. Sin embargo no se produce bucle infinito
si llamamos al código asociado a la transformación:
<PRE>
$commutative_add-&gt;($tree);
</PRE>

<P>
ya que en este caso se produce un sólo recursivo descendente aplicando la transformación
<code>$commutative_add</code>.

<P>
El uso de transformaciones conmutativas no tiene porque dar lugar a 
la no finalización del programa. La parada del programa se puede
garantizar si <SPAN  CLASS="textbf">podemos asegurar que la aplicación reiterada
del patrón implica la desaparición del mismo</SPAN>. Por ejemplo,
la transformación <code>comasocfold</code> puede ser añadida
a la familia <code>algebraic_transformations</code> sin introducir
problemas de parada:
<PRE>
comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
   =&gt; {
  $x-&gt;{attr} = $x-&gt;{attr} * $y-&gt;{attr};
  $_[0] = $DIV;
}

algebraic_transformations = constantfold zero_times times_zero comasocfold;
</PRE>
La introducción de esta transformación permite el plegado de entradas como <code>a=2;b=2/a*3</code>:
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; usetswithtreetransformations3.pl
a=2;b=2/a*3
$VAR1 = bless( { 'children' =&gt; [
    bless( { 'children' =&gt; [
        bless( { 'children' =&gt; [
            bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
            bless( { 'children' =&gt; [
                bless( { 'children' =&gt; [], 'attr' =&gt; 2, 'token' =&gt; 'NUM' }, 'TERMINAL' ) ],
              't' =&gt; 2
            }, 'NUM' )
          ],
          't' =&gt; 'a 2 ='
        }, 'ASSIGN' ),
        bless( { 'children' =&gt; [
            bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
            bless( { 'children' =&gt; [
                bless( { 'children' =&gt; [
                    bless( { 'children' =&gt; [], 'attr' =&gt; 6, 'token' =&gt; 'NUM' }, 'TERMINAL' )
                  ],
                  't' =&gt; 6
                }, 'NUM' ),
                bless( { 'children' =&gt; [
                    bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' )
                  ],
                  't' =&gt; 'a'
                }, 'VAR' )
              ],
              't' =&gt; '6 a /'
            }, 'DIV' )
          ],
          't' =&gt; 'b 6 a / ='
        }, 'ASSIGN' )
      ]
    }, 'EXP' )
  ],
  't' =&gt; [ 'a 2 =', 'b 6 a / =' ]
}, 'PROG' );
</PRE>

<P>

<H4><A NAME="SECTION049600140000000000000">
Ejecución del Ejemplo</A>
</H4>
  

<P>
Una vez compilado el analizador, escribimos 
el programa que usa el módulo generado:
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n usetswithtreetransformations.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use TSwithtreetransformations;
     4  use Parse::Eyapp::Treeregexp;
     5
     6  my $parser = TSwithtreetransformations-&gt;new();
     7  $parser-&gt;Run;
</PRE>
Al ejecutarlo obtenemos la siguiente salida:
<PRE>
nereida:~/src/perl/YappWithDefaultAction/examples&gt; eyapp TSwithtreetransformations.eyp ; \\
                                                   usetswithtreetransformations.pl
input: a=2*-3;b=a*(2-1-1);c=a+b
$VAR1 = bless( { 'children' =&gt; [
    bless( { 'children' =&gt; [
    |   bless( { 'children' =&gt; [
    |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   bless( { 'children' =&gt; [
    |   |   |   bless( { 'children' =&gt; [], 'attr' =&gt; -6, 'token' =&gt; 'NUM' }, 'TERMINAL' )
    |   |   | ],
    |   |   | 't' =&gt; -6
    |   |   }, 'NUM' )
    |   | ],
    |   | 't' =&gt; 'a -6 ='
    |   }, 'ASSIGN' ),
    |   bless( { 'children' =&gt; [
    |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   bless( { 'children' =&gt; [
    |   |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 0, 'token' =&gt; 'NUM' }, 'TERMINAL' )
    |   |   | ],
    |   |   | 't' =&gt; 0
    |   |   }, 'NUM' )
    |   | ],
    |   | 't' =&gt; 'b 0 ='
    |   }, 'ASSIGN' ),
    |   bless( { 'children' =&gt; [
    |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   bless( { 'children' =&gt; [
    |   |   |   bless( { 'children' =&gt; [
    |   |   |       bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' )
    |   |   |     ],
    |   |   |     't' =&gt; 'a'
    |   |   |   }, 'VAR' ),
    |   |   |   bless( { 'children' =&gt; [
    |   |   |       bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'VAR' }, 'TERMINAL' )
    |   |   |     ],
    |   |   |     't' =&gt; 'b'
    |   |   |   }, 'VAR' )
    |   |   | ],
    |   |   | 't' =&gt; 'a b +'
    |   |   }, 'PLUS' )
    |   | ],
    |   | 't' =&gt; 'c a b + ='
    |   }, 'ASSIGN' )
    | ]
    }, 'EXP' )
  ],
  't' =&gt; [ 'a -6 =', 'b 0 =', 'c a b + =' ]
}, 'PROG' );
</PRE>
Como puede verse la traducción de la frase de
entrada <code>a=2*-3;b=a*(2-1-1);c=a+b</code> 
queda como atributo <code>t</code> del nodo raíz <code>PROG</code>.

<P>

<H4><A NAME="SECTION049600150000000000000">
Expresiones Regulares Arbol Array</A>
</H4>
  

<P>
Una expresión regular árbol array se escribe insertando un array Perl
en la expresión regular árbol, por ejemplo <code>@a</code>. 
Una <A NAME="16340"></A><SPAN  CLASS="textbf">expresión regular árbol array</SPAN> <code>@a</code> casa con la secuencia mas corta de hijos del nodo
tal que la siguiente expresión regular árbol (<SPAN ID="txt15999">no array</SPAN>) casa. 
La lista de nodos
que han casado con la expresión regular árbol array quedará en la variable
léxica <code>@a</code>. 
Por ejemplo, despúes de un casamiento de un árbol <code>$t</code> con la expresión regular árbol 
<code>BLOCK(@a, ASSIGN($x, $e), @b)</code>, la variable léxica  
<code>@a</code> contendrá la lista de nodos hijos de  <code>$t</code> 
que precede a la primera aparición de <code>ASSIGN($x, $e)</code>.
Si no 
existe expresión regular árbol siguiente - el caso de <code>@b</code> en el ejemplo -
la expresión regular
array casará con todos los nodos hijo a partir del último casamiento (<SPAN ID="txt16000">no array</SPAN>). 
Asi <code>@b</code> contendrá la lista de referencias a los nodos hijos
de <code>$t</code> posteriores al nodo <code>ASSIGN($x, $e)</code>.

<P>
Es <SPAN ID="txt16001">ilegal</SPAN> escribir dos expresiones regulares arbol array
seguidas (por ejemplo <code>A(@a, @b)</code>).

<P>
El siguiente ejemplo muestra como usar las expresiones árbol array 
para mover las asignaciones invariantes de un bucle fuera
del mismo (líneas 104-116):

<P>
<PRE>
nereida:~/src/perl/YappWithDefaultAction/t&gt; cat -n 34moveinvariantoutofloopcomplexformula.t
  1  #!/usr/bin/perl -w
  2  use strict;
  5  use Parse::Eyapp;
  6  use Data::Dumper;
  7  use Parse::Eyapp::Treeregexp;
  8
  9  my $grammar = q{
 10  %{
 11  use Data::Dumper;
 12  %}
 13  %right  '='
 14  %left   '-' '+'
 15  %left   '*' '/'
 16  %left   NEG
 17  %tree
 18
 19  %%
 20  block:  exp &lt;%name BLOCK + ';'&gt; { $_[1] }
 21  ;
 22
 23  exp:      %name NUM
 24              NUM
 25          | %name WHILE
 26              'while'   exp  '{' block '}'
 27          | %name VAR
 28              VAR
 29          | %name ASSIGN
 30              VAR '=' exp
 31          | %name PLUS
 32              exp '+' exp
 33          | %name MINUS
 34              exp '-' exp
 35          | %name TIMES
 36              exp '*' exp
 37          | %name DIV
 38              exp '/' exp
 39          | %name UMINUS
 40              '-' exp %prec NEG
 41          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
 42  ;
 43
 44  %%
 ..  .......................................................................
 87  }; # end grammar
 88
 ..    ..................
 99  $parser-&gt;YYData-&gt;{INPUT} = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n";
100  my $t = $parser-&gt;Run;
101  print "\n***** Before ******\n";
102  print Dumper($t);
104  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
105    moveinvariant: 
106      BLOCK(@prests, WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)), @possts )
107        and { is_invariant($ASSIGN, $WHILE) } /* Check if ASSIGN is invariant relative */
108      =&gt; {                                    /* to the while loop                     */
109           my $assign = $ASSIGN;   
110           $BLOCK[1]-&gt;delete($ASSIGN);
111           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
112         }
113    },
114    #outputfile =&gt; 'main.pm',
115    firstline =&gt; 104,
116  );
</PRE>
Al ejecutar el programa con la entrada
<code>"a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n"</code>
obtenemos el árbol modificado:
<PRE>
bless( { 'children' =&gt; [
    bless( { 'children' =&gt; [ # a = 1000
    |   bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   bless( { 'children' =&gt; [
    |       bless( { 'children' =&gt; [], 'attr' =&gt; '1000', 'token' =&gt; 'NUM' }, 'TERMINAL' )
    |     ]
    |   }, 'NUM' )
    | ]
    }, 'ASSIGN' ),
    bless( { 'children' =&gt; [ # c = 1
    |   bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   bless( { 'children' =&gt; [ bless( { 'children' =&gt; [], 'attr' =&gt; '1', 'token' =&gt; 'NUM' }, 'TERMINAL' )
    |     ]
    |   }, 'NUM' )
    | ]
    }, 'ASSIGN' ),
    bless( { 'children' =&gt; [ # b = 5 moved out of loop
    |   bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   bless( { 'children' =&gt; [ bless( { 'children' =&gt; [], 'attr' =&gt; '5', 'token' =&gt; 'NUM' }, 'TERMINAL' )
    |     ]
    |   }, 'NUM' )
    | ]
    }, 'ASSIGN' ),
    bless( { 'children' =&gt; [ # while
    |   bless( { 'children' =&gt; [ #   ( a )
    |       bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' )
    |     ]
    |   }, 'VAR' ),
    |   bless( { 'children' =&gt; [ # BLOCK {}
    |   |   bless( { 'children' =&gt; [ # c = c * a
    |   |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   |   bless( { 'children' =&gt; [
    |   |   |       bless( { 'children' =&gt; [
    |   |   |           bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'VAR' }, 'TERMINAL' )
    |   |   |         ]
    |   |   |       }, 'VAR' ),
    |   |   |       bless( { 'children' =&gt; [
    |   |   |           bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' )
    |   |   |         ]
    |   |   |       }, 'VAR' )
    |   |   |     ]
    |   |   |   }, 'TIMES' )
    |   |   | ]
    |   |   }, 'ASSIGN' ),
    |   |   bless( { 'children' =&gt; [ # a = a - 1
    |   |   |   bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' ),
    |   |   |   bless( { 'children' =&gt; [
    |   |   |       bless( { 'children' =&gt; [
    |   |   |           bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'VAR' }, 'TERMINAL' )
    |   |   |         ]
    |   |   |       }, 'VAR' ),
    |   |   |       bless( { 'children' =&gt; [
    |   |   |           bless( { 'children' =&gt; [], 'attr' =&gt; '1', 'token' =&gt; 'NUM' }, 'TERMINAL' )
    |   |   |         ]
    |   |   |       }, 'NUM' )
    |   |   |     ]
    |   |   |   }, 'MINUS' )
    |   |   | ]
    |   |   }, 'ASSIGN' )
    |   | ]
    |   }, 'BLOCK' )
    | ]
    }, 'WHILE' )
  ]
}, 'BLOCK' );
</PRE>

<P>

<H4><A NAME="SECTION049600160000000000000">
Expresión regular árbol estrella</A>
</H4>
  

<P>
Una <A NAME="16346"></A><SPAN  CLASS="textbf">expresión regular árbol estrella</SPAN> casa con la secuencia mas corta de hijos del nodos
tal que la siguiente expresión regular árbol casa. Si no
existe expresión regular árbol siguiente - esto es, la expresión regular
estrella es la última de la lista como en <code>A(B(C,.), *)</code>- la expresión regular
estrella casará con todos los nodos hijo a partir del último casamiento.
Una expresión regular árbol array se escribe insertando el símbolo <code>*</code>
en la expresión regular árbol. Las listas de nodos
que han casado con la expresiones regulares árbol estrella quedaran en las variables
léxicas <code>@W_0</code>, <code>@W_1</code>, <code>@W_2</code>, etc.
En este sentido una expresión regular árbol estrella no es mas que
una abreviación para la expresión regular árbol <code>@W_#</code> 
siendo <code>#</code> el número de orden de aparición.

<P>

<H4><A NAME="SECTION049600170000000000000">
Parámetros Pasados a una Subrutina de Transformación Árbol</A>
</H4>
  

<P>
Como se ha mencionado anteriormente el compilador de expresiones
regulares árbol traduce cada transformación árbol en una subrutina Perl.
Con mayor precisión: se crea un objeto <code>Parse::Eyapp:YATW</code> que es el
encargado de gestionar la transformación. Para que una subrutina pueda
ser convertida en un objeto YATW deben ajustarse al <A NAME="16352"></A><SPAN  CLASS="textbf">Protocolo YATW de LLamada</SPAN>. 
Actualmente (2006) la subrutina asociada con un objeto YATW es llamada como sigue:

<P>
<PRE>
  pattern_sub(
        $_[0],  # Node being visited
        $_[1],  # Father of this node
        $index, # Index of this node in @Father-&gt;children
        $self,  # The YATW pattern object
 );
</PRE>

<P>
Los cuatro argumentos tienen el siguiente significado:

<P>

<OL>
<LI>El nódo del árbol que esta siendo visitado
</LI>
<LI>El padre de dicho nodo
</LI>
<LI>El índice del nodo (<code>$_[0]</code>) en la lista de nodos del padre
</LI>
<LI>Una referencia al objeto YATW
</LI>
</OL>

<P>
La subrutina debe devolver cierto (TRUE) si se produce matching
y falso en otro caso. Recuerde que el método <code>s</code> de los nodos (no así 
el de los objetos YATW) permancerá aplicando las transformaciones
hasta que no se produzcan emparejamientos. Por tanto es importante 
asegurarse cuando se usa la forma <code>$node-&gt;s(@transformations)</code>
que la aplicación reiterada de las transformaciones conduce
a situaciones en las que eventualmente las subrutinas retornan
el valor falso.

<P>
Es posible que el protocolo de llamada YATW cambie en un futuro próximo.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html4019"
  HREF="node91.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4013"
  HREF="node84.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4007"
  HREF="node89.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4015"
  HREF="node229.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4017"
  HREF="node232.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1314/course/view.php?id=1104"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html5"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html6"
  HREF="http://crguezl.github.io/pl-html/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html7"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html8"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html9"
  HREF="https://plus.google.com/u/0/communities/107031495100582318205"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="comunidad g+ PL1314"></A><A NAME="tex2html10"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html12"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html13"
  HREF="https://github.com/crguezl"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="crguezl at github"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html4020"
  HREF="node91.html">La opción SEVERITY</A>
<B>Sup:</B> <A NAME="tex2html4014"
  HREF="node84.html">Transformaciones Árbol</A>
<B> Ant:</B> <A NAME="tex2html4008"
  HREF="node89.html">Transformaciones Arbol con treereg</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2014-04-22</I>
</ADDRESS>
</BODY>
</HTML>
