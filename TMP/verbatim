
<tex2html_mydb_mark>#1#%

<tex2html_mydb_mark>#2#%\topmargin -4 mm

<tex2html_mydb_mark>#3#%\headheight 10 mm

<tex2html_mydb_mark>#4#%\headsep 10 mm

<tex2html_mydb_mark>#5#%\textheight 229 mm

<tex2html_mydb_mark>#6#% Comandos para el índice de referencias cruzadas

<tex2html_mydb_mark>#7#%{\index{#1}{{\tt #1}}}

<tex2html_mydb_mark>#8#%{\index{#1}}

<tex2html_mydb_mark>#9#%%%%%%%%%%%%%% 

<tex2html_mydb_mark>#10#%\newtheorem{lab}{Práctica \addcontentsline{toc}{section}{hola}}[section] 

<tex2html_mydb_mark>#11#%\newcommand{bcita}[0]

<tex2html_mydb_mark>#12#%{\begin{it}\begin{quote}}

<tex2html_mydb_mark>#13#%

<tex2html_mydb_mark>#14#%\newcommand{ecita}{[0]

<tex2html_mydb_mark>#15#%{\end{quote}\end{it}}}

<tex2html_mydb_mark>#16#%%%%%%%%%%%%%%%%%% git

<tex2html_mydb_mark>#17#%%%%%%%%%%%%%%%%%% javascript

<tex2html_mydb_mark>#18#%%%%%%%%%%%%%%%%% ruby

<tex2html_mydb_mark>#19#%%%%%%%%%%%%%%%%% end ruby

<tex2html_mydb_mark>#20#%http://svnbook.red-bean.com/nightly/en/svn.branchmerge.basicmerging.html

<tex2html_mydb_mark>#21#%\newcommand{\svnbook}[2]{\htmladdnormallink{#1}{http://svnbook.red-bean.com/en/1.5/#2.html}}

<tex2html_mydb_mark>#22#%\pagestyle{empty}

<tex2html_mydb_mark>#23#%each page number

<tex2html_mydb_mark>#24#%\input{amssym.def}

<tex2html_mydb_mark>#25#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<tex2html_mydb_mark>#26#%%%%5   \date{\normalsize\today}

<tex2html_mydb_mark>#27#%%%%%%%%%%%%%%%%012345678012345678

<tex2html_mydb_mark>#28#%\vspace{2cm}

<tex2html_mydb_mark>#29#%\vspace{2cm}

<tex2html_mydb_mark>#30#%1 edit chapter1/chapter1.erb

<tex2html_mydb_mark>#31#}
{
<tex2html_mydb_mark>#32#% Never edit chapter1.tex!!. Edit chapter1.erb or changes may

<tex2html_mydb_mark>#33#% dissapear

<tex2html_mydb_mark>#34#% \includegraphics[scale=1.2]{chapter1/javascript_natives.png}

<tex2html_mydb_mark>#35#% \begin{figure}[htb]

<tex2html_mydb_mark>#36#% \centerline{\epsfig{file=chapter1/javascript_natives.eps, height=14cm}}

<tex2html_mydb_mark>#37#% \caption{Jerarquía de Prototipos Nativos}

<tex2html_mydb_mark>#38#% \label{figure:javascriptnatives}

<tex2html_mydb_mark>#39#% \end{figure}

<tex2html_mydb_mark>#40#% \includegraphics[scale=1]{chapter1/proto_and_prototypes.png}

<tex2html_mydb_mark>#41#
;SPMgt; z
{ x: 3, y: 1 }
;SPMgt; Object.keys(z)
?????
;SPMgt; Object.keys(z).forEach(function(i) { console.log(i+;SPMquot; -;SPMgt; ;SPMquot;+z[i]); })
?????
<tex2html_mydb_mark>#42#
;SPMgt; z
{ x: 2, y: 1 }
;SPMgt; Object.defineProperty(z, 'y', {writable : false})
{ x: 2, y: 1 }
;SPMgt; z.x = 3
??????
;SPMgt; z.y = 2
??????
;SPMgt; z
<tex2html_mydb_mark>#43#
;SPMgt; obj = { x : 1, y : 2}
{ x: 1, y: 2 }
;SPMgt; bValue = 5
5
;SPMgt; Object.defineProperty(obj, ;SPMquot;b;SPMquot;, {get: function(){ return bValue; }, 
                                   set: function(y){ bValue = y; }}) 
{ x: 1, y: 2 }
;SPMgt; obj.b = ;SPMquot;hello;SPMquot;

;SPMgt; bValue

;SPMgt; obj.b

;SPMgt; bValue = ;SPMquot;world;SPMquot;

;SPMgt; obj.b

;SPMgt;
<tex2html_mydb_mark>#44#
;SPMgt; var o = {};
undefined
;SPMgt; Object.defineProperty(o, ;SPMquot;a;SPMquot;, { value : 1, enumerable:true });
{ a: 1 }
;SPMgt; Object.defineProperty(o, ;SPMquot;b;SPMquot;, { value : 2, enumerable:false });
{ a: 1 }
;SPMgt; Object.defineProperty(o, ;SPMquot;c;SPMquot;, { value : 3 }); // enumerable defaults to false
{ a: 1 }
;SPMgt; o.d = 4; // enumerable defaults to true when creating a property by setting it
4
;SPMgt;  
undefined
;SPMgt; for (var i in o) {    
...   console.log(i);  
... }
???????
;SPMgt; Object.keys(o); 
???????
;SPMgt; o.propertyIsEnumerable('a'); 
????
;SPMgt; o.propertyIsEnumerable('b');
????
;SPMgt; o.propertyIsEnumerable('c');
????
;SPMgt; o.b
????
;SPMgt; o[;SPMquot;b;SPMquot;]
????
<tex2html_mydb_mark>#45#
;SPMgt; function foo(a, b){return a * b;}
undefined
;SPMgt; f = function foo(a, b){return a * b;}
[Function: foo]
;SPMgt; foo.length
2
;SPMgt; foo.constructor
[Function: Function]
;SPMgt; foo.prototype
{}
;SPMgt; typeof foo.prototype
'object'
;SPMgt; [1, 2].constructor
[Function: Array]
<tex2html_mydb_mark>#46#
;SPMgt; Object.getPrototypeOf({ a: 1})

;SPMgt; Object.getPrototypeOf([1,2,3])

;SPMgt; Object.getPrototypeOf([1,2,3]) == Array.prototype

;SPMgt; Object.getPrototypeOf({ a:1 }) === Object.prototype

;SPMgt; Object.getPrototypeOf(Array.prototype)

;SPMgt; Object.getPrototypeOf(Object.prototype)

;SPMgt; Object.getPrototypeOf(function() {})

;SPMgt; Object.getPrototypeOf(Object.getPrototypeOf(function() {}))

;SPMgt; [1,2,3].__proto__

;SPMgt; [1,2,3].__proto__ == Array.prototype
<tex2html_mydb_mark>#47#
var b = new Foo(20);
var c = new Foo(30);
<tex2html_mydb_mark>#48#
;SPMgt; o = { x: 1}
{ x: 1 }
;SPMgt; ;SPMquot;x;SPMquot; in o
true
;SPMgt; ;SPMquot;y;SPMquot; in o
false
;SPMgt; ;SPMquot;toString;SPMquot; in o
true
;SPMgt; o.hasOwnProperty('x')
true
;SPMgt; o.hasOwnProperty('toString')
false
<tex2html_mydb_mark>#49#
;SPMgt; o = { x: 1 }
{ x: 1 }
;SPMgt; b = Object.create(o)
{}
;SPMgt; b.y = 2
2
;SPMgt; b.propertyIsEnumerable('x')
false
;SPMgt; b.propertyIsEnumerable('y')
true
;SPMgt; Object.prototype.propertyIsEnumerable('toString')
false
;SPMgt; a = {x:1, y:2 }
{ x: 1, y: 2 }
;SPMgt; b = Object.create(a)
{}
;SPMgt; b.z = 3
3
;SPMgt; for(i in b) console.log(b[i])
3
1
2
undefined
;SPMgt; for(i in b) console.log(i)
z
x
y
undefined
;SPMgt; b.propertyIsEnumerable(;SPMquot;toString;SPMquot;)
false
<tex2html_mydb_mark>#50#
[~/Dropbox/src/javascript/learning]$ cat call.js 
var Bob = {
  name: ;SPMquot;Bob;SPMquot;,
  greet: function() {
    console.log(;SPMquot;Hi, I'm ;SPMquot; + this.name);
  }
}
 
var Alice = {
  name: ;SPMquot;Alice;SPMquot;,
};

Bob.greet.call(Alice);
<tex2html_mydb_mark>#51#
[~/Dropbox/src/javascript/learning]$ node call.js
Hi, I'm Alice
<tex2html_mydb_mark>#52#
[~/Dropbox/src/javascript/inheritance]$ cat inh1.js 
//Shape - superclass
function Shape() {
  this.x = 0;
  this.y = 0;
}
 
Shape.prototype.toString = function() {
  return ;SPMquot;(;SPMquot;+this.x+;SPMquot;, ;SPMquot;+this.y+;SPMquot;);SPMquot;;
}

Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info(;SPMquot;Shape moved to ;SPMquot;+this);
};
 
// Rectangle - subclass
function Rectangle() {
  Shape.call(this); //call super constructor.
}
 
// Rectangle inherits from Shape
Rectangle.prototype = Object.create(Shape.prototype);
 
var rect = new Rectangle();
 
console.log(;SPMquot;x = ;SPMquot;+rect);
console.log(;SPMquot;rect is an instance of Rectangle? ;SPMquot;+(rect instanceof Rectangle)) //true.
console.log(;SPMquot;rect is an instance of Shape? ;SPMquot;+(rect instanceof Shape))         //true.
 
rect.move(1, 2); //Outputs, ;SPMquot;Shape moved.;SPMquot;
<tex2html_mydb_mark>#53#
[~/Dropbox/src/javascript/inheritance]$ node inh1.js 
x = (0, 0)
rect is an instance of Rectangle? true
rect is an instance of Shape? true
Shape moved to (1, 2)
<tex2html_mydb_mark>#54#
;SPMgt; function f() { console.log(this.x); }
undefined
;SPMgt; f.toString()
'function f() { console.log(this.x); }'
;SPMgt; z = { x : 99 }
{ x: 99 }
;SPMgt; f.call(z)
99
undefined
;SPMgt;
<tex2html_mydb_mark>#55#
;SPMgt; o  = { x : 15 }
{ x: 15 }
;SPMgt; function f(m) { console.log(m+;SPMquot; ;SPMquot;+this.x); }
undefined
;SPMgt; f(;SPMquot;invoking f;SPMquot;)
invoking f 10
undefined
;SPMgt; f.call(o, ;SPMquot;invoking f via call;SPMquot;);
invoking f via call 15
undefined
<tex2html_mydb_mark>#56#
;SPMgt; String.prototype.repeat = function(times) {
...   return new Array(times+1).join(this)
... }
[Function]
;SPMgt;  
undefined
;SPMgt; ;SPMquot;hello;SPMquot;.repeat(3)

;SPMgt;
<tex2html_mydb_mark>#57#
;SPMgt; z = Object.create({x:1, y:2})
{}
;SPMgt; z.x

;SPMgt; z.y

;SPMgt; z.__proto__

;SPMgt; z.__proto__.__proto__

;SPMgt; z.__proto__.__proto__.__proto__
<tex2html_mydb_mark>#58#
;SPMgt; obj = {x : 'something' }
{ x: 'something' }
;SPMgt; w = Object.create(obj)
{}
;SPMgt; w.x
'something'
;SPMgt; w.x = ;SPMquot;another thing;SPMquot;
'another thing'
;SPMgt; w.__proto__

;SPMgt; obj == w.__proto__
<tex2html_mydb_mark>#59#
;SPMgt; obj = {x : { y : 1} }
{ x: { y: 1 } }
;SPMgt; w = Object.create(obj)
{}
;SPMgt; w.x == obj.x
true
;SPMgt; w.x.y = 2
2
;SPMgt; obj
{ x: { y: 2 } }
;SPMgt;
<tex2html_mydb_mark>#60#
;SPMgt; inherit = Object.create
[Function: create]
;SPMgt; o = {}
{}
;SPMgt; o.x = 1
1
;SPMgt; p = inherit(o)
{}
;SPMgt; p.x
1
;SPMgt; p.y = 2
2
;SPMgt; p
{ y: 2 }
;SPMgt; o
{ x: 1 }
;SPMgt; o.y
undefined
;SPMgt; q = inherit(p)
{}
;SPMgt; q.z = 3
3
;SPMgt; q
{ z: 3 }
;SPMgt; s = q.toString()
'[object Object]'
;SPMgt; q.x+q.y+q.z
6
;SPMgt; o.x
1
;SPMgt; o.x = 4
4
;SPMgt; p.x
4
;SPMgt; q.x
4
;SPMgt; q.x = 5
5
;SPMgt; p.x
4
;SPMgt; o.x
4
<tex2html_mydb_mark>#61#%http://nodejs.org/api/modules.html#loading_from_node_modules_Folders

<tex2html_mydb_mark>#62#
[~/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ cat -n hello_world.js 
     1  console.log(;SPMquot;Hello world!;SPMquot;);
     2  a = [ 'batman', 'robin'];
     3  a.push(;SPMquot;superman;SPMquot;);
     4  console.log(a);
     5  h = { name: 'jane rodriguez-leon', department: 'IT' };
     6  console.log(h);
     7  console.log(h['name']);
<tex2html_mydb_mark>#63#
[~/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ node hello_world.js 
Hello world!
[ 'batman', 'robin', 'superman' ]
{ name: 'jane rodriguez-leon', department: 'IT' }
jane rodriguez-leon
<tex2html_mydb_mark>#64#
[~/Dropbox/academica/ETSII/grado/LPP/LPPbook]$ node
;SPMgt; .help
.break  Sometimes you get stuck, this gets you out
.clear  Alias for .break
.exit Exit the repl
.help Show repl options
.load Load JS from a file into the REPL session
.save Save all evaluated commands in this REPL session to a file

;SPMgt; console.log(;SPMquot;Hello world!;SPMquot;)
Hello world!
undefined
;SPMgt; a = [ 'batman', 'robin']
[ 'batman', 'robin' ]
;SPMgt; a.push(;SPMquot;superman;SPMquot;)
3
;SPMgt; a
[ 'batman', 'robin', 'superman' ]
;SPMgt; h = { name: 'jane rodriguez-leon', department: 'IT' }
{ name: 'jane rodriguez-leon',
  department: 'IT' }
;SPMgt; h['name']
'jane rodriguez-leon'
;SPMgt; 4+2
6
;SPMgt; _    # ultimo valor evaluado
6
;SPMgt; _+1
7
;SPMgt; 
;SPMgt; a = [1,2,3]
[ 1, 2, 3 ]
;SPMgt; a.forEach(function(e) { console.log(e); })
1
2
3
;SPMgt; a.forEach(function(v) {
... console.log(v
..... .break
;SPMgt; a
[ 1, 2, 3 ]
;SPMgt; .exit # también CTRL-D en Unix
[~/Dropbox/academica/ETSII/grado/LPP/LPPbook]$
<tex2html_mydb_mark>#65#
[~/Dropbox/src/javascript/node.js/repl(master)]$ cat repl.js 
var repl = require(;SPMquot;repl;SPMquot;);

connections = 0;

repl.start({
  prompt: ;SPMquot;node via stdin;SPMgt; ;SPMquot;,
  input: process.stdin,
  output: process.stdout
});
<tex2html_mydb_mark>#66#
[~/Dropbox/src/javascript/node.js/repl(master)]$ node repl.js 
node via stdin;SPMgt; 2+3
5
node via stdin;SPMgt; .exit
<tex2html_mydb_mark>#67#
[~/Dropbox/src/javascript/node.js/repl(master)]$ cat repl2.js 
var repl = require(;SPMquot;repl;SPMquot;);

z = 4
repl.start({
  prompt: ;SPMquot;node via stdin;SPMgt; ;SPMquot;,
  input: process.stdin,
  output: process.stdout
}).context.m = ;SPMquot;message;SPMquot;;
<tex2html_mydb_mark>#68#
[~/Dropbox/src/javascript/node.js/repl(master)]$ node repl2.js 
node via stdin;SPMgt; z
4
node via stdin;SPMgt; m
'message'
<tex2html_mydb_mark>#69#
[~/Dropbox/src/javascript/node.js/repl(master)]$ cat repl_server.js 
var net = require(;SPMquot;net;SPMquot;),
    repl = require(;SPMquot;repl;SPMquot;);

connections = 0;

net.createServer(function (socket) {
  connections += 1;
  repl.start({
    prompt: ;SPMquot;node via TCP socket;SPMgt; ;SPMquot;,
    input: socket,
    output: socket
  }).on('exit', function() {
    socket.end();
  });
}).listen(5001);

[~/Dropbox/src/javascript/node.js/repl(master)]$ node repl_server.js
<tex2html_mydb_mark>#70#
[~/Dropbox/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ nc -v localhost 5001
nc: connect to localhost port 5001 (tcp) failed: Connection refused
Connection to localhost 5001 port [tcp/commplex-link] succeeded!
node via TCP socket;SPMgt; a = 2+3
5
node via TCP socket;SPMgt; a
5
node via TCP socket;SPMgt; .exit
[~/Dropbox/src/javascript/node.js/hector_correa_introduction_to_node(master)]$
<tex2html_mydb_mark>#71#%j', b.done);

<tex2html_mydb_mark>#72#%j', a.done);

<tex2html_mydb_mark>#73#%j, b.done=%j', a.done, b.done);

<tex2html_mydb_mark>#74#% http://howtonode.org/how-to-module está desactualizado

<tex2html_mydb_mark>#75#
[~/javascript/node.js/creating_modules(master)]$ cat foo.js 
var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));
<tex2html_mydb_mark>#76#
[~/javascript/node.js/creating_modules(master)]$ cat circle.js 
var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
<tex2html_mydb_mark>#77#
[~/javascript/node.js/creating_modules(master)]$ node foo.js The area of a circle of radius 4 is 50.26548245743669
<tex2html_mydb_mark>#78#
[~/javascript/node.js/creating_modules(master)]$ node debug foo.js 
;SPMlt; debugger listening on port 5858
connecting... ok
break in foo.js:1
  1 var circle = require('./circle.js');
  2 console.log( 'The area of a circle of radius 4 is '
  3            + circle.area(4));
debug;SPMgt; n
break in foo.js:2
  1 var circle = require('./circle.js');
  2 console.log( 'The area of a circle of radius 4 is '
  3            + circle.area(4));
  4 
debug;SPMgt; repl
Press Ctrl + C to leave debug repl
;SPMgt; circle
{ circumference: [Function],
  area: [Function] }
;SPMgt; circle.area(2)
12.566370614359172
;SPMgt; PI
ReferenceError: PI is not defined
;SPMgt;
<tex2html_mydb_mark>#79#
[~/javascript/node.js/creating_modules/cycles(master)]$ cat a.js
console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');
<tex2html_mydb_mark>#80#
[~/javascript/node.js/creating_modules/cycles(master)]$ cat b.js
console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');
<tex2html_mydb_mark>#81#
[~/javascript/node.js/creating_modules/cycles(master)]$ cat main.js
console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);

<tex2html_mydb_mark>#82#
[~/javascript/node.js/creating_modules/cycles(master)]$ node main.js 
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
<tex2html_mydb_mark>#83#
/home/ry/projects/node_modules/bar.js
/home/ry/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
<tex2html_mydb_mark>#84#
{ ;SPMquot;name;SPMquot; : ;SPMquot;some-library;SPMquot;,
  ;SPMquot;main;SPMquot; : ;SPMquot;./lib/some-library.js;SPMquot; }
<tex2html_mydb_mark>#85#
./some-library/index.js
./some-library/index.node
<tex2html_mydb_mark>#86#
[~/javascript/node.js/creating_modules/module_exports(master)]$ cat a.js
var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);
<tex2html_mydb_mark>#87#
$ cat main.js 
var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});
<tex2html_mydb_mark>#88#
$ node main.js 
module a is ready
<tex2html_mydb_mark>#89#%start ... %;SPMquot;);

<tex2html_mydb_mark>#90#%start spec

<tex2html_mydb_mark>#91#%{
    
<tex2html_mydb_mark>#92#%}

<tex2html_mydb_mark>#93#%

<tex2html_mydb_mark>#94#%%' grammar optional_end_block EOF
            
<tex2html_mydb_mark>#95#%%' grammar '%%' CODE EOF
            
<tex2html_mydb_mark>#96#%%'
        
<tex2html_mydb_mark>#97#%

<tex2html_mydb_mark>#98#%%% TEXEXPAND: END FILE ./chapter_node/node.tex

<tex2html_mydb_mark>#99#
[~/javascript/PLgrado/ebnf-parser(master)]$ cat -n package.json 
   1  {
   2    ;SPMquot;name;SPMquot;: ;SPMquot;ebnf-parser;SPMquot;,
   3    ;SPMquot;version;SPMquot;: ;SPMquot;0.1.1;SPMquot;,
   4    ;SPMquot;description;SPMquot;: ;SPMquot;A parser for BNF and EBNF grammars used by jison;SPMquot;,
   5    ;SPMquot;main;SPMquot;: ;SPMquot;ebnf-parser.js;SPMquot;,
   6    ;SPMquot;scripts;SPMquot;: {
   7      ;SPMquot;test;SPMquot;: ;SPMquot;make test;SPMquot;
   8    },
   9    ;SPMquot;repository;SPMquot;: ;SPMquot;;SPMquot;,
  10    ;SPMquot;keywords;SPMquot;: [
  11      ;SPMquot;bnf;SPMquot;,
  12      ;SPMquot;ebnf;SPMquot;,
  13      ;SPMquot;grammar;SPMquot;,
  14      ;SPMquot;parser;SPMquot;,
  15      ;SPMquot;jison;SPMquot;
  16    ],
  17    ;SPMquot;author;SPMquot;: ;SPMquot;Zach Carter;SPMquot;,
  18    ;SPMquot;license;SPMquot;: ;SPMquot;MIT;SPMquot;,
  19    ;SPMquot;devDependencies;SPMquot;: {
  20      ;SPMquot;jison;SPMquot;: ;SPMquot;0.4.x;SPMquot;,
  21      ;SPMquot;lex-parser;SPMquot;: ;SPMquot;0.1.0;SPMquot;,
  22      ;SPMquot;test;SPMquot;: ;SPMquot;*;SPMquot;
  23    }
  24  }
<tex2html_mydb_mark>#100#
$ cat README.md 

# ebnf-parser

A parser for BNF and EBNF grammars used by jison.

## install

    npm install ebnf-parser


## build

To build the parser yourself, clone the git repo then run:

    make

This will generate `parser.js`, which is required by `ebnf-parser.js`.

## usage

The parser translates a string grammar or JSON grammar into a JSON grammar that jison can use (ENBF is transformed into BNF).

    var ebnfParser = require('ebnf-parser');

    // parse a bnf or ebnf string grammar
    ebnfParser.parse(;SPMquot;%start ... %;SPMquot;);

    // transform an ebnf JSON gramamr
    ebnfParser.transform({;SPMquot;ebnf;SPMquot;: ...});


## example grammar

The parser can parse its own BNF grammar, shown below:

    %start spec

    /* grammar for parsing jison grammar files */

    %{
    var transform = require('./ebnf-transform').transform;
    var ebnf = false;
    %}

    %%

    spec
        : declaration_list '%%' grammar optional_end_block EOF
            {$$ = $1; return extend($$, $3);}
        | declaration_list '%%' grammar '%%' CODE EOF
            {$$ = $1; yy.addDeclaration($$,{include:$5}); return extend($$, $3);}
        ;

    optional_end_block
        :
        | '%%'
        ;

    declaration_list
        : declaration_list declaration
            {$$ = $1; yy.addDeclaration($$, $2);}
        |
            {$$ = {};}
        ;

    declaration
        : START id
            {$$ = {start: $2};}
        | LEX_BLOCK
            {$$ = {lex: $1};}
        | operator
            {$$ = {operator: $1};}
        | ACTION
            {$$ = {include: $1};}
        ;

    operator
        : associativity token_list
            {$$ = [$1]; $$.push.apply($$, $2);}
        ;

    associativity
        : LEFT
            {$$ = 'left';}
        | RIGHT
            {$$ = 'right';}
        | NONASSOC
            {$$ = 'nonassoc';}
        ;

    token_list
        : token_list symbol
            {$$ = $1; $$.push($2);}
        | symbol
            {$$ = [$1];}
        ;

    grammar
        : production_list
            {$$ = $1;}
        ;

    production_list
        : production_list production
            {$$ = $1;
              if($2[0] in $$) $$[$2[0]] = $$[$2[0]].concat($2[1]);
              else  $$[$2[0]] = $2[1];}
        | production
            {$$ = {}; $$[$1[0]] = $1[1];}
        ;

    production
        : id ':' handle_list ';'
            {$$ = [$1, $3];}
        ;

    handle_list
        : handle_list '|' handle_action
            {$$ = $1; $$.push($3);}
        | handle_action
            {$$ = [$1];}
        ;

    handle_action
        : handle prec action
            {$$ = [($1.length ? $1.join(' ') : '')];
                if($3) $$.push($3);
                if($2) $$.push($2);
                if ($$.length === 1) $$ = $$[0];
            }
        ;

    handle
        : handle expression_suffix
            {$$ = $1; $$.push($2)}
        |
            {$$ = [];}
        ;

    handle_sublist
        : handle_sublist '|' handle
            {$$ = $1; $$.push($3.join(' '));}
        | handle
            {$$ = [$1.join(' ')];}
        ;

    expression_suffix
        : expression suffix
            {$$ = $expression + $suffix; }
        ;

    expression
        : ID
            {$$ = $1; }
        | STRING
            {$$ = ebnf ? ;SPMquot;';SPMquot;+$1+;SPMquot;';SPMquot; : $1; }
        | '(' handle_sublist ')'
            {$$ = '(' + $handle_sublist.join(' | ') + ')'; }
        ;

    suffix
        : {$$ = ''}
        | '*'
        | '?'
        | '+'
        ;

    prec
        : PREC symbol
            {$$ = {prec: $2};}
        |
            {$$ = null;}
        ;

    symbol
        : id
            {$$ = $1;}
        | STRING
            {$$ = yytext;}
        ;

    id
        : ID
            {$$ = yytext;}
        ;

    action
        : '{' action_body '}'
            {$$ = $2;}
        | ACTION
            {$$ = $1;}
        | ARROW_ACTION
            {$$ = '$$ ='+$1+';';}
        |
            {$$ = '';}
        ;

    action_body
        :
            {$$ = '';}
        | ACTION_BODY
            {$$ = yytext;}
        | action_body '{' action_body '}' ACTION_BODY
            {$$ = $1+$2+$3+$4+$5;}
        | action_body '{' action_body '}'
            {$$ = $1+$2+$3+$4;}
        ;

    %%

    // transform ebnf to bnf if necessary
    function extend (json, grammar) {
        json.bnf = ebnf ? transform(grammar) : grammar;
        return json;
    }

## license

MIT
<tex2html_mydb_mark>#101#%%% TEXEXPAND: END FILE ./chapter1/chapter1.tex

<tex2html_mydb_mark>#102#%2

<tex2html_mydb_mark>#103#
$sudo npm install n -g
<tex2html_mydb_mark>#104#
[~/Dropbox/src/javascript/node.js/creating_modules(master)]$ n help

  Usage: n [options] [COMMAND] [config]

  Commands:

    n                            Output versions installed
    n latest [config ...]        Install or activate the latest node release
    n stable [config ...]        Install or activate the latest stable node release
    n ;SPMlt;version;SPMgt; [config ...]     Install and/or use node ;SPMlt;version;SPMgt;
    n use ;SPMlt;version;SPMgt; [args ...]   Execute node ;SPMlt;version;SPMgt; with [args ...]
    n bin ;SPMlt;version;SPMgt;              Output bin path for ;SPMlt;version;SPMgt;
    n rm ;SPMlt;version ...;SPMgt;           Remove the given version(s)
    n prev                       Revert to the previously activated version
    n --latest                   Output the latest node version available
    n --stable                   Output the latest stable node version available
    n ls                         Output the versions of node available

  Options:

    -V, --version   Output current version of n
    -h, --help      Display help information

  Aliases:

    which   bin
    use     as
    list    ls
    -       rm
<tex2html_mydb_mark>#105#
$ sudo n latest
<tex2html_mydb_mark>#106#%  Power Sh. JavaScript Cookbook. Chapter 1. Working with JavaScript Strings

<tex2html_mydb_mark>#107#%  David Flanagan. JavaScript, the Definitive Guide. O'Reilly.  Chapter 10.

<tex2html_mydb_mark>#108#%  JavaScript. The Missing Manual. Chapter 4. working with words, numbers and dates. A quick object lesson

<tex2html_mydb_mark>#109#%% _.each(items, function(name) { %;SPMgt;;SPMquot;     +
            
<tex2html_mydb_mark>#110#%%= name %;SPMgt;;SPMlt;/td;SPMgt;;SPMquot; +
            
<tex2html_mydb_mark>#111#%% }); %;SPMgt;;SPMquot;;

<tex2html_mydb_mark>#112#%% _.each(items, function(name) { %;SPMamp;gt;;SPMamp;quot;;SPMlt;/span;SPMgt;     ;SPMlt;span class=;SPMquot;o;SPMquot;;SPMgt;+;SPMlt;/span;SPMgt;
            
<tex2html_mydb_mark>#113#%%= name %;SPMamp;gt;;SPMamp;lt;/td;SPMamp;gt;;SPMamp;quot;;SPMlt;/span;SPMgt; ;SPMlt;span class=;SPMquot;o;SPMquot;;SPMgt;+;SPMlt;/span;SPMgt;
            
<tex2html_mydb_mark>#114#%% }); %;SPMamp;gt;;SPMamp;quot;;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;p;SPMquot;;SPMgt;;;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#115#% \includegraphics[scale=0.5]{chapter2/repeated_words.png}

<tex2html_mydb_mark>#116#%  Match INI section headers page 472

<tex2html_mydb_mark>#117#%  Match INI section blocks

<tex2html_mydb_mark>#118#%  Match INI name-value pairs

<tex2html_mydb_mark>#119#%  practica: INI configuration files

<tex2html_mydb_mark>#120#%= ______ %;SPMgt;;SPMquot;;SPMgt; ;SPMlt;%= _ %;SPMgt; ;SPMlt;/span;SPMgt;\n';

<tex2html_mydb_mark>#121#%  ver herramientas firefox y chrome para desarrollo

<tex2html_mydb_mark>#122#%s\n;SPMquot;, msgbuf);
                
<tex2html_mydb_mark>#123#
    <pre>
<span class="nt">;SPMlt;html;SPMgt;</span>
  <span class="nt">;SPMlt;head;SPMgt;</span>
      <span class="nt">;SPMlt;meta</span> <span class="na">http-equiv=</span><span class="s">;SPMquot;Content-Type;SPMquot;</span> <span class="na">content=</span><span class="s">;SPMquot;text/html; charset=UTF-8;SPMquot;</span><span class="nt">;SPMgt;</span>
      <span class="nt">;SPMlt;title;SPMgt;</span>JavaScript Temperature Converter<span class="nt">;SPMlt;/title;SPMgt;</span>
      <span class="nt">;SPMlt;link</span> <span class="na">href=</span><span class="s">;SPMquot;global.css;SPMquot;</span> <span class="na">rel=</span><span class="s">;SPMquot;stylesheet;SPMquot;</span> <span class="na">type=</span><span class="s">;SPMquot;text/css;SPMquot;</span><span class="nt">;SPMgt;</span>

     <span class="nt">;SPMlt;script </span><span class="na">type=</span><span class="s">;SPMquot;text/javascript;SPMquot;</span> <span class="na">src=</span><span class="s">;SPMquot;temperature.js;SPMquot;</span><span class="nt">;SPMgt;;SPMlt;/script;SPMgt;</span>
  <span class="nt">;SPMlt;/head;SPMgt;</span>
  <span class="nt">;SPMlt;body;SPMgt;</span>
    <span class="nt">;SPMlt;h1;SPMgt;</span>Temperature Converter<span class="nt">;SPMlt;/h1;SPMgt;</span>
    <span class="nt">;SPMlt;table;SPMgt;</span>
      <span class="nt">;SPMlt;tr;SPMgt;</span>
        <span class="nt">;SPMlt;th;SPMgt;</span>Enter  Temperature (examples: 32F, 45C, -2.5f):<span class="nt">;SPMlt;/th;SPMgt;</span>
        <span class="nt">;SPMlt;td;SPMgt;;SPMlt;input</span> <span class="na">id=</span><span class="s">;SPMquot;original;SPMquot;</span> <span class="na">onchange=</span><span class="s">;SPMquot;calculate();;SPMquot;</span><span class="nt">;SPMgt;;SPMlt;/td;SPMgt;</span>
      <span class="nt">;SPMlt;/tr;SPMgt;</span>
      <span class="nt">;SPMlt;tr;SPMgt;</span>
        <span class="nt">;SPMlt;th;SPMgt;</span>Converted Temperature:<span class="nt">;SPMlt;/th;SPMgt;</span>
        <span class="nt">;SPMlt;td;SPMgt;;SPMlt;span</span> <span class="na">class=</span><span class="s">;SPMquot;output;SPMquot;</span> <span class="na">id=</span><span class="s">;SPMquot;converted;SPMquot;</span><span class="nt">;SPMgt;;SPMlt;/span;SPMgt;;SPMlt;/td;SPMgt;</span>
      <span class="nt">;SPMlt;/tr;SPMgt;</span>
    <span class="nt">;SPMlt;/table;SPMgt;</span>
  <span class="nt">;SPMlt;/body;SPMgt;</span>
<span class="nt">;SPMlt;/html;SPMgt;</span>
    </pre>
<tex2html_mydb_mark>#124#
    <pre>
<span class="nt">th</span><span class="o">,</span> <span class="nt">td</span>      <span class="p">{</span> <span class="k">vertical-align</span><span class="o">:</span> <span class="k">top</span><span class="p">;</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span> <span class="p">}</span>     
<span class="nf">#converted</span>  <span class="p">{</span> <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span> <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span>          <span class="p">}</span>    
<span class="nt">input</span>       <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span>  <span class="k">border</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span>       <span class="p">}</span>   
<span class="nt">body</span>
<span class="p">{</span>
 <span class="k">background-color</span><span class="o">:</span><span class="m">#b0c4de</span><span class="p">;</span>  <span class="c">/* blue */</span>
 <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span>
<span class="p">}</span>
    </pre>
<tex2html_mydb_mark>#125#
    <pre>
<span class="s2">;SPMquot;use strict;SPMquot;</span><span class="p">;</span> <span class="c1">// Use ECMAScript 5 strict mode in browsers that support it</span>
<span class="kd">function</span> <span class="nx">calculate</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">original</span>       <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">;SPMquot;........;SPMquot;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">original</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="sr">/.............................../</span><span class="p">;</span>
  
  <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">match</span><span class="p">(......);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="p">....;</span>
    <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="p">....;</span>
    <span class="nx">num</span> <span class="o">=</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="o">||</span> <span class="nx">type</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span> <span class="o">*</span> <span class="mi">9</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">32</span><span class="p">;</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">..............................</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="o">/</span><span class="mi">9</span><span class="p">;</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">............................</span>
    <span class="p">}</span>
    <span class="nx">converted</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">converted</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">;SPMquot;ERROR! Try something like &#39;-4.2C&#39; instead;SPMquot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    </pre>
<tex2html_mydb_mark>#126#
<DIV ALIGN="CENTER"><A NAME="figure:csv"></A><A NAME="1213"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura:</STRONG>
Ejemplo de pantalla de La aplicación para el Análisis de Datos en Formato CSV</CAPTION>
<TR><TD><IMG
 WIDTH="769" HEIGHT="410" BORDER="0"
 SRC="csv.png"
 ALT="\begin{figure}\begin{center}
\centerline{\epsfig{file=chapter2/csv.eps, width=17cm}}
\end{center}
\end{figure}"></TD></TR>
</TABLE>
</DIV>
<tex2html_mydb_mark>#127#
;SPMgt; x = ';SPMquot;earth;SPMquot;,1,;SPMquot;moon;SPMquot;,9.374'
';SPMquot;earth;SPMquot;,1,;SPMquot;moon;SPMquot;,9.374'
;SPMgt; y = x.split(/,/)
[ ';SPMquot;earth;SPMquot;', '1', ';SPMquot;moon;SPMquot;', '9.374' ]
<tex2html_mydb_mark>#128#
;SPMgt; x = ';SPMquot;earth, mars;SPMquot;,1,;SPMquot;moon, fobos;SPMquot;,9.374'
';SPMquot;earth, mars;SPMquot;,1,;SPMquot;moon, fobos;SPMquot;,9.374'
;SPMgt; y = x.split(/,/)
[ ';SPMquot;earth', ' mars;SPMquot;', '1', ';SPMquot;moon', ' fobos;SPMquot;', '9.374' ]
<tex2html_mydb_mark>#129#
;SPMgt; x = ';SPMquot;earth, mars;SPMquot;,1,;SPMquot;moon, fobos;SPMquot;,9.374'
';SPMquot;earth, mars;SPMquot;,1,;SPMquot;moon, fobos;SPMquot;,9.374'
;SPMgt; r = /;SPMquot;((?:[^;SPMquot;\\]|\\.)*);SPMquot;\s*,?/g
/;SPMquot;((?:[^;SPMquot;\\]|\\.)*);SPMquot;\s*,?/g
;SPMgt; w = x.match(r)
[ ';SPMquot;earth, mars;SPMquot;,', ';SPMquot;moon, fobos;SPMquot;,' ]
<tex2html_mydb_mark>#130#
;SPMgt; x = ';SPMquot;earth, mars;SPMquot;,1,;SPMquot;moon, fobos;SPMquot;,9.374'
';SPMquot;earth, mars;SPMquot;,1,;SPMquot;moon, fobos;SPMquot;,9.374'
;SPMgt; r = /([^,]+),?|\s*,/g
/([^,]+),?|\s*,/g
;SPMgt; w = x.match(r)
[ ';SPMquot;earth,', ' mars;SPMquot;,', '1,', ';SPMquot;moon,', ' fobos;SPMquot;,', '9.374' ]
<tex2html_mydb_mark>#131#
;SPMlt;html;SPMgt;
  ;SPMlt;head;SPMgt;
     ;SPMlt;meta http-equiv=;SPMquot;Content-Type;SPMquot; content=;SPMquot;text/html; charset=UTF-8;SPMquot;;SPMgt;
     ;SPMlt;title;SPMgt;CSV Analyzer;SPMlt;/title;SPMgt;
     ;SPMlt;link href=;SPMquot;global.css;SPMquot; rel=;SPMquot;stylesheet;SPMquot; type=;SPMquot;text/css;SPMquot;;SPMgt;

     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../../underscore/underscore.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../../jquery/starterkit/jquery.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;csv.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;Comma Separated Value Analyzer;SPMlt;/h1;SPMgt;
    ;SPMlt;div;SPMgt;
      ;SPMlt;i;SPMgt;Write a CSV string. Click the table button. The program outputs a table with the specified data.;SPMlt;/i;SPMgt;
    ;SPMlt;/div;SPMgt;
    ;SPMlt;table;SPMgt;
      ;SPMlt;tr;SPMgt;
        ;SPMlt;th;SPMgt;CSV string:;SPMlt;/th;SPMgt; ;SPMlt;!-- autofocus attribute is HTML5 --;SPMgt;
        ;SPMlt;td;SPMgt;;SPMlt;textarea autofocus cols = ;SPMquot;80;SPMquot; rows = ;SPMquot;5;SPMquot; id=;SPMquot;original;SPMquot;;SPMgt;;SPMlt;/textarea;SPMgt;;SPMlt;/td;SPMgt; 
      ;SPMlt;/tr;SPMgt;
    ;SPMlt;/table;SPMgt;
    ;SPMlt;button type=;SPMquot;button;SPMquot;;SPMgt;table:;SPMlt;/button;SPMgt;;SPMlt;br;SPMgt;
    ;SPMlt;span class=;SPMquot;output;SPMquot; id=;SPMquot;finaltable;SPMquot;;SPMgt;;SPMlt;/span;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#132#
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: right; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
body
{
 background-color:#b0c4de;  /* blue */
}
<tex2html_mydb_mark>#133#
    <pre>
<span class="c1">// See http://en.wikipedia.org/wiki/Comma-separated_values</span>
<span class="s2">;SPMquot;use strict;SPMquot;</span><span class="p">;</span> <span class="c1">// Use ECMAScript 5 strict mode in browsers that support it</span>

<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">$</span><span class="p">(</span><span class="s2">;SPMquot;button;SPMquot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">calculate</span><span class="p">();</span>
   <span class="p">});</span>
 <span class="p">});</span>

<span class="kd">function</span> <span class="nx">calculate</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">original</span>       <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">;SPMquot;original;SPMquot;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">original</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="sr">/_____________________________________________/g</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">lines</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/\n+\s*/</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">commonLength</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// Template using underscore</span>
  <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="s2">;SPMquot;;SPMlt;%% _.each(items, function(name) { %;SPMgt;;SPMquot;</span>     <span class="o">+</span>
            <span class="s2">;SPMquot;                    ;SPMlt;td;SPMgt;;SPMlt;%%= name %;SPMgt;;SPMlt;/td;SPMgt;;SPMquot;</span> <span class="o">+</span>
            <span class="s2">;SPMquot;              ;SPMlt;%% }); %;SPMgt;;SPMquot;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">)</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">original</span>  <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">t</span> <span class="k">in</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">lines</span><span class="p">[</span><span class="nx">t</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">regexp</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">error</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">commonLength</span> <span class="o">;SPMamp;;SPMamp;</span> <span class="p">(</span><span class="nx">commonLength</span> <span class="o">!=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">//alert(&#39;ERROR! row ;SPMlt;&#39;+temp+&#39;;SPMgt; has &#39;+m.length+&#39; items!&#39;);</span>
        <span class="nx">error</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="nx">commonLength</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="nx">error</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">removecomma</span> <span class="o">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/,\s*$/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">remove1stquote</span> <span class="o">=</span> <span class="nx">removecomma</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^\s*;SPMquot;/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">removelastquote</span> <span class="o">=</span> <span class="nx">remove1stquote</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/;SPMquot;\s*$/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">removeescapedquotes</span> <span class="o">=</span> <span class="nx">removelastquote</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\;SPMquot;/</span><span class="p">,</span><span class="s1">&#39;;SPMquot;&#39;</span><span class="p">);</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">removeescapedquotes</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">tr</span> <span class="o">=</span> <span class="nx">error</span><span class="o">?</span> <span class="s1">&#39;;SPMlt;tr class=;SPMquot;error;SPMquot;;SPMgt;&#39;</span> <span class="o">:</span> <span class="s1">&#39;;SPMlt;tr;SPMgt;&#39;</span><span class="p">;</span>
      <span class="nx">r</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tr</span><span class="o">+</span><span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="p">{</span><span class="nx">items</span> <span class="o">:</span> <span class="nx">result</span><span class="p">})</span><span class="o">+</span><span class="s2">;SPMquot;;SPMlt;/tr;SPMgt;;SPMquot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;ERROR! row &#39;</span><span class="o">+</span><span class="nx">temp</span><span class="o">+</span><span class="s1">&#39; does not look as legal CSV&#39;</span><span class="p">);</span>
      <span class="nx">error</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="s1">&#39;;SPMlt;p;SPMgt;\n;SPMlt;table class=;SPMquot;center;SPMquot; id=;SPMquot;result;SPMquot;;SPMgt;&#39;</span><span class="p">);</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;;SPMlt;/table;SPMgt;&#39;</span><span class="p">);</span>
  <span class="c1">//alert(r.join(&#39;\n&#39;)); // debug</span>
  <span class="nx">finaltable</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// If the browser supports localStorage and we have some stored data</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span> <span class="o">;SPMamp;;SPMamp;</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">original</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">;SPMquot;original;SPMquot;</span><span class="p">).</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">original</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
    </pre>
<tex2html_mydb_mark>#134#
;SPMgt; str = ;SPMquot;John Smith;SPMquot;
'John Smith'
;SPMgt; newstr = str.replace(re, ;SPMquot;$2, $1;SPMquot;)
'Smith, John'
<tex2html_mydb_mark>#135#
;SPMgt; re = /d(b+)(d)/ig
/d(b+)(d)/gi
;SPMgt; z = ;SPMquot;dBdxdbbdzdbd;SPMquot;
'dBdxdbbdzdbd'
;SPMgt; result = re.exec(z)
[ 'dBd', 'B', 'd', index: 0, input: 'dBdxdbbdzdbd' ]
;SPMgt; re.lastIndex
3
;SPMgt; result = re.exec(z)
[ 'dbbd', 'bb', 'd', index: 4, input: 'dBdxdbbdzdbd' ]
;SPMgt; re.lastIndex
8
;SPMgt; result = re.exec(z)
[ 'dbd', 'b', 'd', index: 9, input: 'dBdxdbbdzdbd' ]
;SPMgt; re.lastIndex
12
;SPMgt; z.length
12
;SPMgt; result = re.exec(z)
null
<tex2html_mydb_mark>#136#
;SPMgt; x = ;SPMquot;hello;SPMquot;
'hello'
;SPMgt; r = /l(?=o)/
/l(?=o)/
;SPMgt; z = r.exec(x)
[ 'l', index: 3, input: 'hello' ]
<tex2html_mydb_mark>#137#
;SPMgt; x = ;SPMquot;hello;SPMquot;
'hello'
;SPMgt; r = /(?;SPMlt;=l)l/
SyntaxError: Invalid regular expression: /(?;SPMlt;=l)l/: Invalid group
;SPMgt; .exit
<tex2html_mydb_mark>#138#
[~/Dropbox/src/javascript/PLgrado/csv(master)]$ irb
ruby-1.9.2-head :001 ;SPMgt; x = ;SPMquot;hello;SPMquot;
 =;SPMgt; ;SPMquot;hello;SPMquot; 
ruby-1.9.2-head :002 ;SPMgt; r = /(?;SPMlt;=l)l/
 =;SPMgt; ll 
ruby-1.9.2-head :008 ;SPMgt; x =~ r
 =;SPMgt; 3 
ruby-1.9.2-head :009 ;SPMgt; $;SPMamp;
 =;SPMgt; ;SPMquot;l;SPMquot;
<tex2html_mydb_mark>#139#
$ cat phone.html 
;SPMlt;!DOCTYPE html;SPMgt;
;SPMlt;html;SPMgt;  
  ;SPMlt;head;SPMgt;  
    ;SPMlt;meta http-equiv=;SPMquot;Content-Type;SPMquot; content=;SPMquot;text/html; charset=ISO-8859-1;SPMquot;;SPMgt;  
    ;SPMlt;meta http-equiv=;SPMquot;Content-Script-Type;SPMquot; content=;SPMquot;text/javascript;SPMquot;;SPMgt;  
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot;;SPMgt;  
      var re = /\(?\d{3}\)?([-\/\.])\d{3}\1\d{4}/;  
      function testInfo(phoneInput){  
        var OK = re.exec(phoneInput.value);  
        if (!OK)  
          window.alert(RegExp.input + ;SPMquot; isn't a phone number with area code!;SPMquot;);  
        else
          window.alert(;SPMquot;Thanks, your phone number is ;SPMquot; + OK[0]);  
      }  
    ;SPMlt;/script;SPMgt;  
  ;SPMlt;/head;SPMgt;  
  ;SPMlt;body;SPMgt;  
    ;SPMlt;p;SPMgt;Enter your phone number (with area code) and then click ;SPMquot;Check;SPMquot;.
        ;SPMlt;br;SPMgt;The expected format is like ###-###-####.;SPMlt;/p;SPMgt;
    ;SPMlt;form action=;SPMquot;#;SPMquot;;SPMgt;  
      ;SPMlt;input id=;SPMquot;phone;SPMquot;;SPMgt;;SPMlt;button onclick=;SPMquot;testInfo(document.getElementById('phone'));;SPMquot;;SPMgt;Check;SPMlt;/button;SPMgt;
    ;SPMlt;/form;SPMgt;  
  ;SPMlt;/body;SPMgt;  
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#140#
;SPMgt; '1111'.match(/^(11+)\1+$/) # 4 unos
[ '1111',
  '11',
  index: 0,
  input: '1111' ]
;SPMgt; '111'.match(/^(11+)\1+$/) # 3 unos
null
;SPMgt; '11111'.match(/^(11+)\1+$/) # 5 unos
null
;SPMgt; '111111'.match(/^(11+)\1+$/) # 6 unos
[ '111111',
  '111',
  index: 0,
  input: '111111' ]
;SPMgt; '11111111'.match(/^(11+)\1+$/) # 8 unos
[ '11111111',
  '1111',
  index: 0,
  input: '11111111' ]
;SPMgt; '1111111'.match(/^(11+)\1+$/)
null
;SPMgt;
<tex2html_mydb_mark>#141#
;SPMgt; x = ;SPMquot;a,b,c,1,2,d, e,f;SPMquot;
'a,b,c,1,2,d, e,f'
;SPMgt; x.replace(/,/g,;SPMquot;, ;SPMquot;)
'a, b, c, 1, 2, d,  e, f'
<tex2html_mydb_mark>#142#
;SPMgt; x = ;SPMquot;a,b,c,1,2,d, e,f;SPMquot;
'a,b,c,1,2,d, e,f'
;SPMgt; x.replace(/,(\S)/g,;SPMquot;, $1;SPMquot;)
'a, b, c, 1, 2, d, e, f'
<tex2html_mydb_mark>#143#
;SPMgt; x = ;SPMquot;a,b,c,1,2,d, e,f;SPMquot;
'a,b,c,1,2,d, e,f'
;SPMgt; x.replace(/,(\D)/g,;SPMquot;, $1;SPMquot;)
'a, b, c,1,2, d,  e, f'
<tex2html_mydb_mark>#144#
;SPMgt; r = /(\d[,.]\d)|(,(?=\S))/g
/(\d[,.]\d)|(,(?=\S))/g
<tex2html_mydb_mark>#145#
;SPMgt; z = ;SPMquot;a,b,1,2,d, 3,4,e;SPMquot;
'a,b,1,2,d, 3,4,e'
;SPMgt; f = function(match, p1, p2, offset, string) { return (p1 || p2 + ;SPMquot; ;SPMquot;); }
[Function]
;SPMgt; z.replace(r, f)
'a, b, 1,2, d, 3,4, e'
<tex2html_mydb_mark>#146#
<pre>
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$  tree --charset utf-8 
.
├── README
├── global.css
├── index.html
├── input.txt
├── input2.txt
├── inputhtml1.txt
└── repeated_words.js

0 directories, 7 files
</pre>
<tex2html_mydb_mark>#147#
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat index.html 
;SPMlt;html;SPMgt;
  ;SPMlt;head;SPMgt;
     ;SPMlt;meta http-equiv=;SPMquot;Content-Type;SPMquot; content=;SPMquot;text/html; charset=UTF-8;SPMquot;;SPMgt;
     ;SPMlt;title;SPMgt;File Input;SPMlt;/title;SPMgt;
     ;SPMlt;link href=;SPMquot;global.css;SPMquot; rel=;SPMquot;stylesheet;SPMquot; type=;SPMquot;text/css;SPMquot;;SPMgt;

     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../../underscore/underscore.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../../jquery/starterkit/jquery.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;repeated_words.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;File Input;SPMlt;/h1;SPMgt;
    ;SPMlt;input type=;SPMquot;file;SPMquot; id=;SPMquot;fileinput;SPMquot; /;SPMgt;
    ;SPMlt;div id=;SPMquot;out;SPMquot; class=;SPMquot;hidden;SPMquot;;SPMgt;
    ;SPMlt;table;SPMgt;
      ;SPMlt;tr;SPMgt;;SPMlt;th;SPMgt;Original;SPMlt;/th;SPMgt;;SPMlt;th;SPMgt;Transformed;SPMlt;/th;SPMgt;;SPMlt;/tr;SPMgt;
      ;SPMlt;tr;SPMgt;
        ;SPMlt;td;SPMgt;
          ;SPMlt;pre class=;SPMquot;input;SPMquot; id=;SPMquot;initialinput;SPMquot;;SPMgt;;SPMlt;/pre;SPMgt;
        ;SPMlt;/td;SPMgt;
        ;SPMlt;td;SPMgt;
          ;SPMlt;pre class=;SPMquot;output;SPMquot; id=;SPMquot;finaloutput;SPMquot;;SPMgt;;SPMlt;/pre;SPMgt;
        ;SPMlt;/td;SPMgt;
      ;SPMlt;/tr;SPMgt;
    ;SPMlt;/table;SPMgt;
    ;SPMlt;/div;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#148#
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat global.css 
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: right; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: ____; }
.unhidden    { display: _____; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }

body
{
 background-color:#b0c4de;  /* blue */
<tex2html_mydb_mark>#149#
[~/srcPLgrado/repeatedwords(master)]$ cat repeated_words.js 
;SPMquot;use strict;SPMquot;; // Use ECMAScript 5 strict mode in browsers that support it

$(document).ready(function() {
   $(;SPMquot;#fileinput;SPMquot;).change(calculate);
});

function generateOutput(contents) {
  return contents.replace(/____________________/__,'__________________________________');
}

function calculate(evt) {
  var f = evt.target.files[0]; 
  var contents = '';

  if (f) {
    var r = new FileReader();
    r.onload = function(e) { 
      contents = e.target.result;
      var escaped  = escapeHtml(contents);
      var outdiv = document.getElementById(;SPMquot;out;SPMquot;);
      outdiv.className = 'unhidden';
      finaloutput.innerHTML = generateOutput(escaped);
      initialinput.innerHTML = escaped;

    }
    r.readAsText(f);
  } else { 
    alert(;SPMquot;Failed to load file;SPMquot;);
  }
}

var entityMap = {
    ;SPMquot;;SPMamp;;SPMquot;: ;SPMquot;;SPMamp;amp;;SPMquot;,
    ;SPMquot;;SPMlt;;SPMquot;: ;SPMquot;;SPMamp;lt;;SPMquot;,
    ;SPMquot;;SPMgt;;SPMquot;: ;SPMquot;;SPMamp;gt;;SPMquot;,
    ';SPMquot;': ';SPMamp;quot;',
    ;SPMquot;';SPMquot;: ';SPMamp;#39;',
    ;SPMquot;/;SPMquot;: ';SPMamp;#x2F;'
  };

function escapeHtml(string) {
  return String(string).replace(/_________/g, function (s) {
    return ____________;
  });
<tex2html_mydb_mark>#150#
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat input2.txt 
habia una vez 
vez un viejo viejo
hidalgo que vivia 
vivia
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat input.txt 
one one
nothing rep
is two three
three four
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat inputhtml1.txt 
habia =;SPMgt; una vez 
vez ;SPMamp; un viejo viejo ;SPMlt;puchum;SPMgt;
hidalgo  ;SPMamp; ;SPMlt;pacham;SPMgt; que vivia 
vivia ;SPMlt;/que se yo;SPMgt;
<tex2html_mydb_mark>#151#
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.
 
[database]
; use IP address in case network name resolution is not working
server=192.0.2.62     
port=143
file = ;SPMquot;payroll.dat;SPMquot;
<tex2html_mydb_mark>#152#
;SPMgt; x = ;SPMquot;h     = 4;SPMquot;
;SPMgt; r = /([^=]*)(\s*)=(\s*)(.*)/
;SPMgt; r.exec(x)
;SPMgt;
<tex2html_mydb_mark>#153#
;SPMgt; ;SPMquot;bb;SPMquot;.match(/b|bb/)

;SPMgt; ;SPMquot;bb;SPMquot;.match(/bb|b/)
<tex2html_mydb_mark>#154#
;SPMlt;html;SPMgt;
  ;SPMlt;head;SPMgt;
     ;SPMlt;meta http-equiv=;SPMquot;Content-Type;SPMquot; content=;SPMquot;text/html; charset=UTF-8;SPMquot;;SPMgt;
     ;SPMlt;title;SPMgt;INI files;SPMlt;/title;SPMgt;
     ;SPMlt;link href=;SPMquot;global.css;SPMquot; rel=;SPMquot;stylesheet;SPMquot; type=;SPMquot;text/css;SPMquot;;SPMgt;

     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../../underscore/underscore.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../../jquery/starterkit/jquery.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;______;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;INI files;SPMlt;/h1;SPMgt;
    ;SPMlt;input type=;SPMquot;file;SPMquot; id=;SPMquot;_________;SPMquot; /;SPMgt;
    ;SPMlt;div id=;SPMquot;out;SPMquot; class=;SPMquot;hidden;SPMquot;;SPMgt;
    ;SPMlt;table;SPMgt;
      ;SPMlt;tr;SPMgt;;SPMlt;th;SPMgt;Original;SPMlt;/th;SPMgt;;SPMlt;th;SPMgt;Tokens;SPMlt;/th;SPMgt;;SPMlt;/tr;SPMgt;
      ;SPMlt;tr;SPMgt;
        ;SPMlt;td;SPMgt;
          ;SPMlt;pre class=;SPMquot;input;SPMquot; id=;SPMquot;____________;SPMquot;;SPMgt;;SPMlt;/pre;SPMgt;
        ;SPMlt;/td;SPMgt;
        ;SPMlt;td;SPMgt;
          ;SPMlt;pre class=;SPMquot;output;SPMquot; id=;SPMquot;___________;SPMquot;;SPMgt;;SPMlt;/pre;SPMgt;
        ;SPMlt;/td;SPMgt;
      ;SPMlt;/tr;SPMgt;
    ;SPMlt;/table;SPMgt;
    ;SPMlt;/div;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#155#
[~/Dropbox/src/javascript/PLgrado/ini(master)]$ cat global.css
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: left; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: ____; }
.unhidden    { display: _____; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }
span.header { ________________: ____ }
span.comments { ________________: ______ }
span.blanks { ________________: _____ }
span.nameEqualValue { ________________: ____ }
span.error { ________________: ___ }

body
{
 background-color:#b0c4de;  /* blue */
}
<tex2html_mydb_mark>#156#
~/Dropbox/src/javascript/PLgrado/ini(master)]$ cat input.ini 
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.

[database]
; use IP address in case network name resolution is not working
server=192.0.2.62     
port=143
file = ;SPMquot;payroll.dat;SPMquot;
<tex2html_mydb_mark>#157#
$ cat input2.ini 
[special_fields] 
required = ;SPMquot;EmailAddr,FirstName,LastName,Mesg;SPMquot; 
csvfile = ;SPMquot;contacts.csv;SPMquot; 
csvcolumns = ;SPMquot;EmailAddr,FirstName,LastName,Mesg,Date,Time;SPMquot; 

[email_addresses] 
sales = ;SPMquot;jack@yahoo.com,mary@my-sales-force.com,president@my-company.com;SPMquot;
<tex2html_mydb_mark>#158#
$ cat inputerror.ini
[owner]
name=John Doe
organization$Acme Widgets Inc.
 
[database
; use IP address in case network name resolution is not working
server=192.0.2.62     
port=143
file = ;SPMquot;payroll.dat;SPMquot;
<tex2html_mydb_mark>#159#
[~/Dropbox/src/javascript/PLgrado/ini(master)]$ cat ini.js 
;SPMquot;use ______;SPMquot;; // Use ECMAScript 5 strict mode in browsers that support it

$(document)._____(function() {
   $(;SPMquot;#fileinput;SPMquot;).______(calculate);
});

function calculate(evt) {
  var f = evt.target.files[0]; 

  if (f) {
    var r = new __________();
    r.onload = function(e) { 
      var contents = e.target.______;
      
      var tokens = lexer(contents);
      var pretty = tokensToString(tokens);
      
      out.className = 'unhidden';
      initialinput._________ = contents;
      finaloutput._________ = pretty;
    }
    r.__________(f); // Leer como texto
  } else { 
    alert(;SPMquot;Failed to load file;SPMquot;);
  }
}

var temp = ';SPMlt;li;SPMgt; ;SPMlt;span class = ;SPMquot;;SPMlt;%= ______ %;SPMgt;;SPMquot;;SPMgt; ;SPMlt;%= _ %;SPMgt; ;SPMlt;/span;SPMgt;\n';

function tokensToString(tokens) {
   var r = '';
   for(var i in tokens) {
     var t = tokens[i];
     var s = JSON.stringify(t, undefined, 2);
     s = _.template(temp, {t: t, s: s});
     r += s;
   }
   return ';SPMlt;ol;SPMgt;\n'+r+';SPMlt;/ol;SPMgt;';
}

function lexer(input) {
  var blanks         = /^___/;
  var iniheader      = /^________________/;
  var comments       = /^________/;
  var nameEqualValue = /^________________________/;
  var any            = /^_______/;

  var out = [];
  var m = null;

  while (input != '') {
    if (m = blanks.____(input)) {
      input = input.substr(m.index+___________);
      out.push({ type : ________, match: _ });
    }
    else if (m = iniheader.exec(input)) {
      input = input.substr(___________________);
      _______________________________________ // avanzemos en input
    }
    else if (m = comments.exec(input)) {
      input = input.substr(___________________);
      _________________________________________
    }
    else if (m = nameEqualValue.exec(input)) {
      input = input.substr(___________________);
      _______________________________________________
    }
    else if (m = any.exec(input)) {
      _______________________________________
      input = '';
    }
    else {
      alert(;SPMquot;Fatal Error!;SPMquot;+substr(input,0,20));
      input = '';
    }
  }
  return out;
}
<tex2html_mydb_mark>#160#
[~/src/C/regexp]$ cat use_posix.c 
#include ;SPMlt;stdio.h;SPMgt;
#include ;SPMlt;stdlib.h;SPMgt;
#include ;SPMlt;regex.h;SPMgt;        

int main() {
       regex_t regex;
       int reti;
       char msgbuf[100];

/* Compile regular expression */
        reti = regcomp(;SPMamp;regex, ;SPMquot;^a[[:alnum:]];SPMquot;, 0);
        if( reti ){ fprintf(stderr, ;SPMquot;Could not compile regex\n;SPMquot;); exit(1); }

/* Execute regular expression */
        reti = regexec(;SPMamp;regex, ;SPMquot;abc;SPMquot;, 0, NULL, 0);
        if( !reti ){
                puts(;SPMquot;Match;SPMquot;);
        }
        else if( reti == REG_NOMATCH ){
                puts(;SPMquot;No match;SPMquot;);
        }
        else{
                regerror(reti, ;SPMamp;regex, msgbuf, sizeof(msgbuf));
                fprintf(stderr, ;SPMquot;Regex match failed: %s\n;SPMquot;, msgbuf);
                exit(1);
        }

/* Free compiled regular expression if you want to use the regex_t again */
    regfree(;SPMamp;regex);
}
<tex2html_mydb_mark>#161#
[~/src/C/regexp]$ cc use_posix.c  -o use_posix
[~/src/C/regexp]$ ./use_posix 
Match
<tex2html_mydb_mark>#162#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<tex2html_mydb_mark>#163#%%|. La primera secci\'on se denomina \cei{secci\'on de

<tex2html_mydb_mark>#164#%%

<tex2html_mydb_mark>#165#%s;SPMquot;,yytext); }@

<tex2html_mydb_mark>#166#%{| y \verb|%}| se copia

<tex2html_mydb_mark>#167#%%

<tex2html_mydb_mark>#168#%%

<tex2html_mydb_mark>#169#%option main

<tex2html_mydb_mark>#170#%{

<tex2html_mydb_mark>#171#%}

<tex2html_mydb_mark>#172#%%

<tex2html_mydb_mark>#173#%s;SPMquot;,  getlogin());

<tex2html_mydb_mark>#174#%%

<tex2html_mydb_mark>#175#%option main| en el fichero

<tex2html_mydb_mark>#176#%%

<tex2html_mydb_mark>#177#%pointer@ o \verb@%array@. Estas directivas hacen que \tei{yytext}

<tex2html_mydb_mark>#178#%pointer| es la mas eficiente

<tex2html_mydb_mark>#179#%%

<tex2html_mydb_mark>#180#%d: %s\n;SPMquot;,strlen(yytext),yytext);
      
<tex2html_mydb_mark>#181#%array|:

<tex2html_mydb_mark>#182#%array

<tex2html_mydb_mark>#183#%%

<tex2html_mydb_mark>#184#%d: %s\n;SPMquot;,strlen(yytext),yytext);
      
<tex2html_mydb_mark>#185#%pointer@ (pero correcta con \verb@%array@).

<tex2html_mydb_mark>#186#%array@ define \verb|yytext| como un \emph{array} de tamaño \verb|YYLMAX|.

<tex2html_mydb_mark>#187#%{

<tex2html_mydb_mark>#188#%}
 
<tex2html_mydb_mark>#189#%%

<tex2html_mydb_mark>#190#%%

<tex2html_mydb_mark>#191#%d, idcount = %d, yytext = %s\n;SPMquot;,a,b,t);
  
<tex2html_mydb_mark>#192#%d, idcount = %d, yytext = %s\n;SPMquot;,a,b,t);

<tex2html_mydb_mark>#193#%\listinginput{1}{../src/countlwc2.l}

<tex2html_mydb_mark>#194#%{

<tex2html_mydb_mark>#195#%}

<tex2html_mydb_mark>#196#%%

<tex2html_mydb_mark>#197#%%

<tex2html_mydb_mark>#198#%s file1 file2 file3 ...\n;SPMquot;,argv[0]);
    
<tex2html_mydb_mark>#199#%s\n;SPMquot;, argv[1]);
      
<tex2html_mydb_mark>#200#%8lu %8lu %8lu %s\n;SPMquot;, lineCount, wordCount,
    
<tex2html_mydb_mark>#201#%8lu %8lu %8lu total\n;SPMquot;, totalLC, totalWC, totalCC);
  
<tex2html_mydb_mark>#202#%8lu %8lu %8lu %s\n;SPMquot;, lineCount, wordCount,
       
<tex2html_mydb_mark>#203#%s\n;SPMquot;, fileList[currentFile - 1]);
     
<tex2html_mydb_mark>#204#%array

<tex2html_mydb_mark>#205#%%

<tex2html_mydb_mark>#206#%%

<tex2html_mydb_mark>#207#%pointer|, las llamadas a \emph{unput} destruyen los

<tex2html_mydb_mark>#208#%array|.

<tex2html_mydb_mark>#209#%%

<tex2html_mydb_mark>#210#%s\n;SPMquot;,yytext);

<tex2html_mydb_mark>#211#%%

<tex2html_mydb_mark>#212#%\section{Uso de Tablas para Palabras Reservadas e Identificadores}

<tex2html_mydb_mark>#213#%Desde el punto de vista de la eficiencia no es una buena idea mantener una 

<tex2html_mydb_mark>#214#%expresi\'on regular separada para cada \emph{token} del lenguaje. La alternativa 

<tex2html_mydb_mark>#215#%es utilizar dos tablas: una primera para las palabras reservadas y la otra 

<tex2html_mydb_mark>#216#%para los identificadores y definiciones de tipo.

<tex2html_mydb_mark>#217#%

<tex2html_mydb_mark>#218#%El siguiente  ejemplo muestra los contenidos de un analizador 

<tex2html_mydb_mark>#219#%léxico típico. Comenzemos con el código de cabecera:

<tex2html_mydb_mark>#220#%

<tex2html_mydb_mark>#221#%\begin{verbatim}

<tex2html_mydb_mark>#222#%%{

<tex2html_mydb_mark>#223#%/*

<tex2html_mydb_mark>#224#% * samplecl.l at /home/pl/src/samplec_casiano/lexer

<tex2html_mydb_mark>#225#% */

<tex2html_mydb_mark>#226#%

<tex2html_mydb_mark>#227#%#ifdef LDEBUG

<tex2html_mydb_mark>#228#%

<tex2html_mydb_mark>#229#%#define Identifier 257

<tex2html_mydb_mark>#230#%#define Constant 258

<tex2html_mydb_mark>#231#%#define INT 259

<tex2html_mydb_mark>#232#%#define IF 260

<tex2html_mydb_mark>#233#%#define ELSE 261

<tex2html_mydb_mark>#234#%#define WHILE 262

<tex2html_mydb_mark>#235#%#define BREAK 263

<tex2html_mydb_mark>#236#%#define CONTINUE 264

<tex2html_mydb_mark>#237#%#define RETURN 265

<tex2html_mydb_mark>#238#%#define GE 266

<tex2html_mydb_mark>#239#%#define LE 267

<tex2html_mydb_mark>#240#%#define EQ 268

<tex2html_mydb_mark>#241#%#define NE 269

<tex2html_mydb_mark>#242#%#define PE 270

<tex2html_mydb_mark>#243#%#define ME 271

<tex2html_mydb_mark>#244#%#define TE 272

<tex2html_mydb_mark>#245#%#define DE 273

<tex2html_mydb_mark>#246#%#define RE 274

<tex2html_mydb_mark>#247#%#define PP 275

<tex2html_mydb_mark>#248#%#define MM 276

<tex2html_mydb_mark>#249#%

<tex2html_mydb_mark>#250#%main() {

<tex2html_mydb_mark>#251#%  int p;

<tex2html_mydb_mark>#252#%

<tex2html_mydb_mark>#253#%  while (p = yylex())

<tex2html_mydb_mark>#254#%    printf(;SPMquot;%d is \"%s\"\n;SPMquot;,p,yytext);

<tex2html_mydb_mark>#255#%}

<tex2html_mydb_mark>#256#%

<tex2html_mydb_mark>#257#%s_lookup() {}

<tex2html_mydb_mark>#258#%

<tex2html_mydb_mark>#259#%int yy_nerrs = 0;

<tex2html_mydb_mark>#260#%

<tex2html_mydb_mark>#261#%#define x x

<tex2html_mydb_mark>#262#%

<tex2html_mydb_mark>#263#%#else ! LDEBUG /* production version */

<tex2html_mydb_mark>#264#%

<tex2html_mydb_mark>#265#%#include ;SPMquot;y.tab.h;SPMquot;

<tex2html_mydb_mark>#266#%#define x x

<tex2html_mydb_mark>#267#%

<tex2html_mydb_mark>#268#%#endif LDEBUG

<tex2html_mydb_mark>#269#%

<tex2html_mydb_mark>#270#%#define END(v) (v-1 + sizeof v / sizeof v[0])

<tex2html_mydb_mark>#271#%static int screen();

<tex2html_mydb_mark>#272#%

<tex2html_mydb_mark>#273#%%}

<tex2html_mydb_mark>#274#%\end{verbatim}

<tex2html_mydb_mark>#275#%

<tex2html_mydb_mark>#276#%A continuación siguen las definiciones de macros de expresiones regulares:

<tex2html_mydb_mark>#277#%

<tex2html_mydb_mark>#278#%\begin{verbatim}

<tex2html_mydb_mark>#279#%letter                   [a-zA-Z]

<tex2html_mydb_mark>#280#%digit                    [0-9]

<tex2html_mydb_mark>#281#%letter_or_digit          [a-zA-Z0-9]

<tex2html_mydb_mark>#282#%white_space              [ \t\n]

<tex2html_mydb_mark>#283#%blank                    [ \t]

<tex2html_mydb_mark>#284#%other                    .

<tex2html_mydb_mark>#285#%

<tex2html_mydb_mark>#286#%%%

<tex2html_mydb_mark>#287#%\end{verbatim}

<tex2html_mydb_mark>#288#%

<tex2html_mydb_mark>#289#%A continuación siguen las parejas patrón-acción:

<tex2html_mydb_mark>#290#%

<tex2html_mydb_mark>#291#%\begin{verbatim}

<tex2html_mydb_mark>#292#%

<tex2html_mydb_mark>#293#%;SPMquot;#;SPMquot;{blank}*{digit}+({blank}+.*)?\n  yymark();

<tex2html_mydb_mark>#294#%;SPMquot;;SPMgt;=;SPMquot;    return GE;

<tex2html_mydb_mark>#295#%;SPMquot;;SPMlt;=;SPMquot;    return LE;

<tex2html_mydb_mark>#296#%;SPMquot;!=;SPMquot;    return NE;

<tex2html_mydb_mark>#297#%;SPMquot;+=;SPMquot;    return PE;

<tex2html_mydb_mark>#298#%;SPMquot;-=;SPMquot;    return ME;

<tex2html_mydb_mark>#299#%;SPMquot;*=;SPMquot;    return TE;

<tex2html_mydb_mark>#300#%;SPMquot;/=;SPMquot;    return DE;

<tex2html_mydb_mark>#301#%;SPMquot;%=;SPMquot;    return RE;

<tex2html_mydb_mark>#302#%;SPMquot;++;SPMquot;    return PP;

<tex2html_mydb_mark>#303#%;SPMquot;--;SPMquot;    return MM;

<tex2html_mydb_mark>#304#%

<tex2html_mydb_mark>#305#%{letter}{letter_or_digit}* return screen();

<tex2html_mydb_mark>#306#%

<tex2html_mydb_mark>#307#%{digit}+                   {

<tex2html_mydb_mark>#308#%                             s_lookup(Constant);

<tex2html_mydb_mark>#309#%                             return Constant;

<tex2html_mydb_mark>#310#%                           }

<tex2html_mydb_mark>#311#%{white_space}+             ;

<tex2html_mydb_mark>#312#%

<tex2html_mydb_mark>#313#%{other}                    return (yytext[0]);

<tex2html_mydb_mark>#314#%

<tex2html_mydb_mark>#315#%%%

<tex2html_mydb_mark>#316#%\end{verbatim}

<tex2html_mydb_mark>#317#%Por último, el código de cola:

<tex2html_mydb_mark>#318#%\begin{verbatim}

<tex2html_mydb_mark>#319#%/*

<tex2html_mydb_mark>#320#% *  reserved word table

<tex2html_mydb_mark>#321#% */

<tex2html_mydb_mark>#322#%

<tex2html_mydb_mark>#323#%static struct rwtable {

<tex2html_mydb_mark>#324#%  char * rw_name;

<tex2html_mydb_mark>#325#%  int rw_yylex;

<tex2html_mydb_mark>#326#%  } rwtable[] = {

<tex2html_mydb_mark>#327#%  ;SPMquot;break;SPMquot;, BREAK,

<tex2html_mydb_mark>#328#%  ;SPMquot;continue;SPMquot;, CONTINUE,

<tex2html_mydb_mark>#329#%  ;SPMquot;else;SPMquot;, ELSE,

<tex2html_mydb_mark>#330#%  ;SPMquot;if;SPMquot;, IF,

<tex2html_mydb_mark>#331#%  ;SPMquot;int;SPMquot;, INT,

<tex2html_mydb_mark>#332#%  ;SPMquot;return;SPMquot;, RETURN,

<tex2html_mydb_mark>#333#%  ;SPMquot;while;SPMquot;, WHILE

<tex2html_mydb_mark>#334#%  };

<tex2html_mydb_mark>#335#%

<tex2html_mydb_mark>#336#%static int screen() {

<tex2html_mydb_mark>#337#%  struct rwtable * low = rwtable, *high = END(rwtable), *mid;

<tex2html_mydb_mark>#338#%  int c;

<tex2html_mydb_mark>#339#%

<tex2html_mydb_mark>#340#%  while (low ;SPMlt;= high) {

<tex2html_mydb_mark>#341#%    mid = low + (high -low)/2;

<tex2html_mydb_mark>#342#%    if ((c = strcmp(mid-;SPMgt;rw_name, yytext)) == 0)

<tex2html_mydb_mark>#343#%      return mid-;SPMgt;rw_yylex;

<tex2html_mydb_mark>#344#%    else if (c ;SPMlt; 0)

<tex2html_mydb_mark>#345#%      low = mid+1;

<tex2html_mydb_mark>#346#%    else

<tex2html_mydb_mark>#347#%      high = mid-1;

<tex2html_mydb_mark>#348#%  }

<tex2html_mydb_mark>#349#%  s_lookup(Identifier);

<tex2html_mydb_mark>#350#%  return Identifier;

<tex2html_mydb_mark>#351#%}

<tex2html_mydb_mark>#352#%

<tex2html_mydb_mark>#353#%int yywrap() { return 1; }

<tex2html_mydb_mark>#354#%

<tex2html_mydb_mark>#355#%\end{verbatim}

<tex2html_mydb_mark>#356#%

<tex2html_mydb_mark>#357#%\subsection{popen y freopen}

<tex2html_mydb_mark>#358#%La funci\'on \verb|*popen(const char *command, const char *type)| abre

<tex2html_mydb_mark>#359#%un \emph{pipe}. Nuestro programa entra en una ejecuci\'on en canal con el

<tex2html_mydb_mark>#360#%\emph{command} descrito como primer par\'ametro de la funci\'on. 

<tex2html_mydb_mark>#361#%Si la variable \emph{type} es descrita como \verb|;SPMquot;r;SPMquot;|, ello

<tex2html_mydb_mark>#362#%significa que nuestro programa ser\'a alimentado por el programa

<tex2html_mydb_mark>#363#%descrito en \emph{command} a trav\'es del fichero retornado por la funci\'on.  

<tex2html_mydb_mark>#364#%Si el fichero que usaramos fuera

<tex2html_mydb_mark>#365#%\emph{stdin} ser\'{\i}a equivalente a:

<tex2html_mydb_mark>#366#%\begin{center}

<tex2html_mydb_mark>#367#%\verb|command | miprograma|

<tex2html_mydb_mark>#368#%\end{center}

<tex2html_mydb_mark>#369#%El siguiente ejemplo ilustra su uso:

<tex2html_mydb_mark>#370#%\begin{verbatim}

<tex2html_mydb_mark>#371#%% cat popenr.c

<tex2html_mydb_mark>#372#%#include ;SPMlt;stdio.h;SPMgt;

<tex2html_mydb_mark>#373#%main() {

<tex2html_mydb_mark>#374#%  int c, lineno = 1;

<tex2html_mydb_mark>#375#%  char string[80];

<tex2html_mydb_mark>#376#%        FILE * yyin;

<tex2html_mydb_mark>#377#% 

<tex2html_mydb_mark>#378#%  yyin = (FILE *)popen(;SPMquot;cat hello.c;SPMquot;,;SPMquot;r;SPMquot;);

<tex2html_mydb_mark>#379#%        fprintf(stdout,;SPMquot;%2d ;SPMquot;,lineno++);

<tex2html_mydb_mark>#380#%  while ((c = fgetc(yyin)) != EOF) {

<tex2html_mydb_mark>#381#%    putc(c,stdout);

<tex2html_mydb_mark>#382#%    if (c == '\n') fprintf(stdout,;SPMquot;%2d ;SPMquot;,lineno++);

<tex2html_mydb_mark>#383#%  }

<tex2html_mydb_mark>#384#%  pclose(yyin);

<tex2html_mydb_mark>#385#%}                                         

<tex2html_mydb_mark>#386#%\end{verbatim}

<tex2html_mydb_mark>#387#%Su ejecuci\'on es equivalente a: 

<tex2html_mydb_mark>#388#%\begin{center}

<tex2html_mydb_mark>#389#%\verb|cat hello.c | a.out|

<tex2html_mydb_mark>#390#%\end{center}

<tex2html_mydb_mark>#391#%en efecto:

<tex2html_mydb_mark>#392#%\begin{verbatim}

<tex2html_mydb_mark>#393#%% a.out

<tex2html_mydb_mark>#394#% 1 #include ;SPMlt;stdio.h;SPMgt;

<tex2html_mydb_mark>#395#% 2 main() {

<tex2html_mydb_mark>#396#% 3   printf(;SPMquot;Hello World!\n;SPMquot;);

<tex2html_mydb_mark>#397#% 4 }

<tex2html_mydb_mark>#398#% 5 %     

<tex2html_mydb_mark>#399#%\end{verbatim}

<tex2html_mydb_mark>#400#%Cuando se usa la opci\'on \verb|;SPMquot;w;SPMquot;| es lo contrario, las

<tex2html_mydb_mark>#401#%salidas de nuestro programa a trav\'es del fichero utilizado

<tex2html_mydb_mark>#402#%son absorbidas por el programa especificado en \emph{command}.

<tex2html_mydb_mark>#403#%He aqui un ejemplo:

<tex2html_mydb_mark>#404#%\begin{verbatim}

<tex2html_mydb_mark>#405#%% cat popenw.c

<tex2html_mydb_mark>#406#%#include ;SPMlt;stdio.h;SPMgt;

<tex2html_mydb_mark>#407#%main() {

<tex2html_mydb_mark>#408#%        FILE *yyout;

<tex2html_mydb_mark>#409#% 

<tex2html_mydb_mark>#410#%  yyout = (FILE *)popen(;SPMquot;sort;SPMquot;,;SPMquot;w;SPMquot;);

<tex2html_mydb_mark>#411#%  fprintf(yyout,;SPMquot;6\n5\n4\n3\n2\n1\n;SPMquot;);

<tex2html_mydb_mark>#412#%  pclose(yyout);

<tex2html_mydb_mark>#413#%}                                         

<tex2html_mydb_mark>#414#%% gcc popenw.c; a.out

<tex2html_mydb_mark>#415#%1

<tex2html_mydb_mark>#416#%2

<tex2html_mydb_mark>#417#%3

<tex2html_mydb_mark>#418#%4

<tex2html_mydb_mark>#419#%5

<tex2html_mydb_mark>#420#%6                              

<tex2html_mydb_mark>#421#%\end{verbatim}

<tex2html_mydb_mark>#422#%Se observa que su ejecuci\'on es equivalente a:

<tex2html_mydb_mark>#423#%\begin{center}

<tex2html_mydb_mark>#424#%\verb|a.out | sort|

<tex2html_mydb_mark>#425#%\end{center}

<tex2html_mydb_mark>#426#%La otra funci\'on que usamos en el algoritmo de pre-proceso es

<tex2html_mydb_mark>#427#%\emph{freopen}. Su formato es:

<tex2html_mydb_mark>#428#%

<tex2html_mydb_mark>#429#%\begin{center}

<tex2html_mydb_mark>#430#%\verb| FILE  *freopen  (const  char *path, const char *mode, FILE *stream);|

<tex2html_mydb_mark>#431#%\end{center}

<tex2html_mydb_mark>#432#%

<tex2html_mydb_mark>#433#%El fichero designado por \emph{path} se asocia con el fichero 

<tex2html_mydb_mark>#434#%descrito en \emph{stream}. La cadena \emph{mode} determina el modo de

<tex2html_mydb_mark>#435#%lectura. As\'{\i} en el ejemplo que sigue, todas 

<tex2html_mydb_mark>#436#%las lecturas posteriores a la llamada a

<tex2html_mydb_mark>#437#%\verb|freopen(;SPMquot;hello.c;SPMquot;,;SPMquot;r;SPMquot;,stdin);|

<tex2html_mydb_mark>#438#%ocurren desde el fichero ;SPMquot;hello.c;SPMquot;.

<tex2html_mydb_mark>#439#%\begin{verbatim}

<tex2html_mydb_mark>#440#%% cat freopen.c

<tex2html_mydb_mark>#441#%#include ;SPMlt;stdio.h;SPMgt;

<tex2html_mydb_mark>#442#%main() {

<tex2html_mydb_mark>#443#%        int c;

<tex2html_mydb_mark>#444#% 

<tex2html_mydb_mark>#445#%        freopen(;SPMquot;hello.c;SPMquot;,;SPMquot;r;SPMquot;,stdin);

<tex2html_mydb_mark>#446#%        while ((c = getchar()) != EOF) {

<tex2html_mydb_mark>#447#%                putc(c,stdout);

<tex2html_mydb_mark>#448#%        }

<tex2html_mydb_mark>#449#%}

<tex2html_mydb_mark>#450#%/home/casiano/regexp/lex[55]% gcc freopen.c;a.out

<tex2html_mydb_mark>#451#%#include ;SPMlt;stdio.h;SPMgt;

<tex2html_mydb_mark>#452#%main() {

<tex2html_mydb_mark>#453#%  printf(;SPMquot;Hello World!\n;SPMquot;);

<tex2html_mydb_mark>#454#%}                                      

<tex2html_mydb_mark>#455#%\end{verbatim}

<tex2html_mydb_mark>#456#%%

<tex2html_mydb_mark>#457#%%

<tex2html_mydb_mark>#458#%%

<tex2html_mydb_mark>#459#%%

<tex2html_mydb_mark>#460#%d: %s\n;SPMquot;,yyleng,yytext);
            
<tex2html_mydb_mark>#461#%d: %s\n;SPMquot;,yyleng,yytext);
            
<tex2html_mydb_mark>#462#%s\n;SPMquot;,yytext);
            
<tex2html_mydb_mark>#463#%s| para los estados ``inclusivos'' o bien \verb|%x| para los estados ``exclusivos'',

<tex2html_mydb_mark>#464#%option noyywrap

<tex2html_mydb_mark>#465#%{
  
<tex2html_mydb_mark>#466#%}

<tex2html_mydb_mark>#467#%x comment

<tex2html_mydb_mark>#468#%%
 
<tex2html_mydb_mark>#469#%d, YY_START = %d, YYSTATE = %d;SPMquot;,comment,YY_START,YYSTATE);

<tex2html_mydb_mark>#470#%%

<tex2html_mydb_mark>#471#%d lines\n;SPMquot;,linenum);

<tex2html_mydb_mark>#472#%

<tex2html_mydb_mark>#473#%d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);

<tex2html_mydb_mark>#474#%;SPMgt;
 
<tex2html_mydb_mark>#475#%

<tex2html_mydb_mark>#476#%d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);

<tex2html_mydb_mark>#477#%;SPMgt;                                  

<tex2html_mydb_mark>#478#%option main

<tex2html_mydb_mark>#479#%x str

<tex2html_mydb_mark>#480#%{

<tex2html_mydb_mark>#481#%}
 
<tex2html_mydb_mark>#482#%%

<tex2html_mydb_mark>#483#%s;SPMquot;,string_buffer); }

<tex2html_mydb_mark>#484#%o;SPMquot;,;SPMamp;result);
                         
<tex2html_mydb_mark>#485#%%                            

<tex2html_mydb_mark>#486#%d

<tex2html_mydb_mark>#487#%

<tex2html_mydb_mark>#488#%d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);

<tex2html_mydb_mark>#489#%;SPMgt;                                   

<tex2html_mydb_mark>#490#%hello

<tex2html_mydb_mark>#491#%dolly

<tex2html_mydb_mark>#492#%hello

<tex2html_mydb_mark>#493#%dolly

<tex2html_mydb_mark>#494#%Error: non terminated string

<tex2html_mydb_mark>#495#%option stack|

<tex2html_mydb_mark>#496#% \ listinginput{1}{../src/ab2.l}

<tex2html_mydb_mark>#497#%option main

<tex2html_mydb_mark>#498#%option noyywrap

<tex2html_mydb_mark>#499#%option stack

<tex2html_mydb_mark>#500#%{

<tex2html_mydb_mark>#501#%}

<tex2html_mydb_mark>#502#%x estado_a

<tex2html_mydb_mark>#503#%%

<tex2html_mydb_mark>#504#%%

<tex2html_mydb_mark>#505#%\subsection{Ejemplo}

<tex2html_mydb_mark>#506#%El siguiente programa \verb|flex| utiliza las funciones de la pila de estados para reconocer el lenguaje (no regular) \{$x \in \{a,b\} $/ número de $a$es es igual al número de $b$es  y cualquier prefijo de $x$ contiene no menos $a$es que $b$es  \}.

<tex2html_mydb_mark>#507#%\begin{verbatim}

<tex2html_mydb_mark>#508#%$ cat push.l

<tex2html_mydb_mark>#509#%%option stack

<tex2html_mydb_mark>#510#%%x A ACCEPT

<tex2html_mydb_mark>#511#%%%

<tex2html_mydb_mark>#512#%;SPMquot;a;SPMquot;      {  ECHO; yy_push_state(A); printf(;SPMquot;State: %d\n;SPMquot;,YYSTATE); }

<tex2html_mydb_mark>#513#%[^a\n]+.*\n  { printf(;SPMquot;error\n;SPMquot;); }

<tex2html_mydb_mark>#514#%[\n ]+

<tex2html_mydb_mark>#515#%(.|\n)   { printf(;SPMquot;Error!\n;SPMquot;); }

<tex2html_mydb_mark>#516#%;SPMlt;A;SPMgt;{

<tex2html_mydb_mark>#517#%;SPMquot;a;SPMquot; {  ECHO; yy_push_state(A); printf(;SPMquot;State: %d\n;SPMquot;,YYSTATE); }

<tex2html_mydb_mark>#518#%;SPMquot;b;SPMquot; { ECHO;

<tex2html_mydb_mark>#519#%       if (yy_top_state()) {

<tex2html_mydb_mark>#520#%         yy_pop_state();

<tex2html_mydb_mark>#521#%         printf(;SPMquot;State: %d\n;SPMquot;,YYSTATE);

<tex2html_mydb_mark>#522#%       }

<tex2html_mydb_mark>#523#%       else {

<tex2html_mydb_mark>#524#%         printf(;SPMquot;State: %d\n;SPMquot;,YYSTATE);

<tex2html_mydb_mark>#525#%         BEGIN(ACCEPT);

<tex2html_mydb_mark>#526#%       }

<tex2html_mydb_mark>#527#%    }

<tex2html_mydb_mark>#528#%(.|\n)   { printf(;SPMquot;Error!\n;SPMquot;); BEGIN(0); }

<tex2html_mydb_mark>#529#%}

<tex2html_mydb_mark>#530#%;SPMlt;ACCEPT;SPMgt;\n { BEGIN(0); printf(;SPMquot;Accept\n;SPMquot;); }

<tex2html_mydb_mark>#531#%;SPMlt;ACCEPT;SPMgt;. { BEGIN(0); printf(;SPMquot;Error\n;SPMquot;); }

<tex2html_mydb_mark>#532#%%%   

<tex2html_mydb_mark>#533#%$ flex push.l ; gcc lex.yy.c -lfl ; a.out

<tex2html_mydb_mark>#534#%ab

<tex2html_mydb_mark>#535#%aState: 1

<tex2html_mydb_mark>#536#%bState: 1

<tex2html_mydb_mark>#537#%Accept

<tex2html_mydb_mark>#538#%abb

<tex2html_mydb_mark>#539#%aState: 1

<tex2html_mydb_mark>#540#%bState: 1

<tex2html_mydb_mark>#541#%Error

<tex2html_mydb_mark>#542#%bbbbbbbbbba

<tex2html_mydb_mark>#543#%error                             

<tex2html_mydb_mark>#544#%\end{verbatim}

<tex2html_mydb_mark>#545#%\listinginput{1}{../src/nestedcom2.l}

<tex2html_mydb_mark>#546#%option stack

<tex2html_mydb_mark>#547#%x comment

<tex2html_mydb_mark>#548#%%

<tex2html_mydb_mark>#549#%%

<tex2html_mydb_mark>#550#%%

<tex2html_mydb_mark>#551#%s\n;SPMquot;,yytext);}

<tex2html_mydb_mark>#552#%%
 
<tex2html_mydb_mark>#553#%%

<tex2html_mydb_mark>#554#%s\n;SPMquot;,yytext);}

<tex2html_mydb_mark>#555#%%

<tex2html_mydb_mark>#556#%option prefix=;SPMquot;one;SPMquot;| y \verb|%option prefix=;SPMquot;two;SPMquot;| en los respectivos programas 

<tex2html_mydb_mark>#557#%{

<tex2html_mydb_mark>#558#%}
 
<tex2html_mydb_mark>#559#%%

<tex2html_mydb_mark>#560#%c-;SPMquot;,yytext[0]);

<tex2html_mydb_mark>#561#%%
 
<tex2html_mydb_mark>#562#%array

<tex2html_mydb_mark>#563#%{

<tex2html_mydb_mark>#564#%}

<tex2html_mydb_mark>#565#%%

<tex2html_mydb_mark>#566#%s\n;SPMquot;,yytext); }

<tex2html_mydb_mark>#567#%d\n;SPMquot;,atoi(yytext)); }

<tex2html_mydb_mark>#568#%f\n;SPMquot;,atof(yytext)); }

<tex2html_mydb_mark>#569#%%

<tex2html_mydb_mark>#570#%x incl

<tex2html_mydb_mark>#571#%{

<tex2html_mydb_mark>#572#%}

<tex2html_mydb_mark>#573#%%

<tex2html_mydb_mark>#574#%s not found\n;SPMquot;,yytext);
                     
<tex2html_mydb_mark>#575#%%

<tex2html_mydb_mark>#576#%

<tex2html_mydb_mark>#577#%d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);

<tex2html_mydb_mark>#578#%;SPMgt;

<tex2html_mydb_mark>#579#%

<tex2html_mydb_mark>#580#%d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);

<tex2html_mydb_mark>#581#%;SPMgt;                                                            

<tex2html_mydb_mark>#582#%x incl

<tex2html_mydb_mark>#583#%{

<tex2html_mydb_mark>#584#%}

<tex2html_mydb_mark>#585#%%

<tex2html_mydb_mark>#586#%s not found\n;SPMquot;,yytext);
		     
<tex2html_mydb_mark>#587#%%

<tex2html_mydb_mark>#588#%%

<tex2html_mydb_mark>#589#%%

<tex2html_mydb_mark>#590#%{

<tex2html_mydb_mark>#591#%}
 
<tex2html_mydb_mark>#592#%%

<tex2html_mydb_mark>#593#%s [-help | -h | -? ] [-verbose | -v];SPMquot;
         
<tex2html_mydb_mark>#594#%s\n;SPMquot;,fileName);
              
<tex2html_mydb_mark>#595#%{

<tex2html_mydb_mark>#596#%}

<tex2html_mydb_mark>#597#%%

<tex2html_mydb_mark>#598#%%

<tex2html_mydb_mark>#599#%s\n;SPMquot;,fileName);
    
<tex2html_mydb_mark>#600#%c-;SPMquot;,lookahead);
       
<tex2html_mydb_mark>#601#%pointer| y \verb|%array|

<tex2html_mydb_mark>#602#%array| la variable \verb|YYLMAX| controla el tama\~no del

<tex2html_mydb_mark>#603#%array

<tex2html_mydb_mark>#604#%{

<tex2html_mydb_mark>#605#%}

<tex2html_mydb_mark>#606#%%

<tex2html_mydb_mark>#607#%%

<tex2html_mydb_mark>#608#%array

<tex2html_mydb_mark>#609#%{

<tex2html_mydb_mark>#610#%}

<tex2html_mydb_mark>#611#%%

<tex2html_mydb_mark>#612#%%
 
<tex2html_mydb_mark>#613#%d: %d occurrences\n;SPMquot;,i,ctrl[i]);

<tex2html_mydb_mark>#614#%%

<tex2html_mydb_mark>#615#%c;SPMquot;,yytext[0]);

<tex2html_mydb_mark>#616#%c;SPMquot;,yytext[0]);      

<tex2html_mydb_mark>#617#%c;SPMquot;,yytext[0]);
       
<tex2html_mydb_mark>#618#%c;SPMquot;,yytext[0]);
       
<tex2html_mydb_mark>#619#%YY_BREAK% es simplemente un \verb%break%. Si cada acción de usuario termina en un \verb%return%, puedes encontrarte con que el compilador genera un buen número de \verb%warning! unreachable code%. Puedes entonces redefinir \verb%YY_BREAK% a vacío y evitar estos mensajes.

<tex2html_mydb_mark>#620#%suppressed section

<tex2html_mydb_mark>#621#%input{typedef}

<tex2html_mydb_mark>#622#
%%

<tex2html_mydb_mark>#623#
foo |
bar$   { /* action */ }
<tex2html_mydb_mark>#624#
$ uname -a
Linux nereida.deioc.ull.es 2.2.12-20 #10 Mon May 8 19:40:16 WEST 2000 i686 unknown
$ flex --version   
flex version 2.5.4
<tex2html_mydb_mark>#625#
;SPMgt; uname -a
SunOS fonil 5.7 Generic_106541-04 sun4u sparc SUNW,Ultra-5_10
;SPMgt; flex --version
flex version 2.5.2
<tex2html_mydb_mark>#626#
;SPMgt; cat spaces.l
%%
one two { printf(;SPMquot;spaces\n;SPMquot;; }
%%
nereida:~/public_html/regexpr/lex/src;SPMgt; flex spaces.l
nereida:~/public_html/regexpr/lex/src;SPMgt; gcc lex.yy.c
spaces.l: In function `yylex':
spaces.l:2: `two' undeclared (first use in this function)
spaces.l:2: (Each undeclared identifier is reported only once
spaces.l:2: for each function it appears in.)
spaces.l:2: parse error before `{'
spaces.l:4: case label not within a switch statement
lex.yy.c:632: case label not within a switch statement
lex.yy.c:635: case label not within a switch statement
lex.yy.c:757: default label not within a switch statement
lex.yy.c: At top level:
lex.yy.c:762: parse error before `}'
<tex2html_mydb_mark>#627#
$ cat subst.l
%option main
%{
#include ;SPMlt;unistd.h;SPMgt;
%}
%%
username    printf( ;SPMquot;%s;SPMquot;,  getlogin());
%%
$ flex -osubst.c subst.l
$ gcc -o subst subst.c
$ subst
Dear username:
Dear pl:
<tex2html_mydb_mark>#628#
$ cat delete.l
/* delete all entries of zap me */
%%
;SPMquot;zap me;SPMquot;
$ flex delete.l ; gcc lex.yy.c -lfl; a.out
this is zap me a first zap me phrase
this is  a first  phrase
<tex2html_mydb_mark>#629#
$ cat yytextp.l
%%
hello {
        strcat(yytext, ;SPMquot; world;SPMquot;);
        printf(;SPMquot;\n%d: %s\n;SPMquot;,strlen(yytext),yytext);
      }
$ flex yytextp.l ; gcc lex.yy.c -lfl ; a.out
hello
 
11: hello world
 
fatal flex scanner internal error--end of buffer missed
<tex2html_mydb_mark>#630#
$ cat yytext.l
%array
%%
hello {
        strcat(yytext, ;SPMquot; world;SPMquot;);
        printf(;SPMquot;\n%d: %s\n;SPMquot;,strlen(yytext),yytext);
      }
$ flex yytext.l; gcc lex.yy.c -lfl; a.out
hello
 
11: hello world
<tex2html_mydb_mark>#631#
#define YY_DECL char *scanner(int *numcount, int *idcount)
<tex2html_mydb_mark>#632#
$ cat decl.l
%{
#define YY_DECL char *scanner(int *numcount, int *idcount)
%}
 
num [0-9]+
id [a-z]+
%%
{num} {(*numcount)++;}
halt  {return ((char *) strdup(yytext));}
{id}  {(*idcount)++;}
%%
main() {
  int a,b;
  char *t;
 
  a = 0; b = 0;
  t = scanner(;SPMamp;a, ;SPMamp;b);
  printf(;SPMquot;numcount = %d, idcount = %d, yytext = %s\n;SPMquot;,a,b,t);
  t = scanner(;SPMamp;a, ;SPMamp;b);
  printf(;SPMquot;numcount = %d, idcount = %d, yytext = %s\n;SPMquot;,a,b,t);
}
 
int yywrap() {
  return 1;
}
<tex2html_mydb_mark>#633#
$ decl
a b 1 2 3 halt
     numcount = 3, idcount = 2, yytext = halt
 
e 4 5 f
 
numcount = 5, idcount = 4, yytext = (null)
$ decl
a b 1 2 3 halt
     numcount = 3, idcount = 2, yytext = halt
 
e 4 f 5 halt
    numcount = 5, idcount = 4, yytext = halt
<tex2html_mydb_mark>#634#
%{
unsigned long charCount = 0, wordCount = 0, lineCount = 0;
%}

word [^ \t\n]+ 
eol \n 

%%
{word} { wordCount++; charCount += yyleng; }
{eol} { charCount++; lineCount++; }
. charCount++;

%%

char **fileList;
unsigned nFiles;
unsigned currentFile = 0;
unsigned long totalCC = 0;
unsigned long totalWC = 0;
unsigned long totalLC = 0;

main ( int argc, char **argv) {
  FILE *file;

  fileList = argv + 1; nFiles = argc - 1;

  if (nFiles == 0) {
    fprintf(stderr,;SPMquot;Usage is:\n%s file1 file2 file3 ...\n;SPMquot;,argv[0]);
    exit(1);
  }
  file = fopen (fileList[0], ;SPMquot;r;SPMquot;);
  if (!file) {
      fprintf (stderr, ;SPMquot;could not open %s\n;SPMquot;, argv[1]);
      exit (1);
  }
  currentFile = 1; yyrestart(file);
  yylex ();
  printf (;SPMquot;%8lu %8lu %8lu %s\n;SPMquot;, lineCount, wordCount,
    charCount, fileList[currentFile - 1]);
  if (argc ;SPMgt; 2) {
      totalCC += charCount; totalWC += wordCount; totalLC += lineCount;
      printf (;SPMquot;%8lu %8lu %8lu total\n;SPMquot;, totalLC, totalWC, totalCC);
  }
  return 0;
}

int yywrap () {
  FILE *file;

  if (currentFile ;SPMlt; nFiles) {
     printf (;SPMquot;%8lu %8lu %8lu %s\n;SPMquot;, lineCount, wordCount,
       charCount, fileList[currentFile - 1]);
     totalCC += charCount; totalWC += wordCount; totalLC += lineCount;
     charCount = wordCount = lineCount = 0;
     fclose (yyin);

     while (fileList[currentFile] != (char *) 0) {
       file = fopen (fileList[currentFile++], ;SPMquot;r;SPMquot;);
       if (file != NULL) { yyrestart(file); break; }
	  fprintf (stderr, ;SPMquot;could not open %s\n;SPMquot;, fileList[currentFile - 1]);
     }
     return (file ? 0 : 1);
    }
    return 1;
}
<tex2html_mydb_mark>#635#
$ flex countlwc.l;gcc lex.yy.c; a.out *.l
      58      179     1067 ape-05.l
      88      249     1759 countlwc.l
      11       21      126 magic.l
       9       17      139 mgrep.l
       9       16      135 mlg.l
       5       15      181 ml.l
       7       12       87 subst.l
     187      509     3494 total
<tex2html_mydb_mark>#636#
$ cat unput2.l
%array
%%
[a-z] {unput(toupper(yytext[0]));}
[A-Z] ECHO;
%%
$ flex unput2.l ; gcc lex.yy.c -lfl;a.out
abcd
ABCD
<tex2html_mydb_mark>#637#
$ cat unput.l
%%
[0-9]+ {
  int i;
  char *yycopy = (char *) strdup(yytext);
 
  unput(')');
  for(i=strlen(yycopy)-1; i;SPMgt;=0; --i)
    unput(yycopy[i]);
  unput('(');
  free(yycopy);
}
\([0-9]+\) printf(;SPMquot;Num inside parenthesis: %s\n;SPMquot;,yytext);
.|\n
$ flex unput.l ; gcc lex.yy.c -lfl ; a.out
32
Num inside parenthesis: (32)
(43)
Num inside parenthesis: (43)
<tex2html_mydb_mark>#638#
$ cat input.l
%%
;SPMquot;/*;SPMquot; {
        int c;
        for(;;) {
          while ((c=input()) != '*' ;SPMamp;;SPMamp; c != EOF)
            ;
          if (c == '*')  {
            while ((c = input()) == '*')
              ;
            if (c == '/') break;
          }
          if (c == EOF) {
            fprintf(stderr,;SPMquot;Error: EOF in comment;SPMquot;);
            yyterminate();
          }
        }
      }
<tex2html_mydb_mark>#639#
$ flex input.l ; gcc lex.yy.c -lfl ; a.out
hello /* world */
hello
unfinished /* comment
unfinished Error: EOF in comment
<tex2html_mydb_mark>#640#
$ cat reject.l
%%
a    |
ab   |
abc  |
abcd ECHO; REJECT; printf(;SPMquot;Never seen\n;SPMquot;);
.|\n
<tex2html_mydb_mark>#641#
$ gcc lex.yy.c -lfl;a.out
abcd
abcdabcaba
<tex2html_mydb_mark>#642#
$ cat yymore.l
%%
mega- ECHO; yymore();
kludge ECHO;
 
$ flex yymore.l ; gcc lex.yy.c -lfl ; a.out
mega-kludge
mega-mega-kludge
<tex2html_mydb_mark>#643#
$ cat yyless.l
%%
foobar ECHO; yyless(4);
[a-z]+ ECHO;
 
$ flex yyless.l; gcc lex.yy.c -lfl; a.out
foobar
foobarar
<tex2html_mydb_mark>#644#
$ cat quotes.l
%%
\"[^;SPMquot;]+\" {
            printf(;SPMquot;Processing string. %d: %s\n;SPMquot;,yyleng,yytext);
            if (yytext[yyleng-2] =='\\') {
             yyless(yyleng-1); /* so that it will match next time */
             yymore(); /* concatenate  with current yytext */
             printf(;SPMquot;After yyless. %d: %s\n;SPMquot;,yyleng,yytext);
            } else {
              printf(;SPMquot;Finished. The string is: %s\n;SPMquot;,yytext);
            }
          }
<tex2html_mydb_mark>#645#
$ flex quotes.l ; gcc lex.yy.c -lfl ; a.out
;SPMquot;Hello \"Peter\", nice to meet you;SPMquot;
Procesing string. 9: ;SPMquot;Hello \"
After yyless. 8: ;SPMquot;Hello \
Procesing string. 16: ;SPMquot;Hello \"Peter\"
After yyless. 15: ;SPMquot;Hello \"Peter\
Procesing string. 35: ;SPMquot;Hello \"Peter\", nice to meet you;SPMquot;
Finished. The string is: ;SPMquot;Hello \"Peter\", nice to meet you;SPMquot;
<tex2html_mydb_mark>#646#
$ cat comments.l
%option noyywrap
%{
  int linenum = 0;
%}
%x comment
%%
 
;SPMquot;/*;SPMquot; BEGIN(comment); printf(;SPMquot;comment=%d, YY_START = %d, YYSTATE = %d;SPMquot;,comment,YY_START,YYSTATE);
;SPMlt;comment;SPMgt;[^*\n]* /* eat anything that is not a star * /
;SPMlt;comment;SPMgt;;SPMquot;*;SPMquot;+[^*/\n]* /* eat up starts not followed by / */
;SPMlt;comment;SPMgt;\n ++linenum; /* update number of lines */
;SPMlt;comment;SPMgt;;SPMquot;*;SPMquot;+;SPMquot;/;SPMquot; BEGIN(0);
 
\n ECHO; linenum++;
.  ECHO;
%%
main() {
  yylex();
  printf(;SPMquot;\n%d lines\n;SPMquot;,linenum);
}
<tex2html_mydb_mark>#647#
$ flex comments.l ; gcc lex.yy.c ; a.out ;SPMlt; hello.c
main() ;SPMlt;%
int a;SPMlt;:1:;SPMgt;; comment=1, YY_START = 1, YYSTATE = 1
  a;SPMlt;:0:;SPMgt; = 4; comment=1, YY_START = 1, YYSTATE = 1
  printf(;SPMquot;hello world! a(0) is %d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);
%;SPMgt;
 
6 lines     
$ cat hello.c
main() ;SPMlt;%
int a;SPMlt;:1:;SPMgt;; /* a comment */
  a;SPMlt;:0:;SPMgt; = 4; /* a comment in
                 two lines */
  printf(;SPMquot;hello world! a(0) is %d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);
%;SPMgt;                                  

<tex2html_mydb_mark>#648#
$ cat ststring.l
%option main
%x str
%{
#define MAX_STR_CONST 256
 
  char string_buffer[MAX_STR_CONST];
  char *string_buf_ptr;
%}
 
%%
\"  string_buf_ptr  = string_buffer; BEGIN(str);
;SPMlt;str;SPMgt;{
\"             {BEGIN (INITIAL); *string_buf_ptr = '\0'; printf(;SPMquot;%s;SPMquot;,string_buffer); }
\n             { printf(;SPMquot;Error: non terminated string\n;SPMquot;); exit(1); }
\\[0-7]{1,3}   { int result; /* octal escape sequence */
                        (void) sscanf(yytext+1,;SPMquot;%o;SPMquot;,;SPMamp;result);
                         if (result ;SPMgt; 0xff) {printf(;SPMquot;Error: constant out of bounds\n;SPMquot;); exit(2); }
                         *string_buf_ptr++ = result;
                    }
\\[0-9]+       { printf(;SPMquot;Error: bad escape sequence\n;SPMquot;); exit(2); }
\\n            {*string_buf_ptr++ = '\n';}
\\t            {*string_buf_ptr++ = '\t';}
\\b            {*string_buf_ptr++ = '\b';}
\\r            {*string_buf_ptr++ = '\r';}
\\f            {*string_buf_ptr++ = '\f';}
\\(.|\n)       {*string_buf_ptr++ = yytext[1];}
[^\\\n\"]+     {char *yptr = yytext; while(*yptr) *string_buf_ptr++ = *yptr++; }
}
(.|\n)
%%                            
$ flex ststring.l ; gcc lex.yy.c ; a.out ;SPMlt; hello.c
        hello
world! a(0) is %d
$ cat hello.c
main() ;SPMlt;%
int a;SPMlt;:1:;SPMgt;; /* a comment */
  a;SPMlt;:0:;SPMgt; = 4; /* a comment in
                 two lines */
  printf(;SPMquot;\thell\157\nworld! a(0) is %d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);
%;SPMgt;                                   

<tex2html_mydb_mark>#649#
;SPMquot;hello \
dolly;SPMquot;
<tex2html_mydb_mark>#650#|
;SPMquot;hello
<tex2html_mydb_mark>#651#
%option main
%option noyywrap
%option stack
%{
#include ;SPMlt;stdio.h;SPMgt;
#include  ;SPMlt;stdlib.h;SPMgt;
%}
%x estado_a
%%
^a { yy_push_state(estado_a);}
;SPMlt;estado_a;SPMgt;{
a      { yy_push_state(estado_a); }
b      { yy_pop_state();  }
b[^b\n]+    {   printf (;SPMquot;Error\n;SPMquot;); 
        while (YYSTATE != INITIAL)
          yy_pop_state();
        while (input() != '\n') ;
      }
(.|\n)  {  printf (;SPMquot;Error\n;SPMquot;); 
        while (YYSTATE != INITIAL)
          yy_pop_state();
        while (input() != '\n') ;
      }
}
.      {  printf (;SPMquot;Error\n;SPMquot;);
        while (input() != '\n') ;
      }
\n      { printf(;SPMquot;Aceptar\n;SPMquot;);}
%%

<tex2html_mydb_mark>#652#
%option stack
%x comment
%%
;SPMquot;/*;SPMquot;   { yy_push_state(comment); }
(.|\n) ECHO;
;SPMlt;comment;SPMgt;;SPMquot;/*;SPMquot;     { yy_push_state(comment); } 
;SPMlt;comment;SPMgt;;SPMquot;*/;SPMquot;     { yy_pop_state(); } 
;SPMlt;comment;SPMgt;(.|\n)   ;
;SPMlt;comment;SPMgt;;SPMlt;;SPMlt;EOF;SPMgt;;SPMgt;  { fprintf(stderr,;SPMquot;Error\n;SPMquot;); exit(1); }
%%

<tex2html_mydb_mark>#653#
$ cat hello.c
main() {
int a[1]; /* a /* nested comment */. */
  a[0] = 4; /* a  /* nested comment in
                 /* two */ lines  */ *****/
}                                                   
$ flex nestedcom.l ; gcc lex.yy.c -lfl ; a.out ;SPMlt; hello.c
main() {
int a[1];
  a[0] = 4;
}
$ cat hello4.c
main() {
int a[1]; /* a /* nested comment */. */
  a[0] = 4; /* an  /* incorrectly nested comment in
                 /* two  lines  */ *****/
}
$ a.out ;SPMlt; hello4.c
main() {
int a[1];
Error
  a[0] = 4;
<tex2html_mydb_mark>#654# 
yy_create_buffer
yy_delete_buffer
yy_flex_debug
yy_init_buffer
yy_flush_buffer
yy_load_buffer_state
yy_switch_to_buffer
yyin
yyleng
yylex
yylineno
yyout
yyrestart
yytext
yywrap
<tex2html_mydb_mark>#655#
$ cat one.l
%%
one {printf(;SPMquot;1\n;SPMquot;); return 1;}
.   {printf(;SPMquot;First analyzer: %s\n;SPMquot;,yytext);}
%%
 
int onewrap(void) {
  return 1;
}
 
$ cat two.l
%%
two {printf(;SPMquot;2\n;SPMquot;); return 2;}
.   {printf(;SPMquot;Second analyzer: %s\n;SPMquot;,yytext);}
%%
int twowrap(void) {
  return 1;
}
$ cat onetwo.c
main() {
  onelex();
  twolex();
}
<tex2html_mydb_mark>#656#
$ flex -Pone one.l
$ flex -Ptwo two.l
$ ls -ltr | tail -2
-rw-rw----   1 pl       casiano     36537 Nov  7 09:52 lex.one.c
-rw-rw----   1 pl       casiano     36524 Nov  7 09:52 lex.two.c
$ gcc onetwo.c lex.one.c lex.two.c
$ a.out
two
First analyzer: t
First analyzer: w
First analyzer: o
 
one
1
one
Second analyzer: o
Second analyzer: n
Second analyzer: e
 
two
2
$
<tex2html_mydb_mark>#657#
$ cat string.l
%{
#undef YY_INPUT
#define YY_INPUT(b,r,m) (r = yystringinput(b,m))
#define min(a,b) ((a;SPMlt;b)?(a):(b))
%}
 
%%
[0-9]+ printf(;SPMquot;Num-;SPMquot;);
[a-zA-Z][a-zA-Z_0-9]* printf(;SPMquot;Id-;SPMquot;);
[ \t]+
. printf(;SPMquot;%c-;SPMquot;,yytext[0]);
%%
 
extern char string[];
extern char *yyinputptr;
extern char *yyinputlim;
 
int yystringinput(char *buf, int maxsize) {
  int n = min(maxsize, yyinputlim-yyinputptr);
 
  if (n ;SPMgt; 0) {
    memcpy(buf, yyinputptr, n);
    yyinputptr += n;
  }
  return n;
}
 
int yywrap() { return 1; }
<tex2html_mydb_mark>#658#
$ cat stringmain.c
char string[] = ;SPMquot;one=1;two=2;SPMquot;;
char *yyinputptr;
char *yyinputlim;
 
main() {
  yyinputptr = string;
  yyinputlim = string + strlen(string);
  yylex();
  printf(;SPMquot;\n;SPMquot;);
}
<tex2html_mydb_mark>#659#
$ a.out
Id-=-Num-;-Id-=-Num-
<tex2html_mydb_mark>#660#
 cat fortran4.l
%array
%{
#include ;SPMlt;string.h;SPMgt;
#undef YY_INPUT
#define YY_INPUT(buf,result,max) (result = my_input(buf,max))
%}
number [0-9]+
integer [+-]?{number}
float ({integer}\.{number}?|\.{number})(E{integer})?
label [A-Z0-9]+
id   [A-Z]{label}*
%%
DO/{label}={number}\, { printf(;SPMquot;do loop\n;SPMquot;); }
{id} { printf(;SPMquot;Identifier %s\n;SPMquot;,yytext); }
{number} { printf(;SPMquot;Num %d\n;SPMquot;,atoi(yytext)); }
{float} { printf(;SPMquot;Float %f\n;SPMquot;,atof(yytext)); }
(.|\n)
%%

int my_input(char *buf, int max)
{
  char *q1, *q2, *p = (char *) malloc(max);
  int i;
  if ('\0' != fgets(p,max,yyin)) {
    for(i=0, q1=buf, q2=p;(*q2 != '\0');q2++) {
      if (*q2 != ' ') { *q1++ = toupper(*q2); i++; };
    }
    free(p);
    return i;
  }
  else exit(1);
}
<tex2html_mydb_mark>#661#
$ flex fortran4.l; gcc lex.yy.c -lfl; a.out
do j = 1 . 10
Identifier DOJ
Float 1.100000
do k = 1, 5
do loop
Identifier K
Num 1
Num 5
<tex2html_mydb_mark>#662#
$ cat include.l
%x incl
%{
#define yywrap() 1
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}
%%
include          BEGIN(incl);
.                ECHO;
;SPMlt;incl;SPMgt;[ \t]*
;SPMlt;incl;SPMgt;[^ \t\n]+  { /* got the file name */
                   if (include_stack_ptr ;SPMgt;= MAX_INCLUDE_DEPTH) {
                     fprintf(stderr,;SPMquot;Includes nested too deeply\n;SPMquot;);
                     exit(1);
                   }
                   include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
                   yyin = fopen(yytext,;SPMquot;r;SPMquot;);
                   if (!yyin) {
                     fprintf(stderr,;SPMquot;File %s not found\n;SPMquot;,yytext);
                     exit(1);
                   }
                   yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
                   BEGIN(INITIAL);
                 }
;SPMlt;;SPMlt;EOF;SPMgt;;SPMgt; {
          if ( --include_stack_ptr ;SPMlt; 0) {
            yyterminate();
          } else {
            yy_delete_buffer(YY_CURRENT_BUFFER);
            yy_switch_to_buffer(include_stack[include_stack_ptr]);
          }
        }
%%
main(int argc, char ** argv) {
 
  yyin = fopen(argv[1],;SPMquot;r;SPMquot;);
  yylex();
}
<tex2html_mydb_mark>#663#
$ cat hello.c
#include hello2.c
main() ;SPMlt;%
int a;SPMlt;:1:;SPMgt;; /* a comment */
  a;SPMlt;:0:;SPMgt; = 4; /* a comment in
                 two lines */
  printf(;SPMquot;\thell\157\nworld! a(0) is %d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);
%;SPMgt;
$ cat hello2.c
#include hello3.c
/* file hello2.c  */
$ cat hello3.c
/*
third file
*/
$ flex include.l ; gcc lex.yy.c ; a.out hello.c
##/*
third file
*/
 
/* file hello2.c  */
 
main() ;SPMlt;%
int a;SPMlt;:1:;SPMgt;; /* a comment */
  a;SPMlt;:0:;SPMgt; = 4; /* a comment in
                 two lines */
  printf(;SPMquot;\thell\157\nworld! a(0) is %d\n;SPMquot;,a;SPMlt;:0:;SPMgt;);
%;SPMgt;                                                            

<tex2html_mydb_mark>#664#
%x incl
%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}
%%
include          BEGIN(incl);
.                ECHO;
;SPMlt;incl;SPMgt;[ \t]*
;SPMlt;incl;SPMgt;[^ \t\n]+  { /* got the file name */
                   if (include_stack_ptr ;SPMgt;= MAX_INCLUDE_DEPTH) {
		     fprintf(stderr,;SPMquot;Includes nested too deeply\n;SPMquot;);
		     exit(1);
		   }
		   include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
		   yyin = fopen(yytext,;SPMquot;r;SPMquot;);
		   if (!yyin) {
		     fprintf(stderr,;SPMquot;File %s not found\n;SPMquot;,yytext);
		     exit(1);
		   }
		   yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
		   BEGIN(INITIAL);
		 }
%%
main(int argc, char ** argv) {

  yyin = fopen(argv[1],;SPMquot;r;SPMquot;);
  yylex();
}

int yywrap() {
  if ( --include_stack_ptr ;SPMlt; 0) { 
    return 1;
  } else {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(include_stack[include_stack_ptr]);
    return 0;
  }
}
<tex2html_mydb_mark>#665#
$ cat scan_str.l
%%
[0-9]+     printf(;SPMquot;num\n;SPMquot;);
[a-zA-Z]+  printf(;SPMquot;Id\n;SPMquot;);
%%
main(int argc, char ** argv) {
int i;
 
  for(i=1;i;SPMlt;argc;i++) {
    yy_scan_string(argv[i]);
    yylex();
    yy_delete_buffer(YY_CURRENT_BUFFER);
  }
}
 
int yywrap() { return 1; }
$ flex scan_str.l ; gcc lex.yy.c ; a.out Hello World! 1234
Id
Id
!num
<tex2html_mydb_mark>#666#
main(int argc, char ** argv) {
int i;
YY_BUFFER_STATE p;

  for(i=1;i;SPMlt;argc;i++) {
    p = yy_scan_string(argv[i]);
    yylex();
    yy_delete_buffer(p);
  }
}
<tex2html_mydb_mark>#667#
$ fl -v -V -f tokens.h
verbose mode is on
version 1.0
File name is: tokens.h
Analyzing tokens.h
#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks
-int-blanks-#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks-int-blanks-
<tex2html_mydb_mark>#668#
$ cat Makefile
LIBS=-lflarg
CC=gcc -g
LIBPATH=-L. -L~/lib
INCLUDES=-I. -I~/include
 
fl: main.c lex.arg.c lex.yy.c libflarg.a tokens.h
        $(CC) $(LIBPATH) $(INCLUDES) main.c lex.arg.c lex.yy.c $(LIBS) -o fl
lex.arg.c: fl.l
        flex -Parg fl.l
lex.yy.c: trivial.l tokens.h
        flex trivial.l
libflarg.a: flarg.o
        ar r libflarg.a flarg.o
flarg.o: flarg.c
        $(CC) -c flarg.c
clean:                                 
$ make clean;make
rm lex.arg.c lex.yy.c *.o  fl
flex -Parg fl.l
flex trivial.l
gcc -g -c flarg.c
ar r libflarg.a flarg.o
gcc -g -L. -L~/lib -I. -I~/include main.c lex.arg.c lex.yy.c -lflarg -o fl
<tex2html_mydb_mark>#669#
$ cat flarg.h
int yyarglex(int argc, char **argv);
int YY_input_from_argv(char *buf, int max);
int argwrap(void);
 
#undef YY_INPUT
#define YY_INPUT(buf,result,max) (result = YY_input_from_argv(buf,max))
<tex2html_mydb_mark>#670#
  YY_targv = argv+1;
  YY_arglim = argv+argc;
<tex2html_mydb_mark>#671#
$ cat flarg.c
char **YY_targv;
char **YY_arglim;
 
int YY_input_from_argv(char *buf, int max)
{
  static unsigned offset = 0;
 
  int len, copylen;
 
    if (YY_targv ;SPMgt;= YY_arglim) return 0;        /* EOF */
    len = strlen(*YY_targv)-offset;     /* amount of current arg */
    if(len ;SPMgt;= max) {copylen = max-1; offset += copylen; }
    else copylen = len;
    if(len ;SPMgt; 0) memcpy(buf, YY_targv[0]+offset, copylen);
    if(YY_targv[0][offset+copylen] == '\0') {   /* end of arg */
      buf[copylen] = ' '; copylen++; offset = 0; YY_targv++;
    }
    return copylen;
}
 
int yyarglex(int argc, char **argv) {
  YY_targv = argv+1;
  YY_arglim = argv+argc;
  return arglex();
}
 
int argwrap(void) {
  return 1;
}
<tex2html_mydb_mark>#672#
$ cat fl.l
%{
unsigned verbose;
unsigned thereisfile;
char *progName;
char fileName[256];
#include ;SPMquot;flarg.h;SPMquot;
#include ;SPMquot;tokens.h;SPMquot;
%}
 
%%
-h      |
;SPMquot;-?;SPMquot;    |
-help   { printf(;SPMquot;usage is: %s [-help | -h | -? ] [-verbose | -v];SPMquot;
         ;SPMquot; [-Version | -V];SPMquot;
         ;SPMquot; [-f filename]\n;SPMquot;, progName);
        }
 
-v      |
-verbose { printf(;SPMquot;verbose mode is on\n;SPMquot;); verbose = 1; }
 
-V      |
-version { printf(;SPMquot;version 1.0\n;SPMquot;); }
 
-f[[:blank:]]+[^ \t\n]+ {
              strcpy(fileName,argtext+3);
              printf(;SPMquot;File name is: %s\n;SPMquot;,fileName);
              thereisfile = 1;
            }
.
 
\n
<tex2html_mydb_mark>#673#
$ cat trivial.l
%{
#include ;SPMquot;tokens.h;SPMquot;
%}
digit [0-9]
id [a-zA-Z][a-zA-Z0-9]+
blanks [ \t\n]+
operator [+*/-]
%%
{digit}+ {return INTTOKEN; }
{digit}+;SPMquot;.;SPMquot;{digit}+ {return FLOATTOKEN; }
{id} {return IDTOKEN;}
{operator} {return OPERATORTOKEN;}
{blanks} {return BLANKTOKEN;}
. {return (int) yytext[0];}
%%
int yywrap() {
  return 1;
}
<tex2html_mydb_mark>#674#
$ cat tokens.h
#define INTTOKEN  256
#define FLOATTOKEN 257
#define IDTOKEN 258
#define OPERATORTOKEN 259
#define BLANKTOKEN 260
<tex2html_mydb_mark>#675#
$ cat main.c
#include ;SPMlt;stdio.h;SPMgt;
#include ;SPMquot;flarg.h;SPMquot;
#include ;SPMquot;tokens.h;SPMquot;
extern unsigned verbose;
extern unsigned thereisfile;
extern char *progName;
extern char fileName[256];
extern FILE * yyin;
 
main(int argc, char **argv) {
  unsigned lookahead;
  FILE * file;
 
  progName = *argv;
  yyarglex(argc,argv);
  if (thereisfile) {
    if (verbose) printf(;SPMquot;Analyzing %s\n;SPMquot;,fileName);
    file = (fopen(fileName,;SPMquot;r;SPMquot;));
    if (file == NULL) exit(1);
    yyin = file;
    while (lookahead = yylex()) {
      switch (lookahead) {
        case INTTOKEN:
            printf(;SPMquot;int-;SPMquot;);
            break;
          case FLOATTOKEN:
            printf(;SPMquot;float-;SPMquot;);
            break;
          case IDTOKEN:
            printf(;SPMquot;id-;SPMquot;);
            break;
          case OPERATORTOKEN:
            printf(;SPMquot;operator-;SPMquot;);
            break;
          case BLANKTOKEN:
            printf(;SPMquot;blanks-;SPMquot;);
            break;
          default: printf(;SPMquot;%c-;SPMquot;,lookahead);
       }
    } /* while */
    printf(;SPMquot;\n;SPMquot;);
  } /* if */
}
<tex2html_mydb_mark>#676#
$ cat trivial.l
%array
%{
#undef YYLMAX
#define YYLMAX 4
#include ;SPMquot;tokens.h;SPMquot;
%}
digit [0-9]
id [a-zA-Z][a-zA-Z0-9]+
blanks [ \t\n]+
operator [+*/-]
%%
{digit}+ {return INTTOKEN; }
{digit}+;SPMquot;.;SPMquot;{digit}+ {return FLOATTOKEN; }
{id} {return IDTOKEN;}
{operator} {return OPERATORTOKEN;}
{blanks} {return BLANKTOKEN;}
. {return (int) yytext[0];}
%%
int yywrap() {
  return 1;
  }
<tex2html_mydb_mark>#677#
$ fl -V -f tokens.h
version 1.0
File name is: tokens.h
token too large, exceeds YYLMAX
<tex2html_mydb_mark>#678#
$ cat user_action.l
%array
%{
#include ;SPMlt;string.h;SPMgt;
 
int ctrl[YY_NUM_RULES];
#undef YY_USER_ACTION
#define YY_USER_ACTION { ++ctrl[yy_act]; }
%}
number [0-9]+
id   [a-zA-Z_]+[a-zA-Z0-9_]*
whites [ \t\n]+
%%
{id}
{number}
{whites}
.
%%
 
int yywrap() {
  int i;
 
  for(i=1;i;SPMlt;YY_NUM_RULES;i++)
    printf(;SPMquot;Rule %d: %d occurrences\n;SPMquot;,i,ctrl[i]);
}
                                                  
$ flex user_action.l ; gcc lex.yy.c -lfl ; a.out
a=b+2*(c-4)
Rule 1: 3 occurrences
Rule 2: 2 occurrences
Rule 3: 1 occurrences
Rule 4: 6 occurrences
<tex2html_mydb_mark>#679#
$ cat isatty.c
#include ;SPMlt;unistd.h;SPMgt;
#include ;SPMlt;stdio.h;SPMgt;
main() {
 
  if (isatty(0))
    printf(;SPMquot;interactive\n;SPMquot;);
  else
    printf(;SPMquot;non interactive\n;SPMquot;);
}
$ gcc isatty.c; a.out
interactive
$ a.out ;SPMlt; isatty.c
non interactive
$
<tex2html_mydb_mark>#680#
$ cat interactive.l
%%
. printf(;SPMquot;::%c;SPMquot;,yytext[0]);
\n printf(;SPMquot;::%c;SPMquot;,yytext[0]);      

<tex2html_mydb_mark>#681#
/* A lexical scanner generated by flex */
....
#define YY_NUM_RULES 3
#line 1 ;SPMquot;interactive.l;SPMquot;
#define INITIAL 0
#line 363 ;SPMquot;lex.yy.c;SPMquot;
....
YY_DECL {
 ....
#line 1 ;SPMquot;interactive.l;SPMquot;
#line 516 ;SPMquot;lex.yy.c;SPMquot;
 ....
 if ( yy_init ) {
   yy_init = 0;
#ifdef YY_USER_INIT
   YY_USER_INIT;
#endif
   if ( ! yy_start ) yy_start = 1;  /* first start state */
   if ( ! yyin ) yyin = stdin;
   if ( ! yyout ) yyout = stdout;
   if ( ! yy_current_buffer ) yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
   yy_load_buffer_state();
 }
 while ( 1 )    /* loops until end-of-file is reached */ {
   ............................
yy_match:
   do {
    .....
   }
   ............
yy_find_action:
   ............
   YY_DO_BEFORE_ACTION;
   do_action:  /* This label is used only to access EOF actions. */
     switch ( yy_act ) { /* beginning of action switch */
       case 0: 
         ...................
         goto yy_find_action;
     case 1:
     YY_RULE_SETUP
     #line 2 ;SPMquot;interactive.l;SPMquot;
     printf(;SPMquot;::%c;SPMquot;,yytext[0]);
       YY_BREAK
     case 2:
     YY_RULE_SETUP
     #line 3 ;SPMquot;interactive.l;SPMquot;
     printf(;SPMquot;::%c;SPMquot;,yytext[0]);
       YY_BREAK
     case 3:
     YY_RULE_SETUP
     #line 4 ;SPMquot;interactive.l;SPMquot;
     ECHO;
       YY_BREAK
     #line 614 ;SPMquot;lex.yy.c;SPMquot;
     case YY_STATE_EOF(INITIAL):
       yyterminate();
       case YY_END_OF_BUFFER:
         { .....  }
     default:
       YY_FATAL_ERROR(;SPMquot;fatal flex scanner internal error--no action found;SPMquot;);
  } /* end of action switch */
 } /* end of scanning one token */
} /* end of yylex */

#if YY_MAIN
int main()
  { yylex(); return 0; }
#endif
#line 4 ;SPMquot;interactive.l;SPMquot;
<tex2html_mydb_mark>#682#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<tex2html_mydb_mark>#683#%pine% en el que los mensajes recibidos tienen el formato:

<tex2html_mydb_mark>#684#%-n%):

<tex2html_mydb_mark>#685#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#686#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#687#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#688#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#689#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#690#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#691#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#692#%d\n;SPMquot;,fact(4)); /* the
         
<tex2html_mydb_mark>#693#%\n%. En el caso en que

<tex2html_mydb_mark>#694#%^\n$%. La orden \verb%D% deja en el espacio de trabajo una línea vacía y bifurca al comienzo del {\it script}

<tex2html_mydb_mark>#695#%^$%, ``casa''

<tex2html_mydb_mark>#696#%D% de la línea 4 y si que lo hará la orden por defecto final, imprimiéndose la línea

<tex2html_mydb_mark>#697#%$search% por su valor. La nueva comilla simple

<tex2html_mydb_mark>#698#%pine%) 

<tex2html_mydb_mark>#699#%grupo.sh% son:

<tex2html_mydb_mark>#700#
sed [opciones] 'comando' fichero(s)
sed [opciones] -f guion fichero(s)
<tex2html_mydb_mark>#701#
nereida:~/sed;SPMgt; cat b.without.sed
#example of succesive replacements
s/fish/cow/
s/cow/horse/
nereida:~/sed;SPMgt; cat b.test
fish
cow
nereida:~/sed;SPMgt; sed -f b.without.sed b.test
horse
horse
<tex2html_mydb_mark>#702#
[direccion1][,direccion2][!]comando[argumentos]
<tex2html_mydb_mark>#703#
$ cat b.sed
s/fish/cow/
b
s/cow/horse/
$ sed -f b.sed b.test
cow
cow
<tex2html_mydb_mark>#704#
$ cat blabel.sed
s/fish/cow/
b another
s/cow/horse/
:another
s/cow/cat/
$ sed -f blabel.sed b.test
cat
cat
<tex2html_mydb_mark>#705#
$ cat aandi.sed
1{
i\
;SPMlt;html;SPMgt;\
;SPMlt;head;SPMgt;\
;SPMlt;title;SPMgt;
p
i\
;SPMlt;/title;SPMgt;\
;SPMlt;/head;SPMgt;\
;SPMlt;body bgcolor=white;SPMgt;
}
$a\
;SPMlt;/pre;SPMgt;\
;SPMlt;/body;SPMgt;\
;SPMlt;/html;SPMgt;
$ cat aandi.test
hello.world!
$ sed -f aandi.sed aandi.test
;SPMlt;html;SPMgt;
;SPMlt;head;SPMgt;
;SPMlt;title;SPMgt;
hello.world!
;SPMlt;/title;SPMgt;
;SPMlt;/head;SPMgt;
;SPMlt;body bgcolor=white;SPMgt;
hello.world!
;SPMlt;/pre;SPMgt;
;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#706#
$ cat t.test
name: ;SPMquot;fulano de tal;SPMquot; address: ;SPMquot;Leganitos,4;SPMquot; phone: ;SPMquot;342255;SPMquot;
name: ;SPMquot;fulano de cual;SPMquot;
name: ;SPMquot;fulano de alli;SPMquot; address: ;SPMquot;Legitos,4;SPMquot;
name: ;SPMquot;zutano de tal;SPMquot;  address: ;SPMquot;Leg,8;SPMquot;  phone: ;SPMquot;342255;SPMquot;
<tex2html_mydb_mark>#707#
$ cat t.sed
/name:/{
s/.*name:[ ]*;SPMquot;.*;SPMquot;[ ]*address:[ ]*;SPMquot;.*;SPMquot;[ ].*phone:[ ]*;SPMquot;.*;SPMquot;.*/;SPMamp;/
t
s/.*name:[ ]*;SPMquot;.*;SPMquot;[ ]*address:[ ]*;SPMquot;.*;SPMquot;/;SPMamp; phone: ;SPMquot;????;SPMquot;/
t
s/.*name:[ ]*;SPMquot;.*;SPMquot;/;SPMamp; address: ;SPMquot;???? ????;SPMquot; phone: ;SPMquot;????;SPMquot;/
}
<tex2html_mydb_mark>#708#
$ sed -f t.sed t.test
name: ;SPMquot;fulano de tal;SPMquot; address: ;SPMquot;Leganitos,4;SPMquot; phone: ;SPMquot;342255;SPMquot;
name: ;SPMquot;fulano de cual;SPMquot; address: ;SPMquot;???? ????;SPMquot; phone: ;SPMquot;????;SPMquot;
name: ;SPMquot;fulano de alli;SPMquot; address: ;SPMquot;Legitos,4;SPMquot; phone: ;SPMquot;????;SPMquot;
name: ;SPMquot;zutano de tal;SPMquot;  address: ;SPMquot;Leg,8;SPMquot;  phone: ;SPMquot;342255;SPMquot;
$
<tex2html_mydb_mark>#709#
01_NAME: XXX
02_SURNAME: XXX
03_TITLE: SISTEMAS
04_OtherTitle:
05_BIRTHDAY: XXX
06_BIRTHMONTH: XXX
07_BIRTHYEAR: XXX
08_ADDRESSFAMILY: XXX
09_ADDRESSACTUAL: XXX
10_POSTALCODE: XXX
11_EMAIL: XXX@csi.ull.es
12_TELEPHONE: XXX
13_FAX: XXX
14_LABGROUP: xxx
15_COMMENTS:
<tex2html_mydb_mark>#710#
#!/bin/sed -f
/^11_EMAIL:/{
s/11_EMAIL: *\([a-zA-Z0-9]*@[a-zA-Z0-9.]*\)/\1/
t print
s/11_EMAIL: *\([a-zA-Z0-9]*\)/\1@csi.ull.es/
:print
p
}
<tex2html_mydb_mark>#711#
$ cat tables.sed
#Imprime las tablas en un fichero tex
/\\begin{tabular}/,/end{tabular}/p
$ sed -n -f tables.sed *.tex
\begin{tabular}{c|c}
        [address]a$\backslash$ ;SPMamp; [address]i$\backslash$\\
        text                   ;SPMamp; text\\
\end{tabular}\\
\begin{tabular}{c|c}
        [address]a$\backslash$ ;SPMamp; [address]i$\backslash$\\
        text                   ;SPMamp; text\\
\end{tabular}\\
<tex2html_mydb_mark>#712#
$ cat scope.sed
#execute: sed -n -f scope.sed scope.test
/\/\*/,/\*\//p
<tex2html_mydb_mark>#713#
$ cat scope2.test
#file scope2.test
#include ;SPMlt;stdio.h;SPMgt;
 
fact(int n) { /* recursive function
if(n == 0) return 1;
else(return n*fact(n-1));*/
}
 
void toto(id) {
}
 
main() {
  toto();
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
}
<tex2html_mydb_mark>#714#
$ sed -n -f scope.sed scope2.test
fact(int n) { /* recursive function
if(n == 0) return 1;
else(return n*fact(n-1));*/
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
<tex2html_mydb_mark>#715#
$ cat scope.test
#include ;SPMlt;stdio.h;SPMgt;
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
}
<tex2html_mydb_mark>#716#
$ sed -n -f scope.sed scope.test
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
<tex2html_mydb_mark>#717#
$ cat n.sed
# run it with: sed -n -f n.sed n.test
# write commented lines in a C program
#If current line matches /* ...
/\/\*/{
# Comienzo de comentario, aseguremonos que la línea no casa con un cierre
# de comentario.
:loop
/\*\//!{
p
n
b loop
}
p
}
<tex2html_mydb_mark>#718#
$ cat n.test
#include ;SPMlt;stdio.h;SPMgt;
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) { /* This function */ /* is
                   still empty */
}
 
main() {
  toto();
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
  toto();
  /* and here is
     a comment
     extended on 3 lines
  */
}
<tex2html_mydb_mark>#719#
$ sed -n -f n.sed n.test
fact(int n) { /* recursive function */
void toto(id) { /* This function */ /* is
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
  /* and here is
     a comment
     extended on 3 lines
  */
<tex2html_mydb_mark>#720#
$ cat columns.test
11111 22222 33333 44444 55555
  111    22    33  4444  5555
11111 22222 33333 44444 55555
   11    22     3   444  5555
<tex2html_mydb_mark>#721#
$ cat columns.sed
s/^\( *[0-9][0-9]*\)\( .*[0-9] \)\( *[0-9][0-9]*\)$/\3\2\1/
$ sed -f columns.sed columns.test
55555 22222 33333 44444 11111
 5555    22    33  4444   111
55555 22222 33333 44444 11111
 5555    22     3   444    11
<tex2html_mydb_mark>#722#
$ cat col2.sed
#extracts the second column
s/^  *//
s/\;SPMlt;[0-9][0-9]*\;SPMgt;//1
s/\;SPMlt;[0-9][0-9]*\;SPMgt;//2
s/\;SPMlt;[0-9][0-9]*\;SPMgt;//2
s/\;SPMlt;[0-9][0-9]*\;SPMgt;//2
s/  *$//
$ sed -f col2.sed columns.test
 22222
    22
 22222
    22
<tex2html_mydb_mark>#723#
;SPMgt; cat colbranch.sh
#!/bin/bash
sed -e '
s/^\( *[0-9]\+\)\{';SPMquot;$1;SPMquot;'\}//
s/\( *[0-9]\+\)\{';SPMquot;$2;SPMquot;'\}$//
'
<tex2html_mydb_mark>#724#
;SPMgt; cat columns.test
11111 22222 33333 44444 55555
  111    22    33  4444  5555
11111 22222 33333 44444 55555
   11    22     3   444  5555
;SPMgt; colbranch.sh 2 1 ;SPMlt; columns.test
 33333 44444
    33  4444
 33333 44444
     3   444
<tex2html_mydb_mark>#725#
$ cat toupper.sed
y/aáéíóúäëïöübcdefghijklmnopqrstuvxyzñ/AÁÉÍÓÚÄËÏÖÜBCDEFGHIJKLMNOPQRSTUVXYZÑ/
$ cat sp2en.test
¡Coño! ¿Es plím el que hizo plúm?
<tex2html_mydb_mark>#726#
$ sed -f toupper.sed sp2en.test
¡COÑO! ¿ES PLÍM EL QUE HIZO PLÚM?
<tex2html_mydb_mark>#727#
$ cat G.sed
/\;SPMlt;if\;SPMgt;/s/.*/;SPMamp;/
t
/\;SPMlt;else\;SPMgt;/s/.*/;SPMamp;/
t
#... lo mismo para las otras palabras clave
/^[a-zA-Z][a-zA-Z]*([A-Z]*/H
t
/^[a-zA-Z][a-zA-Z]*  *[a-zA-Z][a-zA-Z]*(/H
${
G
}
<tex2html_mydb_mark>#728#
$ cat p.test
#include ;SPMlt;stdio.h;SPMgt;
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
}
<tex2html_mydb_mark>#729#
$ sed -f G.sed p.test
#include ;SPMlt;stdio.h;SPMgt;
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf(;SPMquot;Hello world! factorial of 4 = %d\n;SPMquot;,fact(4)); /* the
         comment takes two lines */
}
 
fact(int n) { /* recursive function */
void toto(id) {
main() {
<tex2html_mydb_mark>#730#
;SPMgt; cat reverse.sed
$!{
:loop
h
n
G
$!b loop
}
${
p
}
<tex2html_mydb_mark>#731#
;SPMgt; cat reverse.test
one
two
three
;SPMgt; sed -n -f reverse.sed reverse.test
three
two
one
<tex2html_mydb_mark>#732#
NAME: xxx
SURNAME: xxx
TITLE: SISTEMAS
OtherTitle: 
BIRTHDAY: xxx
BIRTHMONTH: xxx
BIRTHYEAR: xxx
ADDRESSFAMILY: xxx
ADDRESSACTUAL: xxx
POSTALCODE: xxx
EMAIL: XXXXXXX@csi.ull.es
TELEPHONE: xxx
FAX: xxx
LABGROUP: xxx
COMMENTS:
<tex2html_mydb_mark>#733#
#!/bin/sed -f
/^NAME:/ {
  s/^NAME://
  h
  n
  s/^SURNAME://
  G
  s/\n/,/
  y/áéíóúabcdefghijklmnñopqrstuvwxyz/ÁÉÍÓÚABCDEFGHIJKLMNÑOPQRSTUVWXYZ/
  p
}
<tex2html_mydb_mark>#734#
$ cat multiline2.sed
#Assume the pattern is in no more than two lines
s/Owner and Operator Guide/Installation Guide/g
/Owner/{
  N
  s/ *\n/ /g
  s/Owner  *and  *Operator  *Guide/Installation Guide/g
}
<tex2html_mydb_mark>#735#
$ cat multiline.test
Dear Owner: Consult
Section 3.1 in the Owner and
Operator Guide for a description of the tape drives available for the Owner
of your system.
 
Consult Section 3.1 in the Owner and Operator
Guide for a description of the tape drives
available on your system.
 
Look in the Owner and Operator Guide, we mean the Owner
and Operator Guide shipped with your system.
 
Two manuals are provided including the Owner and
Operator Guide and the User Guide.
 
The Owner and Operator Guide is shipped with your system.
 
Look in the Owner
and Operator Guide shipped with your system.
 
The Owner
and
Operator
Guide is shipped with your system.
<tex2html_mydb_mark>#736#
$ sed -f multiline2.sed multiline.test
Dear Owner: Consult Section 3.1 in the Owner and
Operator Guide for a description of the tape drives available for the Owner
of your system.
 
Consult Section 3.1 in the Installation Guide for a description of the tape
drives
available on your system.
 
Look in the Installation Guide, we mean the Installation Guide shipped with
your system.
 
Two manuals are provided including the Installation Guide and the User Guide.
 
The Installation Guide is shipped with your system.
 
Look in the Installation Guide shipped with your system.
 
The Owner and
Operator
Guide is shipped with your system.
<tex2html_mydb_mark>#737#
$ cat multiline.sed
s/Owner and Operator Guide/Installation Guide/g
/Owner/{
:label
  N
  s/\n/ /g
  s/Owner  *and  *Operator  *Guide/Installation Guide/g
  /Owner *$/b label
  /Owner  *and *$/b label
  /Owner  *and  *Operator *$/b label
  }
<tex2html_mydb_mark>#738#
$sed -f multiline.sed multiline.test
Dear Owner: Consult Section 3.1 in the Installation Guide for \
a description of the tape drives available for the Owner  of \
your system.
 
Consult Section 3.1 in the Installation Guide for a description of the tape drives
available on your system.
 
Look in the Installation Guide, we mean the Installation Guide \
shipped with your system.
 
Two manuals are provided including the Installation Guide and the User Guide.
 
The Installation Guide is shipped with your system.
 
Look in the Installation Guide shipped with your system.
 
The Installation Guide is shipped with your system.
<tex2html_mydb_mark>#739#
#!/bin/sed -f
s/Owner and Operator Guide/Installation Guide/g
/Owner/{
:label
  N
  s/Owner\([ \n]*\)and\([ \n]*\)Operator\([ \n]*\)Guide/Installation\1\2Guide\3/g
  /Owner *$/b label
  /Owner  *and *$/b label
  /Owner  *and  *Operator *$/b label
  }
<tex2html_mydb_mark>#740#
1 ;SPMgt; cat N.sed
2 /^$/{
3 N
4 /^\n$/D
5 }
<tex2html_mydb_mark>#741#
;SPMgt; cat N.test
one empty
 
two empty lines
 
 
three empty lines
 
 
 
end of file
<tex2html_mydb_mark>#742#
;SPMgt; sed -f N.sed N.test
one empty
 
two empty lines
 
three empty lines
 
end of file
<tex2html_mydb_mark>#743#
/^$/{
N
/^\n$/d
}
<tex2html_mydb_mark>#744#
$ cat phrase
#! /bin/sh
# phrase -- search for words across two lines.
# Prints the line number
# $1 = search string; remaining args = filenames
search=$1
shift
for file
do
sed -n '
  /';SPMquot;$search;SPMquot;'/b final
  N
  h
  s/.*\n//
  /';SPMquot;$search;SPMquot;'/b final
  g
  s/ *\n//
  /';SPMquot;$search;SPMquot;'/{
    g
    b final
  }
  g
  D
:final
  =
  p
' $file
done
<tex2html_mydb_mark>#745#
$ phrase ;SPMquot;Owner and Operator Guide;SPMquot; multiline.test
3
Section 3.1 in the Owner and
Operator Guide for a description of the tape drives available for the Owner
7
Consult Section 3.1 in the Owner and Operator
Guide for a description of the tape drives
10
Look in the Owner and Operator Guide, we mean the Owner
14
Two manuals are provided including the Owner and
Operator Guide and the User Guide.
16
The Owner and Operator Guide is shipped with your system.
19
Look in the Owner
and Operator Guide shipped with your system.
<tex2html_mydb_mark>#746#
~/bin/makefichas.sed -n ~/mail/$1 | grupo.sh $2 | sort -u
<tex2html_mydb_mark>#747#
 1  #!/bin/bash
 2  search=$1
 3  sed -n '
 4  /^NAME:/ {
 5    s/^NAME://
 6    h
 7    n
 8    s/^SURNAME://
 9    G
10    s/\n/,/
11    y/ÁÉÍÓÚáéíóúabcdefghijklmnñopqrstuvxyz/AEIOUAEIOUABCDEFGHIJKLMNÑOPQRSTUVXYZ/
12   h
13 }
14 /^LABGROUP:/ {
15   y/ÁÉÍÓÚáéíóúabcdefghijklmnñopqrstuvxyz/AEIOUAEIOUABCDEFGHIJKLMNÑOPQRSTUVXYZ/
16   s/';SPMquot;$search;SPMquot;'/;SPMamp;/
17   t print
18   b 
19 :print
20   g
21   p
22 }
23 '
<tex2html_mydb_mark>#748#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/convert.pl;SPMquot;

<tex2html_mydb_mark>#749#%.2f C = %.2f F\n;SPMquot;, $celsius, $farenheit;
 
<tex2html_mydb_mark>#750#%{{{ % perl code in HTML

<tex2html_mydb_mark>#751#%.2f C = %.2f F;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synSpecial;SPMquot;;SPMgt;\n;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synConstant;SPMquot;;SPMgt;;SPMamp;quot;;SPMlt;/span;SPMgt;, ;SPMlt;span class=;SPMquot;synIdentifier;SPMquot;;SPMgt;$celsius;SPMlt;/span;SPMgt;, ;SPMlt;span class=;SPMquot;synIdentifier;SPMquot;;SPMgt;$farenheit;SPMlt;/span;SPMgt;;

<tex2html_mydb_mark>#752#%}}}

<tex2html_mydb_mark>#753#%{{{ % raw html perldeb

<tex2html_mydb_mark>#754#%}}}

<tex2html_mydb_mark>#755#%{{{ % perl code in HTML

<tex2html_mydb_mark>#756#%}}}

<tex2html_mydb_mark>#757#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/escapes.pl;SPMquot;

<tex2html_mydb_mark>#758#%{{{ % raw html perldeb

<tex2html_mydb_mark>#759#%}}}

<tex2html_mydb_mark>#760#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/smodifier.pl;SPMquot;

<tex2html_mydb_mark>#761#%{{{ % perl code in HTML

<tex2html_mydb_mark>#762#%}}}

<tex2html_mydb_mark>#763#%.2f C = %.2f F\n;SPMquot;, $celsius, $fahrenheit;

<tex2html_mydb_mark>#764#%{{{ % perl code in HTML

<tex2html_mydb_mark>#765#%.2f C = %.2f F;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synSpecial;SPMquot;;SPMgt;\n;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synConstant;SPMquot;;SPMgt;;SPMamp;quot;;SPMlt;/span;SPMgt;, ;SPMlt;span class=;SPMquot;synIdentifier;SPMquot;;SPMgt;$celsius;SPMlt;/span;SPMgt;, ;SPMlt;span class=;SPMquot;synIdentifier;SPMquot;;SPMgt;$fahrenheit;SPMlt;/span;SPMgt;;

<tex2html_mydb_mark>#766#%}}}

<tex2html_mydb_mark>#767#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/mygrep.pl;SPMquot;

<tex2html_mydb_mark>#768#%{{{ % raw html perldeb

<tex2html_mydb_mark>#769#%}}}

<tex2html_mydb_mark>#770#%{{{ % perl code in HTML

<tex2html_mydb_mark>#771#%}}}

<tex2html_mydb_mark>#772#%{{{ % raw html perldeb

<tex2html_mydb_mark>#773#%}}}

<tex2html_mydb_mark>#774#%{{{ % perl code in HTML

<tex2html_mydb_mark>#775#%}}}

<tex2html_mydb_mark>#776#%{{{ % raw html perldeb

<tex2html_mydb_mark>#777#%}}}

<tex2html_mydb_mark>#778#%+| hash.

<tex2html_mydb_mark>#779#%+| 

<tex2html_mydb_mark>#780#%.2f C = %.2f F\n;SPMquot;, $celsius, $farenheit;

<tex2html_mydb_mark>#781#%+) {

<tex2html_mydb_mark>#782#%+) {

<tex2html_mydb_mark>#783#%.2f C = %.2f F\n;SPMquot;, $celsius, $farenheit;

<tex2html_mydb_mark>#784#%\item

<tex2html_mydb_mark>#785#%\htmladdnormallink

<tex2html_mydb_mark>#786#%{Rafael García Suárez: Smart matching in detail}

<tex2html_mydb_mark>#787#%{http://search.cpan.org/~rgarcia/perl-5.10.0/pod/perlsyn.pod#Smart_matching_in_detail}

<tex2html_mydb_mark>#788#%RE|.

<tex2html_mydb_mark>#789#%-ing word}.;SPMquot;\n;SPMquot;  if /$RE{profanity}/;
    
<tex2html_mydb_mark>#790#%-ing word

<tex2html_mydb_mark>#791#%RE| is treated as a hierarchical hash of

<tex2html_mydb_mark>#792#%Sigue un ejemplo de ejecución:

<tex2html_mydb_mark>#793#%

<tex2html_mydb_mark>#794#%\begin{verbatim}

<tex2html_mydb_mark>#795#%casiano@millo:~/Lperltesting$ env | grep -i perl

<tex2html_mydb_mark>#796#%MANPATH=:/soft/perl5lib/man/

<tex2html_mydb_mark>#797#%PERL5LIB=/soft/perl5lib/share/perl/5.8.8/:/soft/perl5lib/lib/perl/5.8.8:/soft/perl5lib/lib/perl/5.8:/soft/perl5lib/share/perl/5.8/

<tex2html_mydb_mark>#798#%PATH=.:/usr/lib/oracle/11.1.0.1/client/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:

<tex2html_mydb_mark>#799#%      /soft/perl5lib/bin:/soft/perl5lib/src/parrot-0.8.0/:/home/casiano/bin

<tex2html_mydb_mark>#800#%PWD=/home/casiano/Lperltesting

<tex2html_mydb_mark>#801#%casiano@millo:~/Lperltesting$ unset PERL5LIB

<tex2html_mydb_mark>#802#%casiano@millo:~/Lperltesting$ env | grep -i perl

<tex2html_mydb_mark>#803#%MANPATH=:/soft/perl5lib/man/

<tex2html_mydb_mark>#804#%PATH=.:/usr/lib/oracle/11.1.0.1/client/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:...:/soft/perl5lib/src/parrot-0.8.0/

<tex2html_mydb_mark>#805#%PWD=/home/casiano/Lperltesting

<tex2html_mydb_mark>#806#%casiano@millo:~/Lperltesting$ ./c2f_5_10v3.pl

<tex2html_mydb_mark>#807#%Can't locate Regexp/Common.pm in @INC (@INC contains: /soft/perl5lib/perl5_10_1/lib/5.10.1/i686-linux-thread-multi 

<tex2html_mydb_mark>#808#%                                                      /soft/perl5lib/perl5_10_1/lib/5.10.1 

<tex2html_mydb_mark>#809#%                                                      /soft/perl5lib/perl5_10_1/lib/site_perl/5.10.1/i686-linux-thread-multi 

<tex2html_mydb_mark>#810#%                                                      /soft/perl5lib/perl5_10_1/lib/site_perl/5.10.1 .) 

<tex2html_mydb_mark>#811#%at ./c2f_5_10v3.pl line 3.

<tex2html_mydb_mark>#812#%BEGIN failed--compilation aborted at ./c2f_5_10v3.pl line 3.

<tex2html_mydb_mark>#813#%\end{verbatim}

<tex2html_mydb_mark>#814#%

<tex2html_mydb_mark>#815#%Reutilicemos la versión de la librería instalada para la 5.8.8:

<tex2html_mydb_mark>#816#%

<tex2html_mydb_mark>#817#%\begin{verbatim}

<tex2html_mydb_mark>#818#%casiano@millo:~/Lperltesting$ export PERL5LIB=/soft/perl5lib/share/perl/5.8.8/:/soft/perl5lib/lib/perl/5.8.8:...

<tex2html_mydb_mark>#819#%casiano@millo:~/Lperltesting$ perldoc -l Regexp::Common

<tex2html_mydb_mark>#820#%/soft/perl5lib/share/perl/5.8.8/Regexp/Common.pm

<tex2html_mydb_mark>#821#%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl

<tex2html_mydb_mark>#822#%Enter a temperature (i.e. 32F, 100C):

<tex2html_mydb_mark>#823#%-32.0e-1f

<tex2html_mydb_mark>#824#%-19.56 C = -3.20 F

<tex2html_mydb_mark>#825#%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl

<tex2html_mydb_mark>#826#%Enter a temperature (i.e. 32F, 100C):

<tex2html_mydb_mark>#827#%-0.0e-0c

<tex2html_mydb_mark>#828#%-0.00 C = 32.00 F

<tex2html_mydb_mark>#829#%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl

<tex2html_mydb_mark>#830#%Enter a temperature (i.e. 32F, 100C):

<tex2html_mydb_mark>#831#%45

<tex2html_mydb_mark>#832#%Expecting a temperature, so don't understand ;SPMquot;45;SPMquot;.

<tex2html_mydb_mark>#833#%\end{verbatim}

<tex2html_mydb_mark>#834#%En general, no es buena idea mezclar librerías de diferentes instalaciones.

<tex2html_mydb_mark>#835#%colour = ( sky   =;SPMgt; 'blue', grass =;SPMgt; 'green', apple =;SPMgt; 'red',)
  
<tex2html_mydb_mark>#836#%colour

<tex2html_mydb_mark>#837#%colour
  
<tex2html_mydb_mark>#838#%colour ~~ /^gr/

<tex2html_mydb_mark>#839#%colour ~~ /^clou/
  
<tex2html_mydb_mark>#840#%taste ~~ %colour;

<tex2html_mydb_mark>#841#%$a
 
<tex2html_mydb_mark>#842#%$b
 
<tex2html_mydb_mark>#843#%$a
 
<tex2html_mydb_mark>#844#%-12s ;SPMquot;, $pat;
 
<tex2html_mydb_mark>#845#%{{{ % perl code in HTML

<tex2html_mydb_mark>#846#%-12s ;SPMamp;quot;, ;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synIdentifier;SPMquot;;SPMgt;$pat;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synConstant;SPMquot;;SPMgt;;;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#847#%}}}

<tex2html_mydb_mark>#848#%\begin{tabular}{l|l}

<tex2html_mydb_mark>#849#%C\'{o}digo    ;SPMamp; Significado \\ 

<tex2html_mydb_mark>#850#%\hline

<tex2html_mydb_mark>#851#%\verb|\d| ;SPMamp; \verb|[0-9]|\\ 

<tex2html_mydb_mark>#852#%\verb|\D| ;SPMamp; \verb|[^0-9]|\\ 

<tex2html_mydb_mark>#853#%\verb|\w| ;SPMamp; \verb|[a-zA-Z0-9_]|\\ 

<tex2html_mydb_mark>#854#%\verb|\W| ;SPMamp; \verb|[^a-zA-Z0-9_]|\\ 

<tex2html_mydb_mark>#855#%\verb|\s| ;SPMamp; \verb|[ \t\n\r\f]|\\ 

<tex2html_mydb_mark>#856#%\verb|\S| ;SPMamp; \verb|[^ \t\n\r\f]|\\ 

<tex2html_mydb_mark>#857#%\end{tabular}

<tex2html_mydb_mark>#858#%]

<tex2html_mydb_mark>#859#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/matchvariables.pl;SPMquot;

<tex2html_mydb_mark>#860#%\pd{perlfaq6}{Why-does-using-\$\&,-\$`,-or-\$'-slow-my-program-down?}

<tex2html_mydb_mark>#861#%\htmladdnormallink

<tex2html_mydb_mark>#862#%{perlfaq6}

<tex2html_mydb_mark>#863#%{http://search.cpan.org/~dapm/perl-5.10.1-RC2/pod/perlfaq6.pod}:

<tex2html_mydb_mark>#864#%\begin{exercise}

<tex2html_mydb_mark>#865#%Estudie el siguiente programa:

<tex2html_mydb_mark>#866#%\begin{verbatim}

<tex2html_mydb_mark>#867#%pl@nereida:~/Lperltesting$ cat -n orton_mod1.pl

<tex2html_mydb_mark>#868#% 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1

<tex2html_mydb_mark>#869#% 2  use v5.10;

<tex2html_mydb_mark>#870#% 3  use re 'debug';

<tex2html_mydb_mark>#871#% 4

<tex2html_mydb_mark>#872#% 5  my $input;

<tex2html_mydb_mark>#873#% 6

<tex2html_mydb_mark>#874#% 7  local $;SPMquot; = ;SPMquot;, ;SPMquot;;

<tex2html_mydb_mark>#875#% 8

<tex2html_mydb_mark>#876#% 9  $parser = qr/(?;SPMlt;foo;SPMgt;foo)((?;SPMamp;foo))/;

<tex2html_mydb_mark>#877#%10  $input = ;SPMlt;;SPMgt;;

<tex2html_mydb_mark>#878#%11  chomp($input);

<tex2html_mydb_mark>#879#%12  if ($input =~ $parser) {

<tex2html_mydb_mark>#880#%13    say ;SPMquot;matches: ;SPMamp; = ($;SPMamp;) 1 = ($1) 2 = ($2);SPMquot;;

<tex2html_mydb_mark>#881#%14    say ;SPMquot;At the very end:\n\@- = (@-)\t ;SPMquot;.scalar(@-)

<tex2html_mydb_mark>#882#%15        .;SPMquot; items\t\$#- = $#-\n\@+ = (@+)\t ;SPMquot;.scalar(@+)

<tex2html_mydb_mark>#883#%16        .;SPMquot; items\t\$#+ = $#+ \n;SPMquot;;

<tex2html_mydb_mark>#884#%17  }

<tex2html_mydb_mark>#885#%18  __END__

<tex2html_mydb_mark>#886#%\end{verbatim}

<tex2html_mydb_mark>#887#%Explique el resultado de la ejecución del programa cuando 

<tex2html_mydb_mark>#888#%recibe la entrada \verb|foofoo|?

<tex2html_mydb_mark>#889#%\begin{verbatim}

<tex2html_mydb_mark>#890#%pl@nereida:~/Lperltesting$ ./orton_mod1.pl

<tex2html_mydb_mark>#891#%Compiling REx ;SPMquot;(?;SPMlt;foo;SPMgt;foo)((?;SPMamp;foo));SPMquot;

<tex2html_mydb_mark>#892#%Final program:

<tex2html_mydb_mark>#893#%   1: OPEN1 'foo' (3)

<tex2html_mydb_mark>#894#%   3:   EXACT ;SPMlt;foo;SPMgt; (5)

<tex2html_mydb_mark>#895#%   5: CLOSE1 'foo' (7)

<tex2html_mydb_mark>#896#%   7: OPEN2 (9)

<tex2html_mydb_mark>#897#%   9:   GOSUB1[-8] (12)

<tex2html_mydb_mark>#898#%  12: CLOSE2 (14)

<tex2html_mydb_mark>#899#%  14: END (0)

<tex2html_mydb_mark>#900#%anchored ;SPMquot;foofoo;SPMquot; at 0 (checking anchored) minlen 6

<tex2html_mydb_mark>#901#%foofoo

<tex2html_mydb_mark>#902#%Guessing start of match in sv for REx ;SPMquot;(?;SPMlt;foo;SPMgt;foo)((?;SPMamp;foo));SPMquot; against ;SPMquot;foofoo;SPMquot;

<tex2html_mydb_mark>#903#%Found anchored substr ;SPMquot;foofoo;SPMquot; at offset 0...

<tex2html_mydb_mark>#904#%Guessed: match at offset 0

<tex2html_mydb_mark>#905#%Matching REx ;SPMquot;(?;SPMlt;foo;SPMgt;foo)((?;SPMamp;foo));SPMquot; against ;SPMquot;foofoo;SPMquot;

<tex2html_mydb_mark>#906#%   0 ;SPMlt;;SPMgt; ;SPMlt;foofoo;SPMgt;             |  1:OPEN1 'foo'(3)

<tex2html_mydb_mark>#907#%   0 ;SPMlt;;SPMgt; ;SPMlt;foofoo;SPMgt;             |  3:EXACT ;SPMlt;foo;SPMgt;(5)

<tex2html_mydb_mark>#908#%   3 ;SPMlt;foo;SPMgt; ;SPMlt;foo;SPMgt;             |  5:CLOSE1 'foo'(7)

<tex2html_mydb_mark>#909#%   3 ;SPMlt;foo;SPMgt; ;SPMlt;foo;SPMgt;             |  7:OPEN2(9)

<tex2html_mydb_mark>#910#%   3 ;SPMlt;foo;SPMgt; ;SPMlt;foo;SPMgt;             |  9:GOSUB1[-8](12)

<tex2html_mydb_mark>#911#%   3 ;SPMlt;foo;SPMgt; ;SPMlt;foo;SPMgt;             |  1:  OPEN1 'foo'(3)

<tex2html_mydb_mark>#912#%   3 ;SPMlt;foo;SPMgt; ;SPMlt;foo;SPMgt;             |  3:  EXACT ;SPMlt;foo;SPMgt;(5)

<tex2html_mydb_mark>#913#%   6 ;SPMlt;foofoo;SPMgt; ;SPMlt;;SPMgt;             |  5:  CLOSE1 'foo'(7)

<tex2html_mydb_mark>#914#%                                    EVAL trying tail ... 0

<tex2html_mydb_mark>#915#%   6 ;SPMlt;foofoo;SPMgt; ;SPMlt;;SPMgt;             | 12:    CLOSE2(14)

<tex2html_mydb_mark>#916#%   6 ;SPMlt;foofoo;SPMgt; ;SPMlt;;SPMgt;             | 14:    END(0)

<tex2html_mydb_mark>#917#%Match successful!

<tex2html_mydb_mark>#918#%matches: ;SPMamp; = (foofoo) 1 = (foo) 2 = (foo)

<tex2html_mydb_mark>#919#%At the very end:

<tex2html_mydb_mark>#920#%@- = (0, 0, 3)   3 items        $#- = 2

<tex2html_mydb_mark>#921#%@+ = (6, 3, 6)   3 items        $#+ = 2

<tex2html_mydb_mark>#922#%

<tex2html_mydb_mark>#923#%Freeing REx: ;SPMquot;(?;SPMlt;foo;SPMgt;foo)((?;SPMamp;foo));SPMquot;

<tex2html_mydb_mark>#924#%\end{verbatim}

<tex2html_mydb_mark>#925#%\end{exercise}

<tex2html_mydb_mark>#926#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/glist.pl;SPMquot;

<tex2html_mydb_mark>#927#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/gscalar.pl;SPMquot;

<tex2html_mydb_mark>#928#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/replacement.pl;SPMquot;

<tex2html_mydb_mark>#929#%5d;SPMquot;,$;SPMamp;)/e;
   
<tex2html_mydb_mark>#930#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/enested.pl;SPMquot;

<tex2html_mydb_mark>#931#%{{{ % perl code in HTML

<tex2html_mydb_mark>#932#%}}}

<tex2html_mydb_mark>#933#%{{{ % perl code in HTML

<tex2html_mydb_mark>#934#%}}}

<tex2html_mydb_mark>#935#%{{{ % raw html perldeb

<tex2html_mydb_mark>#936#%}}}

<tex2html_mydb_mark>#937#%0\begin{verbatim}

<tex2html_mydb_mark>#938#%0casiano@millo:~$ perl5.10.1 -wdE 0

<tex2html_mydb_mark>#939#%0main::(-e:1):   0

<tex2html_mydb_mark>#940#%0  DB;SPMlt;1;SPMgt; ($a = 'bar foo foobar bar barfoo bar baz') =~ s/foo\K/,/g

<tex2html_mydb_mark>#941#%0  DB;SPMlt;2;SPMgt; p $a

<tex2html_mydb_mark>#942#%0bar foo, foo,bar bar barfoo, bar baz

<tex2html_mydb_mark>#943#%0\end{verbatim}

<tex2html_mydb_mark>#944#%\begin{verbatim}

<tex2html_mydb_mark>#945#%casiano@millo:~$ perl5.10.1 -wdE 0

<tex2html_mydb_mark>#946#%  DB;SPMlt;3;SPMgt; ($a = 'bar lookahead bar barlookahead bar baz') =~ s/look\K(?=ahead)/-/g

<tex2html_mydb_mark>#947#%  DB;SPMlt;4;SPMgt; p $a

<tex2html_mydb_mark>#948#%bar look-ahead bar barlook-ahead bar baz

<tex2html_mydb_mark>#949#%\end{verbatim}

<tex2html_mydb_mark>#950#%\begin{verbatim}

<tex2html_mydb_mark>#951#%/foo  # Match starting at foo

<tex2html_mydb_mark>#952#% (         # Capture

<tex2html_mydb_mark>#953#% (?:       # Complex expression:

<tex2html_mydb_mark>#954#%   (?!baz) #   make sure we're not at the beginning of baz 

<tex2html_mydb_mark>#955#%   .       #   accept any character

<tex2html_mydb_mark>#956#% )*        # any number of times

<tex2html_mydb_mark>#957#% )         # End capture

<tex2html_mydb_mark>#958#% bar  # and ending at bar

<tex2html_mydb_mark>#959#%/x;

<tex2html_mydb_mark>#960#%\end{verbatim}

<tex2html_mydb_mark>#961#%\begin{verbatim}

<tex2html_mydb_mark>#962#%  DB;SPMlt;13;SPMgt; x 'abc' =~ /(?=(.)(.)(.))a(b)/

<tex2html_mydb_mark>#963#%0  'a'

<tex2html_mydb_mark>#964#%1  'b'

<tex2html_mydb_mark>#965#%2  'c'

<tex2html_mydb_mark>#966#%3  'b'

<tex2html_mydb_mark>#967#%\end{verbatim}

<tex2html_mydb_mark>#968#%\begin{verbatim}

<tex2html_mydb_mark>#969#%  DB;SPMlt;1;SPMgt; $a = 'ab,cd,e,02,34,56,ef,273,457,c'

<tex2html_mydb_mark>#970#%  DB;SPMlt;4;SPMgt; ($b = $a) =~ s{(?;SPMlt;!\d),|,(?!\d)}{, }g

<tex2html_mydb_mark>#971#%  DB;SPMlt;5;SPMgt; p $b

<tex2html_mydb_mark>#972#%ab, cd, e, 02,34,56, ef, 273,457, c

<tex2html_mydb_mark>#973#%  DB;SPMlt;6;SPMgt; $a = 'ab,cd,e,02,34,56,ef,273,457,c,'

<tex2html_mydb_mark>#974#%  DB;SPMlt;7;SPMgt; ($b = $a) =~ s{(?;SPMlt;!\d),|,(?!\d)}{, }g

<tex2html_mydb_mark>#975#%  DB;SPMlt;9;SPMgt; p ;SPMquot;;SPMlt;$b;SPMgt;;SPMquot;

<tex2html_mydb_mark>#976#%;SPMlt;ab, cd, e, 02,34,56, ef, 273,457, c, ;SPMgt;

<tex2html_mydb_mark>#977#%  DB;SPMlt;10;SPMgt; $a = ',ab,cd,e,02,34,56,ef,273,457,c,'

<tex2html_mydb_mark>#978#%  DB;SPMlt;11;SPMgt; ($b = $a) =~ s{(?;SPMlt;!\d),|,(?!\d)}{, }g

<tex2html_mydb_mark>#979#%  DB;SPMlt;12;SPMgt; p ;SPMquot;;SPMlt;$b;SPMgt;;SPMquot;

<tex2html_mydb_mark>#980#%;SPMlt;, ab, cd, e, 02,34,56, ef, 273,457, c, ;SPMgt;

<tex2html_mydb_mark>#981#%  DB;SPMlt;13;SPMgt;

<tex2html_mydb_mark>#982#%\end{verbatim}

<tex2html_mydb_mark>#983#%\begin{verbatim}

<tex2html_mydb_mark>#984#%  DB;SPMlt;25;SPMgt; p $a

<tex2html_mydb_mark>#985#%,ab, cd, e,02,34,56,ef,273,457,c,

<tex2html_mydb_mark>#986#%  DB;SPMlt;24;SPMgt; ($b = $a) =~ s{(?;SPMlt;!\d),(?!\s)|,(?!\s)(?!\d)}{, }g

<tex2html_mydb_mark>#987#%  DB;SPMlt;26;SPMgt; p $b

<tex2html_mydb_mark>#988#%, ab, cd, e, 02,34,56, ef, 273,457, c,

<tex2html_mydb_mark>#989#%\end{verbatim}

<tex2html_mydb_mark>#990#%\begin{verbatim}

<tex2html_mydb_mark>#991#%  DB;SPMlt;32;SPMgt; $a = ',ab, cd, e,02,34,56,ef,273,457,c,'

<tex2html_mydb_mark>#992#%  DB;SPMlt;33;SPMgt; ($b = $a) =~ s{(?!\d,\d)(.,)(?!\s)}{$1 }g

<tex2html_mydb_mark>#993#%  DB;SPMlt;34;SPMgt; p $b

<tex2html_mydb_mark>#994#%,ab, cd, e, 02,34,56, ef, 273,457, c,

<tex2html_mydb_mark>#995#%\end{verbatim}

<tex2html_mydb_mark>#996#%Con 5.10

<tex2html_mydb_mark>#997#%\begin{verbatim}

<tex2html_mydb_mark>#998#%;SPMgt;;SPMgt; $a = ',ab, cd, e,02,34,56,ef,273,457,c,'

<tex2html_mydb_mark>#999#%;SPMgt;;SPMgt; #save deb

<tex2html_mydb_mark>#1000#%  DB;SPMlt;6;SPMgt; ($b = $a) =~ s{(?!\d,\d)(.,\K)(?!\s)}{ }g

<tex2html_mydb_mark>#1001#%  DB;SPMlt;7;SPMgt; p $b

<tex2html_mydb_mark>#1002#%,ab, cd, e, 02,34,56, ef, 273,457, c,

<tex2html_mydb_mark>#1003#%\end{verbatim}

<tex2html_mydb_mark>#1004#%Abigail http://www.perlmonks.org/?node_id=319742

<tex2html_mydb_mark>#1005#%\begin{verbatim}

<tex2html_mydb_mark>#1006#%  DB;SPMlt;40;SPMgt; p $a

<tex2html_mydb_mark>#1007#%,ab, cd, e,02,34,56,ef,273,457,c,

<tex2html_mydb_mark>#1008#%  DB;SPMlt;41;SPMgt; ($b = $a) =~ s{(\d,\d)|(,(?!\s))}{$1 || ;SPMquot;$2 ;SPMquot;}ge

<tex2html_mydb_mark>#1009#%  DB;SPMlt;42;SPMgt; p $b

<tex2html_mydb_mark>#1010#%, ab, cd, e, 02,34,56, ef, 273,457, c,

<tex2html_mydb_mark>#1011#%\end{verbatim}

<tex2html_mydb_mark>#1012#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1013#%}}}

<tex2html_mydb_mark>#1014#%\begin{verbatim}

<tex2html_mydb_mark>#1015#%pl@nereida:~/Lperltesting$ perl ABC123.pl

<tex2html_mydb_mark>#1016#%1: 'ABC123' =~ /^(ABC)(?!123)/ :

<tex2html_mydb_mark>#1017#% NO

<tex2html_mydb_mark>#1018#%2: 'ABC445' =~ /^(ABC)(?!123)/ :

<tex2html_mydb_mark>#1019#% YES (ABC)

<tex2html_mydb_mark>#1020#%3: 'ABC123' =~ /^(\D*)(?!123)/ :

<tex2html_mydb_mark>#1021#% YES (AB)

<tex2html_mydb_mark>#1022#%4: 'ABC445' =~ /^(\D*)(?!123)/ :

<tex2html_mydb_mark>#1023#% YES (ABC)

<tex2html_mydb_mark>#1024#%\end{verbatim}

<tex2html_mydb_mark>#1025#%+|

<tex2html_mydb_mark>#1026#%-|. Con respecto a el hash \verb|%+|:

<tex2html_mydb_mark>#1027#%LAST_PAREN_MATCH|, \verb|%+|

<tex2html_mydb_mark>#1028#%+| hash allows access to the named capture buffers,

<tex2html_mydb_mark>#1029#%+| hash list only the names of buffers that have

<tex2html_mydb_mark>#1030#%+| is provided by the \cpan{Tie::Hash::NamedCapture} 

<tex2html_mydb_mark>#1031#%-| and \verb|%+| are tied views into a common internal

<tex2html_mydb_mark>#1032#%-|

<tex2html_mydb_mark>#1033#%+| , this variable allows access to the named capture

<tex2html_mydb_mark>#1034#%-) {
   
<tex2html_mydb_mark>#1035#%-| hash correspond to all buffer names found in

<tex2html_mydb_mark>#1036#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1037#%}}}

<tex2html_mydb_mark>#1038#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1039#%}}}

<tex2html_mydb_mark>#1040#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1041#%}}}

<tex2html_mydb_mark>#1042#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1043#%}}}

<tex2html_mydb_mark>#1044#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1045#%}}}

<tex2html_mydb_mark>#1046#%#_{}~^\s,]+
 
<tex2html_mydb_mark>#1047#%#_{}~^\s]+)
 
<tex2html_mydb_mark>#1048#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1049#%#_{}~^;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synSpecial;SPMquot;;SPMgt;\s;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synConstant;SPMquot;;SPMgt;,]+;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#1050#%#_{}~^;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synSpecial;SPMquot;;SPMgt;\s;SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synConstant;SPMquot;;SPMgt;]+);SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#1051#%}}}

<tex2html_mydb_mark>#1052#% end footnote

<tex2html_mydb_mark>#1053#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1054#%}}}

<tex2html_mydb_mark>#1055#%{{{ simpleexpressions.pl

<tex2html_mydb_mark>#1056#%}}}

<tex2html_mydb_mark>#1057#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1058#%}}}

<tex2html_mydb_mark>#1059#%\subsection{Grupos de Captura de Enumeración en Alternativas}

<tex2html_mydb_mark>#1060#%

<tex2html_mydb_mark>#1061#%El siguiente texto tomado de la sección 

<tex2html_mydb_mark>#1062#%Alternative capture group numbering

<tex2html_mydb_mark>#1063#%de

<tex2html_mydb_mark>#1064#%\pd{perlretut}{Alternative-capture-group-numbering}

<tex2html_mydb_mark>#1065#%explica el propósito de esta extensión:

<tex2html_mydb_mark>#1066#%

<tex2html_mydb_mark>#1067#%\begin{it}

<tex2html_mydb_mark>#1068#%\begin{quotation}

<tex2html_mydb_mark>#1069#%Yet another capturing group numbering technique (also as from Perl

<tex2html_mydb_mark>#1070#%5.10) deals with the problem of referring to groups within a set of

<tex2html_mydb_mark>#1071#%alternatives. Consider a pattern for matching a time of the day, civil

<tex2html_mydb_mark>#1072#%or military style:

<tex2html_mydb_mark>#1073#%

<tex2html_mydb_mark>#1074#%\begin{verbatim}

<tex2html_mydb_mark>#1075#%   1. if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){

<tex2html_mydb_mark>#1076#%   2. # process hour and minute

<tex2html_mydb_mark>#1077#%   3. }

<tex2html_mydb_mark>#1078#%\end{verbatim}

<tex2html_mydb_mark>#1079#%

<tex2html_mydb_mark>#1080#%Processing the results requires an additional if statement to determine

<tex2html_mydb_mark>#1081#%whether \verb|$1| and \verb|$2| or \verb|$3| and \verb|$4| contain the goodies. It would be easier if

<tex2html_mydb_mark>#1082#%we could use buffer numbers 1 and 2 in second alternative as well, and

<tex2html_mydb_mark>#1083#%this is exactly what the parenthesized construct \verb#(?|...)#, set around an

<tex2html_mydb_mark>#1084#%alternative achieves. Here is an extended version of the previous pattern:

<tex2html_mydb_mark>#1085#%

<tex2html_mydb_mark>#1086#%\begin{verbatim}

<tex2html_mydb_mark>#1087#%   1. if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){

<tex2html_mydb_mark>#1088#%   2. print ;SPMquot;hour=$1 minute=$2 zone=$3\n;SPMquot;;

<tex2html_mydb_mark>#1089#%   3. }

<tex2html_mydb_mark>#1090#%\end{verbatim}

<tex2html_mydb_mark>#1091#%

<tex2html_mydb_mark>#1092#%Within the alternative numbering group, buffer numbers start at the same

<tex2html_mydb_mark>#1093#%position for each alternative. After the group, numbering continues with

<tex2html_mydb_mark>#1094#%one higher than the maximum reached across all the alternatives.

<tex2html_mydb_mark>#1095#%\end{quotation}

<tex2html_mydb_mark>#1096#%\end{it}

<tex2html_mydb_mark>#1097#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1098#%}}}

<tex2html_mydb_mark>#1099#%+;
 
<tex2html_mydb_mark>#1100#%+;
 
<tex2html_mydb_mark>#1101#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1102#%+;;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#1103#%+;;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#1104#%}}}

<tex2html_mydb_mark>#1105#%+;
 
<tex2html_mydb_mark>#1106#%+;
 
<tex2html_mydb_mark>#1107#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1108#%+;;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#1109#%+;;SPMlt;/span;SPMgt;

<tex2html_mydb_mark>#1110#%}}}

<tex2html_mydb_mark>#1111#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<tex2html_mydb_mark>#1112#%%{{{

<tex2html_mydb_mark>#1113#%%}}}

<tex2html_mydb_mark>#1114#%%{{{

<tex2html_mydb_mark>#1115#%%}}}

<tex2html_mydb_mark>#1116#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1117#%}}}

<tex2html_mydb_mark>#1118#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1119#%}}}

<tex2html_mydb_mark>#1120#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1121#%}}}

<tex2html_mydb_mark>#1122#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1123#%}}}

<tex2html_mydb_mark>#1124#%The lookbehind condition allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,

<tex2html_mydb_mark>#1125#%

<tex2html_mydb_mark>#1126#%    /[ATGC]+(?(?;SPMlt;=AA)G|C)$/;

<tex2html_mydb_mark>#1127#%

<tex2html_mydb_mark>#1128#%matches a DNA sequence such that it either ends in AAG, or some other base pair combination and C. Note that the form is (?(?;SPMlt;=AA)G|C) and not (?((?;SPMlt;=AA))G|C); for the lookahead, lookbehind or code assertions, the parentheses around the conditional are not needed.

<tex2html_mydb_mark>#1129#%

<tex2html_mydb_mark>#1130#%%{{{

<tex2html_mydb_mark>#1131#%%}}}

<tex2html_mydb_mark>#1132#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1133#%}}}

<tex2html_mydb_mark>#1134#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1135#%}}}

<tex2html_mydb_mark>#1136#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1137#%}}}

<tex2html_mydb_mark>#1138#%count = ();
     
<tex2html_mydb_mark>#1139#%s' =;SPMgt; %3d\n;SPMquot;, $_, $count{$_})  for (sort keys %count);

<tex2html_mydb_mark>#1140#% section unicode

<tex2html_mydb_mark>#1141#
grep 'cierre$\|^Las' viq.tex
<tex2html_mydb_mark>#1142#
nereida:~/viq;SPMgt; grep 'cierre$\|^Las' viq.tex
Las expresiones regulares facilitadas por las primeras versiones de estas herramientas
eran limitadas. Por ejemplo, se disponía del cierre de Kleene \verb|*| pero no del cierre
nereida:~/viq;SPMgt;
<tex2html_mydb_mark>#1143#
<pre>
pl@nereida:~/Lperltesting$ cat -n c2f.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">print</span> <span class="synConstant">;SPMquot;Enter a temperature (i.e. 32F, 100C):</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = <span class="synIdentifier">;SPMlt;STDIN;SPMgt;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> !~ <span class="synStatement">m/</span><span class="synConstant">^</span><span class="synSpecial">([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])</span><span class="synConstant">$</span><span class="synStatement">/i</span>) {
<span class="synLinenum">    9</span>     <span class="synStatement">warn</span> <span class="synConstant">;SPMquot;Expecting a temperature, so don't understand </span><span class="synSpecial">\;SPMquot;</span><span class="synIdentifier">$input</span><span class="synSpecial">\;SPMquot;</span><span class="synConstant">.</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   12</span>     <span class="synStatement">my</span> <span class="synIdentifier">$InputNum</span> = <span class="synIdentifier">$1</span>;
<span class="synLinenum">   13</span>     <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$3</span>;
<span class="synLinenum">   14</span>     <span class="synStatement">my</span> (<span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$farenheit</span>);
<span class="synLinenum">   15</span>     <span class="synStatement">if</span> (<span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">;SPMquot;C;SPMquot;</span> <span class="synStatement">or</span> <span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">;SPMquot;c;SPMquot;</span>) {
<span class="synLinenum">   16</span>       <span class="synIdentifier">$celsius</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   17</span>       <span class="synIdentifier">$farenheit</span> = (<span class="synIdentifier">$celsius</span> * <span class="synConstant">9</span>/<span class="synConstant">5</span>)<span class="synConstant">+32</span>;
<span class="synLinenum">   18</span>     }
<span class="synLinenum">   19</span>     <span class="synStatement">else</span> {
<span class="synLinenum">   20</span>       <span class="synIdentifier">$farenheit</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   21</span>       <span class="synIdentifier">$celsius</span> = (<span class="synIdentifier">$farenheit</span> <span class="synConstant">-32</span>)*<span class="synConstant">5</span>/<span class="synConstant">9</span>;
<span class="synLinenum">   22</span>     }
<span class="synLinenum">   23</span>     <span class="synStatement">printf</span> <span class="synConstant">;SPMquot;%.2f C = %.2f F</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>, <span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$farenheit</span>;
<span class="synLinenum">   24</span>   }
</pre>
<tex2html_mydb_mark>#1144#
<pre>
pl@nereida:~/Lperltesting$  <span  class="dbuser">perl -wd c2f.pl</span>
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h' for help, or `man perldebug' for more help.
main::(c2f.pl:4):       print "Enter a temperature (i.e. 32F, 100C):\n";
DB<1>  <span  class="dbuser">c 8</span>
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB<2>  <span  class="dbuser">n</span>
main::(c2f.pl:12):        my $InputNum = $1;
DB<2>  <span  class="dbuser">x ($1, $2, $3)</span>
0  32
1  undef
2  'F'
DB<3>  <span  class="dbuser">use YAPE::Regex::Explain</span>
DB<4>  <span  class="dbuser">p YAPE::Regex::Explain->new('([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$')->explain</span>
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: '-', '+' (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: '0' to '9' (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       '.'
----------------------------------------------------------------------
      [0-9]*                   any character of: '0' to '9' (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you're using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and " ") (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: 'C', 'F'
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------
</pre>
<tex2html_mydb_mark>#1145#
<pre>
pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$a</span> = <span class="synConstant">;SPMquot;hola juanito;SPMquot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$b</span> = <span class="synConstant">;SPMquot;adios anita;SPMquot;</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synIdentifier">$a</span> =~<span class="synStatement"> /</span><span class="synSpecial">(</span><span class="synConstant">ani</span><span class="synSpecial">)</span><span class="synStatement">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$b</span> =~ <span class="synStatement">s/</span><span class="synSpecial">(</span><span class="synConstant">adios</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">*(</span><span class="synIdentifier">$1</span><span class="synSpecial">)</span><span class="synStatement">/</span><span class="synSpecial">\U</span><span class="synIdentifier">$1</span><span class="synConstant"> </span><span class="synIdentifier">$2</span><span class="synStatement">/</span>;
<span class="synLinenum">    9</span>   <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$b</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
</pre>
<tex2html_mydb_mark>#1146#
pl@nereida:~/Lperltesting$ ./dollar1slash1.pl
ADIOS ANIta
<tex2html_mydb_mark>#1147#
$b =~ s/(adios) *(\1)/\U$1 $2/;
<tex2html_mydb_mark>#1148#
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
            123456789ABCDEF
DB;SPMlt;1;SPMgt; $x = ;SPMquot;123456789AAAAAA;SPMquot;
                   1  2  3  4  5  6  7  8  9 10 11  12
DB;SPMlt;2;SPMgt; $r = $x =~ /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/; print ;SPMquot;$r\n$10\n$11\n;SPMquot;
1
A
A
<tex2html_mydb_mark>#1149#
pl@nereida:~/src/perl/perltesting$ cat -n escapes.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $foo = ;SPMquot;one two three four five\nsix seven;SPMquot;;
     5  my ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/);
     6  print ;SPMquot;List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n;SPMquot;;
     7
     8  # This is 'almost' the same than:
     9  ($F1, $F2, $Etc) = split(/\s+/, $foo, 3);
    10  print ;SPMquot;Split: F1 = $F1, F2 = $F2, Etc = $Etc\n;SPMquot;;
<tex2html_mydb_mark>#1150#
pl@nereida:~/src/perl/perltesting$ ./escapes.pl
List Context: F1 = one, F2 = two, Etc = three four five
Split: F1 = one, F2 = two, Etc = three four five
six seven
<tex2html_mydb_mark>#1151#
<pre>
pl@nereida:~/src/perl/perltesting$  <span  class="dbuser">perl -wd ./escapes.pl</span>
main::(./escapes.pl:4): my $foo = "one two three four five\nsix seven";
DB<1>  <span  class="dbuser">c 9</span>
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(' ',$foo, 3);
DB<2>  <span  class="dbuser">($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)</span>
DB<3>  <span  class="dbuser">p "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n"</span>
List Context: F1 = one, F2 = two, Etc = three four five
six seven
</pre>
<tex2html_mydb_mark>#1152#
<pre>
<span class="synLinenum">    1</span>  <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>  <span class="synComment">#use: </span>
<span class="synLinenum">    3</span>  <span class="synComment">#smodifier.pl 'expr' files</span>
<span class="synLinenum">    4</span>  <span class="synComment">#prints the names of the files that match with the give expr</span>
<span class="synLinenum">    5</span>  <span class="synStatement">undef</span> <span class="synIdentifier">$/</span>; <span class="synComment"># input record separator</span>
<span class="synLinenum">    6</span>  <span class="synStatement">my</span> <span class="synIdentifier">$what</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span>;
<span class="synLinenum">    7</span>  <span class="synStatement">while</span>(<span class="synStatement">my</span> <span class="synIdentifier">$file</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span>) {
<span class="synLinenum">    8</span>    <span class="synStatement">open</span>(<span class="synIdentifier">FILE</span>, <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$file</span><span class="synConstant">;SPMquot;</span>);
<span class="synLinenum">    9</span>    <span class="synIdentifier">$line</span> =  <span class="synIdentifier">;SPMlt;FILE;SPMgt;</span>;
<span class="synLinenum">   10</span>    <span class="synStatement">if</span> (<span class="synIdentifier">$line</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$what</span><span class="synStatement">/s</span>) {
<span class="synLinenum">   11</span>      <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$file</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   12</span>    }
<span class="synLinenum">   13</span>  }
</pre>
<tex2html_mydb_mark>#1153#
;SPMgt; smodifier.pl 'three.*three' double.in split.pl doublee.pl
double.in
doublee.pl
<tex2html_mydb_mark>#1154#
   1. $x = ;SPMquot;There once was a girl\nWho programmed in Perl\n;SPMquot;;
   2.
   3. $x =~ /^Who/; # doesn't match, ;SPMquot;Who;SPMquot; not at start of string
   4. $x =~ /^Who/s; # doesn't match, ;SPMquot;Who;SPMquot; not at start of string
   5. $x =~ /^Who/m; # matches, ;SPMquot;Who;SPMquot; at start of second line
   6. $x =~ /^Who/sm; # matches, ;SPMquot;Who;SPMquot; at start of second line
   7.
   8. $x =~ /girl.Who/; # doesn't match, ;SPMquot;.;SPMquot; doesn't match ;SPMquot;\n;SPMquot;
   9. $x =~ /girl.Who/s; # matches, ;SPMquot;.;SPMquot; matches ;SPMquot;\n;SPMquot;
  10. $x =~ /girl.Who/m; # doesn't match, ;SPMquot;.;SPMquot; doesn't match ;SPMquot;\n;SPMquot;
  11. $x =~ /girl.Who/sm; # matches, ;SPMquot;.;SPMquot; matches ;SPMquot;\n;SPMquot;
<tex2html_mydb_mark>#1155#
   1. $x =~ /^Who/m; # matches, ;SPMquot;Who;SPMquot; at start of second line
   2. $x =~ /\AWho/m; # doesn't match, ;SPMquot;Who;SPMquot; is not at start of string
   3.
   4. $x =~ /girl$/m; # matches, ;SPMquot;girl;SPMquot; at end of first line
   5. $x =~ /girl\Z/m; # doesn't match, ;SPMquot;girl;SPMquot; is not at end of string
   6.
   7. $x =~ /Perl\Z/m; # matches, ;SPMquot;Perl;SPMquot; is at newline before end
   8. $x =~ /Perl\z/m; # doesn't match, ;SPMquot;Perl;SPMquot; is not at end of string
<tex2html_mydb_mark>#1156#
nereida:~/perl/src;SPMgt; perl -de 0
  DB;SPMlt;1;SPMgt; $a = ;SPMquot;hola\npedro;SPMquot;
  DB;SPMlt;2;SPMgt; p ;SPMquot;$a;SPMquot;
hola
pedro
  DB;SPMlt;3;SPMgt; $a =~ s/.*/x/m
  DB;SPMlt;4;SPMgt; p $a
x
pedro
  DB;SPMlt;5;SPMgt; $a =~ s/^pedro$/juan/
  DB;SPMlt;6;SPMgt; p ;SPMquot;$a;SPMquot;
x
pedro
  DB;SPMlt;7;SPMgt; $a =~ s/^pedro$/juan/m
  DB;SPMlt;8;SPMgt;  p ;SPMquot;$a;SPMquot;
x
juan
<tex2html_mydb_mark>#1157#
<pre>
casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">print</span> <span class="synConstant">;SPMquot;Enter a temperature (i.e. 32F, 100C):</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = <span class="synIdentifier">;SPMlt;STDIN;SPMgt;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> (<span class="synIdentifier">$InputNum</span>, <span class="synIdentifier">$type</span>);
<span class="synLinenum">    9</span> 
<span class="synLinenum">   10</span>   (<span class="synIdentifier">$InputNum</span>, <span class="synIdentifier">$type</span>) = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m/</span><span class="synConstant">^</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                      </span><span class="synSpecial">([-+]?[0-9]+(?:\.[0-9]*)?)</span><span class="synConstant"> # Temperature</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                      </span><span class="synSpecial">\s*</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">([cCfF])</span><span class="synConstant"> # Celsius or Farenheit</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   $</span><span class="synStatement">/x</span>;
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span>   <span class="synStatement">die</span> <span class="synConstant">;SPMquot;Expecting a temperature, so don't understand </span><span class="synSpecial">\;SPMquot;</span><span class="synIdentifier">$input</span><span class="synSpecial">\;SPMquot;</span><span class="synConstant">.</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span> <span class="synStatement">unless</span> <span class="synStatement">defined</span>(<span class="synIdentifier">$InputNum</span>);
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span>   <span class="synStatement">my</span> (<span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$fahrenheit</span>);
<span class="synLinenum">   19</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">;SPMquot;C;SPMquot;</span> <span class="synStatement">or</span> <span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">;SPMquot;c;SPMquot;</span>) {
<span class="synLinenum">   20</span>     <span class="synIdentifier">$celsius</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   21</span>     <span class="synIdentifier">$fahrenheit</span> = (<span class="synIdentifier">$celsius</span> * <span class="synConstant">9</span>/<span class="synConstant">5</span>)<span class="synConstant">+32</span>;
<span class="synLinenum">   22</span>   }
<span class="synLinenum">   23</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   24</span>     <span class="synIdentifier">$fahrenheit</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   25</span>     <span class="synIdentifier">$celsius</span> = (<span class="synIdentifier">$fahrenheit</span> <span class="synConstant">-32</span>)*<span class="synConstant">5</span>/<span class="synConstant">9</span>;
<span class="synLinenum">   26</span>   }
<span class="synLinenum">   27</span>   <span class="synStatement">printf</span> <span class="synConstant">;SPMquot;%.2f C = %.2f F</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>, <span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$fahrenheit</span>;
</pre>
<tex2html_mydb_mark>#1158#
;SPMgt; cat groupingpar.pl
#!/usr/bin/perl

  my $a = shift;

  $a =~ m/(?:hola )*(juan)/;
  print ;SPMquot;$1\n;SPMquot;;
nereida:~/perl/src;SPMgt; groupingpar.pl 'hola juan'
juan
<tex2html_mydb_mark>#1159#
pl@nereida:~/Lperltesting$ cat -n mygrep.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die ;SPMquot;Usage $0 regexp files ...\n;SPMquot;;
     3  while (;SPMlt;;SPMgt;) {
     4    print ;SPMquot;File $ARGV, rel. line $.: $_;SPMquot; if (/$what/o); # compile only once
     5  }
     6
<tex2html_mydb_mark>#1160#
pl@nereida:~/Lperltesting$ ./mygrep.pl
Usage ./mygrep.pl regexp files ...
pl@nereida:~/Lperltesting$ ./mygrep.pl if labels.c
File labels.c, rel. line 7:        if (a ;SPMlt; 10) goto LABEL;
<tex2html_mydb_mark>#1161#
pl@nereida:~/Lperltesting$ cat -n mygrep2.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die ;SPMquot;Usage $0 regexp files ...\n;SPMquot;;
     3  $what = qr{$what};
     4  while (;SPMlt;;SPMgt;) {
     5    print ;SPMquot;File $ARGV, rel. line $.: $_;SPMquot; if (/$what/);
     6  }
<tex2html_mydb_mark>#1162#
   1. $x = ;SPMquot;the cat in the hat;SPMquot;;
   2. $x =~ /^(.*)(cat)(.*)$/; # matches,
   3. # $1 = 'the '
   4. # $2 = 'cat'
   5. # $3 = ' in the hat'
<tex2html_mydb_mark>#1163#
   1. $x =~ /^(.*)(at)(.*)$/; # matches,
   2. # $1 = 'the cat in the h'
   3. # $2 = 'at'
   4. # $3 = '' (0 characters match)
<tex2html_mydb_mark>#1164#
   1. 'foo' =~ m{ ( o? )* }x;
<tex2html_mydb_mark>#1165#
   1. @matches = ( 'foo' =~ m{ o? }xg );
<tex2html_mydb_mark>#1166#
   1. print ;SPMquot;match: ;SPMlt;$;SPMamp;;SPMgt;\n;SPMquot; while 'foo' =~ m{ o? }xg;
<tex2html_mydb_mark>#1167#
   1.  m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
<tex2html_mydb_mark>#1168#
   1.  m{ (?: NON_ZERO_LENGTH )*
   2.  |
   3.  (?: ZERO_LENGTH )?
   4.  }x;
<tex2html_mydb_mark>#1169#
   1. $_ = 'bar';
   2. s/\w??/;SPMlt;$;SPMamp;;SPMgt;/g;
<tex2html_mydb_mark>#1170#
<pre>
  DB;SPMlt;25>  <span class="dbuser">$c = 0</span>

  DB;SPMlt;26>  <span class="dbuser"> print(($c++).": ;SPMlt;$&>\n") while 'aaaabababab' =~ /a*(ab)*/g;</span>
0: ;SPMlt;aaaa>
1: ;SPMlt;>
2: ;SPMlt;a>
3: ;SPMlt;>
4: ;SPMlt;a>
5: ;SPMlt;>
6: ;SPMlt;a>
7: ;SPMlt;>
8: ;SPMlt;>
</pre>
<tex2html_mydb_mark>#1171#
   1. $x = ;SPMquot;The programming republic of Perl;SPMquot;;
   2. $x =~ /^(.+?)(e|r)(.*)$/; # matches,
   3. # $1 = 'Th'
   4. # $2 = 'e'
   5. # $3 = ' programming republic of Perl'
<tex2html_mydb_mark>#1172#
   1. $x =~ /(m{1,2}?)(.*?)$/; # matches,
   2. # $1 = 'm'
   3. # $2 = 'ming republic of Perl'
<tex2html_mydb_mark>#1173#
   1. $x =~ /(.*?)(m{1,2}?)(.*)$/; # matches,
   2. # $1 = 'The progra'
   3. # $2 = 'm'
   4. # $3 = 'ming republic of Perl'
<tex2html_mydb_mark>#1174#
   1. $x =~ /(.??)(m{1,2})(.*)$/; # matches,
   2. # $1 = 'a'
   3. # $2 = 'mm'
   4. # $3 = 'ing republic of Perl'
<tex2html_mydb_mark>#1175#
casiano@millo:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x ('1'x34) =~ m{^(11+)\1+$}
0  11111111111111111
  DB;SPMlt;2;SPMgt; x ('1'x34) =~ m{^(11+?)\1+$}
????????????????????????????????????
<tex2html_mydb_mark>#1176#
   1. $x = ;SPMquot;the cat in the hat;SPMquot;;
   2. $x =~ /^(.*)(at)(.*)$/; # matches,
   3. # $1 = 'the cat in the h'
   4. # $2 = 'at'
   5. # $3 = '' (0 matches)
<tex2html_mydb_mark>#1177#
            /(a|b+)*/;
<tex2html_mydb_mark>#1178#
<pre>
casiano@millo:~/Lperltesting$ cat -n comments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">;SPMquot;Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$progname</span><span class="synConstant">;SPMquot;</span>) || <span class="synStatement">die</span> <span class="synConstant">;SPMquot;can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = ;SPMlt;<span class="synIdentifier">$PROGRAM</span>;SPMgt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]gsx;
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>
<tex2html_mydb_mark>#1179#
;SPMgt; cat hello.c
#include ;SPMlt;stdio.h;SPMgt;
/* first
comment
*/
main() {
  printf(;SPMquot;hello world!\n;SPMquot;); /* second comment */
}
<tex2html_mydb_mark>#1180#
;SPMgt; comments.pl hello.c
#include ;SPMlt;stdio.h;SPMgt;
 
main() {
  printf(;SPMquot;hello world!\n;SPMquot;);
}
<tex2html_mydb_mark>#1181#
<pre>
pl@nereida:~/src/perl/perltesting$  <span class="dbuser">perl5_10_1 -wde 0</span>
main::(-e:1):   0
  DB<1>  <span class="dbuser"> use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*\*/)}; print "\n$1\n"</span>
Compiling REx "(/\*.*\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT <*/> (9)
   9: CLOSE1 (11)
  11: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 <; /* 3c > <*/ }>       |  7:  EXACT <*/>(9)
  43 <; /* 3c */> < }>       |  9:  CLOSE1(11)
  43 <; /* 3c */> < }>       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: "(/\*.*\*/)"

  DB<2>  <span class="dbuser"> use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*?\*/)}; print "\n$1\n"</span>
Compiling REx "(/\*.*?\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT <*/> (10)
  10: CLOSE1 (12)
  12: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*?\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*?\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:MINMOD(6)
   9 <() /*> < 1c */ { />    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 <* 1c > <*/ { /* 2c>    |  8:  EXACT <*/>(10)
  15 <1c */> < { /* 2c *>    | 10:  CLOSE1(12)
  15 <1c */> < { /* 2c *>    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: "(/\*.*?\*/)"

  DB<3>
</pre>
<tex2html_mydb_mark>#1182#
pl@nereida:~/Lperltesting$ cat -n negynogreedy.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $b = 'Ella dijo ;SPMquot;Ana;SPMquot; y yo contesté: ;SPMquot;Jamás!;SPMquot;. Eso fué todo.';
     5  my $a;
     6  ($a = $b) =~ s/;SPMquot;.*?!;SPMquot;/-$;SPMamp;-/;
     7  print ;SPMquot;$a\n;SPMquot;;
     8
     9  $b =~ s/;SPMquot;[^;SPMquot;]*!;SPMquot;/-$;SPMamp;-/;
    10  print ;SPMquot;$b\n;SPMquot;;
<tex2html_mydb_mark>#1183#
;SPMgt; negynogreedy.pl
Ella dijo -;SPMquot;Ana;SPMquot; y yo contesté: ;SPMquot;Jamás!;SPMquot;-. Eso fué todo.
Ella dijo ;SPMquot;Ana;SPMquot; y yo contesté: -;SPMquot;Jamás!;SPMquot;-. Eso fué todo.
<tex2html_mydb_mark>#1184#
$d = $s;
$d =~ s/esto/por lo otro/;
<tex2html_mydb_mark>#1185#
($d = $s) =~ s/esto/por lo otro/;
<tex2html_mydb_mark>#1186#
   1. $a99a = '([a-z])(\d)\2\1'; # matches a11a, g22g, x33x, etc.
<tex2html_mydb_mark>#1187#
   1. $line = ;SPMquot;code=e99e;SPMquot;;
   2. if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   3.   print ;SPMquot;$1 is valid\n;SPMquot;;
   4. } else {
   5.   print ;SPMquot;bad line: '$line'\n;SPMquot;;
   6. }
<tex2html_mydb_mark>#1188#
   1. $a99a = '([a-z])(\d)\g{-1}\g{-2}'; # safe for being interpolated
<tex2html_mydb_mark>#1189#
<pre>
casiano@millo:~/Lperltesting$ cat -n backreference.pl
<span class="synLinenum">    1</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>re <span class="synConstant">'debug'</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$a99a</span> = <span class="synConstant">'([a-z])(\d)\2\1'</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">;SPMquot;code=e99e;SPMquot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$line</span> =~<span class="synStatement"> /</span><span class="synConstant">^</span><span class="synSpecial">(\w+)</span><span class="synConstant">=</span><span class="synIdentifier">$a99a</span><span class="synConstant">$</span><span class="synStatement">/</span>){ <span class="synComment"># unexpected behavior!</span>
<span class="synLinenum">    7</span>     <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$1</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    8</span>   } <span class="synStatement">else</span> {
<span class="synLinenum">    9</span>     <span class="synStatement">print</span> <span class="synConstant">;SPMquot;bad line: '</span><span class="synIdentifier">$line</span><span class="synConstant">'</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   10</span>   }
</pre>
<tex2html_mydb_mark>#1190#
<pre>
casiano@millo:~/Lperltesting$  <span class="dbuser">perl5.10.1 -wd backreference.pl</span>
main::(backreference.pl:4):     my $a99a = '([a-z])(\d)\2\1';
  DB<1>  <span class="dbuser">c 6</span>
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB<2>  <span class="dbuser">x ($line =~ /^(\w+)=$a99a$/)</span>
  empty array
  DB<4>  <span class="dbuser">$a99a = '([a-z])(\d)\g{-1}\g{-2}'</span>
  DB<5>  <span class="dbuser">x ($line =~ /^(\w+)=$a99a$/)</span>
0  'code'
1  'e'
2  9
</pre>
<tex2html_mydb_mark>#1191#
   1.  $fmt1 = '(?;SPMlt;y;SPMgt;\d\d\d\d)-(?;SPMlt;m;SPMgt;\d\d)-(?;SPMlt;d;SPMgt;\d\d)';
   2.  $fmt2 = '(?;SPMlt;m;SPMgt;\d\d)/(?;SPMlt;d;SPMgt;\d\d)/(?;SPMlt;y;SPMgt;\d\d\d\d)';
   3.  $fmt3 = '(?;SPMlt;d;SPMgt;\d\d)\.(?;SPMlt;m;SPMgt;\d\d)\.(?;SPMlt;y;SPMgt;\d\d\d\d)';
   4.  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
   5.    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
   6.      print ;SPMquot;day=$+{d} month=$+{m} year=$+{y}\n;SPMquot;;
   7.    }
   8.  }
<tex2html_mydb_mark>#1192#
casiano@millo:~/Lperltesting$ cat -n namedbackreferences.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $fmt1 = '(?;SPMlt;y;SPMgt;\d\d\d\d)-(?;SPMlt;m;SPMgt;\d\d)-(?;SPMlt;d;SPMgt;\d\d)';
     5  my $fmt2 = '(?;SPMlt;m;SPMgt;\d\d)/(?;SPMlt;d;SPMgt;\d\d)/(?;SPMlt;y;SPMgt;\d\d\d\d)';
     6  my $fmt3 = '(?;SPMlt;d;SPMgt;\d\d)\.(?;SPMlt;m;SPMgt;\d\d)\.(?;SPMlt;y;SPMgt;\d\d\d\d)';
     7
     8  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
     9    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
    10      print ;SPMquot;day=$+{d} month=$+{m} year=$+{y}\n;SPMquot;;
    11    }
    12  }
<tex2html_mydb_mark>#1193#
casiano@millo:~/Lperltesting$ perl5.10.1 -w namedbackreferences.pl
day=21 month=10 year=2006
day=15 month=01 year=2007
day=31 month=10 year=2005
<tex2html_mydb_mark>#1194#
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
DB;SPMlt;1;SPMgt;  # ... only the leftmost one of the eponymous set can be referenced
DB;SPMlt;2;SPMgt; $r = qr{(?;SPMlt;a;SPMgt;[a-c])(?;SPMlt;a;SPMgt;[a-f])}
DB;SPMlt;3;SPMgt; print $+{a} if 'ad' =~ $r
a
DB;SPMlt;4;SPMgt; print $+{a} if 'cf' =~ $r
c
DB;SPMlt;5;SPMgt; print $+{a} if 'ak' =~ $r
<tex2html_mydb_mark>#1195#
pl@nereida:~/Lperltesting$ cat -n c2f_5_10v2.pl
 1  #!/usr/local/bin/perl5_10_1 -w
 2  use strict;
 3
 4  print ;SPMquot;Enter a temperature (i.e. 32F, 100C):\n;SPMquot;;
 5  my $input = ;SPMlt;STDIN;SPMgt;;
 6  chomp($input);
 7
 8  $input =~ m/^
 9              (?;SPMlt;farenheit;SPMgt;[-+]?[0-9]+(?:\.[0-9]*)?)\s*[fF]
10              |
11              (?;SPMlt;celsius;SPMgt;[-+]?[0-9]+(?:\.[0-9]*)?)\s*[cC]
12           $/x;
13
14  my ($celsius, $farenheit);
15  if (exists $+{celsius}) {
16    $celsius = $+{celsius};
17    $farenheit = ($celsius * 9/5)+32;
18  }
19  elsif (exists $+{farenheit}) {
20    $farenheit = $+{farenheit};
21    $celsius = ($farenheit -32)*5/9;
22  }
23  else {
24    die ;SPMquot;Expecting a temperature, so don't understand \"$input\".\n;SPMquot;;
25  }
26
27  printf ;SPMquot;%.2f C = %.2f F\n;SPMquot;, $celsius, $farenheit;

<tex2html_mydb_mark>#1196#
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x ;SPMquot;abbacddc;SPMquot; =~ /(.)(.)\2\1/
0  'a'
1  'b'
<tex2html_mydb_mark>#1197#
  DB;SPMlt;2;SPMgt; x ;SPMquot;abbacddc;SPMquot; =~ /((.)(.)\2\1){2}/
  empty array
<tex2html_mydb_mark>#1198#
  DB;SPMlt;3;SPMgt; x ;SPMquot;abbacddc;SPMquot; =~ /((.)(.)\3\2){2}/
0  'cddc'
1  'c'
2  'd'
  DB;SPMlt;4;SPMgt; ;SPMquot;abbacddc;SPMquot; =~ /((.)(.)\3\2){2}/; print ;SPMquot;$;SPMamp;\n;SPMquot;
abbacddc
<tex2html_mydb_mark>#1199#
  DB;SPMlt;5;SPMgt; x ;SPMquot;abbacddc;SPMquot; =~ /((?;SPMlt;a;SPMgt;.)(?;SPMlt;b;SPMgt;.)\k;SPMlt;b;SPMgt;\k;SPMlt;a;SPMgt;){2}/
0  'cddc'
1  'c'
2  'd'
<tex2html_mydb_mark>#1200#
casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x ;SPMquot;AABB;SPMquot; =~ /(A)(?-1)(?+1)(B)/
0  'A'
1  'B'
  # Parenthesis:       1   2   2                  1
  DB;SPMlt;2;SPMgt; x 'ababa' =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  'ababa'
1  'a'
  DB;SPMlt;3;SPMgt; x 'bbabababb' =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  'bbabababb'
1  'b'
<tex2html_mydb_mark>#1201#
casiano@millo:~/src/perl/perltesting$ cat -n c2f_5_10v3.pl
 1  #!/soft/perl5lib/bin/perl5.10.1 -w
 2  use strict;
 3  use Regexp::Common;
 4
 5  print ;SPMquot;Enter a temperature (i.e. 32F, 100C):\n;SPMquot;;
 6  my $input = ;SPMlt;STDIN;SPMgt;;
 7  chomp($input);
 8
 9  $input =~ m/^
10              (?;SPMlt;farenheit;SPMgt;$RE{num}{real})\s*[fF]
11              |
12              (?;SPMlt;celsius;SPMgt;$RE{num}{real})\s*[cC]
13           $/x;
14
15  my ($celsius, $farenheit);
16  if ('celsius' ~~ %+) {
17    $celsius = $+{celsius};
18    $farenheit = ($celsius * 9/5)+32;
19  }
20  elsif ('farenheit' ~~ %+) {
21    $farenheit = $+{farenheit};
22    $celsius = ($farenheit -32)*5/9;
23  }
24  else {
25    die ;SPMquot;Expecting a temperature, so don't understand \"$input\".\n;SPMquot;;
26  }
27
28  printf ;SPMquot;%.2f C = %.2f F\n;SPMquot;, $celsius, $farenheit;

<tex2html_mydb_mark>#1202#
casiano@millo:~/Lperltesting$ cat -n regexpcommonsynopsis.pl
     1  use strict;
     2  use Perl6::Say;
     3  use Regexp::Common;
     4
     5  while (;SPMlt;;SPMgt;) {
     6      say q{a number}              if /$RE{num}{real}/;
     7
     8      say q{a [';SPMquot;`] quoted string} if /$RE{quoted}/;
     9
    10      say q{a /.../ sequence}      if m{$RE{delimited}{'-delim'=;SPMgt;'/'}};
    11
    12      say q{balanced parentheses}  if /$RE{balanced}{'-parens'=;SPMgt;'()'}/;
    13
    14      die q{a #*@%-ing word}.;SPMquot;\n;SPMquot;  if /$RE{profanity}/;
    15
    16  }
    17
<tex2html_mydb_mark>#1203#
casiano@millo:~/Lperltesting$ perl regexpcommonsynopsis.pl
43
a number
;SPMquot;2+2 es;SPMquot; 4
a number
a [';SPMquot;`] quoted string
x/y/z
a /.../ sequence
(2*(4+5/(3-2)))
a number
balanced parentheses
fuck you!
a #*@%-ing word

<tex2html_mydb_mark>#1204#
        $RE{num}{real}
<tex2html_mydb_mark>#1205#
        $RE{num}{int}
<tex2html_mydb_mark>#1206#
        $RE{num}{real}{-base =;SPMgt; 2}{-sep =;SPMgt; ','}{-group =;SPMgt; 3}
<tex2html_mydb_mark>#1207#
        $RE{num}{real}{-sep =;SPMgt; ','}{-group =;SPMgt; 3}{-base =;SPMgt; 2}
<tex2html_mydb_mark>#1208#
        $RE{num}{-base =;SPMgt; 2}{real}{-group =;SPMgt; 3}{-sep =;SPMgt; ','}
<tex2html_mydb_mark>#1209#
        $RE{-base =;SPMgt; 2}{-group =;SPMgt; 3}{-sep =;SPMgt; ','}{num}{real}
<tex2html_mydb_mark>#1210#
        $RE{list}{set}
<tex2html_mydb_mark>#1211#
        $RE{set}{list}
<tex2html_mydb_mark>#1212#
casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x 'numero: 10,101,110.110101101 101.1e-1 234' =~ m{($RE{num}{real}{-base =;SPMgt; 2}{-sep =;SPMgt; ','}{-group =;SPMgt; 3})}g
0  '10,101,110.110101101'
1  '101.1e-1'
<tex2html_mydb_mark>#1213#
casiano@millo:~/src/perl/perltesting$ perl5.10.1 -wd c2f_5_10v3.pl
main::(c2f_5_10v3.pl:5):     print ;SPMquot;Enter a temperature (i.e. 32F, 100C):\n;SPMquot;;
  DB;SPMlt;1;SPMgt; p $RE{num}{real}
(?:(?i)(?:[+-]?)(?:(?=[0123456789]|[.])(?:[0123456789]*)(?:(?:[.])(?:[0123456789]{0,}))?)(?:(?:[E])(?:(?:[+-]?)(?:[0123456789]+))|))
<tex2html_mydb_mark>#1214#
casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
DB;SPMlt;2;SPMgt; x 'one, two, three, four, five' =~ /$RE{list}{-pat =;SPMgt; '\w+'}/
0  1
DB;SPMlt;3;SPMgt; x 'one, two, three, four, five' =~ /$RE{list}{-pat =;SPMgt; '\w+'}{-keep}/
0  'one, two, three, four, five'
1  ', '
<tex2html_mydb_mark>#1215#
    use feature qw(say);

    my $x = ;SPMquot;foo;SPMquot;;
    my $y = ;SPMquot;bar;SPMquot;;
    my $z = ;SPMquot;foo;SPMquot;;

    say '$x and $y are identical strings' if $x ~~ $y;
    say '$x and $z are identical strings' if $x ~~ $z;    # Printed
<tex2html_mydb_mark>#1216#
    my $num   = 100;
    my $input = ;SPMlt;STDIN;SPMgt;;

    say 'You entered 100' if $num ~~ $input;
<tex2html_mydb_mark>#1217#
    my $input  = ;SPMlt;STDIN;SPMgt;;

    say 'You said the secret word!' if $input ~~ /xyzzy/;
<tex2html_mydb_mark>#1218#
casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB;SPMlt;2;SPMgt; print ;SPMquot;You're a friend;SPMquot; if 'Pippin' ~~ @friends
You're a friend
  DB;SPMlt;3;SPMgt; print ;SPMquot;You're a friend;SPMquot; if 'Mordok' ~~ @friends
<tex2html_mydb_mark>#1219#
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; use List::Util qw{first}
  DB;SPMlt;2;SPMgt; @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB;SPMlt;3;SPMgt; x first { $_ eq 'Pippin'} @friends
0  'Pippin'
  DB;SPMlt;4;SPMgt; x first { $_ eq 'Mordok'} @friends
0  undef
<tex2html_mydb_mark>#1220#
  DB;SPMlt;4;SPMgt; @foo = qw(x y z xyzzy ninja)
  DB;SPMlt;5;SPMgt; @bar = qw(x y z xyzzy ninja)
  DB;SPMlt;7;SPMgt; print ;SPMquot;Identical arrays;SPMquot; if @foo ~~ @bar
Identical arrays
  DB;SPMlt;8;SPMgt; @bar = qw(x y z xyzzy nOnjA)
  DB;SPMlt;9;SPMgt; print ;SPMquot;Identical arrays;SPMquot; if @foo ~~ @bar
  DB;SPMlt;10;SPMgt;
<tex2html_mydb_mark>#1221#
 DB;SPMlt;11;SPMgt; x @foo = qw(x y z xyzzy ninja)
0  'x'
1  'y'
2  'z'
3  'xyzzy'
4  'ninja'
  DB;SPMlt;12;SPMgt; print ;SPMquot;Array contains a ninja ;SPMquot; if @foo ~~ 'ninja'
<tex2html_mydb_mark>#1222#
  DB;SPMlt;13;SPMgt; print ;SPMquot;Array contains magic pattern;SPMquot; if @foo ~~ /xyz/
Array contains magic pattern
  DB;SPMlt;14;SPMgt; print ;SPMquot;Array contains magic pattern;SPMquot; if @foo ~~ /\d+/
<tex2html_mydb_mark>#1223#
  DB;SPMlt;16;SPMgt; $array_ref = [ 1..10 ]
  DB;SPMlt;17;SPMgt; print ;SPMquot;Array contains 10;SPMquot; if 10 ~~ $array_ref
Array contains 10
  DB;SPMlt;18;SPMgt; print ;SPMquot;Array contains 10;SPMquot; if $array_ref ~~ 10
  DB;SPMlt;19;SPMgt;
<tex2html_mydb_mark>#1224#
casiano@millo:~/Lperltesting$ perl5.10.1 -E 'say ;SPMquot;ok;SPMquot; if 42 ~~  [23, 17, [40..50], 70];'
ok
casiano@millo:~/Lperltesting$ perl5.10.1 -E 'say ;SPMquot;ok;SPMquot; if 42 ~~  [23, 17, [50..60], 70];'
casiano@millo:~/Lperltesting$
<tex2html_mydb_mark>#1225#
  DB;SPMlt;19;SPMgt; %colour = ( sky   =;SPMgt; 'blue', grass =;SPMgt; 'green', apple =;SPMgt; 'red',)
  DB;SPMlt;20;SPMgt; print ;SPMquot;I know the colour;SPMquot; if 'grass' ~~ %colour
I know the colour
  DB;SPMlt;21;SPMgt; print ;SPMquot;I know the colour;SPMquot; if 'cloud' ~~ %colour
  DB;SPMlt;22;SPMgt;
  DB;SPMlt;23;SPMgt; print ;SPMquot;A key starts with 'gr';SPMquot; if %colour ~~ /^gr/
A key starts with 'gr'
  DB;SPMlt;24;SPMgt; print ;SPMquot;A key starts with 'clou';SPMquot; if %colour ~~ /^clou/
  DB;SPMlt;25;SPMgt;
<tex2html_mydb_mark>#1226#
  DB;SPMlt;26;SPMgt; print 'Hashes have identical keys' if %taste ~~ %colour;
Hashes have identical keys
<tex2html_mydb_mark>#1227#
 $a      $b        Type of Match Implied    Matching Code
 ======  =====     =====================    =============
 Any     undef     undefined                !defined $a

 Any     Object    invokes ~~ overloading on $object, or dies

 Hash    CodeRef   sub truth for each key[1] !grep { !$b-;SPMgt;($_) } keys %$a
 Array   CodeRef   sub truth for each elt[1] !grep { !$b-;SPMgt;($_) } @$a
 Any     CodeRef   scalar sub truth          $b-;SPMgt;($a)

 Hash    Hash      hash keys identical (every key is found in both hashes)
 Array   Hash      hash slice existence     grep { exists $b-;SPMgt;{$_} } @$a
 Regex   Hash      hash key grep            grep /$a/, keys %$b
 undef   Hash      always false (undef can't be a key)
 Any     Hash      hash entry existence     exists $b-;SPMgt;{$a}

 Hash    Array     hash slice existence     grep { exists $a-;SPMgt;{$_} } @$b
 Array   Array     arrays are comparable[2]
 Regex   Array     array grep               grep /$a/, @$b
 undef   Array     array contains undef     grep !defined, @$b
 Any     Array     match against an array element[3]
                                            grep $a ~~ $_, @$b

 Hash    Regex     hash key grep            grep /$b/, keys %$a
 Array   Regex     array grep               grep /$b/, @$a
 Any     Regex     pattern match            $a =~ /$b/

 Object  Any       invokes ~~ overloading on $object, or falls back:
 Any     Num       numeric equality         $a == $b
 Num     numish[4] numeric equality         $a == $b
 undef   Any       undefined                !defined($b)
 Any     Any       string equality          $a eq $b
<tex2html_mydb_mark>#1228#
<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat twonumbers</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synIdentifier">$_</span><span class="synConstant"> = ;SPMquot;I have 2 numbers: 53147;SPMquot;;</span>
<span class="synLinenum">    3</span> <span class="synIdentifier">@pats</span><span class="synConstant"> = qw{</span>
<span class="synLinenum">    4</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d*)</span>
<span class="synLinenum">    5</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d+)</span>
<span class="synLinenum">    6</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d*)</span>
<span class="synLinenum">    7</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d+)</span>
<span class="synLinenum">    8</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">    9</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   10</span> <span class="synConstant">  </span><span class="synSpecial">(.*)\b(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   11</span> <span class="synConstant">  </span><span class="synSpecial">(.*\D)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   12</span> <span class="synConstant">};</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">print ;SPMquot;</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   15</span> <span class="synConstant">for </span><span class="synIdentifier">$pat</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@pats</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synLinenum">   16</span> <span class="synConstant">  printf ;SPMquot;%-12s ;SPMquot;, </span><span class="synIdentifier">$pat</span><span class="synConstant">;</span>
<span class="synLinenum">   17</span> <span class="synConstant">  ;SPMlt;;SPMgt;;</span>
<span class="synLinenum">   18</span> <span class="synConstant">  if </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synStatement">/</span><span class="synIdentifier">$pat</span>/ ) {
<span class="synLinenum">   19</span>     <span class="synStatement">print</span> <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$1</span><span class="synConstant">;SPMgt; ;SPMlt;</span><span class="synIdentifier">$2</span><span class="synConstant">;SPMgt;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   20</span>   } <span class="synStatement">else</span> {
<span class="synLinenum">   21</span>     <span class="synStatement">print</span> <span class="synConstant">;SPMquot;FAIL</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   22</span>   }
<span class="synLinenum">   23</span> }
</pre>
<tex2html_mydb_mark>#1229#
pl@nereida:~/Lperltesting$ perl5_10_1 -wde 0

Loading DB routines from perl5db.pl version 1.32
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(-e:1):   0
  DB;SPMlt;1;SPMgt; use re 'debug'; 'astr' =~ m{[sf].r}
Compiling REx ;SPMquot;[sf].r;SPMquot;
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT ;SPMlt;r;SPMgt; (15)
  15: END (0)
anchored ;SPMquot;r;SPMquot; at 2 (checking anchored) stclass ANYOF[fs][] minlen 3
Guessing start of match in sv for REx ;SPMquot;[sf].r;SPMquot; against ;SPMquot;astr;SPMquot;
Found anchored substr ;SPMquot;r;SPMquot; at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx ;SPMquot;[sf].r;SPMquot; against ;SPMquot;str;SPMquot;
   1 ;SPMlt;a;SPMgt; ;SPMlt;str;SPMgt;               |  1:ANYOF[fs][](12)
   2 ;SPMlt;as;SPMgt; ;SPMlt;tr;SPMgt;               | 12:REG_ANY(13)
   3 ;SPMlt;ast;SPMgt; ;SPMlt;r;SPMgt;               | 13:EXACT ;SPMlt;r;SPMgt;(15)
   4 ;SPMlt;astr;SPMgt; ;SPMlt;;SPMgt;               | 15:END(0)
Match successful!
Freeing REx: ;SPMquot;[sf].r;SPMquot;
<tex2html_mydb_mark>#1230#
 DB;SPMlt;3;SPMgt; use re 'debug'; $re = qr{[sf].r}
Compiling REx ;SPMquot;[sf].r;SPMquot;
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT ;SPMlt;r;SPMgt; (15)
  15: END (0)
anchored ;SPMquot;r;SPMquot; at 2 (checking anchored) stclass ANYOF[fs][] minlen 3

  DB;SPMlt;4;SPMgt; 'astr' =~ $re
Guessing start of match in sv for REx ;SPMquot;[sf].r;SPMquot; against ;SPMquot;astr;SPMquot;
Found anchored substr ;SPMquot;r;SPMquot; at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx ;SPMquot;[sf].r;SPMquot; against ;SPMquot;str;SPMquot;
   1 ;SPMlt;a;SPMgt; ;SPMlt;str;SPMgt;               |  1:ANYOF[fs][](12)
   2 ;SPMlt;as;SPMgt; ;SPMlt;tr;SPMgt;               | 12:REG_ANY(13)
   3 ;SPMlt;ast;SPMgt; ;SPMlt;r;SPMgt;               | 13:EXACT ;SPMlt;r;SPMgt;(15)
   4 ;SPMlt;astr;SPMgt; ;SPMlt;;SPMgt;               | 15:END(0)
Match successful!
<tex2html_mydb_mark>#1231#
   1. \ Quote the next metacharacter
   2. ^ Match the beginning of the line
   3. . Match any character (except newline)
   4. $ Match the end of the line (or before newline at the end)
   5. | Alternation
   6. () Grouping
   7. [] Character class
<tex2html_mydb_mark>#1232#
   1. * Match 0 or more times
   2. + Match 1 or more times
   3. ? Match 1 or 0 times
   4. {n} Match exactly n times
   5. {n,} Match at least n times
   6. {n,m} Match at least n but not more than m times
<tex2html_mydb_mark>#1233#
   1. *? Match 0 or more times, not greedily
   2. +? Match 1 or more times, not greedily
   3. ?? Match 0 or 1 time, not greedily
   4. {n}? Match exactly n times, not greedily
   5. {n,}? Match at least n times, not greedily
   6. {n,m}? Match at least n but not more than m times, not greedily
<tex2html_mydb_mark>#1234#
   1. *+ Match 0 or more times and give nothing back
   2. ++ Match 1 or more times and give nothing back
   3. ?+ Match 0 or 1 time and give nothing back
   4. {n}+ Match exactly n times and give nothing back (redundant)
   5. {n,}+ Match at least n times and give nothing back
   6. {n,m}+ Match at least n but not more than m times and give nothing back
<tex2html_mydb_mark>#1235#
   1. \t tab (HT, TAB)
   2. \n newline (LF, NL)
   3. \r return (CR)
   4. \f form feed (FF)
   5. \a alarm (bell) (BEL)
   6. \e escape (think troff) (ESC)
   7. \033 octal char (example: ESC)
   8. \x1B hex char (example: ESC)
   9. \x{263a} long hex char (example: Unicode SMILEY)
  10. \cK control char (example: VT)
  11. \N{name} named Unicode character
  12. \l lowercase next char (think vi)
  13. \u uppercase next char (think vi)
  14. \L lowercase till \E (think vi)
  15. \U uppercase till \E (think vi)
  16. \E end case modification (think vi)
  17. \Q quote (disable) pattern metacharacters till \E
<tex2html_mydb_mark>#1236#
casiano@tonga:~$ perl -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $x = '([a-z]+)'
  DB;SPMlt;2;SPMgt; x 'hola' =~ /$x/
0  'hola'
  DB;SPMlt;3;SPMgt; x 'hola' =~ /\Q$x/
  empty array
  DB;SPMlt;4;SPMgt; x '([a-z]+)' =~ /\Q$x/
0  1
<tex2html_mydb_mark>#1237#
   1. \w Match a ;SPMquot;word;SPMquot; character (alphanumeric plus ;SPMquot;_;SPMquot;)
   2. \W Match a non-;SPMquot;word;SPMquot; character
   3. \s Match a whitespace character
   4. \S Match a non-whitespace character
   5. \d Match a digit character
   6. \D Match a non-digit character
   7. \pP Match P, named property. Use \p{Prop} for longer names.
   8. \PP Match non-P
   9. \X Match eXtended Unicode ;SPMquot;combining character sequence;SPMquot;,
  10.    equivalent to (?;SPMgt;\PM\pM*)
  11. \C Match a single C char (octet) even under Unicode.
  12.    NOTE: breaks up characters into their UTF-8 bytes,
  13.    so you may end up with malformed pieces of UTF-8.
  14.    Unsupported in lookbehind.
  15. \1 Backreference to a specific group.
  16. '1' may actually be any positive integer.
  17. \g1 Backreference to a specific or previous group,
  18. \g{-1} number may be negative indicating a previous buffer and may
  19.        optionally be wrapped in curly brackets for safer parsing.
  20. \g{name} Named backreference
  21. \k;SPMlt;name;SPMgt; Named backreference
  22. \K Keep the stuff left of the \K, don't include it in $;SPMamp;
  23. \v Vertical whitespace
  24. \V Not vertical whitespace
  25. \h Horizontal whitespace
  26. \H Not horizontal whitespace
  27. \R Linebreak
<tex2html_mydb_mark>#1238#
   1. \b Match a word boundary
   2. \B Match except at a word boundary
   3. \A Match only at beginning of string
   4. \Z Match only at end of string, or before newline at the end
   5. \z Match only at end of string
   6. \G Match only at pos() (e.g. at the end-of-match position
   7. of prior m//g)
<tex2html_mydb_mark>#1239#
   1. [:class:]
<tex2html_mydb_mark>#1240#
   1. # this is correct:
   2. $string =~ /[[:alpha:]]/;
   3.
   4. # this is not, and will generate a warning:
   5. $string =~ /[:alpha:]/;
<tex2html_mydb_mark>#1241#
   1. alpha
   2. alnum
   3. ascii
   4. blank
   5. cntrl
   6. digit \d
   7. graph
   8. lower
   9. print
  10. punct
  11. space \s 
  12. upper
  13. word \w 
  14. xdigit
<tex2html_mydb_mark>#1242#
   1. [01[:alpha:]%]

<tex2html_mydb_mark>#1243#
   1. [[:...:]] \p{...} backslash
   2.
   3. alpha IsAlpha
   4. alnum IsAlnum
   5. ascii IsASCII
   6. blank
   7. cntrl IsCntrl
   8. digit IsDigit \d
   9. graph IsGraph
  10. lower IsLower
  11. print IsPrint 
  12. punct IsPunct 
  13. space IsSpace
  14. IsSpacePerl \s
  15. upper IsUpper
  16. word IsWord \w
  17. xdigit IsXDigit
<tex2html_mydb_mark>#1244#
   1. POSIX traditional Unicode
   2.
   3. [[:^digit:]] \D \P{IsDigit}
   4. [[:^space:]] \S \P{IsSpace}
   5. [[:^word:]] \W \P{IsWord}
<tex2html_mydb_mark>#1245#
   1 #!/usr/bin/perl -w
   2 if (;SPMquot;Hello there, neighbor;SPMquot; =~ /\s(\w+),/) {
   3   print ;SPMquot;That was: ($`)($;SPMamp;)($').\n;SPMquot;,
   4 }
<tex2html_mydb_mark>#1246#
;SPMgt; matchvariables.pl
That was: (Hello)( there,)( neighbor).
<tex2html_mydb_mark>#1247#
pl@nereida:~/Lperltesting$ cat ampersandoldway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

'hola juan' =~ /ju/;
my ($a, $b, $c) = ($`, $;SPMamp;, $');


cmpthese( -1, {
    oldway =;SPMgt; sub { 'hola juan' =~ /ju/  },
});
pl@nereida:~/Lperltesting$ cat ampersandnewway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

'hola juan' =~ /ju/p;
my ($a, $b, $c) = (${^PREMATCH}, ${^MATCH}, ${^POSTMATCH});


cmpthese( -1, {
    newway =;SPMgt; sub { 'hola juan' =~ /ju/  },
});

pl@nereida:~/Lperltesting$ time ./ampersandoldway.pl
            Rate oldway
oldway 2991861/s     --

real    0m3.761s
user    0m3.740s
sys     0m0.020s
pl@nereida:~/Lperltesting$ time ./ampersandnewway.pl
            Rate newway
newway 8191999/s     --

real    0m6.721s
user    0m6.704s
sys     0m0.016s
<tex2html_mydb_mark>#1248#
  DB;SPMlt;9;SPMgt; ;SPMquot;Revision: 4.5;SPMquot; =~ /Version: (.*)|Revision: (.*)/ ;SPMamp;;SPMamp; ($rev = $+);
  DB;SPMlt;10;SPMgt; x $rev
0  4.5
  DB;SPMlt;11;SPMgt; ;SPMquot;Version: 4.5;SPMquot; =~ /Version: (.*)|Revision: (.*)/ ;SPMamp;;SPMamp; ($rev = $+);
  DB;SPMlt;12;SPMgt; x $rev
0  4.5
<tex2html_mydb_mark>#1249#
#           012345678
DB;SPMlt;1;SPMgt; $z = ;SPMquot;hola13.47;SPMquot;
DB;SPMlt;2;SPMgt; if ($z =~ m{a(\d+)(\.(\d+))?}) { print ;SPMquot;@-\n;SPMquot;; }
3 4 6 7
<tex2html_mydb_mark>#1250#
    $` is the same as substr($var, 0, $-[0])
    $;SPMamp; is the same as substr($var, $-[0], $+[0] - $-[0])
    $' is the same as substr($var, $+[0])
    $1 is the same as substr($var, $-[1], $+[1] - $-[1])
    $2 is the same as substr($var, $-[2], $+[2] - $-[2])
    $3 is the same as substr($var, $-[3], $+[3] - $-[3])
<tex2html_mydb_mark>#1251#
#            0123456789
DB;SPMlt;17;SPMgt; $z = ;SPMquot;hola13.47x;SPMquot;
DB;SPMlt;18;SPMgt; if ($z =~ m{a(\d+)(\.)(\d+)?}) { print ;SPMquot;@+\n;SPMquot;; }
9 6 7 9
<tex2html_mydb_mark>#1252#
  DB;SPMlt;29;SPMgt; $z = ;SPMquot;h;SPMquot;
  DB;SPMlt;30;SPMgt; print ;SPMquot;$#+\n;SPMquot; if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
3
  DB;SPMlt;31;SPMgt; $z = ;SPMquot;ab;SPMquot;
  DB;SPMlt;32;SPMgt; print ;SPMquot;$#+\n;SPMquot; if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
2
<tex2html_mydb_mark>#1253#
  DB;SPMlt;1;SPMgt; $x = '13.47'; $y = '125'
  DB;SPMlt;2;SPMgt; if ($y =~ m{(\d+)(\.(\d+))?}) { print ;SPMquot;last par = $#-, content = $+\n;SPMquot;; }
last par = 1, content = 125
  DB;SPMlt;3;SPMgt; if ($x =~ m{(\d+)(\.(\d+))?}) { print ;SPMquot;last par = $#-, content = $+\n;SPMquot;; }
last par = 3, content = 47
<tex2html_mydb_mark>#1254#
  DB;SPMlt;1;SPMgt; ;SPMquot;a;SPMquot; =~ /(a)|(b)/; @a = @-; @b = @+
  DB;SPMlt;2;SPMgt; x @a
0  0
1  0
  DB;SPMlt;3;SPMgt; x @b
0  1
1  1
2  undef
<tex2html_mydb_mark>#1255#
if (m/(...)/) {
  ;SPMamp;do_something();
  print ;SPMquot;the matched variable was $1.\n;SPMquot;;
}
<tex2html_mydb_mark>#1256#
   1 #!/usr/bin/perl -w
   2 ($one, $five, $fifteen) = (`uptime` =~ /(\d+\.\d+)/g);
   3 print ;SPMquot;$one, $five, $fifteen\n;SPMquot;;
<tex2html_mydb_mark>#1257#
;SPMgt; uptime
  1:35pm  up 19:22,  0 users,  load average: 0.01, 0.03, 0.00
;SPMgt; glist.pl
0.01, 0.03, 0.00
<tex2html_mydb_mark>#1258#
   1 #!/usr/bin/perl -w
   2 # count sentences in a document
   3 #defined as ending in [.!?] perhaps with
   4 # quotes or parens on either side.
   5 $/ = ;SPMquot;;SPMquot;; # paragraph mode
   6 while ($paragraph = ;SPMlt;;SPMgt;) {
   7   print $paragraph;
   8   while ($paragraph =~ /[a-z][';SPMquot;)]*[.!?]+[';SPMquot;)]*\s/g) {
   9     $sentences++;
  10   }
  11 }
  12 print ;SPMquot;$sentences\n;SPMquot;;
<tex2html_mydb_mark>#1259#
;SPMgt; gscalar.pl
este primer parrafo. Sera seguido de un
segundo parrafo.
 
;SPMquot;Cita de Seneca;SPMquot;.
 
3
<tex2html_mydb_mark>#1260#
   1 #!/usr/bin/perl -w
   2 $_ = ;SPMquot;abc123xyz\n;SPMquot;;
   3 s/\d+/$;SPMamp;*2/e;
   4 print;
   5 s/\d+/sprintf(;SPMquot;%5d;SPMquot;,$;SPMamp;)/e;
   6 print;
   7 s/\w/$;SPMamp; x 2/eg;
   8 print;
<tex2html_mydb_mark>#1261#
;SPMgt; replacement.pl
abc246xyz
abc  246xyz
aabbcc  224466xxyyzz
<tex2html_mydb_mark>#1262#
   1 #!/usr/bin/perl 
   2 $a =;SPMquot;one;SPMquot;;
   3 $b = ;SPMquot;two;SPMquot;;
   4 $_ = '$a $b';
   5 print ;SPMquot;_ = $_\n\n;SPMquot;;
   6 s/(\$\w+)/$1/ge;
   7 print ;SPMquot;After 's/(\$\w+)/$1/ge' _ = $_\n\n;SPMquot;;
   8 s/(\$\w+)/$1/gee;
   9 print ;SPMquot;After 's/(\$\w+)/$1/gee' _ = $_\n\n;SPMquot;;
<tex2html_mydb_mark>#1263# 
;SPMgt; enested.pl
_ = $a $b
 
After 's/($w+)/$b/ge' _ = $a $b
 
After 's/($w+)/$b/gee' _ = one two
<tex2html_mydb_mark>#1264#
s/,/, /g;
<tex2html_mydb_mark>#1265#
s/(\d[,.]\d)|(,(?!\s))/$1 || ;SPMquot;$2 ;SPMquot;/ge;
<tex2html_mydb_mark>#1266#
   1. $pattern = ;SPMquot;foobar;SPMquot;;
   2. if ( /$pattern/i ) { }
   3.
   4. # more flexible:
   5.
   6. $pattern = ;SPMquot;(?i)foobar;SPMquot;;
   7. if ( /$pattern/ ) { }
<tex2html_mydb_mark>#1267#
   1. ( (?i) blah ) \s+ \1
<tex2html_mydb_mark>#1268#
<pre>
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">;SPMquot;Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$progname</span><span class="synConstant">;SPMquot;</span>) || <span class="synStatement">die</span> <span class="synConstant">;SPMquot;can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = ;SPMlt;<span class="synIdentifier">$PROGRAM</span>;SPMgt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span><span class="synSpecial">(?xs)</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">    |</span>
<span class="synLinenum">   16</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">-s</span><span class="synSpecial">)</span><span class="synConstant">//</span><span class="synSpecial">.*</span><span class="synConstant"> # C</span><span class="synSpecial">++</span><span class="synConstant"> // comments</span><span class="synSpecial">.</span><span class="synConstant"> No s modifier</span>
<span class="synLinenum">   17</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]g;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>
<tex2html_mydb_mark>#1269#
casiano@tonga:~/Lperltesting$ cat -n ehello.c
     1  #include ;SPMlt;stdio.h;SPMgt;
     2  /* first
     3  comment
     4  */
     5  main() { // A C++ comment
     6    printf(;SPMquot;hello world!\n;SPMquot;); /* second comment */
     7  } // final comment
<tex2html_mydb_mark>#1270#
casiano@tonga:~/Lperltesting$ extendedcomments.pl ehello.c | cat -n
     1  #include ;SPMlt;stdio.h;SPMgt;
     2
     3  main() {
     4    printf(;SPMquot;hello world!\n;SPMquot;);
     5  }
<tex2html_mydb_mark>#1271#
<pre>
> cat -n lookahead.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span> 
<span class="synLinenum">    3</span>  <span class="synIdentifier">$a</span> = <span class="synConstant">;SPMquot;bugs the rabbit;SPMquot;</span>;
<span class="synLinenum">    4</span>  <span class="synIdentifier">$b</span> = <span class="synConstant">;SPMquot;bugs the frog;SPMquot;</span>;
<span class="synLinenum">    5</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$a</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$a</span><span class="synConstant"> matches. </span><span class="synSpecial">\$</span><span class="synConstant">;SPMamp; = </span><span class="synIdentifier">$;SPMamp;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>; }
<span class="synLinenum">    6</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$a</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>; }
<span class="synLinenum">    7</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$b</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$b</span><span class="synConstant"> matches. </span><span class="synSpecial">\$</span><span class="synConstant">;SPMamp; = </span><span class="synIdentifier">$;SPMamp;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>; }
<span class="synLinenum">    8</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$b</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>; }
</pre>
<tex2html_mydb_mark>#1272#
;SPMgt; lookahead.pl
bugs the rabbit matches. $;SPMamp; = bugs
bugs the frog does not match
;SPMgt;
<tex2html_mydb_mark>#1273#
<pre>
  DB<1>  <span class="dbuser">     #012345678901234567890</span>
  DB<2>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<3>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x  =~ /cat(?=\s)/g</span>
(cat) (20)                    # matches 'cat' in 'housecat'

  DB<5>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip" # To reset pos</span>
  DB<6>  <span class="dbuser">x @catwords = ($x =~ /(?<=\s)cat\w+/g)</span>
0  'catch'
1  'catnip'

  DB<7>  <span class="dbuser">     #012345678901234567890123456789</span>
  DB<8>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<9>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x =~ /\bcat\b/g</span>
(cat) (29) # matches 'cat' in 'Tom-cat'

  DB<10>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<11>  <span class="dbuser">x  $x =~ /(?<=\s)cat(?=\s)/</span>
  empty array
  DB<12>  <span class="dbuser"># doesn't match; no isolated 'cat' in middle of $x</span>
</pre>
<tex2html_mydb_mark>#1274#
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x 'aaa2a1' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
  DB;SPMlt;2;SPMgt; x 'aaaaaa' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB;SPMlt;3;SPMgt; x '1111111' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB;SPMlt;4;SPMgt; x '1111111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB;SPMlt;5;SPMgt; x '111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
<tex2html_mydb_mark>#1275#
    $x = ;SPMquot;foobar;SPMquot;;
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?;SPMlt;!\s)foo/;  # matches, there is no \s before 'foo'
<tex2html_mydb_mark>#1276#
casiano@tonga:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $str = ;SPMquot;one two - --6-8;SPMquot;
  DB;SPMlt;2;SPMgt; x @toks = split / \s+ | (?;SPMlt;=\S) (?=-) | (?;SPMlt;=-)  (?=\S)/x, $str
0  'one'
1  'two'
2  '-'
3  '-'
4  '-'
5  6
6  '-'
7  8
<tex2html_mydb_mark>#1277#
    if (/bar/ ;SPMamp;;SPMamp; $` !~ /foo$/)
<tex2html_mydb_mark>#1278#
  s/(foo)bar/$1/g;
<tex2html_mydb_mark>#1279#
  s/foo\Kbar//g;
<tex2html_mydb_mark>#1280#
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; print ;SPMquot;;SPMamp; = ;SPMlt;$;SPMamp;;SPMgt; 1 = ;SPMlt;$1;SPMgt;\n;SPMquot; if ;SPMquot;alphabet;SPMquot; =~ /([^aeiou][a-z][aeiou])[a-z]/
;SPMamp; = ;SPMlt;phab;SPMgt; 1 = ;SPMlt;pha;SPMgt;
  DB;SPMlt;2;SPMgt; print ;SPMquot;;SPMamp; = ;SPMlt;$;SPMamp;;SPMgt; 1 = ;SPMlt;$1;SPMgt;\n;SPMquot; if ;SPMquot;alphabet;SPMquot; =~ /\K([^aeiou][a-z][aeiou])[a-z]/
;SPMamp; = ;SPMlt;phab;SPMgt; 1 = ;SPMlt;pha;SPMgt;
  DB;SPMlt;3;SPMgt; print ;SPMquot;;SPMamp; = ;SPMlt;$;SPMamp;;SPMgt; 1 = ;SPMlt;$1;SPMgt;\n;SPMquot; if ;SPMquot;alphabet;SPMquot; =~ /([^aeiou]\K[a-z][aeiou])[a-z]/
;SPMamp; = ;SPMlt;hab;SPMgt; 1 = ;SPMlt;pha;SPMgt;
  DB;SPMlt;4;SPMgt; print ;SPMquot;;SPMamp; = ;SPMlt;$;SPMamp;;SPMgt; 1 = ;SPMlt;$1;SPMgt;\n;SPMquot; if ;SPMquot;alphabet;SPMquot; =~ /([^aeiou][a-z]\K[aeiou])[a-z]/
;SPMamp; = ;SPMlt;ab;SPMgt; 1 = ;SPMlt;pha;SPMgt;
  DB;SPMlt;5;SPMgt; print ;SPMquot;;SPMamp; = ;SPMlt;$;SPMamp;;SPMgt; 1 = ;SPMlt;$1;SPMgt;\n;SPMquot; if ;SPMquot;alphabet;SPMquot; =~ /([^aeiou][a-z][aeiou])\K[a-z]/
;SPMamp; = ;SPMlt;b;SPMgt; 1 = ;SPMlt;pha;SPMgt;
  DB;SPMlt;6;SPMgt; print ;SPMquot;;SPMamp; = ;SPMlt;$;SPMamp;;SPMgt; 1 = ;SPMlt;$1;SPMgt;\n;SPMquot; if ;SPMquot;alphabet;SPMquot; =~ /([^aeiou][a-z][aeiou])[a-z]\K/
;SPMamp; = ;SPMlt;;SPMgt; 1 = ;SPMlt;pha;SPMgt;
  DB;SPMlt;7;SPMgt; @a = ;SPMquot;alphabet;SPMquot; =~ /([aeiou]\K[^aeiou])/g; print ;SPMquot;$;SPMamp;\n;SPMquot;
t
  DB;SPMlt;8;SPMgt; x @a
0  'al'
1  'ab'
2  'et'
<tex2html_mydb_mark>#1281#
  DB;SPMlt;23;SPMgt; $x = '  cadena entre blancos  '
  DB;SPMlt;24;SPMgt; ($y = $x) =~ s/.*\b\K.*//g
  DB;SPMlt;25;SPMgt; p ;SPMquot;;SPMlt;$y;SPMgt;;SPMquot;
;SPMlt;  cadena entre blancos;SPMgt;
<tex2html_mydb_mark>#1282#
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; ($b = $a = 'abc/xyz.something') =~ s{\.[^.]*$}{.txt}
  DB;SPMlt;2;SPMgt; p $b
abc/xyz.txt
  DB;SPMlt;3;SPMgt; ($b = $a = 'abc/xyz.something') =~ s/\.\K[^.]*$/txt/;
  DB;SPMlt;4;SPMgt; p $b
abc/xyz.txt
  DB;SPMlt;5;SPMgt; p $a
abc/xyz.something
<tex2html_mydb_mark>#1283#
  DB;SPMlt;6;SPMgt; x ($a = 'foo foo bar bar foo bar bar') =~ /foo(?!.*foo)/g; print pos($a).;SPMquot;\n;SPMquot;
19
  DB;SPMlt;7;SPMgt; x ($a = 'foo foo bar bar foo bar bar') =~ s/foo(?!.*foo)/\U$;SPMamp;/
0  1
  DB;SPMlt;8;SPMgt; x $a
0  'foo foo bar bar FOO bar bar'
<tex2html_mydb_mark>#1284#
/regexp(?![abc])/
<tex2html_mydb_mark>#1285#
/regexp(?=[^abc])/
<tex2html_mydb_mark>#1286#
;SPMgt; cat lookaheadneg.pl
#!/usr/bin/perl

 $a = ;SPMquot;452;SPMquot;;
 if ($a =~ m{\d+(?=[^.])}i) { print ;SPMquot;$a casa clase negada. \$;SPMamp; = $;SPMamp;\n;SPMquot;; }
 else { print ;SPMquot;$a no casa\n;SPMquot;; }
 if ($a =~ m{\d+(?!\.)}i) { print ;SPMquot;$a casa predicción negativa. \$;SPMamp; = $;SPMamp;\n;SPMquot;; }
 else { print ;SPMquot;$b no casa\n;SPMquot;; }
nereida:~/perl/src;SPMgt; lookaheadneg.pl
452 casa clase negada. $;SPMamp; = 45
452 casa predicción negativa. $;SPMamp; = 452
<tex2html_mydb_mark>#1287#
;SPMgt; cat estoyeso.pl
#!/usr/bin/perl

 my $a = shift;

 if ($a =~ m{^(?=.*?esto)(?=.*?eso)}i) { print ;SPMquot;$a matches.\n;SPMquot;; }
 else { print ;SPMquot;$a does not match\n;SPMquot;; }

;SPMgt;estoyeso.pl 'hola eso y esto'
hola eso y esto matches.
;SPMgt; estoyeso.pl 'hola esto y eso'
hola esto y eso matches.
;SPMgt; estoyeso.pl 'hola aquello y eso'
hola aquello y eso does not match
;SPMgt; estoyeso.pl 'hola esto y aquello'
hola esto y aquello does not match
<tex2html_mydb_mark>#1288#
pl@nereida:~/Lperltesting$ cat -n foobar.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $a = shift;
     5
     6  for my $r (q{(?;SPMlt;!foo)bar}, q{(?!foo)bar}, q{(?!foo)...bar}) {
     7    if ($a =~ /$r/) {
     8      say ;SPMquot;$a casa con $r;SPMquot;
     9    }
    10    else {
    11      say ;SPMquot;$a no casa con $r;SPMquot;
    12    }
    13  }
<tex2html_mydb_mark>#1289#
pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl foobar
foobar no casa con (?;SPMlt;!foo)bar
foobar casa con (?!foo)bar
foobar no casa con (?!foo)...bar

pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl bar
bar casa con (?;SPMlt;!foo)bar
bar casa con (?!foo)bar
bar no casa con (?!foo)...bar
<tex2html_mydb_mark>#1290#
        if (/bar/ and $` !~ /foo$/)
<tex2html_mydb_mark>#1291#
        if (/bar/p ;SPMamp;;SPMamp; ${^PREMATCH} =~ /foo$/)
<tex2html_mydb_mark>#1292#
pl@nereida:~/Lperltesting$ cat -n foobarprematch.pl
 1  use v5.10;
 2  use strict;
 3
 4  $_ = shift;
 5
 6  if (/bar/p ;SPMamp;;SPMamp; ${^PREMATCH} =~ /foo$/) {
 7    say ;SPMquot;$_ no cumple ;SPMquot;.q{/bar/p ;SPMamp;;SPMamp; ${^PREMATCH} =~ /foo$/};
 8  }
 9  else {
10    say ;SPMquot;$_ cumple ;SPMquot;.q{/bar/p ;SPMamp;;SPMamp; ${^PREMATCH} =~ /foo$/};
11  }
12  if (/(?;SPMlt;!foo)bar/) {
13    say ;SPMquot;$_ casa con (?;SPMlt;!foo)bar;SPMquot;
14  }
15  else {
16    say ;SPMquot;$_ no casa con (?;SPMlt;!foo)bar;SPMquot;
17  }
<tex2html_mydb_mark>#1293#
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl bar
bar cumple /bar/p ;SPMamp;;SPMamp; ${^PREMATCH} =~ /foo$/
bar casa con (?;SPMlt;!foo)bar
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl foobar
foobar no cumple /bar/p ;SPMamp;;SPMamp; ${^PREMATCH} =~ /foo$/
foobar no casa con (?;SPMlt;!foo)bar
<tex2html_mydb_mark>#1294#
  DB;SPMlt;1;SPMgt; x 'abc' =~ /(?=(.)(.)(.))a(b)/
<tex2html_mydb_mark>#1295#
s/,/, /g;
<tex2html_mydb_mark>#1296#
s/,/, /g;
<tex2html_mydb_mark>#1297#
<pre>
pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n ABC123</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  use warnings;</span>
<span class="synConstant">     2  use strict;</span>
<span class="synConstant">     3</span>
<span class="synConstant">     4  my </span><span class="synIdentifier">$c</span><span class="synConstant"> = 0;</span>
<span class="synConstant">     5  my </span><span class="synIdentifier">@p</span><span class="synConstant"> = </span><span class="synSpecial">(</span><span class="synConstant">'^</span><span class="synSpecial">(</span><span class="synConstant">ABC</span><span class="synSpecial">)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">', '^</span><span class="synSpecial">(\D*)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">',</span><span class="synSpecial">)</span><span class="synConstant">;</span>
<span class="synConstant">     6</span>
<span class="synConstant">     7  for my </span><span class="synIdentifier">$r</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@p</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     8    for my </span><span class="synIdentifier">$s</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synConstant">qw{ABC123 ABC445}</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     9      </span><span class="synIdentifier">$c</span><span class="synSpecial">++</span><span class="synConstant">;</span>
<span class="synConstant">    10      print ;SPMquot;</span><span class="synIdentifier">$c</span><span class="synConstant">: '</span><span class="synIdentifier">$s</span><span class="synConstant">' =~ </span><span class="synStatement">/</span><span class="synIdentifier">$r</span>/ : <span class="synConstant">;SPMquot;;</span>
<span class="synConstant">    11      ;SPMlt;;SPMgt;;</span>
<span class="synConstant">    12      if (</span><span class="synIdentifier">$s</span><span class="synConstant"> =~ /</span><span class="synIdentifier">$r</span><span class="synConstant">/) {</span>
<span class="synConstant">    13        print ;SPMquot;</span> YES (<span class="synIdentifier">$1</span>)\n<span class="synConstant">;SPMquot;;</span>
<span class="synConstant">    14      }</span>
<span class="synConstant">    15      else {</span>
<span class="synConstant">    16        print ;SPMquot;</span> NO\n<span class="synConstant">;SPMquot;;</span>
<span class="synConstant">    17      }</span>
<span class="synConstant">    18    }</span>
<span class="synConstant">    19  }</span>
</pre>
<tex2html_mydb_mark>#1298#
pl@nereida:~/Lperltesting$ cat -n definingnamedpatterns.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3
 4  my $regexp = qr{
 5     ^ (?;SPMlt;num;SPMgt;
 6               (?;SPMamp;osg)[\t\ ]* (?: (?;SPMamp;int)(?;SPMamp;dec)? | (?;SPMamp;dec) )
 7       )
 8       (?: [eE]
 9       (?;SPMlt;exp;SPMgt; (?;SPMamp;osg)(?;SPMamp;int)) )?
10     $
11        (?(DEFINE)
12         (?;SPMlt;osg;SPMgt;[-+]?)         # optional sign
13         (?;SPMlt;int;SPMgt;\d++)          # integer
14         (?;SPMlt;dec;SPMgt;\.(?;SPMamp;int))     # decimal fraction
15        )
16  }x;
17
18  my $input = ;SPMlt;;SPMgt;;
19  chomp($input);
20  my @r;
21  if (@r = $input =~ $regexp) {
22    my $exp = $+{exp} || '';
23    say ;SPMquot;$input matches: (num =;SPMgt; '$+{num}', exp =;SPMgt; '$exp');SPMquot;;
24  }
25  else {
26    say ;SPMquot;does not match;SPMquot;;
27  }
<tex2html_mydb_mark>#1299#
   1. /(?;SPMlt;NAME;SPMgt;(?;SPMamp;NAME_PAT))(?;SPMlt;ADDR;SPMgt;(?;SPMamp;ADDRESS_PAT))
   2.        (?(DEFINE)
   3.          (?;SPMlt;NAME_PAT;SPMgt;....)
   4.          (?;SPMlt;ADRESS_PAT;SPMgt;....)
   5. )/x
<tex2html_mydb_mark>#1300#
   1. 'foo' =~ /(?;SPMlt;foo;SPMgt;foo)/;
<tex2html_mydb_mark>#1301#
   1. if ('1234' =~ /(?;SPMlt;A;SPMgt;1)(?;SPMlt;B;SPMgt;2)(?;SPMlt;A;SPMgt;3)(?;SPMlt;B;SPMgt;4)/) {
   2.   foreach my $bufname (sort keys %-) {
   3.     my $ary = $-{$bufname};
   4.     foreach my $idx (0..$#$ary) {
   5.       print ;SPMquot;\$-{$bufname}[$idx] : ;SPMquot;,
   6.             (defined($ary-;SPMgt;[$idx]) ? ;SPMquot;'$ary-;SPMgt;[$idx]';SPMquot; : ;SPMquot;undef;SPMquot;),
   7.             ;SPMquot;\n;SPMquot;;
   8.     }
   9.   }
  10. }
<tex2html_mydb_mark>#1302#
   1. $-{A}[0] : '1'
   2. $-{A}[1] : '3'
   3. $-{B}[0] : '2'
   4. $-{B}[1] : '4'
<tex2html_mydb_mark>#1303#
<pre>
casiano<span class="synIdentifier">@millo</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n palindromos</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
     <span class="synConstant">3</span>
     <span class="synConstant">4</span>  <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span>
<span class="synConstant">     5                       </span><span class="synSpecial">(?:</span>
<span class="synConstant">     6                             </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\g</span><span class="synConstant">{-1}  # palindromo estricto</span>
<span class="synConstant">     7                           |</span>
<span class="synConstant">     8                             </span><span class="synSpecial">\w?</span><span class="synConstant">               # no recursiva</span>
<span class="synConstant">     9                       </span><span class="synSpecial">)</span>
<span class="synConstant">    10                    </span><span class="synSpecial">\W*)</span><span class="synConstant">$/ix</span>;
    <span class="synConstant">11</span>
    <span class="synConstant">12</span>  <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
    <span class="synConstant">13</span>  <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
    <span class="synConstant">14</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
    <span class="synConstant">15</span>    say <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome;SPMquot;</span>;
    <span class="synConstant">16</span>  }
    <span class="synConstant">17</span>  <span class="synStatement">else</span> {
    <span class="synConstant">18</span>    say <span class="synConstant">;SPMquot;does not match;SPMquot;</span>;
    <span class="synConstant">19</span>  }
</pre>
<tex2html_mydb_mark>#1304#
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a canal: Panama!</span>
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cam, a yak, a yam, a canal – Panama!</span>
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!</span>
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">saippuakauppias</span>
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">dfghjgfd</span>
does not match
<span class="dbuser">pl@nereida:~/Lperltesting$ ./palindromos.pl</span>
<span class="dbuser">...,;;;;</span>
...,;;;; is a palindrome
</pre>
<tex2html_mydb_mark>#1305#
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt;  x ($a = ;SPMquot;12 aAbB 34;SPMquot;) =~ s/([aA])(?-1)(?+1)([bB])/-\1\2-/g
0  1
  DB;SPMlt;2;SPMgt; p $a
12 -aB- 34
<tex2html_mydb_mark>#1306#
<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat perlrebalancedpar</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span>  <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(</span><span class="synConstant">                      # paren group 1 </span><span class="synSpecial">(</span><span class="synConstant">full function</span><span class="synSpecial">)</span>
<span class="synLinenum">    7</span> <span class="synConstant">                foo</span>
<span class="synLinenum">    8</span> <span class="synConstant">                   </span><span class="synSpecial">(</span><span class="synConstant">                    # paren group 2 </span><span class="synSpecial">(</span><span class="synConstant">parens</span><span class="synSpecial">)</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">\(</span>
<span class="synLinenum">   10</span> <span class="synConstant">                        </span><span class="synSpecial">(</span><span class="synConstant">               # paren group 3 </span><span class="synSpecial">(</span><span class="synConstant">contents of parens</span><span class="synSpecial">)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                </span><span class="synSpecial">[^()]+</span><span class="synConstant">  # Non-parens</span>
<span class="synLinenum">   13</span> <span class="synConstant">                              |</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                </span><span class="synSpecial">(?</span><span class="synConstant">2</span><span class="synSpecial">)</span><span class="synConstant"> # Recurse to start of paren group 2</span>
<span class="synLinenum">   15</span> <span class="synConstant">                           </span><span class="synSpecial">)*</span>
<span class="synLinenum">   16</span> <span class="synConstant">                        </span><span class="synSpecial">)</span><span class="synConstant">               # 3</span>
<span class="synLinenum">   17</span> <span class="synConstant">                     </span><span class="synSpecial">\)</span>
<span class="synLinenum">   18</span> <span class="synConstant">                    </span><span class="synSpecial">)</span><span class="synConstant">                   # 2</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span><span class="synConstant">                         # 1</span>
<span class="synLinenum">   20</span> <span class="synConstant">    }x</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">my</span> <span class="synIdentifier">@res</span> = (<span class="synIdentifier">$input</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$regexp</span><span class="synStatement">/</span>);
<span class="synLinenum">   25</span> <span class="synStatement">if</span> (<span class="synIdentifier">@res</span>) {
<span class="synLinenum">   26</span>   say <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">;SPMgt; is balanced</span><span class="synSpecial">\n</span><span class="synConstant">Paren: (</span><span class="synIdentifier">@res</span><span class="synConstant">);SPMquot;</span>;
<span class="synLinenum">   27</span> }
<span class="synLinenum">   28</span> <span class="synStatement">else</span> {
<span class="synLinenum">   29</span>   say <span class="synConstant">;SPMquot;does not match;SPMquot;</span>;
<span class="synLinenum">   30</span> }
</pre>
<tex2html_mydb_mark>#1307#
<pre>
pl@nereida:~/Lperltesting$  <span class="dbuser">./perlrebalancedpar.pl</span>
<span class="dbuser">foo(bar(baz)+baz(bop))</span>
;SPMlt;foo(bar(baz)+baz(bop));SPMgt; is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
</pre>
<tex2html_mydb_mark>#1308#
   1. my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
   2. if (/foo $parens \s+ + \s+ bar $parens/x) {
   3.   # do something here...
   4. }
<tex2html_mydb_mark>#1309#
<pre>
<span class="synLinenum">    1</span>   pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocks</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span>   <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span>   
<span class="synLinenum">    7</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">      </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">        </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">               </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">           |</span>
<span class="synLinenum">   13</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   14</span> <span class="synConstant">                </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">     # recursivo</span>
<span class="synLinenum">   15</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   16</span> <span class="synConstant">           </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   17</span> <span class="synConstant">         </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">    }</span>;
<span class="synLinenum">   20</span>   
<span class="synLinenum">   21</span>   <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   25</span>   say(<span class="synIdentifier">$i</span>++.<span class="synConstant">;SPMquot;:</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">===;SPMquot;</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>
<tex2html_mydb_mark>#1310#
pl@nereida:~/Lperltesting$ cat -n blocks.c
     1  main() { /* 1 */
     2    { /* 2 */ }
     3    { /* 3 */ }
     4  }
     5
     6  f(){  /* 4 */
     7    {   /* 5 */
     8      { /* 6 */ }
     9    }
    10    {   /* 7 */
    11      { /* 8 */ }
    12    }
    13  }
    14
    15  g(){ /* 9 */
    16  }
    17
    18  h() {
    19  {{{}}}
    20  }
    21  /* end h */
<tex2html_mydb_mark>#1311#
pl@nereida:~/Lperltesting$ perl5.10.1 blocks.pl blocks.c
0:
{ /* 1 */
  { /* 2 */ }
  { /* 3 */ }
}
===
1:
{  /* 4 */
  {   /* 5 */
    { /* 6 */ }
  }
  {   /* 7 */
    { /* 8 */ }
  }
}
===
2:
{ /* 9 */
}
===
3:
{
{{{}}}
}
===
<tex2html_mydb_mark>#1312#
<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat latex5_10</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    7</span> <span class="synConstant">    </span><span class="synSpecial">\A(?</span><span class="synConstant">;SPMamp;File</span><span class="synSpecial">)\z</span>
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synConstant">    </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;File;SPMgt;     </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;Element</span><span class="synSpecial">)*+\s*</span>
<span class="synLinenum">   11</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> 
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;Element;SPMgt;  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;Command</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                  |  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;Literal</span><span class="synSpecial">)</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;Command;SPMgt;  </span><span class="synSpecial">\\</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;L;SPMgt;</span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;Literal</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;Op;SPMgt;</span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;Options</span><span class="synSpecial">)?)</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;A;SPMgt;</span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;Args</span><span class="synSpecial">))</span>
<span class="synLinenum">   18</span> <span class="synConstant">           </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   19</span> <span class="synConstant">              say ;SPMquot;command: ;SPMlt;</span><span class="synIdentifier">$+</span><span class="synConstant">{L}</span>;SPMgt; options: ;SPMlt;<span class="synIdentifier">$+</span>{Op};SPMgt; args: ;SPMlt;<span class="synIdentifier">$+</span>{A};SPMgt;<span class="synConstant">;SPMquot;</span>
<span class="synLinenum">   20</span> <span class="synConstant">           })</span>
<span class="synLinenum">   21</span> <span class="synConstant">        )</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span> <span class="synConstant">        (?;SPMlt;Options;SPMgt;  </span><span class="synSpecial">\[</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?:(?;SPMamp;Option) (?:</span><span class="synSpecial">\s</span><span class="synConstant">*,</span><span class="synSpecial">\s</span><span class="synConstant">* (?;SPMamp;Option) )*)? </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">\]</span>
<span class="synLinenum">   24</span> <span class="synConstant">        )</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">        (?;SPMlt;Args;SPMgt;     (?: </span><span class="synSpecial">&#92;{</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?;SPMamp;Element)* </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">&#92;}</span><span class="synConstant"> )*</span>
<span class="synLinenum">   27</span> <span class="synConstant">        )</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        (?;SPMlt;Option;SPMgt;   </span><span class="synSpecial">\s</span><span class="synConstant">* [^][</span><span class="synSpecial">\$</span><span class="synConstant">;SPMamp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">,]+</span>
<span class="synLinenum">   30</span> <span class="synConstant">        )</span>
<span class="synLinenum">   31</span> 
<span class="synLinenum">   32</span> <span class="synConstant">        (?;SPMlt;Literal;SPMgt;  </span><span class="synSpecial">\s</span><span class="synConstant">* ([^][</span><span class="synSpecial">\$</span><span class="synConstant">;SPMamp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">]+)</span>
<span class="synLinenum">   33</span> <span class="synConstant">        )</span>
<span class="synLinenum">   34</span> <span class="synConstant">    )</span>
<span class="synLinenum">   35</span> <span class="synConstant">}xms;</span>
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span> <span class="synConstant">my </span><span class="synIdentifier">$input</span><span class="synConstant"> = do{ local </span><span class="synIdentifier">$/</span><span class="synConstant">; ;SPMlt;;SPMgt;};</span>
<span class="synLinenum">   38</span> <span class="synConstant">if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$regexp</span><span class="synConstant">) {</span>
<span class="synLinenum">   39</span> <span class="synConstant">  say ;SPMquot;</span><span class="synIdentifier">$@</span>: matches:\n<span class="synIdentifier">$;SPMamp;</span><span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   40</span> <span class="synConstant">}</span>
<span class="synLinenum">   41</span> <span class="synConstant">else {</span>
<span class="synLinenum">   42</span> <span class="synConstant">  say ;SPMquot;</span>does <span class="synStatement">not</span> match<span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   43</span> <span class="synConstant">}</span>
</pre>
<tex2html_mydb_mark>#1313#
         (?;SPMlt;Command;SPMgt;  \\ \s* (?;SPMlt;L;SPMgt;(?;SPMamp;Literal)) \s* (?;SPMlt;Op;SPMgt;(?;SPMamp;Options)?) \s* (?;SPMlt;A;SPMgt;(?;SPMamp;Args)?)
            (?{
               say ;SPMquot;command: ;SPMlt;$+{L};SPMgt; options: ;SPMlt;$+{Op};SPMgt; args: ;SPMlt;$+{A};SPMgt;;SPMquot;
            })
         )
<tex2html_mydb_mark>#1314#
pl@nereida:~/Lperltesting$ cat prueba.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba.tex
command: ;SPMlt;documentclass;SPMgt; options: ;SPMlt;[a4paper,11pt];SPMgt; args: ;SPMlt;{article};SPMgt;
command: ;SPMlt;usepackage;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{latexsym};SPMgt;
command: ;SPMlt;author;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{D. Conway};SPMgt;
command: ;SPMlt;LaTeX;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{};SPMgt;
command: ;SPMlt;title;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{Parsing \LaTeX{}};SPMgt;
command: ;SPMlt;begin;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{document};SPMgt;
command: ;SPMlt;maketitle;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;;SPMgt;
command: ;SPMlt;tableofcontents;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;;SPMgt;
command: ;SPMlt;section;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{Description};SPMgt;
command: ;SPMlt;emph;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{necessarily};SPMgt;
command: ;SPMlt;footnote;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{But not\\ \emph{necessarily} simple};SPMgt;
command: ;SPMlt;end;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{document};SPMgt;
: matches:
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}
<tex2html_mydb_mark>#1315#
pl@nereida:~/Lperltesting$ cat prueba3.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
\comm{a}{b}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
$In$ fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba3.tex
command: ;SPMlt;documentclass;SPMgt; options: ;SPMlt;[a4paper,11pt];SPMgt; args: ;SPMlt;{article};SPMgt;
command: ;SPMlt;usepackage;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{latexsym};SPMgt;
command: ;SPMlt;author;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{D. Conway};SPMgt;
command: ;SPMlt;LaTeX;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{};SPMgt;
command: ;SPMlt;title;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{Parsing \LaTeX{}};SPMgt;
command: ;SPMlt;begin;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{document};SPMgt;
command: ;SPMlt;maketitle;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;;SPMgt;
command: ;SPMlt;tableofcontents;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;;SPMgt;
command: ;SPMlt;section;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{Description};SPMgt;
command: ;SPMlt;comm;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{a}{b};SPMgt;
command: ;SPMlt;emph;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{necessarily};SPMgt;
command: ;SPMlt;footnote;SPMgt; options: ;SPMlt;;SPMgt; args: ;SPMlt;{But not\\ \emph{necessarily} simple};SPMgt;
does not match
<tex2html_mydb_mark>#1316#
 10          (?;SPMlt;File;SPMgt;     (?;SPMamp;Element)*+\s*
 11          )
<tex2html_mydb_mark>#1317#
<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    7</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;EXPR;SPMgt;</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;TERM;SPMgt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;ID;SPMgt;</span><span class="synSpecial">[a-zA-Z]+)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;INT;SPMgt;</span><span class="synSpecial">[1-9]\d*)</span>
<span class="synLinenum">   12</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\(</span>
<span class="synLinenum">   13</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;EXPR</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\)</span>
<span class="synLinenum">   15</span> <span class="synConstant">                     </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant">           # possibly followed by a sequence of </span><span class="synSpecial">...</span>
<span class="synLinenum">   16</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;OP;SPMgt;</span><span class="synSpecial">[-+*/])</span>
<span class="synLinenum">   17</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;TERM</span><span class="synSpecial">)</span><span class="synConstant">        # </span><span class="synSpecial">...</span><span class="synConstant"> operand TERM pairs</span>
<span class="synLinenum">   18</span> <span class="synConstant">                       </span><span class="synSpecial">)*</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   20</span> <span class="synConstant">            }x</span>;
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   22</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   25</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   26</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   28</span>               );
<span class="synLinenum">   29</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   30</span>     say(<span class="synConstant">;SPMquot;</span><span class="synIdentifier">$_</span><span class="synConstant">:;SPMquot;</span>);
<span class="synLinenum">   31</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">;SPMquot;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMlt;</span><span class="synIdentifier">$_</span><span class="synConstant">;SPMgt; is valid;SPMquot;</span> : <span class="synConstant">;SPMquot;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMlt;</span><span class="synIdentifier">$_</span><span class="synConstant">;SPMgt; is not valid;SPMquot;</span>)
<span class="synLinenum">   32</span>   }
</pre>
<tex2html_mydb_mark>#1318#
<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">   10</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;EXPR;SPMgt;</span>
<span class="synLinenum">   11</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;TERM;SPMgt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   12</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;ID;SPMgt;</span><span class="synSpecial">[a-zA-Z]+)</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">{ print ;SPMquot;</span><span class="synSpecial">[ID $+{ID}]</span><span class="synConstant"> ;SPMquot;  }</span>)
<span class="synLinenum">   13</span>                           | <span class="synIdentifier">$skip</span> (?<span class="synIdentifier">;SPMlt;INT;SPMgt;</span>[<span class="synConstant">1-9</span>]\d*)  (?{ <span class="synStatement">print</span> <span class="synConstant">;SPMquot;[INT </span><span class="synIdentifier">$+</span><span class="synConstant">{INT}] ;SPMquot;</span> })
<span class="synLinenum">   14</span>                           | <span class="synIdentifier">$skip</span> \(                (?{ <span class="synStatement">print</span> <span class="synConstant">;SPMquot;[(] ;SPMquot;</span> })
<span class="synLinenum">   15</span>                             <span class="synIdentifier">$skip</span>  (?<span class="synIdentifier">;SPMamp;EXPR</span>)
<span class="synLinenum">   16</span>                             <span class="synIdentifier">$skip</span> \)                (?{ <span class="synStatement">print</span> <span class="synConstant">;SPMquot;[)] ;SPMquot;</span> })
<span class="synLinenum">   17</span>                      ) (?: <span class="synIdentifier">$skip</span>           <span class="synComment"># possibly followed by a sequence of ...</span>
<span class="synLinenum">   18</span>                            (?<span class="synIdentifier">;SPMlt;OP;SPMgt;</span>[-+*/])            (?{ <span class="synStatement">print</span> <span class="synConstant">;SPMquot;[OP </span><span class="synIdentifier">$+</span><span class="synConstant">{OP}] ;SPMquot;</span> })
<span class="synLinenum">   19</span>                            (?<span class="synIdentifier">;SPMamp;TERM</span>)        <span class="synComment"># ... operand TERM pairs</span>
<span class="synLinenum">   20</span>                        )*
<span class="synLinenum">   21</span>               )
<span class="synLinenum">   22</span>             }x;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   24</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   28</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   29</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   30</span>               );
<span class="synLinenum">   31</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   32</span>     say(<span class="synConstant">;SPMquot;</span><span class="synIdentifier">$_</span><span class="synConstant">:;SPMquot;</span>);
<span class="synLinenum">   33</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">;SPMquot;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMlt;</span><span class="synIdentifier">$_</span><span class="synConstant">;SPMgt; is valid;SPMquot;</span> : <span class="synConstant">;SPMquot;</span><span class="synSpecial">\n</span><span class="synConstant">;SPMlt;</span><span class="synIdentifier">$_</span><span class="synConstant">;SPMgt; is not valid;SPMquot;</span>)
<span class="synLinenum">   34</span>   }
</pre>
<tex2html_mydb_mark>#1319#
pl@nereida:~/Lperltesting$ ./simpleexpressions.pl
(a + 3):
[(] [ID a] [OP +] [INT 3] [)]
;SPMlt;(a + 3);SPMgt; is valid
(3 * 4)+(b + x):
[(] [INT 3] [OP *] [INT 4] [)] [OP +] [(] [ID b] [OP +] [ID x] [)]
;SPMlt;(3 * 4)+(b + x);SPMgt; is valid
(5 - a)*z:
[(] [INT 5] [OP -] [ID a] [)] [OP *] [ID z]
;SPMlt;(5 - a)*z;SPMgt; is valid
((5 - a))*((((z)))+2):
[(] [(] [INT 5] [OP -] [ID a] [)] [)] [OP *] [(] [(] [(] [(] [ID z] [)] [)] [)] [OP +] [INT 2] [)]
;SPMlt;((5 - a))*((((z)))+2);SPMgt; is valid
3 + 2:
[INT 3] [OP +] [INT 2]
;SPMlt;3 + 2;SPMgt; is valid
!3 + 2:

;SPMlt;!3 + 2;SPMgt; is not valid
3 + 2!:
[INT 3] [OP +] [INT 2]
;SPMlt;3 + 2!;SPMgt; is not valid
3 a:
[INT 3]
;SPMlt;3 a;SPMgt; is not valid
3 3:
[INT 3]
;SPMlt;3 3;SPMgt; is not valid
3 * * 3:
[INT 3] [OP *]
;SPMlt;3 * * 3;SPMgt; is not valid
2 - 3 * 4:
[INT 2] [OP -] [INT 3] [OP *] [INT 4]
;SPMlt;2 - 3 * 4;SPMgt; is valid
2 - 3 + 4:
[INT 2] [OP -] [INT 3] [OP +] [INT 4]
;SPMlt;2 - 3 + 4;SPMgt; is valid
<tex2html_mydb_mark>#1320#
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x 'aaaa' =~ /(a+a)/
0  'aaaa'
  DB;SPMlt;2;SPMgt; x 'aaaa' =~ /(a++a)/
  empty array
<tex2html_mydb_mark>#1321#
pl@nereida:~/Lperltesting$ cat -n ./quotedstrings.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
     2  use v5.10;
     3
     4  my $regexp = qr/
     5    ;SPMquot;             # double quote
     6    (?:           # no memory
     7        [^;SPMquot;\\]++  # no ;SPMquot; or escape: Don't backtrack
     8      | \\.       # escaped character
     9    )*+
    10    ;SPMquot;             # end double quote
    11  /x;
    12
    13  my $input = ;SPMlt;;SPMgt;;
    14  chomp($input);
    15  if ($input =~ $regexp) {
    16    say ;SPMquot;$;SPMamp; is a string;SPMquot;;
    17  }
    18  else {
    19    say ;SPMquot;does not match;SPMquot;;
    20  }
<tex2html_mydb_mark>#1322#
pl@nereida:~/Lperltesting$ cat -n ./balancedparenthesis.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3
 4  my $regexp =
 5      qr/^(
 6             [^()]*+ # no hay paréntesis, no backtrack
 7            \(
 8                (?;SPMgt;        # subgrupo posesivo
 9                   [^()]++ # no hay paréntesis, + posesivo, no backtrack
10                  |(?1)    # o es un paréntesis equilibrado
11                )*
12             \)
13             [^()]*+ # no hay paréntesis
14           )$/x;
15
16  my $input = ;SPMlt;;SPMgt;;
17  chomp($input);
18  if ($input =~ $regexp) {
19    say ;SPMquot;$;SPMamp; is a balanced parenthesis;SPMquot;;
20  }
21  else {
22    say ;SPMquot;does not match;SPMquot;;
23  }
<tex2html_mydb_mark>#1323#
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5)*2
(2*(3+4)-5)*2 is a balanced parenthesis
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5))*2
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
2*(3+4
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
4*(2*(3+4)-5)*2
4*(2*(3+4)-5)*2 is a balanced parenthesis
<tex2html_mydb_mark>#1324#
<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocksopti</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">    </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">      </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">         </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">         |</span>
<span class="synLinenum">   13</span> <span class="synConstant">             </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">      # recursivo</span>
<span class="synLinenum">   14</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   15</span> <span class="synConstant">         </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   16</span> <span class="synConstant">       </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   17</span> <span class="synConstant">    </span><span class="synSpecial">)</span>
<span class="synLinenum">   18</span> <span class="synConstant">  }</span>;
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   21</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   22</span> <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   23</span> <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   24</span> say(<span class="synIdentifier">$i</span>++.<span class="synConstant">;SPMquot;:</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">===;SPMquot;</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>
<tex2html_mydb_mark>#1325#
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; '23:12' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print ;SPMquot;1-;SPMgt;$1 2-;SPMgt;$2\n;SPMquot;
1-;SPMgt;23 2-;SPMgt;12

  DB;SPMlt;2;SPMgt; '2312' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print ;SPMquot;3-;SPMgt;$3 4-;SPMgt;$4\n;SPMquot;
3-;SPMgt;23 4-;SPMgt;12
<tex2html_mydb_mark>#1326#
  DB;SPMlt;3;SPMgt; '2312' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print ;SPMquot;1-;SPMgt;$1 2-;SPMgt;$2\n;SPMquot;
1-;SPMgt;23 2-;SPMgt;12

  DB;SPMlt;4;SPMgt; '23:12' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print ;SPMquot;1-;SPMgt;$1 2-;SPMgt;$2\n;SPMquot;
1-;SPMgt;23 2-;SPMgt;12
<tex2html_mydb_mark>#1327#
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $x = ;SPMquot;abcdef;SPMquot;
  DB;SPMlt;2;SPMgt; $x =~ /abc(?{ ;SPMquot;Hi mom\n;SPMquot; })def(?{ print $^R })$/
Hi mom
  DB;SPMlt;3;SPMgt; $x =~ /abc(?{ print ;SPMquot;Hi mom\n;SPMquot;; 4 })def(?{ print ;SPMquot;$^R\n;SPMquot; })/
Hi mom
4
  DB;SPMlt;4;SPMgt; $x =~ /abc(?{ print ;SPMquot;Hi mom\n;SPMquot;; 4 })ddd(?{ print ;SPMquot;$^R\n;SPMquot; })/ # does not match
  DB;SPMlt;5;SPMgt;
<tex2html_mydb_mark>#1328#
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $x = ;SPMquot;The brown fox jumps over the lazy dog;SPMquot;
  DB;SPMlt;2;SPMgt; x $x =~ /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i
0  'brown'
1  'fox'
  DB;SPMlt;3;SPMgt; p ;SPMquot;color=$color animal=$animal\n;SPMquot;
color=brown animal=fox
  DB;SPMlt;4;SPMgt; $x =~ /the (\S+)(?{ print (substr($_,0,pos($_))).;SPMquot;\n;SPMquot; }) (\S+)/i
The brown
<tex2html_mydb_mark>#1329#
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $x = ;SPMquot;aaaa;SPMquot;
  DB;SPMlt;2;SPMgt;  $x =~ /(a(?{ $c++ }))*/
  DB;SPMlt;3;SPMgt; p $c
4
  DB;SPMlt;4;SPMgt; $y = ;SPMquot;abcd;SPMquot;
  DB;SPMlt;5;SPMgt; $y =~ /(?:(.)(?{ print ;SPMquot;-$1-\n;SPMquot; }))*/
-a-
-b-
-c-
-d-
<tex2html_mydb_mark>#1330#
<pre>
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  <span class="synStatement">use strict</span>;

  <span class="synStatement">our</span> (<span class="synIdentifier">$cnt</span>, <span class="synIdentifier">$res</span>);

<span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> echo </span>{
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$pre</span> = <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">0</span>,<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>));
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$post</span> = (<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>) ;SPMlt; <span class="synStatement">length</span>)? (<span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">1</span>+<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>))) : <span class="synConstant">''</span>;

    <span class="synStatement">print</span>(<span class="synConstant">;SPMquot;</span><span class="synIdentifier">$pre</span><span class="synConstant">(count = </span><span class="synIdentifier">$cnt</span><span class="synConstant">)</span><span class="synIdentifier">$post</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>);
  }

  <span class="synIdentifier">$_</span> = <span class="synConstant">'a'</span> x <span class="synConstant">8</span>;
  m;SPMlt;
    (?{ <span class="synIdentifier">$cnt</span> = <span class="synConstant">0</span> }) <span class="synComment"># Initialize $cnt.</span>
    (
      a
      (?{
        <span class="synStatement">local</span> <span class="synIdentifier">$cnt</span> = <span class="synIdentifier">$cnt</span> + <span class="synConstant">1</span>; <span class="synComment"># Update $cnt, backtracking-safe.</span>
        echo();
      })
    )*
    aaaa
    (?{ <span class="synIdentifier">$res</span> = <span class="synIdentifier">$cnt</span> }) <span class="synComment"># On success copy to non-localized</span>
    <span class="synComment"># location.</span>
  ;SPMgt;x;

  <span class="synStatement">print</span> <span class="synConstant">;SPMquot;FINAL RESULT: cnt = </span><span class="synIdentifier">$cnt</span><span class="synConstant"> res =</span><span class="synIdentifier">$res</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
</pre>
<tex2html_mydb_mark>#1331#
pl@nereida:~/Lperltesting$ perl5.8.8 -w embededcodescope.pl
a(count = 1)aaaaaa
aa(count = 2)aaaaa
aaa(count = 3)aaaa
aaaa(count = 4)aaa
aaaaa(count = 5)aa
aaaaaa(count = 6)a
aaaaaaa(count = 7)
aaaaaaaa(count = 8)
FINAL RESULT: cnt = 0 res =4
<tex2html_mydb_mark>#1332#
   1. $re = ;SPMlt;;SPMgt;;
   2. chomp $re;
   3. $string =~ /$re/;
<tex2html_mydb_mark>#1333#
<pre>
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$;SPMquot;</span> = <span class="synConstant">;SPMquot;, ;SPMquot;</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;i;SPMgt; </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;j;SPMgt; </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say ;SPMquot;main </span><span class="synSpecial">\$+</span><span class="synConstant"> hash:;SPMquot;;</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say ;SPMquot; </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =;SPMgt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">;SPMquot; for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?;SPMlt;expr;SPMgt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?;SPMlt;i;SPMgt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?;SPMlt;j;SPMgt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say ;SPMquot;</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say ;SPMquot;</span> (<span class="synIdentifier">$_</span> =;SPMgt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">;SPMquot; for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = ;SPMlt;;SPMgt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say ;SPMquot;</span>matches: (<span class="synIdentifier">$;SPMamp;</span>)<span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>
<tex2html_mydb_mark>#1334#
pl@nereida:~/Lperltesting$ ./clashofnamedofssets.pl
abab
expr $+ hash:
 (i =;SPMgt; a)
 (j =;SPMgt; b)
expr $+ hash:
 (i =;SPMgt; ab)
 (j =;SPMgt; b)
main $+ hash:
 (i =;SPMgt; ab)
 (j =;SPMgt; ab)
matches: (abab)
<tex2html_mydb_mark>#1335#
<pre>
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$;SPMquot;</span> = <span class="synConstant">;SPMquot;, ;SPMquot;</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;i;SPMgt; </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;j;SPMgt; </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say ;SPMquot;main </span><span class="synSpecial">\$+</span><span class="synConstant"> hash:;SPMquot;;</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say ;SPMquot; </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =;SPMgt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">;SPMquot; for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?;SPMlt;expr;SPMgt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?;SPMlt;i_e;SPMgt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?;SPMlt;j_e;SPMgt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say ;SPMquot;</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say ;SPMquot;</span> (<span class="synIdentifier">$_</span> =;SPMgt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">;SPMquot; for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = ;SPMlt;;SPMgt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say ;SPMquot;</span>matches: (<span class="synIdentifier">$;SPMamp;</span>)<span class="synConstant">;SPMquot;;</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>
<tex2html_mydb_mark>#1336#
pl@nereida:~/Lperltesting$ ./namedoffsets.pl
abab
expr $+ hash:
 (i_e =;SPMgt; a)
 (j_e =;SPMgt; b)
expr $+ hash:
 (i =;SPMgt; ab)
 (i_e =;SPMgt; a)
 (j_e =;SPMgt; b)
main $+ hash:
 (i =;SPMgt; ab)
 (j =;SPMgt; ab)
matches: (abab)
<tex2html_mydb_mark>#1337#
                (??{ Código Perl })
<tex2html_mydb_mark>#1338#
<pre>
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              </span><span class="synSpecial">([ab])</span><span class="synConstant">             # save 'a' or 'b' in </span><span class="synSpecial">\$</span><span class="synConstant">1</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(??</span><span class="synConstant">{ ;SPMquot;</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant">;SPMquot;x3 }</span>)  <span class="synComment"># 3 more of the same as in \$1</span>
<span class="synLinenum">    8</span>             };
<span class="synLinenum">    9</span>   say <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">;SPMgt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-;SPMquot;</span> <span class="synStatement">if</span> <span class="synConstant">'bbbb'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   10</span>   say <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">;SPMgt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-;SPMquot;</span> <span class="synStatement">if</span> <span class="synConstant">'aaaa'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   11</span>   say <span class="synConstant">;SPMquot;;SPMlt;abab;SPMgt; didn't match;SPMquot;</span> <span class="synStatement">unless</span> <span class="synConstant">'abab'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   12</span>   say <span class="synConstant">;SPMquot;;SPMlt;aaab;SPMgt; didn't match;SPMquot;</span> <span class="synStatement">unless</span> <span class="synConstant">'aaab'</span> =~ <span class="synIdentifier">$r</span>;
</pre>
<tex2html_mydb_mark>#1339#
pl@nereida:~/Lperltesting$ ./postponedregexp.pl
;SPMlt;bbbb;SPMgt; lastpar = 1
;SPMlt;aaaa;SPMgt; lastpar = 1
;SPMlt;abab;SPMgt; didn't match
;SPMlt;aaab;SPMgt; didn't match
<tex2html_mydb_mark>#1340#
<pre>
pl@nereida:~/Lperltesting$ cat -n intints.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">           </span><span class="synSpecial">(\d)</span><span class="synConstant">                # a digit</span>
<span class="synLinenum">    7</span> <span class="synConstant">           </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">(??</span><span class="synConstant">{</span>
<span class="synLinenum">    8</span> <span class="synConstant">               ;SPMquot;</span><span class="synSpecial">\\</span><span class="synConstant">d{</span><span class="synIdentifier">$^</span><span class="synConstant">N};SPMquot;      # as many as the former</span>
<span class="synLinenum">    9</span> <span class="synConstant">             })                # digit says</span>
<span class="synLinenum">   10</span> <span class="synConstant">           )</span>
<span class="synLinenum">   11</span> <span class="synConstant">          };</span>
<span class="synLinenum">   12</span> <span class="synConstant">say ;SPMquot;</span>;SPMlt;<span class="synIdentifier">$;SPMamp;</span>;SPMgt; ;SPMlt;<span class="synIdentifier">$1</span>;SPMgt; ;SPMlt;<span class="synIdentifier">$2</span>;SPMgt;<span class="synConstant">;SPMquot; if '3428' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   13</span> <span class="synConstant">say ;SPMquot;</span>;SPMlt;<span class="synIdentifier">$;SPMamp;</span>;SPMgt; ;SPMlt;<span class="synIdentifier">$1</span>;SPMgt; ;SPMlt;<span class="synIdentifier">$2</span>;SPMgt;<span class="synConstant">;SPMquot; if '228' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   14</span> <span class="synConstant">say ;SPMquot;</span>;SPMlt;<span class="synIdentifier">$;SPMamp;</span>;SPMgt; ;SPMlt;<span class="synIdentifier">$1</span>;SPMgt; ;SPMlt;<span class="synIdentifier">$2</span>;SPMgt;<span class="synConstant">;SPMquot; if '14' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   15</span> <span class="synConstant">say ;SPMquot;24</span> does <span class="synStatement">not</span> match<span class="synConstant">;SPMquot; unless '24' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   16</span> <span class="synConstant">say ;SPMquot;4324</span> does <span class="synStatement">not</span> match<span class="synConstant">;SPMquot; unless '4324' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
</pre>
<tex2html_mydb_mark>#1341#
pl@nereida:~/Lperltesting$ ./intints.pl
;SPMlt;3428;SPMgt; ;SPMlt;3;SPMgt; ;SPMlt;428;SPMgt;
;SPMlt;228;SPMgt; ;SPMlt;2;SPMgt; ;SPMlt;28;SPMgt;
;SPMlt;14;SPMgt; ;SPMlt;1;SPMgt; ;SPMlt;4;SPMgt;
24 does not match
4324 does not match
<tex2html_mydb_mark>#1342#
<pre>
pl@nereida:~$  <span class="dbuser">perl5.10.1 -wdE 0</span>
main::(-e:1):   0
  DB;SPMlt;1;SPMgt;  <span class="dbuser">x join '', map { "(?!".$_."{7})" } 0..9</span>
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB;SPMlt;2;SPMgt;  <span class="dbuser">x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB;SPMlt;3;SPMgt;  <span class="dbuser">x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  7777778
  DB;SPMlt;4;SPMgt;  <span class="dbuser">x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB;SPMlt;5;SPMgt;  <span class="dbuser">x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  4422444
</pre>
<tex2html_mydb_mark>#1343#
<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat actionspanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl </span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>;
<span class="synLinenum">    7</span> <span class="synStatement">use </span>Switch;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synStatement">sub</span><span class="synIdentifier"> f </span>{
<span class="synLinenum">   10</span>   <span class="synStatement">my</span> <span class="synIdentifier">$char</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synStatement">switch</span>(<span class="synIdentifier">$char</span>) {
<span class="synLinenum">   13</span>     case [ <span class="synConstant">qw{a á}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[aá]'</span> }
<span class="synLinenum">   14</span>     case [ <span class="synConstant">qw{e é}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[eé]'</span> }
<span class="synLinenum">   15</span>     case [ <span class="synConstant">qw{i í}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[ií]'</span> }
<span class="synLinenum">   16</span>     case [ <span class="synConstant">qw{o ó}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[oó]'</span> }
<span class="synLinenum">   17</span>     case [ <span class="synConstant">qw{u ú}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[uú]'</span> }
<span class="synLinenum">   18</span>     <span class="synStatement">else</span>             { <span class="synStatement">return</span> <span class="synIdentifier">$char</span>  };
<span class="synLinenum">   19</span>   }
<span class="synLinenum">   20</span> }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">   23</span> <span class="synConstant">                            </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">-2</span><span class="synSpecial">)(??</span><span class="synConstant">{ f</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant"> }</span><span class="synSpecial">)</span>
<span class="synLinenum">   24</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant"> </span>
<span class="synLinenum">   25</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span>
<span class="synLinenum">   26</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">                $</span>
<span class="synLinenum">   28</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   31</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   32</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   33</span>   say <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome;SPMquot;</span>;
<span class="synLinenum">   34</span> }
<span class="synLinenum">   35</span> <span class="synStatement">else</span> {
<span class="synLinenum">   36</span>   say <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match;SPMquot;</span>;
<span class="synLinenum">   37</span> }
</pre>
<tex2html_mydb_mark>#1344#
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$<span class="dbuser"> ./actionspanishpalin.pl </span>
<span class="dbuser">éoíúaáuioé</span>
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dáed</span>
dáed does not match
</pre>
<tex2html_mydb_mark>#1345#
<pre>
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid_expr </span>{
<span class="synLinenum">    6</span>      <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>      <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>      <span class="synIdentifier">$skip</span> = qr! \s* !x;
<span class="synLinenum">   10</span>      <span class="synIdentifier">$term</span> = qr! <span class="synIdentifier">$skip</span> [a-zA-Z]+              <span class="synComment"># A term is an identifier</span>
<span class="synLinenum">   11</span>                | <span class="synIdentifier">$skip</span> [<span class="synConstant">1-9</span>][<span class="synConstant">0-9</span>]*            <span class="synComment"># or a number</span>
<span class="synLinenum">   12</span>                | <span class="synIdentifier">$skip</span> \( (??{ <span class="synIdentifier">$expr</span> }) <span class="synIdentifier">$skip</span> <span class="synComment"># or an expression</span>
<span class="synLinenum">   13</span>                        \)
<span class="synLinenum">   14</span>                !x;
<span class="synLinenum">   15</span>      <span class="synIdentifier">$expr</span> = qr! <span class="synIdentifier">$term</span>                         <span class="synComment"># A expr is a term</span>
<span class="synLinenum">   16</span>                  (?: <span class="synIdentifier">$skip</span> [-+*/] <span class="synIdentifier">$term</span> )*     <span class="synComment"># or a term + a term ...</span>
<span class="synLinenum">   17</span>                !x;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>      <span class="synStatement">return</span> <span class="synIdentifier">$_</span>[<span class="synConstant">0</span>] =~<span class="synStatement"> /</span><span class="synConstant"> ^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant"> </span><span class="synStatement">/x</span>;
<span class="synLinenum">   20</span>   }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">print</span>(is_valid_expr(<span class="synIdentifier">$_</span>) ? <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$_</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span> : <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$_</span><span class="synConstant"> is not valid</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>) <span class="synStatement">foreach</span> (
<span class="synLinenum">   23</span>    <span class="synConstant">'(a + 3)'</span>,
<span class="synLinenum">   24</span>    <span class="synConstant">'(3 * 4)+(b + x)'</span>,
<span class="synLinenum">   25</span>    <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   26</span>    <span class="synConstant">'3 + 2'</span>,
<span class="synLinenum">   27</span> 
<span class="synLinenum">   28</span>    <span class="synConstant">'!3 + 2'</span>,
<span class="synLinenum">   29</span>    <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>    <span class="synConstant">'3 a'</span>,
<span class="synLinenum">   32</span>    <span class="synConstant">'3 3'</span>,
<span class="synLinenum">   33</span>    <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span>    <span class="synConstant">'2 - 3 * 4'</span>,
<span class="synLinenum">   36</span>    <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   37</span>   );
</pre>
<tex2html_mydb_mark>#1346#
pl@nereida:~/Lperltesting$ perl complexformula.pl
(a + 3) is valid
(3 * 4)+(b + x) is valid
(5 - a)*z is valid
3 + 2 is valid
!3 + 2 is not valid
3 + 2! is not valid
3 a is not valid
3 3 is not valid
3 * * 3 is not valid
2 - 3 * 4 is valid
2 - 3 + 4 is valid
<tex2html_mydb_mark>#1347#
  DB;SPMlt;1;SPMgt; x 'hola' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  'ol'
  DB;SPMlt;2;SPMgt; x 'ha' =~ /^(.)(..)?(?(2)a|b)/
  empty array
  DB;SPMlt;3;SPMgt; x 'hb' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  undef
<tex2html_mydb_mark>#1348#
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x 'aa' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  undef
  DB;SPMlt;2;SPMgt; x 'abba' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  'b'
  DB;SPMlt;3;SPMgt; x 'abbc' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
  empty array
  DB;SPMlt;4;SPMgt; x 'juanpedropedrojuan' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'juan'
1  'pedro'
<tex2html_mydb_mark>#1349#
  DB;SPMlt;1;SPMgt; $a = 0; print ;SPMquot;$;SPMamp;;SPMquot; if 'hola' =~ m{(?(?{$a})hola|adios)} # No hay matching

  DB;SPMlt;2;SPMgt; $a = 1; print ;SPMquot;$;SPMamp;;SPMquot; if 'hola' =~ m{(?(?{$a})hola|adios)}
hola
<tex2html_mydb_mark>#1350#
<pre>
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              ^</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">\(</span><span class="synConstant"> </span><span class="synSpecial">)?</span><span class="synConstant">            # may be it comes an open par</span>
<span class="synLinenum">    8</span> <span class="synConstant">              </span><span class="synSpecial">[^()]+</span><span class="synConstant">             # no parenthesis</span>
<span class="synLinenum">    9</span> <span class="synConstant">              </span><span class="synSpecial">(?(</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">              # did we sart with par</span><span class="synSpecial">?</span>
<span class="synLinenum">   10</span> <span class="synConstant">                </span><span class="synSpecial">\)</span><span class="synConstant">               # if yes then close par</span>
<span class="synLinenum">   11</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> <span class="synConstant">              $</span>
<span class="synLinenum">   13</span> <span class="synConstant">            }</span>;
<span class="synLinenum">   14</span>   say <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">;SPMgt;;SPMquot;</span> <span class="synStatement">if</span> <span class="synConstant">'(abcd)'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   15</span>   say <span class="synConstant">;SPMquot;;SPMlt;</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">;SPMgt;;SPMquot;</span> <span class="synStatement">if</span> <span class="synConstant">'abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   16</span>   say <span class="synConstant">;SPMquot;;SPMlt;(abc;SPMgt; does not match;SPMquot;</span> <span class="synStatement">unless</span> <span class="synConstant">'(abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   17</span>   say <span class="synConstant">;SPMquot;;SPMlt;abc);SPMgt; does not match;SPMquot;</span> <span class="synStatement">unless</span> <span class="synConstant">'abc)'</span> =~ <span class="synIdentifier">$r</span>;
</pre>
<tex2html_mydb_mark>#1351#
pl@nereida:~/Lperltesting$ ./conditionalregexp.pl
;SPMlt;(abcd);SPMgt;
;SPMlt;abc;SPMgt;
;SPMlt;(abc;SPMgt; does not match
;SPMlt;abc);SPMgt; does not match
<tex2html_mydb_mark>#1352#
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; x 'bbaaaabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbaaaabb'
  DB;SPMlt;2;SPMgt; x 'bb' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB;SPMlt;3;SPMgt; x 'bab' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB;SPMlt;4;SPMgt; x 'bbabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbabb'
<tex2html_mydb_mark>#1353#
<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat spanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;pal;SPMgt;</span><span class="synSpecial">\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">    8</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;L;SPMgt;</span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;a;SPMgt;</span><span class="synSpecial">[áa])</span><span class="synConstant">|</span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;e;SPMgt;</span><span class="synSpecial">[ée])</span><span class="synConstant">|</span><span class="synSpecial">\w)</span><span class="synConstant"> # letter</span>
<span class="synLinenum">    9</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;pal</span><span class="synSpecial">)</span><span class="synConstant">                        # nested palindrome</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synSpecial">(?(</span><span class="synConstant">;SPMlt;a;SPMgt;</span><span class="synSpecial">)[áa]</span><span class="synConstant">                    # if is an ;SPMquot;a;SPMquot; group</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                  |</span><span class="synSpecial">(?:((?</span><span class="synConstant">;SPMlt;e;SPMgt;</span><span class="synSpecial">)[ée]</span><span class="synConstant">          # if is an ;SPMquot;e;SPMquot; group</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                            |</span><span class="synSpecial">\g</span><span class="synConstant">{L}         # exact match</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">)</span><span class="synConstant">                    # end if </span><span class="synSpecial">[ée]</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   </span><span class="synSpecial">)</span><span class="synConstant">                       # end group</span>
<span class="synLinenum">   15</span> <span class="synConstant">                            </span><span class="synSpecial">)</span><span class="synConstant">                              # end if </span><span class="synSpecial">[áa]</span>
<span class="synLinenum">   16</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant">                            # non rec</span><span class="synSpecial">.</span><span class="synConstant"> case</span>
<span class="synLinenum">   17</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span><span class="synConstant">                                # punctuation symbols</span>
<span class="synLinenum">   18</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">                $</span>
<span class="synLinenum">   20</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   25</span>   say <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome;SPMquot;</span>;
<span class="synLinenum">   26</span> }
<span class="synLinenum">   27</span> <span class="synStatement">else</span> {
<span class="synLinenum">   28</span>   say <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match;SPMquot;</span>;
<span class="synLinenum">   29</span> }
</pre>
<tex2html_mydb_mark>#1354#
<pre>
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">óuuo</span>
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">éaáe</span>
éaáe is a palindrome
</pre>
<tex2html_mydb_mark>#1355#
  1   I 1 STDIN is assumed to be in UTF-8
  2   O 2 STDOUT will be in UTF-8
  3   E 4 STDERR will be in UTF-8
  4   S 7 I + O + E
  5   i 8 UTF-8 is the default PerlIO layer for input streams
  6   o 16 UTF-8 is the default PerlIO layer for output streams
  7   D 24 i + o
  8   A 32 the @ARGV elements are expected to be strings encoded
  9   in UTF-8
 10   L 64 normally the ;SPMquot;IOEioA;SPMquot; are unconditional,
 11   the L makes them conditional on the locale environment
 12   variables (the LC_ALL, LC_TYPE, and LANG, in the order
 13   of decreasing precedence) -- if the variables indicate
 14   UTF-8, then the selected ;SPMquot;IOEioA;SPMquot; are in effect
 15   a 256 Set ${^UTF8CACHE} to -1, to run the UTF-8 caching code in
 16   debugging mode.
<tex2html_mydb_mark>#1356#
<pre>
lhp<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperl</span><span class="synStatement">/s</span>rc/testing$ cat -n dot_utf8_2.pl
     <span class="synConstant">1</span>  <span class="synComment">#!/usr/local/bin/perl -w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use strict</span>;
     <span class="synConstant">3</span>  <span class="synStatement">use utf8</span>;
     <span class="synConstant">4</span>  <span class="synStatement">use </span>charnames <span class="synConstant">qw{greek}</span>;
     <span class="synConstant">5</span>
     <span class="synConstant">6</span>  <span class="synStatement">binmode</span>(<span class="synIdentifier">STDOUT</span>, <span class="synConstant">':utf8'</span>);
     <span class="synConstant">7</span>
     <span class="synConstant">8</span>  <span class="synStatement">my</span> <span class="synIdentifier">$x</span> = <span class="synConstant">'αβγδεφ'</span>;
     <span class="synConstant">9</span>
    <span class="synConstant">10</span>  <span class="synStatement">my</span> <span class="synIdentifier">@w</span> = <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">11</span>  <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">@w</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
    <span class="synConstant">12</span>
    <span class="synConstant">13</span>  {
    <span class="synConstant">14</span>    <span class="synStatement">use </span>bytes;
    <span class="synConstant">15</span>    <span class="synStatement">my</span> <span class="synIdentifier">@v</span> = <span class="synStatement">map</span> { <span class="synStatement">ord</span> } <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">16</span>    <span class="synStatement">print</span> <span class="synConstant">;SPMquot;</span><span class="synIdentifier">@v</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
    <span class="synConstant">17</span>  }
</pre>

Al ejcutar el programa obtenemos la salida:
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">perl dot_utf8_2.pl</span>
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134

</pre>
<tex2html_mydb_mark>#1357#
pl@nereida:~/Lperltesting$ cat -n vowelcount.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
     2  use strict;
     3
     4  my $input = shift() || ;SPMlt;STDIN;SPMgt;;
     5  my %count = ();
     6  $input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
     7  printf(;SPMquot;'%s' =;SPMgt; %3d\n;SPMquot;, $_, $count{$_})  for (sort keys %count);

<tex2html_mydb_mark>#1358#
pl@nereida:~/Lperltesting$ ./vowelcount.pl
supercalifragilistico
'a' =;SPMgt;   2
'e' =;SPMgt;   1
'i' =;SPMgt;   4
'o' =;SPMgt;   1
'u' =;SPMgt;   1
<tex2html_mydb_mark>#1359#
  DB;SPMlt;1;SPMgt; x 'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'AB'
1  'B'
2  undef
  DB;SPMlt;2;SPMgt; x 'ACDE'  =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'ACD'
1  'C'
2  'E'
<tex2html_mydb_mark>#1360#
pl@nereida:~/Lperltesting$ cat -n SKIP.pl
     1  #!/soft/perl5lib/bin/perl5.10.1 -w
     2  use strict;
     3  use v5.10;
     4
     5  say ;SPMquot;NO SKIP: /a+b?(*FAIL)/;SPMquot;;
     6  our $count = 0;
     7  'aaab' =~ /a+b?(?{print ;SPMquot;$;SPMamp;\n;SPMquot;; $count++})(*FAIL)/;
     8  say ;SPMquot;Count=$count\n;SPMquot;;
     9
    10  say ;SPMquot;WITH SKIP: a+b?(*SKIP)(*FAIL)/;SPMquot;;
    11  $count = 0;
    12  'aaab' =~ /a+b?(*SKIP)(?{print ;SPMquot;$;SPMamp;\n;SPMquot;; $count++})(*FAIL)/;
    13  say ;SPMquot;WITH SKIP: Count=$count\n;SPMquot;;
    14
    15  say ;SPMquot;WITH SKIP /a+(*SKIP)b?(*FAIL)/:;SPMquot;;
    16  $count = 0;
    17  'aaab' =~ /a+(*SKIP)b?(?{print ;SPMquot;$;SPMamp;\n;SPMquot;; $count++})(*FAIL)/;
    18  say ;SPMquot;Count=$count\n;SPMquot;;
    19
    20  say ;SPMquot;WITH SKIP /(*SKIP)a+b?(*FAIL): ;SPMquot;;
    21  $count = 0;
    22  'aaab' =~ /(*SKIP)a+b?(?{print ;SPMquot;$;SPMamp;\n;SPMquot;; $count++})(*FAIL)/;
    23  say ;SPMquot;Count=$count\n;SPMquot;;
<tex2html_mydb_mark>#1361#
pl@nereida:~/Lperltesting$ perl5.10.1 SKIP.pl
NO SKIP: /a+b?(*FAIL)/
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9

WITH SKIP: a+b?(*SKIP)(*FAIL)/
aaab
WITH SKIP: Count=1

WITH SKIP /a+(*SKIP)b?(*FAIL)/:
aaab
aaa
Count=2

WITH SKIP /(*SKIP)a+b?(*FAIL):
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9
<tex2html_mydb_mark>#1362#
pl@nereida:~/Lperltesting$ cat -n mark.pl
 1  use v5.10;
 2  use strict;
 3
 4  our $REGMARK;
 5
 6  $_ = shift;
 7  say $REGMARK if /(?:x(*MARK:mx)|y(*MARK:my)|z(*MARK:mz))/;
 8  say $REGMARK if /(?:x(*:xx)|y(*:yy)|z(*:zz))/;
<tex2html_mydb_mark>#1363#
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl y
my
yy
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl z
mz
zz
<tex2html_mydb_mark>#1364#
s/,/, /g;
<tex2html_mydb_mark>#1365#
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $a = 'ab,cd, ef,12,34,efg,56,78,df, ef,'
  DB;SPMlt;2;SPMgt; x ($b = $a) =~ s/\d,\d(*:d)|,(?!\s)/($REGMARK eq 'd')? $;SPMamp; : ', '/ge
0  8
  DB;SPMlt;3;SPMgt; p ;SPMquot;;SPMlt;$b;SPMgt;;SPMquot;
;SPMlt;ab, cd, ef, 12,34, efg, 56,78, df, ef, ;SPMgt;
<tex2html_mydb_mark>#1366#% UTF-8 caracteres no son soportados por LaTeX :-(

<tex2html_mydb_mark>#1367#%04X;SPMquot;, charnames::vianame(;SPMquot;FOUR TEARDROP-SPOKED ASTERISK;SPMquot;)

<tex2html_mydb_mark>#1368#%s: %s\n;SPMquot;, pattern, errstr);

<tex2html_mydb_mark>#1369#%.*s%s%.*s%s;SPMquot;,

<tex2html_mydb_mark>#1370#%s\n;SPMquot;, line + offset);

<tex2html_mydb_mark>#1371#%.2f'%(celsius), ;SPMquot; C = ;SPMquot;, '%.2f'%(fahrenheit), ;SPMquot; F\n;SPMquot;

<tex2html_mydb_mark>#1372#%%{{{

<tex2html_mydb_mark>#1373#%%}}}

<tex2html_mydb_mark>#1374#%Esta es la solución:

<tex2html_mydb_mark>#1375#%%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/doublee.pl;SPMquot;

<tex2html_mydb_mark>#1376#%\begin{verbatim}

<tex2html_mydb_mark>#1377#%   1 #!/usr/bin/perl -w

<tex2html_mydb_mark>#1378#%   2 # one ;SPMlt;a;SPMgt;one;SPMlt;/a;SPMgt;

<tex2html_mydb_mark>#1379#%   3 # is two three

<tex2html_mydb_mark>#1380#%   4 # three

<tex2html_mydb_mark>#1381#%   5 $/ = ;SPMquot;.\n;SPMquot;;

<tex2html_mydb_mark>#1382#%   6 while (;SPMlt;;SPMgt;) {

<tex2html_mydb_mark>#1383#%   7   next if !s{

<tex2html_mydb_mark>#1384#%   8     \b                 # start word ...

<tex2html_mydb_mark>#1385#%   9     ([a-z]+)           # grab word in $1 and \1

<tex2html_mydb_mark>#1386#%  10     (                  # save the tags and spaces in $2

<tex2html_mydb_mark>#1387#%  11     (\s|;SPMlt;[^;SPMgt;]+;SPMgt;)+      # spaces or HTML tags 

<tex2html_mydb_mark>#1388#%  12     )   

<tex2html_mydb_mark>#1389#%  13     (\1\b)             # repeated word in $4

<tex2html_mydb_mark>#1390#%  14   }

<tex2html_mydb_mark>#1391#%  15   ;SPMquot;\e[7m$1\e[m$2\e[7m$4\e[m;SPMquot;igx;

<tex2html_mydb_mark>#1392#%  16   s/^([^\e]*\n)+//mg;  # remove lines that don't contain escapes

<tex2html_mydb_mark>#1393#%  17   s/^/$ARGV: /mg;      # insert filename at the beginning of the lines

<tex2html_mydb_mark>#1394#%  18   print;

<tex2html_mydb_mark>#1395#%  19 }

<tex2html_mydb_mark>#1396#%\end{verbatim}

<tex2html_mydb_mark>#1397#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/csv.pl;SPMquot;

<tex2html_mydb_mark>#1398#%Two MIT math grads bump into each other while shopping at Fry’s. They haven't seen each other in over 20 years.

<tex2html_mydb_mark>#1399#%

<tex2html_mydb_mark>#1400#%First grad to the second: ;SPMquot;How have you been?;SPMquot;

<tex2html_mydb_mark>#1401#%Second: ;SPMquot;Great! I got married and I have three daughters now.;SPMquot;

<tex2html_mydb_mark>#1402#%First: ;SPMquot;Really? How old are they?;SPMquot;

<tex2html_mydb_mark>#1403#%Second: ;SPMquot;Well, the product of their ages is 72, and the sum of their ages is the same as the number on that building over there...;SPMquot;

<tex2html_mydb_mark>#1404#%First: ;SPMquot;Right, ok... Oh wait... Hmm, I still don't know.;SPMquot;

<tex2html_mydb_mark>#1405#%Second: ;SPMquot;Oh sorry, the oldest one just started to play the piano.;SPMquot;

<tex2html_mydb_mark>#1406#%First: ;SPMquot;Wonderful! My oldest is the same age!;SPMquot; 

<tex2html_mydb_mark>#1407#%u;
 
<tex2html_mydb_mark>#1408#%\item

<tex2html_mydb_mark>#1409#%\htmladdnormallink

<tex2html_mydb_mark>#1410#%{http://blog.stevenlevithan.com/archives/algebra-with-regexes}

<tex2html_mydb_mark>#1411#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/numsust.pl;SPMquot;

<tex2html_mydb_mark>#1412#%8)/e) {}
   
<tex2html_mydb_mark>#1413#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1414#%8);SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synStatement;SPMquot;;SPMgt;/e;SPMlt;/span;SPMgt;) {}

<tex2html_mydb_mark>#1415#%}}}

<tex2html_mydb_mark>#1416#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1417#%}}}

<tex2html_mydb_mark>#1418#%8)/ge;
   
<tex2html_mydb_mark>#1419#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1420#%8);SPMlt;/span;SPMgt;;SPMlt;span class=;SPMquot;synStatement;SPMquot;;SPMgt;/ge;SPMlt;/span;SPMgt;;

<tex2html_mydb_mark>#1421#%}}}

<tex2html_mydb_mark>#1422#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/split.pl;SPMquot;

<tex2html_mydb_mark>#1423#%%%%%%%%%%%%%%%listinginput: Input from: ;SPMquot;../src/tr.pl;SPMquot;

<tex2html_mydb_mark>#1424#%\item

<tex2html_mydb_mark>#1425#%\htmladdnormallink{CSS Tutorial}{http://www.w3schools.com/css/}

<tex2html_mydb_mark>#1426#%\item

<tex2html_mydb_mark>#1427#%\htmladdnormallink{Edición extremadamente simple de HTML}{http://www.psicobyte.com/html/index.html}

<tex2html_mydb_mark>#1428#%\item

<tex2html_mydb_mark>#1429#%\htmladdnormallink{Perl-XML Frequently Asked Questions}{http://perl-xml.sourceforge.net/faq/}

<tex2html_mydb_mark>#1430#% see jeff Pinyan Regex::Parser

<tex2html_mydb_mark>#1431#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1432#%}}}

<tex2html_mydb_mark>#1433#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1434#%}}}

<tex2html_mydb_mark>#1435#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1436#%}}}

<tex2html_mydb_mark>#1437#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1438#%}}}

<tex2html_mydb_mark>#1439#%/| variable will contain

<tex2html_mydb_mark>#1440#%]);SPMgt; ;SPMlt;Y=Mult;SPMgt;

<tex2html_mydb_mark>#1441#%MATCH| within any code block

<tex2html_mydb_mark>#1442#% ;SPMlt;Y=Mult;SPMgt;

<tex2html_mydb_mark>#1443#% $MATCH{Y}; })

<tex2html_mydb_mark>#1444#%cmds;SPMgt;

<tex2html_mydb_mark>#1445#%dict;SPMgt;

<tex2html_mydb_mark>#1446#%cmds| and \verb|%dict|) 

<tex2html_mydb_mark>#1447#%cmd = map { ($_ =;SPMgt; undef ) } qw( uname pwd date );
 
<tex2html_mydb_mark>#1448#%cmd;SPMgt; (?: ;SPMlt;[arg];SPMgt; )*

<tex2html_mydb_mark>#1449#%/;

<tex2html_mydb_mark>#1450#%f = (
    
<tex2html_mydb_mark>#1451#%{{{ % raw html perldeb

<tex2html_mydb_mark>#1452#%}}}

<tex2html_mydb_mark>#1453#%{{{ % perl code in HTML

<tex2html_mydb_mark>#1454#%}}}

<tex2html_mydb_mark>#1455#%semdesc = @_;
  
<tex2html_mydb_mark>#1456#%semdesc) {
  
<tex2html_mydb_mark>#1457#%sem = %{$semdesc{$class}};
  
<tex2html_mydb_mark>#1458#%%% TEXEXPAND: END FILE ./chapter2/perlregexp.tex

<tex2html_mydb_mark>#1459#%

<tex2html_mydb_mark>#1460#
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; use Unicode::UCD qw{charinfo charscripts}
  DB;SPMlt;2;SPMgt; x charinfo(0x41)
0  HASH(0xc69a88)
   'bidi' =;SPMgt; 'L'
   'block' =;SPMgt; 'Basic Latin'
   'category' =;SPMgt; 'Lu'
   'code' =;SPMgt; 0041
   'combining' =;SPMgt; 0
   'comment' =;SPMgt; ''
   'decimal' =;SPMgt; ''
   'decomposition' =;SPMgt; ''
   'digit' =;SPMgt; ''
   'lower' =;SPMgt; 0061
   'mirrored' =;SPMgt; 'N'
   'name' =;SPMgt; 'LATIN CAPITAL LETTER A'
   'numeric' =;SPMgt; ''
   'script' =;SPMgt; 'Latin'
   'title' =;SPMgt; ''
   'unicode10' =;SPMgt; ''
   'upper' =;SPMgt; ''
  DB;SPMlt;3;SPMgt; x @{charscripts()-;SPMgt;{Greek}}[0..3]
0  ARRAY(0xd676a8)
   0  880
   1  883
   2  'Greek'
1  ARRAY(0xd86300)
   0  885
   1  885
   2  'Greek'
2  ARRAY(0xd6c718)
   0  886
   1  887
   2  'Greek'
3  ARRAY(0xd6c790)
   0  890
   1  890
   2  'Greek'
<tex2html_mydb_mark>#1461#
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8_1.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3
     4  my $x = 'áéíóúñ€';
     5  print ;SPMquot;$x\n;SPMquot;;
     6  print length($x).;SPMquot;\n;SPMquot;;
<tex2html_mydb_mark>#1462#
lhp@nereida:~/Lperl/src/testing$ useutf8_1.pl
áéíóúñ€
15
<tex2html_mydb_mark>#1463#
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8_2.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4
     5  my $x = 'áéíóúñ€';
     6  print ;SPMquot;$x\n;SPMquot;;
     7  print length($x).;SPMquot;\n;SPMquot;;
<tex2html_mydb_mark>#1464#
lhp@nereida:~/Lperl/src/testing$ useutf8_2.pl
Wide character in print at ./useutf8_2.pl line 6.
áéíóúñ€
7
<tex2html_mydb_mark>#1465#
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8_3.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4  binmode(STDOUT, ':utf8');
     5
     6  my $x = 'áéíóúñ€';
     7  print ;SPMquot;$x\n;SPMquot;;
     8  print length($x).;SPMquot;\n;SPMquot;;
<tex2html_mydb_mark>#1466#
lhp@nereida:~/Lperl/src/testing$ useutf8_3.pl
áéíóúñ€
7
<tex2html_mydb_mark>#1467#
lhp@nereida:~/Lperl/src/testing$ perl useutf8_1.pl
áéíóúñ€
15
lhp@nereida:~/Lperl/src/testing$ perl -Mutf8 -COE useutf8_1.pl
áéíóúñ€
7
<tex2html_mydb_mark>#1468#
As of 5.8.1, the ;SPMquot;-C;SPMquot; can be followed either by a number or a list of option
letters.  The letters, their numeric values, and effects are as follows;
listing the letters is equal to summing the numbers.

  I     1    STDIN is assumed to be in UTF-8
  O     2    STDOUT will be in UTF-8
  E     4    STDERR will be in UTF-8
  S     7    I + O + E
  i     8    UTF-8 is the default PerlIO layer for input streams
  o    16    UTF-8 is the default PerlIO layer for output streams
  D    24    i + o
  A    32    the @ARGV elements are expected to be strings encoded in UTF-8
  L    64    normally the ;SPMquot;IOEioA;SPMquot; are unconditional,
             the L makes them conditional on the locale environment
             variables (the LC_ALL, LC_TYPE, and LANG, in the order
             of decreasing precedence) -- if the variables indicate
             UTF-8, then the selected ;SPMquot;IOEioA;SPMquot; are in effect
<tex2html_mydb_mark>#1469#
pl@nereida:~/Lperltesting$ cat -n is_utf8.pl
     1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1 -w -COE
     2  use strict;
     3  use utf8;
     4
     5  my $x = 'áéíóúñ€';
     6  my $y = 'abc';
     7  my $z = 'αβγδη';
     8  print ;SPMquot;$x is utf8\n;SPMquot; if utf8::is_utf8($x);
     9  print ;SPMquot;$y is utf8\n;SPMquot; if utf8::is_utf8($y);
    10  print ;SPMquot;$z is utf8\n;SPMquot; if utf8::is_utf8($z);
<tex2html_mydb_mark>#1470#
pl@nereida:~/Lperltesting$ ./is_utf8.pl
áéíóúñ€ is utf8
αβγδη is utf8
<tex2html_mydb_mark>#1471#
        set encoding=utf-8
<tex2html_mydb_mark>#1472#
casiano@millo:~/Lperltesting$ locale
LANG=es_ES.UTF-8
LC_CTYPE=;SPMquot;es_ES.UTF-8;SPMquot;
LC_NUMERIC=;SPMquot;es_ES.UTF-8;SPMquot;
LC_TIME=;SPMquot;es_ES.UTF-8;SPMquot;
LC_COLLATE=;SPMquot;es_ES.UTF-8;SPMquot;
LC_MONETARY=;SPMquot;es_ES.UTF-8;SPMquot;
LC_MESSAGES=;SPMquot;es_ES.UTF-8;SPMquot;
LC_PAPER=;SPMquot;es_ES.UTF-8;SPMquot;
LC_NAME=;SPMquot;es_ES.UTF-8;SPMquot;
LC_ADDRESS=;SPMquot;es_ES.UTF-8;SPMquot;
LC_TELEPHONE=;SPMquot;es_ES.UTF-8;SPMquot;
LC_MEASUREMENT=;SPMquot;es_ES.UTF-8;SPMquot;
LC_IDENTIFICATION=;SPMquot;es_ES.UTF-8;SPMquot;
LC_ALL=
<tex2html_mydb_mark>#1473#
lhp@nereida:~/Lperl/src/testing$ cat -n utf8file.txt
     1  áéíóúñÑ
     2  àèìòùÇç
     3  ェッニは大き
<tex2html_mydb_mark>#1474#
pl@nereida:~/Lperltesting$ perl5.10.1 -C7 -E 'say chr($_) for (0x30a7, 0x30c3, 0x30cb, 0x306f,  0x5927, 0x304d)'
ェ
ッ
ニ
は
大
き
<tex2html_mydb_mark>#1475#
:echo globpath(;SPMamp;rtp, ;SPMquot;keymap/*.vim;SPMquot;)
<tex2html_mydb_mark>#1476#
/usr/share/vim/vim70/keymap/accents.vim
/usr/share/vim/vim70/keymap/arabic.vim
/usr/share/vim/vim70/keymap/arabic_utf-8.vim
/usr/share/vim/vim70/keymap/bulgarian.vim
/usr/share/vim/vim70/keymap/canfr-win.vim
/usr/share/vim/vim70/keymap/czech.vim
/usr/share/vim/vim70/keymap/czech_utf-8.vim
/usr/share/vim/vim70/keymap/esperanto.vim
/usr/share/vim/vim70/keymap/esperanto_utf-8.vim
/usr/share/vim/vim70/keymap/greek.vim
/usr/share/vim/vim70/keymap/greek_cp1253.vim
/usr/share/vim/vim70/keymap/greek_cp737.vim
/usr/share/vim/vim70/keymap/greek_iso-8859-7.vim
/usr/share/vim/vim70/keymap/greek_utf-8.vim
....
<tex2html_mydb_mark>#1477#
;SPMlt;language;SPMgt;_;SPMlt;encoding;SPMgt;.vim
<tex2html_mydb_mark>#1478#
$ cat -n /usr/share/vim/vim70/keymap/greek_utf-8.vim
 1 ;SPMquot; Vim Keymap file for greek
 2 ;SPMquot; Maintainer: Panagiotis Louridas ;SPMlt;louridas@acm.org;SPMgt;
 3 ;SPMquot; Last Updated: Thu Mar 23 23:45:02 EET 2006
 4 
 .......................................................................
72 let b:keymap_name = ;SPMquot;grk;SPMquot;
73 loadkeymap
74 ;SPMquot; PUNCTUATION MARKS - SYMBOLS (GREEK SPECIFIC)
75 ;SPMquot;
76 E$	;SPMlt;char-0x20AC;SPMgt;  ;SPMquot; EURO SIGN
............................................................................
115 ;SPMquot;
116 ;SPMquot; GREEK LETTERS
117 ;SPMquot;
118 A	;SPMlt;char-0x0391;SPMgt;   ;SPMquot; GREEK CAPITAL LETTER ALPHA
119 B	;SPMlt;char-0x0392;SPMgt;   ;SPMquot; GREEK CAPITAL LETTER BETA
120 G	;SPMlt;char-0x0393;SPMgt;   ;SPMquot; GREEK CAPITAL LETTER GAMMA
121 D	;SPMlt;char-0x0394;SPMgt;   ;SPMquot; GREEK CAPITAL LETTER DELTA
122 E	;SPMlt;char-0x0395;SPMgt;   ;SPMquot; GREEK CAPITAL LETTER EPSILON
123 Z	;SPMlt;char-0x0396;SPMgt;   ;SPMquot; GREEK CAPITAL LETTER ZETA
<tex2html_mydb_mark>#1479#
:set keymap=greek
<tex2html_mydb_mark>#1480#
CTRL-^.
<tex2html_mydb_mark>#1481#
CTRL-6.
<tex2html_mydb_mark>#1482#
:set encoding
  encoding=utf-8
<tex2html_mydb_mark>#1483#
:set encoding latin1
<tex2html_mydb_mark>#1484#
lhp@nereida:~/Lperl/src/testing$ cat -n abreutf8.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  binmode(STDOUT, ;SPMquot;utf8;SPMquot;);
 4  open my $f, ';SPMlt;:utf8', shift();
 5  my @a = ;SPMlt;$f;SPMgt;;
 6  chomp(@a);
 7  print ;SPMquot;$_ tiene longitud ;SPMquot;.length($_).;SPMquot;\n;SPMquot; for @a;
<tex2html_mydb_mark>#1485#
lhp@nereida:~/Lperl/src/testing$ abreutf8.pl tutu
ジジェッニgfは大好あき tiene longitud 14
αβγεφγη tiene longitud 7
νμοπ;ρ^αβψδε tiene longitud 12
;SPMamp; ασηφδξδξδη tiene longitud 12
abc tiene longitud 3
αβγδ;SPMamp;αβψ tiene longitud 8
<tex2html_mydb_mark>#1486#
lhp@nereida:~/Lperl/src/testing$ cat -n alfabeta.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use charnames qw{:full greek hebrew katakana};
 4  binmode(STDOUT, ':utf8');
 5
 6  print ;SPMquot;\N{alpha}+\N{beta} = \N{pi}\n;SPMquot;;
 7  print ;SPMquot;\N{alef} es la primera letra del alfabeto hebreo\n;SPMquot;;
 8  print ;SPMquot;Un poco de Katakana: \N{sa}\N{i}\N{n}\N{mo}\n;SPMquot;;
 9
10  # Usando el nombre completo definido en el Standard Unicode
11  print ;SPMquot;Hello \N{WHITE SMILING FACE}\n;SPMquot;;
<tex2html_mydb_mark>#1487#
lhp@nereida:~/Lperl/src/testing$ alfabeta.pl
α+β = ピ
א es la primera letra del alfabeto hebreo
Un poco de Katakana: サインモ
Hello ☺
<tex2html_mydb_mark>#1488#
pl@nereida:~/Lperltesting$ perl5.10.1 -COE -Mutf8 -dE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt;   use charnames ':full'
  DB;SPMlt;2;SPMgt;  print charnames::viacode(0x2722)
FOUR TEARDROP-SPOKED ASTERISK
  DB;SPMlt;3;SPMgt; printf ;SPMquot;%04X;SPMquot;, charnames::vianame(;SPMquot;FOUR TEARDROP-SPOKED ASTERISK;SPMquot;)
2722
<tex2html_mydb_mark>#1489#
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use utf8;
 4  binmode(STDOUT, ':utf8');
 5
 6  my $x = 'áéíóúñ€';
 7  print ;SPMquot;$x\n;SPMquot;;
 8  print length($x).;SPMquot;\n;SPMquot;;
 9
10  my$y = $x;
11  $y =~ tr/áéíóúñ€/aeioun$/;
12  print ;SPMquot;$y\n;SPMquot;;
13
14  $y = $x;
15  $y =~ m/áéíóúñ(€)/;
16  print ;SPMquot;$1\n;SPMquot;;
<tex2html_mydb_mark>#1490#
lhp@nereida:~/Lperl/src/testing$ useutf8.pl
áéíóúñ€
7
aeioun$
€
<tex2html_mydb_mark>#1491#
lhp@nereida:~/Lperl/src/testing$ unicode -x 966..96f | egrep '096|\.0'
          .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F
     096.  ॠ  ॡ      ।  ॥  ०  १  २  ३  ४  ५  ६  ७  ८  ९
<tex2html_mydb_mark>#1492#
lhp@nereida:~/Lperl/src/testing$ cat -n regexputf8.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  binmode(STDOUT, ;SPMquot;utf8;SPMquot;);
 4  use utf8;
 5
 6  # Digitos Devanagari del 0 al 9
 7  my @dd  = map { chr } (2406..2415);
 8  my $x = join '+', @dd;
 9  print ;SPMquot;La interpolación ocurre: $x\n;SPMquot;;
10  my @number = $x =~ m{(\d+)}g;
11  print ;SPMquot;Las expresiones regulares funcionan: @number\n;SPMquot;;
12  print ;SPMquot;Sin embargo la conversión numérica no es automática: ;SPMquot;.($number[0]+$number[1]).;SPMquot;\n;SPMquot;;
<tex2html_mydb_mark>#1493#
lhp@nereida:~/Lperl/src/testing$ regexputf8.pl
La interpolación ocurre: ०+१+२+३+४+५+६+७+८+९
Las expresiones regulares funcionan: ० १ २ ३ ४ ५ ६ ७ ८ ९
Argument ;SPMquot;\x{967};SPMquot; isn't numeric in addition (+) at ./regexputf8.pl line 12.
Argument ;SPMquot;\x{966};SPMquot; isn't numeric in addition (+) at ./regexputf8.pl line 12.
Sin embargo la conversión numérica no es automática: 0
<tex2html_mydb_mark>#1494#
lhp@nereida:~/Lperl/src/testing$ cat -n words_utf8.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4  use charnames qw{greek};
     5  binmode(STDOUT, ':utf8');
     6
     7  my $x = 'áéíóúñ€αβγδη';
     8  my @w = $x =~ /(\w)/g;
     9  print ;SPMquot;@w\n;SPMquot;;
lhp@nereida:~/Lperl/src/testing$ words_utf8.pl
á é í ó ú ñ α β γ δ η
<tex2html_mydb_mark>#1495#
pl@nereida:~/Lperltesting$ cat -n dot_utf8.pl
     1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1 -w -COE
     2  use v5.10;
     3  use strict;
     4  use utf8;
     5
     6  my $x = 'αβγδεφ';
     7  my @w = $x =~ /(.)/g;
     8  say ;SPMquot;@w;SPMquot;;
     9
    10  my @v = map { ord } $x =~ /(\C)/g;
    11  say ;SPMquot;@v;SPMquot;;
pl@nereida:~/Lperltesting$ ./dot_utf8.pl
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134
<tex2html_mydb_mark>#1496#
lhp@nereida:~/Lperl/src/testing$ cat -n dot_utf8_2.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4  use charnames qw{greek};
     5
     6  binmode(STDOUT, ':utf8');
     7
     8  my $x = 'αβγδεφ';
     9
    10  my @w = $x =~ /(.)/g;
    11  print ;SPMquot;@w\n;SPMquot;;
    12
    13  {
    14    use bytes;
    15    my @v = map { ord } $x =~ /(.)/g;
    16    print ;SPMquot;@v\n;SPMquot;;
    17  }
<tex2html_mydb_mark>#1497#
lhp@nereida:~/Lperl/src/testing$ cat -n alfabeta1.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use utf8;
 4  use charnames qw{greek};
 5  binmode(STDOUT, ':utf8');
 6
 7  my $x = ;SPMquot;\N{alpha}+\N{beta} = \N{pi};SPMquot;;
 8  print uc($x).;SPMquot;\n;SPMquot;;
 9  print scalar(reverse($x)).;SPMquot;\n;SPMquot;;
10
11  my $y = ;SPMquot;áéíóúñ;SPMquot;;
12  print uc($y).;SPMquot;\n;SPMquot;;
13  print scalar(reverse($y)).;SPMquot;\n;SPMquot;;
<tex2html_mydb_mark>#1498#
lhp@nereida:~/Lperl/src/testing$ alfabeta1.pl
Α+Β = Π
π = β+α
ÁÉÍÓÚÑ
ñúóíéá
<tex2html_mydb_mark>#1499#
lhp@nereida:~/Lperl/src/testing$ cat -n properties.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use utf8;
 4  use charnames qw{greek};
 5  binmode(STDOUT, ':utf8');
 6
 7  my @a = ('$', 'az', '£', 'α', '€', '￥');
 8  my $x =  ;SPMquot;@a\n;SPMquot;;
 9
10  print /\p{CurrencySymbol}/? ;SPMquot;$_ = Dinero!!\n;SPMquot; : ;SPMquot;$_ : No hay dinero\n;SPMquot; for @a;
11  print /\p{Greek}/? ;SPMquot;$_ = Griego\n;SPMquot; : ;SPMquot;$_ : No es griego\n;SPMquot; for @a;
<tex2html_mydb_mark>#1500#
lhp@nereida:~/Lperl/src/testing$ properties.pl
$ = Dinero!!
az : No hay dinero
£ = Dinero!!
α : No hay dinero
€ = Dinero!!
￥ = Dinero!!
$ : No es griego
az : No es griego
£ : No es griego
α = Griego
€ : No es griego
￥ : No es griego
<tex2html_mydb_mark>#1501#
casiano@millo:~$ echo $PERL5LIB
/soft/perl5lib/perl5_10_1/lib/:/soft/perl5lib/perl5_10_1/lib/perl5:/soft/perl5lib/perl5_10_1/share/perl/5.8.8/
casiano@millo:~$ perl5.10.1 -COE -Mutf8 -dE 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; use Unicode::Properties 'uniprops'
  DB;SPMlt;2;SPMgt; x  uniprops ('☺'); # Unicode smiley face
0  'Alphabetic'
1  'Any'
2  'Assigned'
3  'IDContinue'
4  'IDStart'
5  'InLatin1Supplement'
6  'Latin'
7  'Lowercase'
<tex2html_mydb_mark>#1502#
lhp@nereida:~/Lbook$ unicode 'hebrew letter alef'
U+05D0 HEBREW LETTER ALEF
UTF-8: d7 90  UTF-16BE: 05d0  Decimal: ;SPMamp;#1488;
א
Category: Lo (Letter, Other)
Bidi: R (Right-to-Left)

U+FB2E HEBREW LETTER ALEF WITH PATAH
UTF-8: ef ac ae  UTF-16BE: fb2e  Decimal: ;SPMamp;#64302;
אַ
Category: Lo (Letter, Other)
Bidi: R (Right-to-Left)
Decomposition: 05D0 05B7
...
<tex2html_mydb_mark>#1503#
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use warnings;
 4  for my $file (@ARGV) {
 5    my $ifile = ;SPMquot;$file.ISO_8859-15;SPMquot;;
 6
 7    system(;SPMquot;cp $file $ifile;SPMquot;);
 8    system(;SPMquot;iconv -f ISO_8859-15 -t UTF-8 $ifile ;SPMgt; $file;SPMquot;);
 9  }
<tex2html_mydb_mark>#1504#
casiano@nereida:~/Lwiley_book_tracer/Coordinado$ paps --help
Usage:
  paps [OPTION...] [text file]

Help Options:
  -?, --help              Show help options

Application Options:
  --landscape             Landscape output. (Default: portrait)
  --columns=NUM           Number of columns output. (Default: 1)
  --font_scale=NUM        Font scaling. (Default: 12)
  --family=FAMILY         Pango FT2 font family. (Default: Monospace)
  --rtl                   Do rtl layout.
  --justify               Do justify the lines.
  --paper=PAPER           Choose paper size. Known paper sizes are legal,
                          letter, a4. (Default: a4)
  --bottom-margin=NUM     Set bottom margin. (Default: 36)
  --top-margin=NUM        Set top margin. (Default: 36)
  --right-margin=NUM      Set right margin. (Default: 36)
  --left-margin=NUM       Set left margin. (Default: 36)
  --header                Draw page header for each page.
<tex2html_mydb_mark>#1505#
casiano@nereida:~/projects/PA/regexp$ cat -n Application.java
 1  /**
 2   * javac Application.java
 3   * java Application
 4   */
 5
 6  import java.io.*;
 7  import java.util.regex.Pattern;
 8  import java.util.regex.Matcher;
 9
10  public class Application {
11
12      public static void main(String[] args){
13          String regexp = ;SPMquot;;SPMquot;;
14          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
15          try {
16              System.out.print(;SPMquot;Enter your regex: ;SPMquot;);
17              regexp = br.readLine();
18          } catch (IOException e) { System.exit(1); };
19          while (true) {
20
21              String input = ;SPMquot;;SPMquot;;
22              try {
23                System.out.print(;SPMquot;Enter input string to search: ;SPMquot;);
24                input = br.readLine();
25              } catch (IOException e) { System.exit(1); };
26
27              Pattern pattern = Pattern.compile(regexp);
28              Matcher matcher = pattern.matcher(input);
29
30              boolean found = false;
31              while (matcher.find()) {
32                  System.out.println(;SPMquot;I found the text ;SPMquot;
33                                     + matcher.group()
34                                     + ;SPMquot; starting at index ;SPMquot;
35                                     + matcher.start()
36                                     + ;SPMquot; and ending at index ;SPMquot;
37                                     +matcher.end()
38                  );
39                  found = true;
40              }
41              if(!found){
42                  System.out.println(;SPMquot;No match found.;SPMquot;);
43              }
44          }
45      }
46  }
<tex2html_mydb_mark>#1506#
casiano@nereida:~/Ljavatesting$ java Application
Enter your regex: (\d+).(\d+)
Enter input string to search: a4b5d6c7efg
I found the text 4b5 starting at index 1 and ending at index 4
I found the text 6c7 starting at index 5 and ending at index 8
Enter input string to search: abc
No match found.
Enter input string to search:
<tex2html_mydb_mark>#1507#
pl@nereida:~/src/bash$ cat -n f2c
     1  #!/bin/bash
     2  echo ;SPMquot;Enter a temperature (i.e. 32F, 100C):;SPMquot;;
     3  read input;
     4
     5  if [ -z ;SPMquot;$(echo $input | grep -i '^[-+]\?[0-9]\+\(\.[0-9]*\)\?\ *[CF]$');SPMquot; ]
     6  then
     7    echo ;SPMquot;Expecting a temperature, so don't understand \"$input\".;SPMquot; 1;SPMgt;;SPMamp;2;
     8  else
     9    input=$(echo $input | tr -d ' ');
    10    InputNum=${input:0:${#input}-1};
    11    Type=${input: -1}
    12
    13    if [ $Type = ;SPMquot;c;SPMquot; -o $Type = ;SPMquot;C;SPMquot; ]
    14    then
    15     celsius=$InputNum;
    16     fahrenheit=$(echo ;SPMquot;scale=2; ($celsius * 9/5)+32;SPMquot; | bc -l);
    17    else
    18     fahrenheit=$InputNum;
    19     celsius=$(echo ;SPMquot;scale=2; ($fahrenheit -32)*5/9;SPMquot; | bc -l);
    20    fi
    21
    22    echo ;SPMquot;$celsius C = $fahrenheit F;SPMquot;;
    23  fi
<tex2html_mydb_mark>#1508#
pl@nereida:~/src/regexpr$ cat -n pcregrep.c
 1  #include ;SPMlt;stdio.h;SPMgt;
 2  #include ;SPMlt;stdlib.h;SPMgt;
 3  #include ;SPMlt;string.h;SPMgt;
 4  #include ;SPMlt;assert.h;SPMgt;
 5  #include ;SPMlt;pcre.h;SPMgt;
 6
 7  char enter_reverse_mode[] = ;SPMquot;\33[7m;SPMquot;;
 8  char exit_reverse_mode[] = ;SPMquot;\33[0m;SPMquot;;
 9
10  int main(int argc, char **argv)
11  {
12    const char *pattern;
13    const char *errstr;
14    int erroffset;
15    pcre *expr;
16    char line[512];
17    assert(argc == 2); /* XXX fixme */
18    pattern = argv[1];
19    if (!(expr = pcre_compile(pattern, 0, ;SPMamp;errstr, ;SPMamp;erroffset, 0))) {
20      fprintf(stderr, ;SPMquot;%s: %s\n;SPMquot;, pattern, errstr);
21      return EXIT_FAILURE;
22    }
23    while (fgets(line, sizeof line, stdin)) {
24      size_t len = strcspn(line, ;SPMquot;\n;SPMquot;);
25      int matches[2];
26      int offset = 0;
27      int flags = 0;
28      line[len] = '\0';
29      while (0 ;SPMlt; pcre_exec(expr, 0, line, len, offset, flags, matches, 2)) {
30        printf(;SPMquot;%.*s%s%.*s%s;SPMquot;,
31          matches[0] - offset, line + offset,
32          enter_reverse_mode,
33          matches[1] - matches[0], line + matches[0],
34          exit_reverse_mode);
35        offset = matches[1];
36        flags |= PCRE_NOTBOL;
37      }
38      printf(;SPMquot;%s\n;SPMquot;, line + offset);
39    }
40    return EXIT_SUCCESS;
41  }
<tex2html_mydb_mark>#1509#
pl@nereida:~/src/regexpr$ gcc -lpcre pcregrep.c -o pcregrep
<tex2html_mydb_mark>#1510#
pl@nereida:~/src/regexpr$ ./pcregrep '\d+'
435 otro 23
<tex2html_mydb_mark>#1511#
hola
hola
<tex2html_mydb_mark>#1512#
pl@nereida:~/src/python$ cat -n c2f.py
 1  #!/usr/local/bin/python
 2  import re
 3
 4  temp = raw_input( ' Introduzca una temperatura (i.e. 32F, 100C): ' )
 5  pattern = re.compile( ;SPMquot;^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$;SPMquot;, re.IGNORECASE )
 6  mo = pattern.match( temp )
 7
 8  if mo:
 9    inputNum = float(mo.group( 1 ))
10    type = mo.group( 3 )
11    celsius = 0.0
12    fahrenheit = 0.0
13    if ( type == ;SPMquot;C;SPMquot; or type == ;SPMquot;c;SPMquot; ) :
14      celsius = inputNum
15      fahrenheit = ( celsius * 9/5 ) + 32
16    else :
17      fahrenheit = inputNum
18      celsius = ( fahrenheit - 32 ) * 5/9
19    print ;SPMquot; ;SPMquot;, '%.2f'%(celsius), ;SPMquot; C = ;SPMquot;, '%.2f'%(fahrenheit), ;SPMquot; F\n;SPMquot;
20  else :
21    print ;SPMquot; Se experaba una temperatura, no se entiende;SPMquot;, temp, ;SPMquot;\n;SPMquot;
<tex2html_mydb_mark>#1513#
pl@nereida:~/src/ruby$ cat -n f2c_b
 1  #!/usr/bin/ruby
 2
 3  # Primero leemos una temperatura
 4  class Temperature_calculator
 5    def initialize temp
 6    comp = Regexp.new('^([-+]?\d+(\.\d*)?)\s*([CFcf])$')
 7    if temp =~ comp
 8    begin
 9      cifra = Float($1)
10      @C,@F = ( $3 == ;SPMquot;F;SPMquot; or $3 == ;SPMquot;f;SPMquot;)? [(cifra -32) * 5/9, cifra] : [cifra , cifra * 9/5 + 32]
11    end
12    else
13      raise(;SPMquot;Entrada incorrecta;SPMquot;)
14    end
15  end
16
17    def show
18      puts ;SPMquot;Temperatura en Celsius: #{@C}, temperatura en Fahrenheit: #{@F};SPMquot;
19    end
20  end
21
22  temperatura = Temperature_calculator.new(readline.chop)
23  temperatura.show
<tex2html_mydb_mark>#1514#
;SPMlt;SCRIPT LANGUAGE=;SPMquot;JavaScript;SPMquot;;SPMgt;;SPMlt;!--
function demoMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  if (document.demoMatch.subject.value.match(re)) {
    alert(;SPMquot;Successful match;SPMquot;);
  } else {
    alert(;SPMquot;No match;SPMquot;);
  }
}

function demoShowMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  var m = re.exec(document.demoMatch.subject.value);
  if (m == null) {
    alert(;SPMquot;No match;SPMquot;);
  } else {
    var s = ;SPMquot;Match at position ;SPMquot; + m.index + ;SPMquot;:\n;SPMquot;;
    for (i = 0; i ;SPMlt; m.length; i++) {
      s = s + m[i] + ;SPMquot;\n;SPMquot;;
    }
    alert(s);
  }
}

function demoReplaceClick() {
  var re = new RegExp(document.demoMatch.regex.value, ;SPMquot;g;SPMquot;);
  document.demoMatch.result.value = 
    document.demoMatch.subject.value.replace(re, 
      document.demoMatch.replacement.value);
}
// --;SPMgt;
;SPMlt;/SCRIPT;SPMgt;

;SPMlt;FORM ID=;SPMquot;demoMatch;SPMquot; NAME=;SPMquot;demoMatch;SPMquot; METHOD=POST ACTION=;SPMquot;javascript:void(0);SPMquot;;SPMgt;
;SPMlt;P;SPMgt;Regexp: ;SPMlt;INPUT TYPE=TEXT NAME=;SPMquot;regex;SPMquot; VALUE=;SPMquot;\bt[a-z]+\b;SPMquot; SIZE=50;SPMgt;;SPMlt;/P;SPMgt;
;SPMlt;P;SPMgt;Subject string: ;SPMlt;INPUT TYPE=TEXT NAME=;SPMquot;subject;SPMquot; 
   VALUE=;SPMquot;This is a test of the JavaScript RegExp object;SPMquot; SIZE=50;SPMgt;;SPMlt;/P;SPMgt;
;SPMlt;P;SPMgt;;SPMlt;INPUT TYPE=SUBMIT VALUE=;SPMquot;Test Match;SPMquot; ONCLICK=;SPMquot;demoMatchClick();SPMquot;;SPMgt;
;SPMlt;INPUT TYPE=SUBMIT VALUE=;SPMquot;Show Match;SPMquot; ONCLICK=;SPMquot;demoShowMatchClick();SPMquot;;SPMgt;;SPMlt;/P;SPMgt;

;SPMlt;P;SPMgt;Replacement text: ;SPMlt;INPUT TYPE=TEXT NAME=;SPMquot;replacement;SPMquot; VALUE=;SPMquot;replaced;SPMquot; SIZE=50;SPMgt;;SPMlt;/P;SPMgt;
;SPMlt;P;SPMgt;Result: ;SPMlt;INPUT TYPE=TEXT NAME=;SPMquot;result;SPMquot; 
   VALUE=;SPMquot;click the button to see the result;SPMquot; SIZE=50;SPMgt;;SPMlt;/P;SPMgt;
;SPMlt;P;SPMgt;;SPMlt;INPUT TYPE=SUBMIT VALUE=;SPMquot;Replace;SPMquot; ONCLICK=;SPMquot;demoReplaceClick();SPMquot;;SPMgt;;SPMlt;/P;SPMgt;
;SPMlt;/FORM;SPMgt;
<tex2html_mydb_mark>#1515#
@nums = grep {m/^12/} m/\d{6}/g;
<tex2html_mydb_mark>#1516#
@nums = grep { defined } m/(12\d{4})|\d{6}/g;
<tex2html_mydb_mark>#1517#
DB;SPMlt;1;SPMgt; $x = '012345678901123334234567890123125934890123345126'
DB;SPMlt;2;SPMgt; x  ($x =~ m/(12\d{4})|\d{6}/g)
0  undef
1  undef
2  123334
3  undef
4  undef
5  125934
6  undef
7  undef
<tex2html_mydb_mark>#1518#
 DB;SPMlt;3;SPMgt; x @nums = $x =~ m/(?:\d{6})*?(12\d{4})/g;
0  123334
1  125934
2  123345
<tex2html_mydb_mark>#1519#
@nums = m/(?:\d{6})*?(12\d{4})(?:(?!12)\d{6})*/g;
<tex2html_mydb_mark>#1520#
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
DB;SPMlt;1;SPMgt; $_ = '012345678901123334234567890123125934890123345126'
DB;SPMlt;2;SPMgt; x m/\G(?:\d{6})*?(12\d{4})/g
0  123334
1  125934
<tex2html_mydb_mark>#1521#
casiano@nereida:~/docs/curriculums/CV_MEC$ perl -wde 0
DB;SPMlt;1;SPMgt; x $x = '012345678901123334234567890123125934890123345126'
0  012345678901123334234567890123125934890123345126
DB;SPMlt;2;SPMgt; x  ($y = $x) =~ s/(12\d{4})|\d{6}/$1? ;SPMquot;-$1-;SPMquot;:$;SPMamp; /ge
0  8
DB;SPMlt;3;SPMgt; p $y
012345678901-123334-234567890123-125934-890123345126
<tex2html_mydb_mark>#1522#
<pre>
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use </span>Term::ANSIScreen <span class="synConstant">qw/:constants/</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$bold</span> = BOLD();
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$clear</span> = CLEAR();
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synComment"># read paragraph</span>
<span class="synLinenum">   10</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synConstant">;SPMquot;.</span><span class="synSpecial">\n</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   11</span> <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$par</span> = ;SPMlt;;SPMgt;) {
<span class="synLinenum">   12</span>   <span class="synStatement">next</span> <span class="synStatement">unless</span> <span class="synIdentifier">$par</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">\b</span><span class="synConstant">                 # start word </span><span class="synSpecial">...</span>
<span class="synLinenum">   14</span> <span class="synConstant">        </span><span class="synSpecial">([a-z]+)</span><span class="synConstant">           # grab word in </span><span class="synIdentifier">$1</span><span class="synConstant"> and </span><span class="synSpecial">\1</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">(</span><span class="synConstant">                  # save the tags and spaces in </span><span class="synIdentifier">$2</span>
<span class="synLinenum">   16</span> <span class="synConstant">        </span><span class="synSpecial">(\s</span><span class="synConstant">|;SPMlt;</span><span class="synSpecial">[^;SPMgt;]+</span><span class="synConstant">;SPMgt;</span><span class="synSpecial">)+</span><span class="synConstant">      # spaces or HTML tags </span>
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">)</span><span class="synConstant">   </span>
<span class="synLinenum">   18</span> <span class="synConstant">        </span><span class="synSpecial">(\1\b)</span><span class="synConstant">             # repeated word in </span><span class="synIdentifier">$4</span>
<span class="synLinenum">   19</span> <span class="synConstant">  </span><span class="synStatement">}</span>!<span class="synIdentifier">$bold$1$clear$2$bold$4$clear</span>!igx;
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synIdentifier">$par</span> =~ <span class="synStatement">s/</span><span class="synConstant">^</span><span class="synStatement">/</span><span class="synConstant">;SPMquot;</span><span class="synIdentifier">$ARGV</span><span class="synConstant">(;SPMquot;.</span><span class="synIdentifier">$line</span><span class="synConstant">++.;SPMquot;): ;SPMquot;</span><span class="synStatement">/meg</span>;   <span class="synComment"># insert filename and line number</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">print</span> <span class="synIdentifier">$par</span>;
<span class="synLinenum">   24</span> }
</pre>
<tex2html_mydb_mark>#1523#
Sigue un ejemplo de uso:
<pre>
pl@nereida:~/Lperltesting$ cat -n t.t
     1  one one
     2  nothing rep
     3  is two three
     4  three four
     5
pl@nereida:~/Lperltesting$ ./repeatedwords2.pl t.t
t.t(1): <font color="blue">one one</font>
t.t(2): nothing rep
t.t(3): is two <font color="blue">three</font>
t.t(4): <font color="blue">three</font> four
t.t(5):
</pre>
<tex2html_mydb_mark>#1524#
;SPMquot;earth;SPMquot;,1,;SPMquot;moon;SPMquot;,9.374
<tex2html_mydb_mark>#1525#
@fields = split(/,/,$text);
<tex2html_mydb_mark>#1526#
   1 #!/usr/bin/perl -w
   2 use Text::ParseWords;
   3 
   4 sub parse_csv {
   5   my $text = shift;
   6   my @fields = (); # initialize @fields to be empty
   7 
   8   while ($text =~ 
   9     m/;SPMquot;(([^;SPMquot;\\]|\\.)*);SPMquot;,? # quoted fields
  10       | 
  11       ([^,]+),?           # $3 = non quoted fields
  12       | 
  13       ,                   # allows empty fields
  14     /gx 
  15     )
  16   {
  17     push(@fields, defined($1)? $1:$3); # add the just matched field
  18   }
  19   push(@fields, undef) if $text =~ m/,$/; #account for an empty last field
  20   return @fields;
  21 }
  22        
  23 $test = ';SPMquot;earth;SPMquot;,1,;SPMquot;a1, a2;SPMquot;,;SPMquot;moon;SPMquot;,9.374';
  24 print ;SPMquot;string = \'$test\'\n;SPMquot;;
  25 print ;SPMquot;Using parse_csv\n:;SPMquot;;
  26 @fields = parse_csv($test);
  27 foreach $i (@fields) {
  28   print ;SPMquot;$i\n;SPMquot;;
  29 }
  30 
  31 print ;SPMquot;Using Text::ParseWords\n:;SPMquot;;
  32 #  @words = ;SPMamp;quotewords($delim, $keep, @lines);  
  33 #The $keep argument is a boolean flag.  If true, then the
  34 #tokens are split on the specified delimiter, but all other
  35 #characters (quotes, backslashes, etc.) are kept in the
  36 #tokens.  If $keep is false then the ;SPMamp;*quotewords()
  37 #functions remove all quotes and backslashes that are not
  38 #themselves backslash-escaped or inside of single quotes
  39 #(i.e., ;SPMamp;quotewords() tries to interpret these characters
  40 #just like the Bourne shell). 
  41 
  42 @fields = quotewords(',',0,$test);
  43 foreach $i (@fields) {
  44   print ;SPMquot;$i\n;SPMquot;;
  45 }
<tex2html_mydb_mark>#1527#
@fields = parse_csv $test;
<tex2html_mydb_mark>#1528#
@fields = ;SPMamp;parse_csv;
<tex2html_mydb_mark>#1529#
push(@fields, $+);
<tex2html_mydb_mark>#1530#
;SPMgt; csv.pl
string = ';SPMquot;earth;SPMquot;,1,;SPMquot;a1, a2;SPMquot;,;SPMquot;moon;SPMquot;,9.374'
Using parse_csv
:earth
1
a1, a2
moon
9.374
Using Text::ParseWords
:earth
1
a1, a2
moon
9.374
<tex2html_mydb_mark>#1531#
pl@nereida:~/Lperltesting$ cat -n isprime.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  my $num = shift;
 5  die ;SPMquot;Usage: $0 integer\n;SPMquot; unless (defined($num) ;SPMamp;;SPMamp; $num =~ /^\d+$/);
 6
 7  if ((;SPMquot;1;SPMquot; x $num) =~ /^(11+)\1+$/) {
 8    my $factor = length($1);
 9    print ;SPMquot;$num is $factor x ;SPMquot;.$num/$factor.;SPMquot;\n;SPMquot;;
10  }
11  else {
12    print ;SPMquot;$num is prime\n;SPMquot;;
13  }
<tex2html_mydb_mark>#1532#
pl@nereida:~/Lperltesting$ ./isprime.pl 35.32
Usage: ./isprime.pl integer
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 147
147 is 49 x 3
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 49
49 is 7 x 7
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
<tex2html_mydb_mark>#1533#
  DB;SPMlt;1;SPMgt; # Resolvamos 3x + 2y + 5z = 40
DB;SPMlt;2;SPMgt; x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
1  'aa'
2  'aaaaa'
DB;SPMlt;3;SPMgt; x map { length }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  33
1  2
2  5
DB;SPMlt;4;SPMgt; @c = (3, 2, 5)
DB;SPMlt;5;SPMgt; x map { length($_) / $c[$i++] }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  11
1  1
2  1
DB;SPMlt;6;SPMgt; p 3*11+2*1+5*1
40
<tex2html_mydb_mark>#1534#
main::(-e:1):   0
DB;SPMlt;1;SPMgt;  sub equ { my @c = @_; print ;SPMquot;\t3*$c[0]+2*$c[1]+5*$c[2] = ;SPMquot;,3*$c[0]+2*$c[1]+5*$c[2],;SPMquot;\n;SPMquot; }
DB;SPMlt;2;SPMgt; sub f { my @c = ((length($1)/3), (length($2)/2), (length($3)/5)); equ(@c); }
DB;SPMlt;3;SPMgt; x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$(?{ f() })(*FAIL)/x
        3*11+2*1+5*1 = 40
        3*9+2*4+5*1 = 40
        3*8+2*3+5*2 = 40
        3*7+2*7+5*1 = 40
        3*7+2*2+5*3 = 40
        3*6+2*6+5*2 = 40
        3*6+2*1+5*4 = 40
        3*5+2*10+5*1 = 40
        3*5+2*5+5*3 = 40
        3*4+2*9+5*2 = 40
        3*4+2*4+5*4 = 40
        3*3+2*13+5*1 = 40
        3*3+2*8+5*3 = 40
        3*3+2*3+5*5 = 40
        3*2+2*12+5*2 = 40
        3*2+2*7+5*4 = 40
        3*2+2*2+5*6 = 40
        3*1+2*16+5*1 = 40
        3*1+2*11+5*3 = 40
        3*1+2*6+5*5 = 40
        3*1+2*1+5*7 = 40
  empty array
DB;SPMlt;4;SPMgt;
<tex2html_mydb_mark>#1535#
pl@nereida:~/Lperltesting$ cat -n diophantinesolvergen.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3  use strict;
 4
 5  # Writes a Perl solver for
 6  # a1 x1 + a2 x2 + ... + an xn = b
 7  # a_i and b integers ;SPMgt; 0
 8  #
 9
10  my $b = pop;
11  my @a = @ARGV;
12  my $debug = 1;
13
14  my $b1 = '1'x$b;
15  my @a1 = map { '1'x$_ } @a;
16  my @index = map { 'length($'.$_.;SPMquot;)/;SPMquot;.$a[$_-1] } 1..(@a);
17  my $aux = join ;SPMquot;,;SPMquot;, @index;
18
19  my $regexp = '^';
20  $regexp .= ;SPMquot;((?:$_)+);SPMquot; for @a1;
21
22  $regexp .= '$(?{ f() })(*FAIL)';
23
24  my $solver = ;SPMlt;;SPMlt;;SPMquot;SOLVER;SPMquot;;
25  my \@stack;
26  sub f {
27    my \@s = ($aux);
28    push \@stack, [ \@s ];
29  }
30
31  q{$b1} =~ m{$regexp}x;
32
33  return \@stack;
34  SOLVER
35
36  print ;SPMquot;Solver:\n--------\n$solver\n--------\n;SPMquot; if $debug;
37
38  my @stack = eval $solver;
39
40  say(;SPMquot;@$_;SPMquot;) for @stack
<tex2html_mydb_mark>#1536#
pl@nereida:~/Lperltesting$ ./diophantinesolvergen.pl 3 2 5 40
Solver:
--------
my @stack;
sub f {
  my @s = (length($1)/3,length($2)/2,length($3)/5);
  push @stack, [ @s ];
}

q{1111111111111111111111111111111111111111} =~ m{^((?:111)+)((?:11)+)((?:11111)+)$(?{ f() })(*FAIL)}x;

return @stack;

--------
11 1 1
9 4 1
8 3 2
7 7 1
7 2 3
6 6 2
6 1 4
5 10 1
5 5 3
4 9 2
4 4 4
3 13 1
3 8 3
3 3 5
2 12 2
2 7 4
2 2 6
1 16 1
1 11 3
1 6 5
1 1 7
<tex2html_mydb_mark>#1537#
pl@nereida:~/Lperltesting$ cat -n playspiano.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
 2  use v5.10;
 3  use strict;
 4  use List::Util qw{sum};
 5
 6  local our %u;
 7  sub f {
 8    my @a = @_;
 9    @a = sort { $b ;SPMlt;=;SPMgt; $a } (length($a[1]), length($a[0])/length($a[1]), 36/length($a[0]) );
10
11    local $;SPMquot; = ;SPMquot;, ;SPMquot;;
12    say ;SPMquot;(@a)\t ;SPMquot;.sum(@a) unless exists($u{;SPMquot;@a;SPMquot;});
13    $u{;SPMquot;@a;SPMquot;} = undef;
14  }
15
16  say ;SPMquot;SOL\t\tNUMBER;SPMquot;;
17  my @a =  ('1'x36) =~
18           /^((1+)\2+)(\1+)$
19                     (?{ f($1, $2, $3)
20                      })
21             (*FAIL)
22           /x;
<tex2html_mydb_mark>#1538#
pl@nereida:~/Lperltesting$ ./playspiano.pl
SOL             NUMBER
(9, 2, 2)        13
(6, 3, 2)        11
(4, 3, 3)        10
(18, 2, 1)       21
(12, 3, 1)       16
(9, 4, 1)        14
(6, 6, 1)        13
<tex2html_mydb_mark>#1539#
   1 #!/usr/bin/perl -w
   2 undef($/);
   3 $paragraph = ;SPMlt;STDIN;SPMgt;;
   4 $count = 0;
   5 $count = ($paragraph =~ s/Mister\b/Mr./ig);
   6 print ;SPMquot;$paragraph;SPMquot;;
   7 print ;SPMquot;\n$count\n;SPMquot;;
<tex2html_mydb_mark>#1540#
;SPMgt; numsust.pl
Dear Mister Bean,
Is a pleasure for me and Mister Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mister Goofy.
 
Yours sincerely
  Mister Mickey Mouse
Dear Mr. Bean,
Is a pleasure for me and Mr. Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mr. Goofy.
 
Yours sincerely
  Mr. Mickey Mouse
 
4
<tex2html_mydb_mark>#1541#
<pre>
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span> <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>   <span class="synStatement">while</span> (<span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/e</span>) {}
<span class="synLinenum">    8</span>   <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span> }
</pre>
<tex2html_mydb_mark>#1542#
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">cat -nt tabs.in</span>
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ <span class="dbuser">./expandtabs.pl tabs.in | cat -tn</span>
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
</pre>
<tex2html_mydb_mark>#1543#
<pre>
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>     <span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$;SPMamp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/ge</span>;
<span class="synLinenum">    8</span>     <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span>   }
</pre>
<tex2html_mydb_mark>#1544#
perl -e 's/\|hyperpage//gi' -p -i.bak  alu*/*/info.txt
<tex2html_mydb_mark>#1545#
while (;SPMlt;;SPMgt;) {
        ...             # your script goes here
} continue {
        print;
}
<tex2html_mydb_mark>#1546#
#!/usr/bin/perl -pi.bak
s/foo/bar/;
<tex2html_mydb_mark>#1547#
$ perl -de 0
  DB;SPMlt;1;SPMgt; $a = 'fiboncacci'
  DB;SPMlt;2;SPMgt; $a =~ tr/aeiou/AEIOU/
  DB;SPMlt;3;SPMgt; print $a
fIbOncAccI
  DB;SPMlt;4;SPMgt; $a =~ y/fbnc/FBNC/
  DB;SPMlt;5;SPMgt; print $a
FIBONCACCI
<tex2html_mydb_mark>#1548#
$cnt = $sky =~ tr/*/*/; # count the stars in $sky
<tex2html_mydb_mark>#1549#
  DB;SPMlt;6;SPMgt; print $a
FIBONCACCI
  DB;SPMlt;7;SPMgt; $a =~ y/OA//d
  DB;SPMlt;8;SPMgt; print $a
FIBNCCCI
<tex2html_mydb_mark>#1550#
  DB;SPMlt;1;SPMgt; $b = 'aaghhh!'
  DB;SPMlt;2;SPMgt; $b =~ tr/ah//s
  DB;SPMlt;3;SPMgt; p $b
agh!
<tex2html_mydb_mark>#1551#
tr/a-zA-Z/ /cs; # change non-alphas to single space
<tex2html_mydb_mark>#1552#
tr/AAA/XYZ/
<tex2html_mydb_mark>#1553#
   1 #!/usr/bin/perl -w
   2 $search = shift(@ARGV) or die(;SPMquot;you must provide a regexpr\n;SPMquot;);
   3 $search =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   4 open(FILE,;SPMquot;/etc/passwd;SPMquot;);
   5 while ($line = ;SPMlt;FILE;SPMgt;) {
   6   $line =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   7   if ($line =~ /$search/io) {
   8     @fields = split(;SPMquot;:;SPMquot;,$line);
   9     $login = $fields[0];
  10     if ($line !~ /^#/) {
  11       print ;SPMquot;$login\n;SPMquot;;
  12     }
  13     else {
  14       print ;SPMquot;#$login\n;SPMquot;;
  15     }
  16   }
  17 }
  18
<tex2html_mydb_mark>#1554#
;SPMgt; split.pl Rodriguez
##direccion
call
casiano
alu5
alu6
##doctorado
paco
falmeida
##ihiu07
<tex2html_mydb_mark>#1555#
   1 #!/usr/bin/perl -w
   2 $searchlist = shift @ARGV;
   3 $replacelist = shift @ARGV;
   4 $option = ;SPMquot;;SPMquot;;
   5 $option = shift @ARGV if @ARGV;
   6 
   7 while (;SPMlt;;SPMgt;) {
   8   $num = eval ;SPMquot;tr/$searchlist/$replacelist/$option;SPMquot;;
   9   die $@ if $@;
  10   print ;SPMquot;$num: $_;SPMquot;;
  11 }
<tex2html_mydb_mark>#1556#
;SPMgt; tr.pl 'a-z' 'A-Z' s
jose hernandez
13: JOSE HERNANDEZ
joosee hernnandez
16: JOSE HERNANDEZ
<tex2html_mydb_mark>#1557#
pack(;SPMquot;CCC;SPMquot;, 65, 66, 67, 68) # empaquetamos A B C D
<tex2html_mydb_mark>#1558#
unpack(;SPMquot;CCC;SPMquot;, ;SPMquot;ABCD;SPMquot;)
<tex2html_mydb_mark>#1559#
DB;SPMlt;1;SPMgt; $a = pack ;SPMquot;A2A3;SPMquot;, ;SPMquot;Pea;SPMquot;,;SPMquot;rl;SPMquot;
DB;SPMlt;2;SPMgt; p $a
Perl
DB;SPMlt;3;SPMgt; @b = unpack ;SPMquot;A2A3;SPMquot;, ;SPMquot;Perl;SPMquot;
DB;SPMlt;4;SPMgt; p ;SPMquot;@b;SPMquot;
Pe rl
<tex2html_mydb_mark>#1560#
p ord('A')
65
DB;SPMlt;22;SPMgt; $x = pack ;SPMquot;B8;SPMquot;, ;SPMquot;01000001;SPMquot;
DB;SPMlt;23;SPMgt; p $x
A
DB;SPMlt;24;SPMgt; @y = unpack ;SPMquot;B8;SPMquot;, ;SPMquot;A;SPMquot;
DB;SPMlt;25;SPMgt; p ;SPMquot;@y;SPMquot;
01000001
DB;SPMlt;26;SPMgt; $x = pack ;SPMquot;b8;SPMquot;, ;SPMquot;10000010;SPMquot;
DB;SPMlt;27;SPMgt; p $x
<tex2html_mydb_mark>#1561#
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  ;SPMlt;?xml version=;SPMquot;1.0;SPMquot;?;SPMgt;
 2  ;SPMlt;!DOCTYPE invitation SYSTEM ;SPMquot;invitation.dtd;SPMquot;;SPMgt;
 3  ;SPMlt;invitation;SPMgt;
 4  ;SPMlt;!-- ++++ The header part of the document ++++ --;SPMgt;
 5  ;SPMlt;front;SPMgt;
 6  ;SPMlt;to;SPMgt;Anna, Bernard, Didier, Johanna;SPMlt;/to;SPMgt;
 7  ;SPMlt;date;SPMgt;Next Friday Evening at 8 pm;SPMlt;/date;SPMgt;
 8  ;SPMlt;where;SPMgt;The Web Cafe;SPMlt;/where;SPMgt;
 9  ;SPMlt;why;SPMgt;My first XML baby;SPMlt;/why;SPMgt;
10  ;SPMlt;/front;SPMgt;
11  ;SPMlt;!-- +++++ The main part of the document +++++ --;SPMgt;
12  ;SPMlt;body;SPMgt;
13  ;SPMlt;par;SPMgt;
14  I would like to invite you all to celebrate
15  the birth of ;SPMlt;emph;SPMgt;Invitation;SPMlt;/emph;SPMgt;, my
16  first XML document child.
17  ;SPMlt;/par;SPMgt;
18  ;SPMlt;par;SPMgt;
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  ;SPMlt;/par;SPMgt;
22  ;SPMlt;par;SPMgt;
23  I ;SPMlt;emph;SPMgt;really;SPMlt;/emph;SPMgt; look forward to see you soon!
24  ;SPMlt;/par;SPMgt;
25  ;SPMlt;/body;SPMgt;
26  ;SPMlt;!-- +++ The closing part of the document ++++ --;SPMgt;
27  ;SPMlt;back;SPMgt;
28  ;SPMlt;signature;SPMgt;Michel;SPMlt;/signature;SPMgt;
29  ;SPMlt;/back;SPMgt;
30  ;SPMlt;/invitation;SPMgt;
<tex2html_mydb_mark>#1562#
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.dtd
 1  ;SPMlt;!-- invitation DTD   --;SPMgt;
 2  ;SPMlt;!-- May 26th 1998 mg --;SPMgt;
 3  ;SPMlt;!ELEMENT invitation (front, body, back) ;SPMgt;
 4  ;SPMlt;!ELEMENT front      (to, date, where, why?) ;SPMgt;
 5  ;SPMlt;!ELEMENT date       (#PCDATA) ;SPMgt;
 6  ;SPMlt;!ELEMENT to         (#PCDATA) ;SPMgt;
 7  ;SPMlt;!ELEMENT where      (#PCDATA) ;SPMgt;
 8  ;SPMlt;!ELEMENT why        (#PCDATA) ;SPMgt;
 9  ;SPMlt;!ELEMENT body       (par+) ;SPMgt;
10  ;SPMlt;!ELEMENT par        (#PCDATA|emph)* ;SPMgt;
11  ;SPMlt;!ELEMENT emph       (#PCDATA) ;SPMgt;
12  ;SPMlt;!ELEMENT back       (signature) ;SPMgt;
13  ;SPMlt;!ELEMENT signature  (#PCDATA) ;SPMgt;
<tex2html_mydb_mark>#1563#
 exp -;SPMgt;   exp '-' digits
        | digits
<tex2html_mydb_mark>#1564#
exp -;SPMgt;   digits rest
rest -;SPMgt;   '-' rest
        | # empty
<tex2html_mydb_mark>#1565#
<pre>
pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># original grammar:</span>
<span class="synLinenum">    6</span>   <span class="synComment">#  exp -;SPMgt;   exp '-' digits</span>
<span class="synLinenum">    7</span>   <span class="synComment">#         | digits</span>
<span class="synLinenum">    8</span>   <span class="synComment">#</span>
<span class="synLinenum">    9</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   10</span>   <span class="synComment">#  exp -;SPMgt;   digits rest</span>
<span class="synLinenum">   11</span>   <span class="synComment">#  rest -;SPMgt;   '-' rest</span>
<span class="synLinenum">   12</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   13</span>   <span class="synComment">#</span>
<span class="synLinenum">   14</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   15</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$tran</span> = <span class="synConstant">''</span>;
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   21</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;exp;SPMgt;    </span><span class="synSpecial">((?</span><span class="synConstant">;SPMamp;digits</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">{ </span><span class="synIdentifier">$tran</span><span class="synConstant"> </span><span class="synSpecial">.</span><span class="synConstant">= ;SPMquot;</span><span class="synIdentifier">$^</span><span class="synConstant">N ;SPMquot;; say ;SPMquot;tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">;SPMquot;; }</span>) (?<span class="synIdentifier">;SPMamp;rest</span>)
<span class="synLinenum">   22</span>                         (?{
<span class="synLinenum">   23</span>                            say <span class="synConstant">;SPMquot;exp -;SPMgt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rest;SPMquot;</span>;
<span class="synLinenum">   24</span>                         })
<span class="synLinenum">   25</span>           )
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span>           (?<span class="synIdentifier">;SPMlt;rest;SPMgt;</span>     \s* - ((?<span class="synIdentifier">;SPMamp;digits</span>)) (?{ <span class="synIdentifier">$tran</span> .= <span class="synConstant">;SPMquot;</span><span class="synIdentifier">$^</span><span class="synConstant">N - ;SPMquot;</span>; say <span class="synConstant">;SPMquot;tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">;SPMquot;</span>; }) (?<span class="synIdentifier">;SPMamp;rest</span>)
<span class="synLinenum">   28</span>                           (?{
<span class="synLinenum">   29</span>                              say <span class="synConstant">;SPMquot;rest -;SPMgt; - digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rest;SPMquot;</span>;
<span class="synLinenum">   30</span>                           })
<span class="synLinenum">   31</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   32</span>                           (?{
<span class="synLinenum">   33</span>                              say <span class="synConstant">;SPMquot;rest -;SPMgt; empty;SPMquot;</span>;
<span class="synLinenum">   34</span>                           })
<span class="synLinenum">   35</span>           )
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span>           (?<span class="synIdentifier">;SPMlt;digits;SPMgt;</span>  \s* (\d+)
<span class="synLinenum">   38</span>           )
<span class="synLinenum">   39</span>       )
<span class="synLinenum">   40</span>   }xms;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>   <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   43</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   44</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   45</span>     say <span class="synConstant">;SPMquot;matches: </span><span class="synIdentifier">$;SPMamp;</span><span class="synSpecial">\n</span><span class="synConstant">tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">;SPMquot;</span>;
<span class="synLinenum">   46</span>   }
<span class="synLinenum">   47</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   48</span>     say <span class="synConstant">;SPMquot;does not match;SPMquot;</span>;
<span class="synLinenum">   49</span>   }
</pre>
<tex2html_mydb_mark>#1566#
pl@nereida:~/Lperltesting$ ./infixtopostfix.pl
ab 5 - 3 -2 cd;
tran= 5
tran= 5  3 -
tran= 5  3 - 2 -
rest -;SPMgt; empty
rest -;SPMgt; - digits(2) rest
rest -;SPMgt; - digits( 3) rest
exp -;SPMgt; digits( 5) rest
matches:  5 - 3 -2
tran= 5  3 - 2 -
<tex2html_mydb_mark>#1567#
<pre>
pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -;SPMgt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -;SPMgt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -;SPMgt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -;SPMgt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -;SPMgt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -;SPMgt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   24</span> 
<span class="synLinenum">   25</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$op</span> = <span class="synConstant">''</span>;
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   27</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   30</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;exp;SPMgt;    </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   31</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say ;SPMquot;exp -;SPMgt; term re;SPMquot; }</span>)
<span class="synLinenum">   32</span>           )
<span class="synLinenum">   33</span> 
<span class="synLinenum">   34</span>           (?<span class="synIdentifier">;SPMlt;re;SPMgt;</span>     \s* ([+-]) (?<span class="synIdentifier">;SPMamp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N }) (?<span class="synIdentifier">;SPMamp;re</span>)
<span class="synLinenum">   35</span>                        (?{ say <span class="synConstant">;SPMquot;re -;SPMgt; [+-] term re;SPMquot;</span> })
<span class="synLinenum">   36</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   37</span>                        (?{ say <span class="synConstant">;SPMquot;re -;SPMgt; empty;SPMquot;</span> })
<span class="synLinenum">   38</span>           )
<span class="synLinenum">   39</span> 
<span class="synLinenum">   40</span>           (?<span class="synIdentifier">;SPMlt;term;SPMgt;</span>   ((?<span class="synIdentifier">;SPMamp;digits</span>))
<span class="synLinenum">   41</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   42</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N
<span class="synLinenum">   43</span>                         })
<span class="synLinenum">   44</span>                      (?<span class="synIdentifier">;SPMamp;rt</span>)
<span class="synLinenum">   45</span>                         (?{
<span class="synLinenum">   46</span>                             say <span class="synConstant">;SPMquot;term-;SPMgt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt;SPMquot;</span>;
<span class="synLinenum">   47</span>                         })
<span class="synLinenum">   48</span>           )
<span class="synLinenum">   49</span> 
<span class="synLinenum">   50</span>           (?<span class="synIdentifier">;SPMlt;rt;SPMgt;</span>     \s*([*/])
<span class="synLinenum">   51</span>                              (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   52</span>                                 <span class="synStatement">local</span> <span class="synIdentifier">$op</span> = <span class="synIdentifier">$^</span>N;
<span class="synLinenum">   53</span>                              })
<span class="synLinenum">   54</span>                      ((?<span class="synIdentifier">;SPMamp;digits</span>)) \s*
<span class="synLinenum">   55</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   56</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N, <span class="synIdentifier">$op</span>
<span class="synLinenum">   57</span>                               })
<span class="synLinenum">   58</span>                      (?<span class="synIdentifier">;SPMamp;rt</span>) <span class="synComment"># end of ;SPMlt;rt;SPMgt; definition</span>
<span class="synLinenum">   59</span>                              (?{
<span class="synLinenum">   60</span>                                   say <span class="synConstant">;SPMquot;rt -;SPMgt; [*/] digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt;SPMquot;</span>
<span class="synLinenum">   61</span>                               })
<span class="synLinenum">   62</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   63</span>                        (?{ say <span class="synConstant">;SPMquot;rt -;SPMgt; empty;SPMquot;</span> })
<span class="synLinenum">   64</span>           )
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>           (?<span class="synIdentifier">;SPMlt;digits;SPMgt;</span>  \s* \d+
<span class="synLinenum">   67</span>           )
<span class="synLinenum">   68</span>       )
<span class="synLinenum">   69</span>   }xms;
<span class="synLinenum">   70</span> 
<span class="synLinenum">   71</span>   <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   72</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   73</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   74</span>     say <span class="synConstant">;SPMquot;matches: </span><span class="synIdentifier">$;SPMamp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">);SPMquot;</span>;
<span class="synLinenum">   75</span>   }
<span class="synLinenum">   76</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   77</span>     say <span class="synConstant">;SPMquot;does not match;SPMquot;</span>;
<span class="synLinenum">   78</span>   }
</pre>
<tex2html_mydb_mark>#1568#
pl@nereida:~/Lperltesting$ ./calc510withactions3.pl
5-8/4/2-1
rt -;SPMgt; empty
term-;SPMgt; digits(5) rt
rt -;SPMgt; empty
rt -;SPMgt; [*/] digits(2) rt
rt -;SPMgt; [*/] digits(4) rt
term-;SPMgt; digits(8) rt
rt -;SPMgt; empty
term-;SPMgt; digits(1) rt
re -;SPMgt; empty
re -;SPMgt; [+-] term re
re -;SPMgt; [+-] term re
exp -;SPMgt; term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
<tex2html_mydb_mark>#1569#
<pre>
pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -;SPMgt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -;SPMgt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -;SPMgt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -;SPMgt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -;SPMgt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -;SPMgt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> rc </span>{
<span class="synLinenum">   22</span>     <span class="synStatement">my</span> <span class="synIdentifier">$ofs</span> = - <span class="synStatement">shift</span>;
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>     <span class="synComment"># Number of parenthesis that matched</span>
<span class="synLinenum">   25</span>     <span class="synStatement">my</span> <span class="synIdentifier">$np</span> = @-;
<span class="synLinenum">   26</span>     <span class="synComment"># $_ contains the string being matched</span>
<span class="synLinenum">   27</span>     <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$-</span>[<span class="synIdentifier">$ofs</span>], <span class="synIdentifier">$+</span>[<span class="synIdentifier">$np</span>+<span class="synIdentifier">$ofs</span>] - <span class="synIdentifier">$-</span>[<span class="synIdentifier">$ofs</span>])
<span class="synLinenum">   28</span>   }
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   31</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   34</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   35</span> 
<span class="synLinenum">   36</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   37</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;exp;SPMgt;    </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   38</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say ;SPMquot;exp -;SPMgt; term re;SPMquot; }</span>)
<span class="synLinenum">   39</span>           )
<span class="synLinenum">   40</span> 
<span class="synLinenum">   41</span>           (?<span class="synIdentifier">;SPMlt;re;SPMgt;</span>     \s* ([+-]) (?<span class="synIdentifier">;SPMamp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>) }) (?<span class="synIdentifier">;SPMamp;re</span>)
<span class="synLinenum">   42</span>                        (?{ say <span class="synConstant">;SPMquot;re -;SPMgt; [+-] term re;SPMquot;</span> })
<span class="synLinenum">   43</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   44</span>                        (?{ say <span class="synConstant">;SPMquot;re -;SPMgt; empty;SPMquot;</span> })
<span class="synLinenum">   45</span>           )
<span class="synLinenum">   46</span> 
<span class="synLinenum">   47</span>           (?<span class="synIdentifier">;SPMlt;term;SPMgt;</span>   ((?<span class="synIdentifier">;SPMamp;digits</span>))
<span class="synLinenum">   48</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   49</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>)
<span class="synLinenum">   50</span>                         })
<span class="synLinenum">   51</span>                      (?<span class="synIdentifier">;SPMamp;rt</span>)
<span class="synLinenum">   52</span>                         (?{
<span class="synLinenum">   53</span>                             say <span class="synConstant">;SPMquot;term-;SPMgt; digits(;SPMquot;</span>.rc(<span class="synConstant">1</span>).<span class="synConstant">;SPMquot;) rt;SPMquot;</span>;
<span class="synLinenum">   54</span>                         })
<span class="synLinenum">   55</span>           )
<span class="synLinenum">   56</span> 
<span class="synLinenum">   57</span>           (?<span class="synIdentifier">;SPMlt;rt;SPMgt;</span>     \s*([*/]) ((?<span class="synIdentifier">;SPMamp;digits</span>)) \s*
<span class="synLinenum">   58</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   59</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>), rc(<span class="synConstant">2</span>)
<span class="synLinenum">   60</span>                               })
<span class="synLinenum">   61</span>                      (?<span class="synIdentifier">;SPMamp;rt</span>) <span class="synComment"># end of ;SPMlt;rt;SPMgt; definition</span>
<span class="synLinenum">   62</span>                              (?{
<span class="synLinenum">   63</span>                                   say <span class="synConstant">;SPMquot;rt -;SPMgt; [*/] digits(;SPMquot;</span>.rc(<span class="synConstant">1</span>).<span class="synConstant">;SPMquot;) rt;SPMquot;</span>
<span class="synLinenum">   64</span>                               })
<span class="synLinenum">   65</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   66</span>                        (?{ say <span class="synConstant">;SPMquot;rt -;SPMgt; empty;SPMquot;</span> })
<span class="synLinenum">   67</span>           )
<span class="synLinenum">   68</span> 
<span class="synLinenum">   69</span>           (?<span class="synIdentifier">;SPMlt;digits;SPMgt;</span>  \s* \d+
<span class="synLinenum">   70</span>           )
<span class="synLinenum">   71</span>       )
<span class="synLinenum">   72</span>   }xms;
<span class="synLinenum">   73</span> 
<span class="synLinenum">   74</span>   <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   75</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   76</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   77</span>     say <span class="synConstant">;SPMquot;matches: </span><span class="synIdentifier">$;SPMamp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">);SPMquot;</span>;
<span class="synLinenum">   78</span>   }
<span class="synLinenum">   79</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   80</span>     say <span class="synConstant">;SPMquot;does not match;SPMquot;</span>;
<span class="synLinenum">   81</span>   }
</pre>
<tex2html_mydb_mark>#1570#
         (?;SPMlt;rt;SPMgt;     \s*([*/]) ((?;SPMamp;digits)) \s*
                            (?{  # intermediate action
                                 push @stack, rc(1), rc(2)
                             })
<tex2html_mydb_mark>#1571#
pl@nereida:~/Lperltesting$ ./calc510withactions4.pl
5-8/4/2-1
rt -;SPMgt; empty
term-;SPMgt; digits(5) rt
rt -;SPMgt; empty
rt -;SPMgt; [*/] digits(2) rt
rt -;SPMgt; [*/] digits(4) rt
term-;SPMgt; digits(8) rt
rt -;SPMgt; empty
term-;SPMgt; digits(1) rt
re -;SPMgt; empty
re -;SPMgt; [+-] term re
re -;SPMgt; [+-] term re
exp -;SPMgt; term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
pl@nereida:~/Lperltesting$
<tex2html_mydb_mark>#1572#
47          (?;SPMlt;rt;SPMgt;     \s*(?;SPMlt;op;SPMgt;[*/]) (?;SPMlt;num;SPMgt;(?;SPMamp;digits)) \s*
48                             (?{  # intermediate action
49                                  push @stack, $+{num}, $+{op}
50                              })
<tex2html_mydb_mark>#1573#
<pre>
pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -;SPMgt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -;SPMgt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -;SPMgt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -;SPMgt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -;SPMgt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -;SPMgt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   24</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">;SPMlt;exp;SPMgt;    </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">;SPMamp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   28</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say ;SPMquot;exp -;SPMgt; term re;SPMquot; }</span>)
<span class="synLinenum">   29</span>           )
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>           (?<span class="synIdentifier">;SPMlt;re;SPMgt;</span>     \s* ([+-]) (?<span class="synIdentifier">;SPMamp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N }) (?<span class="synIdentifier">;SPMamp;re</span>)
<span class="synLinenum">   32</span>                        (?{ say <span class="synConstant">;SPMquot;re -;SPMgt; [+-] term re;SPMquot;</span> })
<span class="synLinenum">   33</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   34</span>                        (?{ say <span class="synConstant">;SPMquot;re -;SPMgt; empty;SPMquot;</span> })
<span class="synLinenum">   35</span>           )
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span>           (?<span class="synIdentifier">;SPMlt;term;SPMgt;</span>   ((?<span class="synIdentifier">;SPMamp;digits</span>))
<span class="synLinenum">   38</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   39</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N
<span class="synLinenum">   40</span>                         })
<span class="synLinenum">   41</span>                      (?<span class="synIdentifier">;SPMamp;rt</span>)
<span class="synLinenum">   42</span>                         (?{
<span class="synLinenum">   43</span>                             say <span class="synConstant">;SPMquot;term-;SPMgt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt;SPMquot;</span>;
<span class="synLinenum">   44</span>                         })
<span class="synLinenum">   45</span>           )
<span class="synLinenum">   46</span> 
<span class="synLinenum">   47</span>           (?<span class="synIdentifier">;SPMlt;rt;SPMgt;</span>     \s*(?<span class="synIdentifier">;SPMlt;op;SPMgt;</span>[*/]) (?<span class="synIdentifier">;SPMlt;num;SPMgt;</span>(?<span class="synIdentifier">;SPMamp;digits</span>)) \s*
<span class="synLinenum">   48</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   49</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$+</span>{num}, <span class="synIdentifier">$+</span>{op}
<span class="synLinenum">   50</span>                               })
<span class="synLinenum">   51</span>                      (?<span class="synIdentifier">;SPMamp;rt</span>) <span class="synComment"># end of ;SPMlt;rt;SPMgt; definition</span>
<span class="synLinenum">   52</span>                              (?{
<span class="synLinenum">   53</span>                                   say <span class="synConstant">;SPMquot;rt -;SPMgt; [*/] digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt;SPMquot;</span>
<span class="synLinenum">   54</span>                               })
<span class="synLinenum">   55</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   56</span>                        (?{ say <span class="synConstant">;SPMquot;rt -;SPMgt; empty;SPMquot;</span> })
<span class="synLinenum">   57</span>           )
<span class="synLinenum">   58</span> 
<span class="synLinenum">   59</span>           (?<span class="synIdentifier">;SPMlt;digits;SPMgt;</span>  \s* \d+
<span class="synLinenum">   60</span>           )
<span class="synLinenum">   61</span>       )
<span class="synLinenum">   62</span>   }xms;
<span class="synLinenum">   63</span> 
<span class="synLinenum">   64</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;;
<span class="synLinenum">   65</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   66</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   67</span>     say <span class="synConstant">;SPMquot;matches: </span><span class="synIdentifier">$;SPMamp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">);SPMquot;</span>;
<span class="synLinenum">   68</span>   }
<span class="synLinenum">   69</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   70</span>     say <span class="synConstant">;SPMquot;does not match;SPMquot;</span>;
<span class="synLinenum">   71</span>   }
</pre>
<tex2html_mydb_mark>#1574#
pl@nereida:~/Lperltesting$ ./calc510withnamedpar.pl
5-8/4/2-1
rt -;SPMgt; empty
term-;SPMgt; digits(5) rt
rt -;SPMgt; empty
rt -;SPMgt; [*/] digits(2) rt
rt -;SPMgt; [*/] digits(4) rt
term-;SPMgt; digits(8) rt
rt -;SPMgt; empty
term-;SPMgt; digits(1) rt
re -;SPMgt; empty
re -;SPMgt; [+-] term re
re -;SPMgt; [+-] term re
exp -;SPMgt; term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
<tex2html_mydb_mark>#1575#
.
|-- ASTandtrans3.pl    # programa principal
|-- BinaryOp.pm        # clases para el manejo de los nodos del AST
|-- testreegxpparen.pl # prueba para Regexp::Paren
`-- Regexp
    `-- Paren.pm       # módulo de extensión de $^N
<tex2html_mydb_mark>#1576#
pl@nereida:~/Lperltesting$ ./ASTandtrans3.pl
2*(3-4)
factor -;SPMgt; NUM(2)
factor -;SPMgt; NUM(3)
rt -;SPMgt; empty
term-;SPMgt; factor rt
factor -;SPMgt; NUM(4)
rt -;SPMgt; empty
term-;SPMgt; factor rt
re -;SPMgt; empty
re -;SPMgt; [+-] term re
exp -;SPMgt; term re
factor -;SPMgt; ( exp )
rt -;SPMgt; empty
rt -;SPMgt; [*/] factor rt
term-;SPMgt; factor rt
re -;SPMgt; empty
exp -;SPMgt; term re
matches: 2*(3-4)
<tex2html_mydb_mark>#1577#
exp =;SPMgt; term re =;SPMgt; term =;SPMgt; factor rt =;SPMgt; 
factor [*/](*) factor rt =;SPMgt; factor [*/](*) factor =;SPMgt; 
factor [*/](*) ( exp ) =;SPMgt; factor [*/](*) ( term re ) =;SPMgt;  
factor [*/](*) ( term [+-](-) term re ) =;SPMgt;  
factor [*/](*) ( term [+-](-) term ) =;SPMgt; 
factor [*/](*) ( term [+-](-) factor rt ) =;SPMgt;
factor [*/](*) ( term [+-](-) factor ) =;SPMgt; 
factor [*/](*) ( term [+-](-) NUM(4) ) =;SPMgt;
factor [*/](*) ( factor rt [+-](-) NUM(4) ) =;SPMgt; 
factor [*/](*) ( factor [+-](-) NUM(4) ) =;SPMgt;
factor [*/](*) ( NUM(3) [+-](-) NUM(4) )  =;SPMgt; 
NUM(2) [*/](*) ( NUM(3) [+-](-) NUM(4) )
<tex2html_mydb_mark>#1578#
AST:
$VAR1 = bless( {
  'left' =;SPMgt; bless( { 'val' =;SPMgt; '2' }, 'NUM' ),
  'right' =;SPMgt; bless( {
    'left' =;SPMgt; bless( { 'val' =;SPMgt; '3' }, 'NUM' ),
    'right' =;SPMgt; bless( { 'val' =;SPMgt; '4' }, 'NUM' ),
    'op' =;SPMgt; '-'
  }, 'ADD' ),
  'op' =;SPMgt; '*'
}, 'MULT' );
<tex2html_mydb_mark>#1579#
<img src="ast234.png" alt="MUL(2,ADD(3,4))" height=200>
<tex2html_mydb_mark>#1580#
2 3 4 - *
<tex2html_mydb_mark>#1581#
 exp    -;SPMgt;   exp [-+] term
           | term
 term   -;SPMgt;   term [*/] factor
           | factor
 factor -;SPMgt;  \( exp \)
           | \d+
<tex2html_mydb_mark>#1582#
 exp       -;SPMgt;   term restoexp
 restoexp  -;SPMgt;   [-+] term restoexp
              | # vacío
 term      -;SPMgt;   term restoterm
 restoterm -;SPMgt;   [*/] factor restoterm
              | # vacío
 factor    -;SPMgt;   \( exp \)
              | \d+
<tex2html_mydb_mark>#1583#
 exp    -;SPMgt;   exp ([-+]) term       { ADD-;SPMgt;new(left =;SPMgt; $exp, right =;SPMgt; $term, op =;SPMgt; $1) }
           | term                  { $term }
 term   -;SPMgt;   term ([*/]) factor    { MULT-;SPMgt;new(left =;SPMgt; $exp, right =;SPMgt; $term, op =;SPMgt; $1) } 
           | factor                { $factor }
 factor -;SPMgt;  \( exp \)              { $exp }
           | (\d+)                 { NUM-;SPMgt;new(val =;SPMgt; $1) }
<tex2html_mydb_mark>#1584#
pl@nereida:~/Lperltesting$ cat -n ./ASTandtrans3.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3  use strict;
 4  use Regexp::Paren qw{g};
 5  use BinaryOp;
 6
 7  use Data::Dumper;
 8  $Data::Dumper::Indent = 1;
 9
10  # Builds AST
11  my @stack;
12  my $regexp = qr{
13      (?;SPMamp;exp)
14
15      (?(DEFINE)
16          (?;SPMlt;exp;SPMgt;    (?;SPMamp;term) (?;SPMamp;re)
17                       (?{ say ;SPMquot;exp -;SPMgt; term re;SPMquot; })
18          )
19
20          (?;SPMlt;re;SPMgt;     \s* ([+-]) (?;SPMamp;term)
21                        (?{  # intermediate action
22                            local our ($ch1, $term) = splice @stack, -2;
23
24                            push @stack, ADD-;SPMgt;new( {left =;SPMgt; $ch1, right =;SPMgt; $term, op =;SPMgt; g(1)});
25                        })
26                     (?;SPMamp;re)
27                       (?{ say ;SPMquot;re -;SPMgt; [+-] term re;SPMquot; })
28                   | # empty
29                       (?{ say ;SPMquot;re -;SPMgt; empty;SPMquot; })
30          )
31
32          (?;SPMlt;term;SPMgt;   ((?;SPMamp;factor)) (?;SPMamp;rt)
33                        (?{
34                            say ;SPMquot;term-;SPMgt; factor rt;SPMquot;;
35                        })
36          )
37
38          (?;SPMlt;rt;SPMgt;     \s*([*/]) (?;SPMamp;factor)
39                         (?{  # intermediate action
40                              local our ($ch1, $ch2) = splice @stack, -2;
41
42                              push @stack, MULT-;SPMgt;new({left =;SPMgt; $ch1, right =;SPMgt; $ch2, op =;SPMgt; g(1)});
43                          })
44                     (?;SPMamp;rt) # end of ;SPMlt;rt;SPMgt; definition
45                         (?{
46                              say ;SPMquot;rt -;SPMgt; [*/] factor rt;SPMquot;
47                          })
48                   | # empty
49                         (?{ say ;SPMquot;rt -;SPMgt; empty;SPMquot; })
50          )
51
52          (?;SPMlt;factor;SPMgt; \s* (\d+)
53                          (?{
54                             say ;SPMquot;factor -;SPMgt; NUM($^N);SPMquot;;
55                             push @stack, bless { 'val' =;SPMgt; g(1) }, 'NUM';
56                          })
57                     | \s* \( (?;SPMamp;exp) \s* \)
58                          (?{ say ;SPMquot;factor -;SPMgt; ( exp );SPMquot; })
59          )
60      )
61  }xms;
62
63  my $input = ;SPMlt;;SPMgt;;
64  chomp($input);
65  if ($input =~ $regexp) {
66    say ;SPMquot;matches: $;SPMamp;;SPMquot;;
67    my $ast = pop @stack;
68    say ;SPMquot;AST:\n;SPMquot;, Dumper $ast;
69
70    say $ast-;SPMgt;translate;
71  }
72  else {
73    say ;SPMquot;does not match;SPMquot;;
74  }
<tex2html_mydb_mark>#1585#
my $self = shift;
my $etiqueta1 = generar_nueva_etiqueta;
my $etiqueta2 = generar_nueva_etiqueta;

my $boolexpr      = $self-;SPMgt;boolexpr-;SPMgt;translate;
my $ifstatement   = $self-;SPMgt;ifstatement-;SPMgt;translate,  
my $elsestatement = $self-;SPMgt;elsestatement-;SPMgt;translate, 
return ;SPMlt;;SPMlt; ;SPMquot;ENDTRANS;SPMquot;;
    $boolexpr
    JUMPZERO $etiqueta1:
    $ifstatement
    JUMP     $etiqueta2:
  $etiqueta1:
    $elsestatement
  $etiqueta2:
ENDTRANS
<tex2html_mydb_mark>#1586#
pl@nereida:~/Lperltesting$ cat -n BinaryOp.pm
 1  package BinaryOp;
 2  use strict;
 3  use base qw(Class::Accessor);
 4
 5  BinaryOp-;SPMgt;mk_accessors(qw{left right op});
 6
 7  sub translate {
 8    my $self = shift;
 9
10    return $self-;SPMgt;left-;SPMgt;translate.;SPMquot; ;SPMquot;.$self-;SPMgt;right-;SPMgt;translate.;SPMquot; ;SPMquot;.$self-;SPMgt;op;
11  }
12
13  package ADD;
14  use base qw{BinaryOp};
15
16  package MULT;
17  use base qw{BinaryOp};
18
19  package NUM;
20
21  sub translate {
22    my $self = shift;
23
24    return $self-;SPMgt;{val};
25  }
26
27  1;
<tex2html_mydb_mark>#1587#
pl@nereida:~/Lperltesting$ cat -n Regexp/Paren.pm
 1  package Regexp::Paren;
 2  use strict;
 3
 4  use base qw{Exporter};
 5
 6  our @EXPORT_OK = qw{g};
 7
 8  sub g {
 9    die ;SPMquot;Error in 'Regexp::Paren::g'. Not used inside (?{ code }) construct\n;SPMquot; unless defined($_);
10    my $ofs = - shift;
11
12    # Number of parenthesis that matched
13    my $np = @-;
14    die ;SPMquot;Error. Illegal 'Regexp::Paren::g' ref inside (?{ code }) construct\n;SPMquot; unless ($np ;SPMgt; - $ofs ;SPMamp;;SPMamp; $ofs ;SPMlt; 0);
15    # $_ contains the string being matched
16    substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
17  }
18
19  1;
20
21  =head1 NAME
22
23  Regexp::Paren - Extends $^N inside (?{ ... }) constructs
24
25  =head1 SYNOPSIS
26
27    use Regexp::Paren qw{g};
28
29    'abcde' =~ qr{(.)(.)(.)
30                         (?{ print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot;\n;SPMquot; })                   # c b a
31                 (.)     (?{ print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot; ;SPMquot;.g(4).;SPMquot;\n;SPMquot; })          # d c b a
32                 (.)     (?{ print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot; ;SPMquot;.g(4).;SPMquot; ;SPMquot;.g(5).;SPMquot;\n;SPMquot; }) # e d c b a
33                }x;
34
35    print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot; ;SPMquot;.g(4).;SPMquot; ;SPMquot;.g(5).;SPMquot;\n;SPMquot;; # error!
36
37  =head1 DESCRIPTION
38
39  Inside a C;SPMlt;(?{ ... });SPMgt; construct, C;SPMlt;g(1);SPMgt; refers to what matched the last parenthesis
40  (like C;SPMlt;$^N;SPMgt;), C;SPMlt;g(2);SPMgt; refers to the string that matched with the parenthesis before
41  the last, C;SPMlt;g(3);SPMgt; refers to the string that matched with the parenthesis at distance 3,
42  etc.
43
44  =head1 SEE ALSO
45
46  =over 2
47
48  =item * L;SPMlt;perlre;SPMgt;
49
50  =item * L;SPMlt;perlretut;SPMgt;
51
52  =item * PerlMonks node I;SPMlt;Strange behavior o;SPMgt; C;SPMlt;@-;SPMgt; I;SPMlt;and;SPMgt; C;SPMlt;@+;SPMgt; I;SPMlt;in perl5.10 regexps;SPMgt; L;SPMlt;http://www.perlmonks.org/?node_id=794736;SPMgt;
53
54  =item * PerlMonks node I;SPMlt;Backreference variables in code embedded inside Perl 5.10 regexps;SPMgt; L;SPMlt;http://www.perlmonks.org/?node_id=794424;SPMgt;
55
56  =back
57
58  =head1 AUTHOR
59
60  Casiano Rodriguez-Leon (casiano@ull.es)
61
62  =head1 ACKNOWLEDGMENTS
63
64  This work has been supported by CEE (FEDER) and the Spanish Ministry of
65  I;SPMlt;Educacion y Ciencia;SPMgt; through I;SPMlt;Plan Nacional I+D+I;SPMgt; number TIN2005-08818-C04-04
66  (ULL::OPLINK project L;SPMlt;http://www.oplink.ull.es/;SPMgt;).
67  Support from Gobierno de Canarias was through GC02210601
68  (I;SPMlt;Grupos Consolidados;SPMgt;).
69  The University of La Laguna has also supported my work in many ways
70  and for many years.
71
72  =head1 LICENCE AND COPYRIGHT
73
74  Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
75
76  These modules are free software; you can redistribute it and/or
77  modify it under the same terms as Perl itself. See L;SPMlt;perlartistic;SPMgt;.
78
79  This program is distributed in the hope that it will be useful,
80  but WITHOUT ANY WARRANTY; without even the implied warranty of
81  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
<tex2html_mydb_mark>#1588#
NAME
    Regexp::Paren - Extends $^N inside (?{ ... }) constructs

SYNOPSIS
      use Regexp::Paren qw{g};

      'abcde' =~ qr{(.)(.)(.)
                           (?{ print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot;\n;SPMquot; })                   # c b a
                   (.)     (?{ print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot; ;SPMquot;.g(4).;SPMquot;\n;SPMquot; })          # d c b a
                   (.)     (?{ print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot; ;SPMquot;.g(4).;SPMquot; ;SPMquot;.g(5).;SPMquot;\n;SPMquot; }) # e d c b a
                  }x;

      print g(1).;SPMquot; ;SPMquot;.g(2).;SPMquot; ;SPMquot;.g(3).;SPMquot; ;SPMquot;.g(4).;SPMquot; ;SPMquot;.g(5).;SPMquot;\n;SPMquot;; # error!

DESCRIPTION
    Inside a ;SPMquot;(?{ ... });SPMquot; construct, g(1) refers to what matched the last
    parenthesis (like $^N), g(2) refers to the string that matched with the
    parenthesis before the last, g(3) refers to the string that matched with
    the parenthesis at distance 3, etc.

SEE ALSO
    * perlre
    * perlretut
    * PerlMonks node *Strange behavior o* ;SPMquot;@-;SPMquot; *and* ;SPMquot;@+;SPMquot; *in perl5.10
      regexps* ;SPMlt;http://www.perlmonks.org/?node_id=794736;SPMgt;
    * PerlMonks node *Backreference variables in code embedded inside Perl
      5.10 regexps* ;SPMlt;http://www.perlmonks.org/?node_id=794424;SPMgt;

AUTHOR
    Casiano Rodriguez-Leon (casiano@ull.es)

ACKNOWLEDGMENTS
    This work has been supported by CEE (FEDER) and the Spanish Ministry of
    *Educacion y Ciencia* through *Plan Nacional I+D+I* number
    TIN2005-08818-C04-04 (ULL::OPLINK project ;SPMlt;http://www.oplink.ull.es/;SPMgt;).
    Support from Gobierno de Canarias was through GC02210601 (*Grupos
    Consolidados*). The University of La Laguna has also supported my work
    in many ways and for many years.

LICENCE AND COPYRIGHT
    Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights
<tex2html_mydb_mark>#1589#
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  ;SPMlt;?xml version=;SPMquot;1.0;SPMquot;?;SPMgt;
 2  ;SPMlt;!DOCTYPE invitation SYSTEM ;SPMquot;invitation.dtd;SPMquot;;SPMgt;
 3  ;SPMlt;invitation;SPMgt;
 4  ;SPMlt;!-- ++++ The header part of the document ++++ --;SPMgt;
 5  ;SPMlt;front;SPMgt;
 6  ;SPMlt;to;SPMgt;Anna, Bernard, Didier, Johanna;SPMlt;/to;SPMgt;
 7  ;SPMlt;date;SPMgt;Next Friday Evening at 8 pm;SPMlt;/date;SPMgt;
 8  ;SPMlt;where;SPMgt;The Web Cafe;SPMlt;/where;SPMgt;
 9  ;SPMlt;why;SPMgt;My first XML baby;SPMlt;/why;SPMgt;
10  ;SPMlt;/front;SPMgt;
11  ;SPMlt;!-- +++++ The main part of the document +++++ --;SPMgt;
12  ;SPMlt;body;SPMgt;
13  ;SPMlt;par;SPMgt;
14  I would like to invite you all to celebrate
15  the birth of ;SPMlt;emph;SPMgt;Invitation;SPMlt;/emph;SPMgt;, my
16  first XML document child.
17  ;SPMlt;/par;SPMgt;
18  ;SPMlt;par;SPMgt;
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  ;SPMlt;/par;SPMgt;
22  ;SPMlt;par;SPMgt;
23  I ;SPMlt;emph;SPMgt;really;SPMlt;/emph;SPMgt; look forward to see you soon!
24  ;SPMlt;/par;SPMgt;
25  ;SPMlt;/body;SPMgt;
26  ;SPMlt;!-- +++ The closing part of the document ++++ --;SPMgt;
27  ;SPMlt;back;SPMgt;
28  ;SPMlt;signature;SPMgt;Michel;SPMlt;/signature;SPMgt;
29  ;SPMlt;/back;SPMgt;
30  ;SPMlt;/invitation;SPMgt;
<tex2html_mydb_mark>#1590#
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat invcss.html.save
;SPMlt;HTML;SPMgt;
;SPMlt;HEAD;SPMgt;
;SPMlt;TITLE;SPMgt; Invitation (sgmlpl/CSS formatting) ;SPMlt;/TITLE;SPMgt;
;SPMlt;LINK href=;SPMquot;invit.css;SPMquot; rel=;SPMquot;style-sheet;SPMquot; type=;SPMquot;text/css;SPMquot;;SPMgt;
;SPMlt;!-- 24 August 1998 mg --;SPMgt;
;SPMlt;/HEAD;SPMgt;
;SPMlt;BODY;SPMgt;
;SPMlt;H1;SPMgt;INVITATION;SPMlt;/H1;SPMgt;
;SPMlt;P;SPMgt;;SPMlt;TABLE;SPMgt;
;SPMlt;TBODY;SPMgt;
;SPMlt;TR;SPMgt;;SPMlt;TD class=;SPMquot;front;SPMquot;;SPMgt;To: ;SPMlt;/TD;SPMgt;
;SPMlt;TD;SPMgt;Anna, Bernard, Didier, Johanna;SPMlt;/TD;SPMgt;;SPMlt;/TR;SPMgt;
;SPMlt;TR;SPMgt;;SPMlt;TD class=;SPMquot;front;SPMquot;;SPMgt;When: ;SPMlt;/TD;SPMgt;
;SPMlt;TD;SPMgt;Next Friday Evening at 8 pm;SPMlt;/TD;SPMgt;;SPMlt;/TR;SPMgt;
;SPMlt;TR;SPMgt;;SPMlt;TD class=;SPMquot;front;SPMquot;;SPMgt;Venue: ;SPMlt;/TD;SPMgt;
;SPMlt;TD;SPMgt;The Web Cafe;SPMlt;/TD;SPMgt;;SPMlt;/TR;SPMgt;
;SPMlt;TR;SPMgt;;SPMlt;TD class=;SPMquot;front;SPMquot;;SPMgt;Occasion: ;SPMlt;/TD;SPMgt;
;SPMlt;TD;SPMgt;My first XML baby;SPMlt;/TD;SPMgt;;SPMlt;/TR;SPMgt;
;SPMlt;/TBODY;SPMgt;
;SPMlt;/TABLE;SPMgt;
;SPMlt;P;SPMgt;
I would like to invite you all to celebrate
the birth of ;SPMlt;EM;SPMgt;Invitation;SPMlt;/EM;SPMgt;, my
first XML document child.
;SPMlt;/P;SPMgt;
;SPMlt;P;SPMgt;
Please do your best to come and join me next Friday
evening. And, do not forget to bring your friends.
;SPMlt;/P;SPMgt;
;SPMlt;P;SPMgt;
I ;SPMlt;EM;SPMgt;really;SPMlt;/EM;SPMgt; look forward to see you soon!
;SPMlt;/P;SPMgt;
;SPMlt;P CLASS=;SPMquot;signature;SPMquot;;SPMgt;Michel;SPMlt;/P;SPMgt;
;SPMlt;/BODY;SPMgt;
;SPMlt;/HTML;SPMgt;
<tex2html_mydb_mark>#1591#
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invit.css
 1  /* CSS stylesheet for invitation1 in HTML */
 2  BODY {margin-top: 1em;     /* global page parameters */
 3        margin-bottom: 1em;
 4        margin-left: 1em;
 5        margin-right: 1em;
 6        font-family: serif;
 7        line-height: 1.1;
 8        color: black;
 9  }
10  H1   {text-align: center;  /* for global title   */
11        font-size: x-large;
12  }
13  P    {text-align: justify; /* paragraphs in body */
14        margin-top: 1em;
15  }
16  TABLE { border-width: 0pt }
17  TBODY { border-width: 0pt }
18  TD[class=;SPMquot;front;SPMquot;] {        /* table data in front matter */
19        text-align: left;
20        font-weight: bold;
21  }
22  TD.front {        /* table data in front matter */
23        text-align: left;
24        font-weight: bold;
25  }
26  EM   {font-style: italic;  /* emphasis in body   */
27  }
28  P.signature {     /* signature          */
29        text-align: right;
30        font-weight: bold;
31  }
<tex2html_mydb_mark>#1592#
pl@nereida:~/Lregexpgrammars/demo$ cat -n balanced_brackets.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        (;SPMlt;pp;SPMgt;)
    10
    11        ;SPMlt;rule: pp;SPMgt;   \( (?: [^()]*+ | ;SPMlt;escape;SPMgt; | ;SPMlt;pp;SPMgt; )* \)
    12
    13        ;SPMlt;token: escape;SPMgt; \\.
    14
    15      }xs;
    16  };
    17
    18  while (my $input = ;SPMlt;;SPMgt;) {
    19      while ($input =~ m{$rbb}g) {
    20          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    21          say Dumper \%/;
    22      }
    23  }
<tex2html_mydb_mark>#1593#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 balanced_brackets.pl
(2*(3+5))*4+(2-3)
matches: ;SPMlt;(2*(3+5));SPMgt;
$VAR1 = {
          '' =;SPMgt; '(2*(3+5))',
          'pp' =;SPMgt; {
                    '' =;SPMgt; '(2*(3+5))',
                    'pp' =;SPMgt; '(3+5)'
                  }
        };

matches: ;SPMlt;(2-3);SPMgt;
$VAR1 = {
          '' =;SPMgt; '(2-3)',
          'pp' =;SPMgt; '(2-3)'
        };
<tex2html_mydb_mark>#1594#
    13        ;SPMlt;rule: escape;SPMgt; \\.
<tex2html_mydb_mark>#1595#
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsrule.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        ;SPMlt;s;SPMgt;
    10
    11        ;SPMlt;rule: s;SPMgt; ;SPMlt;a;SPMgt; ;SPMlt;c;SPMgt;
    12
    13        ;SPMlt;rule: c;SPMgt;  c d
    14
    15        ;SPMlt;token: a;SPMgt;  a b
    16
    17      }xs;
    18  };
    19
    20  while (my $input = ;SPMlt;;SPMgt;) {
    21      if ($input =~ m{$rbb}) {
    22          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    23          say Dumper \%/;
    24      }
    25      else {
    26          say ;SPMquot;Does not match;SPMquot;;
    27      }
    28  }
<tex2html_mydb_mark>#1596#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 tokenvsrule.pl
ab c d
matches: ;SPMlt;ab c d;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'ab c d',
          's' =;SPMgt; {
                   '' =;SPMgt; 'ab c d',
                   'c' =;SPMgt; 'c d',
                   'a' =;SPMgt; 'ab'
                 }
        };

a b c d
Does not match
ab cd
matches: ;SPMlt;ab cd;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'ab cd',
          's' =;SPMgt; {
                   '' =;SPMgt; 'ab cd',
                   'c' =;SPMgt; 'cd',
                   'a' =;SPMgt; 'ab'
                 }
        };
<tex2html_mydb_mark>#1597#
                      ;SPMlt;token: ws;SPMgt;
                         (?: \s+ | #[^\n]* )*
<tex2html_mydb_mark>#1598#
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsruleandws.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      no warnings 'uninitialized';
 9      qr{
10        ;SPMlt;s;SPMgt;
11
12        ;SPMlt;token: ws;SPMgt; (?: \s+ | /\* .*? \*/)*+
13
14        ;SPMlt;rule: s;SPMgt; ;SPMlt;a;SPMgt; ;SPMlt;c;SPMgt;
15
16        ;SPMlt;rule: c;SPMgt;  c d
17
18        ;SPMlt;token: a;SPMgt;  a b
19
20      }xs;
21  };
22
23  while (my $input = ;SPMlt;;SPMgt;) {
24      if ($input =~ m{$rbb}) {
25          say Dumper \%/;
26      }
27      else {
28          say ;SPMquot;Does not match;SPMquot;;
29      }
30  }
<tex2html_mydb_mark>#1599#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 -w tokenvsruleandws.pl
ab /* 1 */ c d
$VAR1 = {
          '' =;SPMgt; 'ab /* 1 */ c d',
          's' =;SPMgt; {
                   '' =;SPMgt; 'ab /* 1 */ c d',
                   'c' =;SPMgt; 'c d',
                   'a' =;SPMgt; 'ab'
                 }
        };
<tex2html_mydb_mark>#1600#
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               ;SPMlt;name;SPMgt;            # Call ;SPMlt;rule: name;SPMgt;
               ;SPMlt;options;SPMgt;?        # Call ;SPMlt;rule: options;SPMgt; (it's okay if it fails)

               ;SPMlt;rule: name;SPMgt;
                   # etc.
           }x;
<tex2html_mydb_mark>#1601#
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               \;SPMlt;name;SPMgt;           # Match literal sequence ';SPMlt;' 'n' 'a' 'm' 'e' ';SPMgt;'
               ;SPMlt;options;SPMgt;?        # Call ;SPMlt;rule: options;SPMgt; (it's okay if it fails)

               ;SPMlt;rule: name;SPMgt;
                   # etc.
           }x;
<tex2html_mydb_mark>#1602#
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n badbracket.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        (;SPMlt;pp;SPMgt;)
10
11        ;SPMlt;rule: pp;SPMgt;   \( (?: ;SPMlt;b  ;SPMgt; | \;SPMlt; | ;SPMlt; escape;SPMgt; | ;SPMlt;pp;SPMgt; )* \)
12
13        ;SPMlt;token: b  ;SPMgt; b
14
15        ;SPMlt;token: escape;SPMgt; \\.
16
17      }xs;
18  };
19
20  while (my $input = ;SPMlt;;SPMgt;) {
21      while ($input =~ m{$rbb}g) {
22          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
23          say Dumper \%/;
24      }
25  }
<tex2html_mydb_mark>#1603#
casiano@millo:~/src/perl/regexp-grammar-examples$ perl5.10.1 badbracket.pl
(\(\))
matches: ;SPMlt;(\(\));SPMgt;
$VAR1 = {
          '' =;SPMgt; '(\\(\\))',
          'pp' =;SPMgt; {
                    '' =;SPMgt; '(\\(\\))',
                    'escape' =;SPMgt; '\\)'
                  }
        };

(b)
matches: ;SPMlt;(b);SPMgt;
$VAR1 = {
          '' =;SPMgt; '(b)',
          'pp' =;SPMgt; {
                    '' =;SPMgt; '(b)',
                    'b' =;SPMgt; 'b'
                  }
        };

(;SPMlt;)
matches: ;SPMlt;(;SPMlt;);SPMgt;
$VAR1 = {
          '' =;SPMgt; '(;SPMlt;)',
          'pp' =;SPMgt; '(;SPMlt;)'
        };

(c)

casiano@millo:
<tex2html_mydb_mark>#1604#
    ;SPMlt;rule: sentence;SPMgt;
        I see dead people
<tex2html_mydb_mark>#1605#
    sentence =;SPMgt; 'I see dead people'
<tex2html_mydb_mark>#1606#
    ;SPMlt;rule: sentence;SPMgt;
        ;SPMlt;noun;SPMgt; ;SPMlt;verb;SPMgt; ;SPMlt;object;SPMgt;
<tex2html_mydb_mark>#1607#
    sentence =;SPMgt; {
        ;SPMquot;;SPMquot;     =;SPMgt; 'I saw a dog',
        noun   =;SPMgt; {
            ;SPMquot;;SPMquot; =;SPMgt; 'I',
        },
        verb   =;SPMgt; {
            ;SPMquot;;SPMquot; =;SPMgt; 'saw',
        },
        object =;SPMgt; {
            ;SPMquot;;SPMquot;      =;SPMgt; 'a dog',
            article =;SPMgt; {
                ;SPMquot;;SPMquot; =;SPMgt; 'a',
            },
            noun    =;SPMgt; {
                ;SPMquot;;SPMquot; =;SPMgt; 'dog',
            },
        },
    }
<tex2html_mydb_mark>#1608#
pl@nereida:~/Lregexpgrammars/demo$ cat -n unaryproductions.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        ;SPMlt;s;SPMgt;
10
11        ;SPMlt;rule: s;SPMgt; ;SPMlt;noun;SPMgt; ;SPMlt;verb;SPMgt; ;SPMlt;object;SPMgt;
12
13        ;SPMlt;token: noun;SPMgt; he | she | Peter | Jane
14
15        ;SPMlt;token: verb;SPMgt; saw | sees
16
17        ;SPMlt;token: object;SPMgt; a\s+dog | a\s+cat
18
19      }x;
20  };
21
22  while (my $input = ;SPMlt;;SPMgt;) {
23      while ($input =~ m{$rbb}g) {
24          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
25          say Dumper \%/;
26      }
27  }
<tex2html_mydb_mark>#1609#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 unaryproductions.pl
he saw a dog
matches: ;SPMlt;he saw a dog;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'he saw a dog',
          's' =;SPMgt; {
                   '' =;SPMgt; 'he saw a dog',
                   'object' =;SPMgt; 'a dog',
                   'verb' =;SPMgt; 'saw',
                   'noun' =;SPMgt; 'he'
                 }
        };

Jane sees a cat
matches: ;SPMlt;Jane sees a cat;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'Jane sees a cat',
          's' =;SPMgt; {
                   '' =;SPMgt; 'Jane sees a cat',
                   'object' =;SPMgt; 'a cat',
                   'verb' =;SPMgt; 'sees',
                   'noun' =;SPMgt; 'Jane'
                 }
        };
<tex2html_mydb_mark>#1610#
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 .          ........
28      }xms
29  };
<tex2html_mydb_mark>#1611#
    ;SPMlt;objrule: Element;SPMgt;
        # ...Defines a rule that can be called as ;SPMlt;Element;SPMgt;
        # ...and which returns a hash-based Element object
<tex2html_mydb_mark>#1612#
    ;SPMlt;objrule: LaTeX::Element;SPMgt; 
        # ...Defines a rule that can be called as ;SPMlt;Element;SPMgt;
        # ...and which returns a hash-based LaTeX::Element object
<tex2html_mydb_mark>#1613#
    ;SPMlt;rule: copy_cmd;SPMgt;
        copy ;SPMlt;file;SPMgt; ;SPMlt;file;SPMgt;
<tex2html_mydb_mark>#1614#
    ;SPMlt;rule: copy_cmd;SPMgt;
        copy ;SPMlt;from=file;SPMgt; ;SPMlt;to=file;SPMgt;
<tex2html_mydb_mark>#1615#
    ;SPMlt;rule: copy_cmd;SPMgt;
        copy ;SPMlt;from=file;SPMgt;        ;SPMlt;to=file;SPMgt;
      | dup    ;SPMlt;to=file;SPMgt;  as  ;SPMlt;from=file;SPMgt;
      |      ;SPMlt;from=file;SPMgt;  -;SPMgt;    ;SPMlt;to=file;SPMgt;
      |        ;SPMlt;to=file;SPMgt;  ;SPMlt;-  ;SPMlt;from=file;SPMgt;
<tex2html_mydb_mark>#1616#
    copy_cmd =;SPMgt; {
        from =;SPMgt; 'oldfile',
          to =;SPMgt; 'newfile',
    }
<tex2html_mydb_mark>#1617#
pl@nereida:~/Lregexpgrammars/demo$ cat -n copygrammar.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        ;SPMlt;copy_cmd;SPMgt;
    10
    11        ;SPMlt;rule: copy_cmd;SPMgt;
    12              copy ;SPMlt;from=file;SPMgt; ;SPMlt;to=file;SPMgt;
    13          |   ;SPMlt;from=file;SPMgt; -;SPMgt;   ;SPMlt;to=file;SPMgt;
    14          |   ;SPMlt;to=file;SPMgt;   ;SPMlt;- ;SPMlt;from=file;SPMgt;
    15
    16        ;SPMlt;token: file;SPMgt; [\w./\\]+
    17      }x;
    18  };
    19
    20  while (my $input = ;SPMlt;;SPMgt;) {
    21      while ($input =~ m{$rbb}g) {
    22          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    23          say Dumper \%/;
    24      }
    25  }
<tex2html_mydb_mark>#1618#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 copygrammar.pl
copy a b
matches: ;SPMlt;copy a b;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'copy a b',
          'copy_cmd' =;SPMgt; {
                          '' =;SPMgt; 'copy a b',
                          'to' =;SPMgt; 'b',
                          'from' =;SPMgt; 'a'
                        }
        };

b ;SPMlt;- a
matches: ;SPMlt;b ;SPMlt;- a;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'b ;SPMlt;- a',
          'copy_cmd' =;SPMgt; {
                          '' =;SPMgt; 'b ;SPMlt;- a',
                          'to' =;SPMgt; 'b',
                          'from' =;SPMgt; 'a'
                        }
        };

a -;SPMgt; b
matches: ;SPMlt;a -;SPMgt; b;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'a -;SPMgt; b',
          'copy_cmd' =;SPMgt; {
                          '' =;SPMgt; 'a -;SPMgt; b',
                          'to' =;SPMgt; 'b',
                          'from' =;SPMgt; 'a'
                        }
        };
<tex2html_mydb_mark>#1619#
           ;SPMlt;rule: file_sequence;SPMgt;
               ;SPMlt;file;SPMgt;+
<tex2html_mydb_mark>#1620#
           file_sequence {
               ;SPMquot;;SPMquot;   =;SPMgt; 'foo.pl bar.py baz.php',
               file =;SPMgt; 'baz.php',
           }
<tex2html_mydb_mark>#1621#
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers3.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        ;SPMlt;numbers;SPMgt;
11
12        ;SPMlt;rule: numbers;SPMgt;
13          (;SPMlt;number;SPMgt;)+
14
15        ;SPMlt;token: number;SPMgt; \s*\d+
16      }xms;
17  };
18
19  while (my $input = ;SPMlt;;SPMgt;) {
20      if ($input =~ m{$rbb}) {
21          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
22          say Dumper \%/;
23      }
24  }
<tex2html_mydb_mark>#1622#
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers3.pl
1 2 3 4
matches: ;SPMlt;1 2 3 4;SPMgt;
$VAR1 = {
          '' =;SPMgt; '1 2 3 4',
          'numbers' =;SPMgt; {
                         '' =;SPMgt; '1 2 3 4',
                         'number' =;SPMgt; ' 4'
                       }
        };
<tex2html_mydb_mark>#1623#
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        ;SPMlt;numbers;SPMgt;
    11  
    12        ;SPMlt;rule: numbers;SPMgt; 
    13          (;SPMlt;number;SPMgt;)+
    14  
    15        ;SPMlt;token: number;SPMgt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = ;SPMlt;;SPMgt;) {
    20      if ($input =~ m{$rbb}) {
    21          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    22          say Dumper \%/;
    23      }
    24  }
<tex2html_mydb_mark>#1624#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers.pl 
12 34 56
matches: ;SPMlt;12;SPMgt;
$VAR1 = {
          '' =;SPMgt; '12',
          'numbers' =;SPMgt; {
                         '' =;SPMgt; '12',
                         'number' =;SPMgt; '12'
                       }
        };
<tex2html_mydb_mark>#1625#
      ;SPMlt;rule: numbers;SPMgt;
        (;SPMlt;number;SPMgt; )+

      ;SPMlt;token: number;SPMgt; \d+
<tex2html_mydb_mark>#1626#
           ;SPMlt;rule: file_sequence;SPMgt;
               ;SPMlt;[file];SPMgt;+
<tex2html_mydb_mark>#1627#
           file_sequence {
               ;SPMquot;;SPMquot;   =;SPMgt; 'foo.pl bar.py baz.php',
               file =;SPMgt; [ 'foo.pl', 'bar.py', 'baz.php' ],
           }
<tex2html_mydb_mark>#1628#
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers4.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8
     9      qr{
    10        ;SPMlt;numbers;SPMgt;
    11
    12        ;SPMlt;rule: numbers;SPMgt;
    13          (?:  ;SPMlt;[number];SPMgt; )+
    14
    15        ;SPMlt;token: number;SPMgt; \d+
    16      }xms;
    17  };
    18
    19  while (my $input = ;SPMlt;;SPMgt;) {
    20      if ($input =~ m{$rbb}) {
    21          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    22          say Dumper \%/;
    23      }
    24  }
<tex2html_mydb_mark>#1629#
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers4.pl
1 2 3 4
matches: ;SPMlt;1 2 3 4
;SPMgt;
$VAR1 = {
          '' =;SPMgt; '1 2 3 4
',
          'numbers' =;SPMgt; {
                         '' =;SPMgt; '1 2 3 4
',
                         'number' =;SPMgt; [ '1', '2', '3', '4' ]
                       }
        };
<tex2html_mydb_mark>#1630#
    ;SPMlt;rule: size_option;SPMgt;   
        -size ;SPMlt;[size];SPMgt; (?: x ;SPMlt;[size];SPMgt; )?
<tex2html_mydb_mark>#1631#
pl@nereida:~/Lregexpgrammars/demo$ cat -n sizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        ;SPMlt;command;SPMgt;
11
12        ;SPMlt;rule: command;SPMgt; ls ;SPMlt;size_option;SPMgt;
13
14        ;SPMlt;rule: size_option;SPMgt;
15            -size ;SPMlt;[size];SPMgt; (?: x ;SPMlt;[size];SPMgt; )?
16
17        ;SPMlt;token: size;SPMgt; \d+
18      }x;
19  };
20
21  while (my $input = ;SPMlt;;SPMgt;) {
22      while ($input =~ m{$rbb}g) {
23          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
24          say Dumper \%/;
25      }
26  }
<tex2html_mydb_mark>#1632#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 sizes.pl
ls -size 4
matches: ;SPMlt;ls -size 4
;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'ls -size 4
',
          'command' =;SPMgt; {
                         'size_option' =;SPMgt; {
                                            '' =;SPMgt; '-size 4
',
                                            'size' =;SPMgt; [ '4' ]
                                          },
                         '' =;SPMgt; 'ls -size 4
'
                       }
        };

ls -size 2x8
matches: ;SPMlt;ls -size 2x8
;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'ls -size 2x8
',
          'command' =;SPMgt; {
                         'size_option' =;SPMgt; {
                                            '' =;SPMgt; '-size 2x8
',
                                            'size' =;SPMgt; [ '2', '8' ]
                                          },
                         '' =;SPMgt; 'ls -size 2x8
'
                       }
        };
<tex2html_mydb_mark>#1633#
    ;SPMlt;rule: size_option;SPMgt;   
        -size ;SPMlt;[size=pos_integer];SPMgt; (?: x ;SPMlt;[size=pos_integer];SPMgt; )?
<tex2html_mydb_mark>#1634#
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedsizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        ;SPMlt;command;SPMgt;
11
12        ;SPMlt;rule: command;SPMgt; ls ;SPMlt;size_option;SPMgt;
13
14        ;SPMlt;rule: size_option;SPMgt;
15            -size ;SPMlt;[size=int];SPMgt; (?: x ;SPMlt;[size=int];SPMgt; )?
16
17        ;SPMlt;token: int;SPMgt; \d+
18      }x;
19  };
20
21  while (my $input = ;SPMlt;;SPMgt;) {
22      while ($input =~ m{$rbb}g) {
23          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
24          say Dumper \%/;
25      }
26  }
<tex2html_mydb_mark>#1635#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedsizes.pl
ls -size 2x4
matches: ;SPMlt;ls -size 2x4
;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'ls -size 2x4
',
          'command' =;SPMgt; {
                         'size_option' =;SPMgt; {
                                            '' =;SPMgt; '-size 2x4
',
                                            'size' =;SPMgt; [
                                                        '2',
                                                        '4'
                                                      ]
                                          },
                         '' =;SPMgt; 'ls -size 2x4
'
                       }
        };
<tex2html_mydb_mark>#1636#
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers5.pl 
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        ;SPMlt;numbers;SPMgt;
    11  
    12        ;SPMlt;rule: numbers;SPMgt; 
    13          ;SPMlt;number;SPMgt;+
    14  
    15        ;SPMlt;token: number;SPMgt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = ;SPMlt;;SPMgt;) {
    20      if ($input =~ m{$rbb}) {
    21          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    22          say Dumper \%/;
    23      }
    24  }
<tex2html_mydb_mark>#1637#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers5.pl 
  warn | Repeated subrule ;SPMlt;number;SPMgt;+ will only capture its final match
       | (Did you mean ;SPMlt;[number];SPMgt;+ instead?)
       |
<tex2html_mydb_mark>#1638#
        ;SPMlt;ListElem;SPMgt;*
<tex2html_mydb_mark>#1639#
        ;SPMlt;ListElem;SPMgt;+
<tex2html_mydb_mark>#1640#
        ;SPMlt;[ListElem];SPMgt;*
<tex2html_mydb_mark>#1641#
        ;SPMlt;[ListElem];SPMgt;+
<tex2html_mydb_mark>#1642#
        (;SPMlt;ListElem;SPMgt;)*
<tex2html_mydb_mark>#1643#
        (?: ;SPMlt;ListElem;SPMgt; )+
<tex2html_mydb_mark>#1644#
    ;SPMlt;ALIAS= (SUBPATTERN) ;SPMgt;
<tex2html_mydb_mark>#1645#
    ;SPMlt;rule: file_command;SPMgt;

        ;SPMlt;cmd=(mv|cp|ln);SPMgt;  ;SPMlt;from=file;SPMgt;  ;SPMlt;to=file;SPMgt;
<tex2html_mydb_mark>#1646#
pl@nereida:~/Lregexpgrammars/demo$ cat -n subpattern.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10          ;SPMlt;file_command;SPMgt;
11
12          ;SPMlt;rule: file_command;SPMgt;
13
14          ;SPMlt;cmd=(mv|cp|ln);SPMgt;  ;SPMlt;from=([\w./]+);SPMgt;  ;SPMlt;to=([\w./]+);SPMgt;
15
16      }x;
17  };
18
19  while (my $input = ;SPMlt;;SPMgt;) {
20      while ($input =~ m{$rbb}g) {
21          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
22          say Dumper \%/;
23      }
24  }
<tex2html_mydb_mark>#1647#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 subpattern.pl
mv a b
matches: ;SPMlt;mv a b;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'mv a b',
          'file_command' =;SPMgt; {
                              '' =;SPMgt; 'mv a b',
                              'to' =;SPMgt; 'b',
                              'cmd' =;SPMgt; 'mv',
                              'from' =;SPMgt; 'a'
                            }
        };

cp c d
matches: ;SPMlt;cp c d;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'cp c d',
          'file_command' =;SPMgt; {
                              '' =;SPMgt; 'cp c d',
                              'to' =;SPMgt; 'd',
                              'cmd' =;SPMgt; 'cp',
                              'from' =;SPMgt; 'c'
                            }
        }
<tex2html_mydb_mark>#1648#
    ;SPMlt;ALIAS= (?{ your($code-;SPMgt;here) }) ;SPMgt;
<tex2html_mydb_mark>#1649#
    ;SPMlt;ALIAS= { your($code-;SPMgt;here } ;SPMgt;
<tex2html_mydb_mark>#1650#
    ;SPMlt;rule: copy_cmd;SPMgt;
        copy ;SPMlt;from=file;SPMgt;        ;SPMlt;to=file;SPMgt;
      | dup    ;SPMlt;to=file;SPMgt;  as  ;SPMlt;from=file;SPMgt;
      |      ;SPMlt;from=file;SPMgt;  -;SPMgt;    ;SPMlt;to=file;SPMgt;
      |        ;SPMlt;to=file;SPMgt;  ;SPMlt;-  ;SPMlt;from=file;SPMgt;
<tex2html_mydb_mark>#1651#
    ;SPMlt;rule: copy_cmd;SPMgt;
        copy ;SPMlt;from=file;SPMgt;        ;SPMlt;to=file;SPMgt;  ;SPMlt;type=(?{ 'std' });SPMgt; 
      | dup    ;SPMlt;to=file;SPMgt;  as  ;SPMlt;from=file;SPMgt;  ;SPMlt;type=(?{ 'rev' });SPMgt; 
      |      ;SPMlt;from=file;SPMgt;  -;SPMgt;    ;SPMlt;to=file;SPMgt;  ;SPMlt;type=(?{ 'fwd' });SPMgt; 
      |        ;SPMlt;to=file;SPMgt;  ;SPMlt;-  ;SPMlt;from=file;SPMgt;  ;SPMlt;type=(?{ 'bwd' });SPMgt;
<tex2html_mydb_mark>#1652#
    copy_cmd =;SPMgt; {
        from =;SPMgt; 'oldfile',
          to =;SPMgt; 'newfile',
        type =;SPMgt; 'fwd',
    }
<tex2html_mydb_mark>#1653#
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedcodeblock2.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        ;SPMlt;copy_cmd;SPMgt;
10
11        ;SPMlt;rule: copy_cmd;SPMgt;
12              copy (;SPMlt;from=file;SPMgt;) (;SPMlt;to=file;SPMgt;) ;SPMlt;type=(?{ 'std' });SPMgt;
13          |   ;SPMlt;from=file;SPMgt; -;SPMgt;   ;SPMlt;to=file;SPMgt; ;SPMlt;type=(?{ 'fwd' });SPMgt;
14          |   ;SPMlt;to=file;SPMgt;   ;SPMlt;- ;SPMlt;from=file;SPMgt; ;SPMlt;type=(?{ 'bwd' });SPMgt;
15          |   .+ (?{ die ;SPMquot;Syntax error!\n;SPMquot; })
16
17        ;SPMlt;token: file;SPMgt; [\w./\\]+
18      }x;
19  };
20
21  while (my $input = ;SPMlt;;SPMgt;) {
22      while ($input =~ m{$rbb}g) {
23          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
24          say Dumper \%/;
25      }
26  }
<tex2html_mydb_mark>#1654#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedcodeblock2.pl
copy a b
matches: ;SPMlt;copy a b
;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'copy a b
',
          'copy_cmd' =;SPMgt; {
                          '' =;SPMgt; 'copy a b
',
                          'to' =;SPMgt; 'b',
                          'from' =;SPMgt; 'a',
                          'type' =;SPMgt; 'std'
                        }
        };

b ;SPMlt;- a
matches: ;SPMlt;b ;SPMlt;- a
;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'b ;SPMlt;- a
',
          'copy_cmd' =;SPMgt; {
                          '' =;SPMgt; 'b ;SPMlt;- a
',
                          'to' =;SPMgt; 'b',
                          'from' =;SPMgt; 'a',
                          'type' =;SPMgt; 'bwd'
                        }
        };

a -;SPMgt; b
matches: ;SPMlt;a -;SPMgt; b
;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'a -;SPMgt; b
',
          'copy_cmd' =;SPMgt; {
                          '' =;SPMgt; 'a -;SPMgt; b
',
                          'to' =;SPMgt; 'b',
                          'from' =;SPMgt; 'a',
                          'type' =;SPMgt; 'fwd'
                        }
        };

cp a b
Syntax error!
<tex2html_mydb_mark>#1655#
    ;SPMlt;.SUBRULE;SPMgt;
<tex2html_mydb_mark>#1656#
    ;SPMlt;rule: paren_pair;SPMgt; 

        \( 
            (?: ;SPMlt;escape;SPMgt; | ;SPMlt;paren_pair;SPMgt; | ;SPMlt;brace_pair;SPMgt; | [^()] )*
        \)
<tex2html_mydb_mark>#1657#
    ;SPMlt;rule: paren_pair;SPMgt; 

        ;SPMlt;.left_paren;SPMgt;
            (?: ;SPMlt;escape;SPMgt; | ;SPMlt;paren_pair;SPMgt; | ;SPMlt;brace_pair;SPMgt; | ;SPMlt;.non_paren;SPMgt; )*
        ;SPMlt;.right_paren;SPMgt;
    
    ;SPMlt;token: left_paren;SPMgt;   \(
    ;SPMlt;token: right_paren;SPMgt;  \)
    ;SPMlt;token: non_paren;SPMgt;    [^()]
<tex2html_mydb_mark>#1658#
    ;SPMlt;rule: paren_pair;SPMgt; 

        ;SPMlt;.left_paren;SPMgt;
            (?: ;SPMlt;.escape;SPMgt; | ;SPMlt;.paren_pair;SPMgt; | ;SPMlt;.brace_pair;SPMgt; | ;SPMlt;.non_paren;SPMgt; )*
        ;SPMlt;.right_paren;SPMgt;
<tex2html_mydb_mark>#1659#
    ;SPMlt;.Alias= (SUBPATTERN) ;SPMgt;
<tex2html_mydb_mark>#1660#
pl@nereida:~/Lregexpgrammars/demo$ cat -n numberscomma.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        ;SPMlt;numbers;SPMgt;
    12
    13        ;SPMlt;objrule: numbers;SPMgt;
    14          ;SPMlt;[number];SPMgt; (;SPMlt;comma;SPMgt; ;SPMlt;[number];SPMgt;)*
    15
    16        ;SPMlt;objtoken: number;SPMgt; \s*\d+
    17        ;SPMlt;token: comma;SPMgt;  \s*,
    18      }xms;
    19  };
    20
    21  while (my $input = ;SPMlt;;SPMgt;) {
    22      if ($input =~ m{$rbb}) {
    23          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    24          say Dumper \%/;
    25      }
    26  }
<tex2html_mydb_mark>#1661#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma.pl
2, 3, 4
matches: ;SPMlt;2, 3, 4;SPMgt;
$VAR1 = {
  '' =;SPMgt; '2, 3, 4',
  'numbers' =;SPMgt; bless( {
    '' =;SPMgt; '2, 3, 4',
    'number' =;SPMgt; [
      bless( { '' =;SPMgt; '2' }, 'number' ),
      bless( { '' =;SPMgt; '3' }, 'number' ),
      bless( { '' =;SPMgt; '4' }, 'number' )
    ],
    'comma' =;SPMgt; ','
  }, 'numbers' )
};
<tex2html_mydb_mark>#1662#
pl@nereida:~/Lregexpgrammars/demo$ diff numberscomma.pl numberscomma2.pl
14c14
;SPMlt;         ;SPMlt;[number];SPMgt; (;SPMlt;comma;SPMgt; ;SPMlt;[number];SPMgt;)*
---
;SPMgt;         ;SPMlt;[number];SPMgt; (;SPMlt;.comma;SPMgt; ;SPMlt;[number];SPMgt;)*
<tex2html_mydb_mark>#1663#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma2.pl
2, 3, 4
matches: ;SPMlt;2, 3, 4;SPMgt;
$VAR1 = {
  '' =;SPMgt; '2, 3, 4',
  'numbers' =;SPMgt; bless( {
    '' =;SPMgt; '2, 3, 4',
    'number' =;SPMgt; [
      bless( { '' =;SPMgt; '2' }, 'number' ),
      bless( { '' =;SPMgt; '3' }, 'number' ),
      bless( { '' =;SPMgt; '4' }, 'number' )
    ]
  }, 'numbers' )
};
<tex2html_mydb_mark>#1664#
    ;SPMlt;MATCH=filename;SPMgt;
<tex2html_mydb_mark>#1665#
    ;SPMlt;MATCH=( \w+ );SPMgt;
<tex2html_mydb_mark>#1666#
    ;SPMlt;MATCH=(?{ 42 });SPMgt;
<tex2html_mydb_mark>#1667#
    ;SPMlt;rule: term;SPMgt;
          ;SPMlt;MATCH=literal;SPMgt;
        | ;SPMlt;left_paren;SPMgt; ;SPMlt;MATCH=expr;SPMgt; ;SPMlt;right_paren;SPMgt;
<tex2html_mydb_mark>#1668#
$ cat -n demo_calc.pl
 1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 8          ;SPMlt;Answer;SPMgt;
 9
10          ;SPMlt;rule: Answer;SPMgt;
11              ;SPMlt;X=Mult;SPMgt; ;SPMlt;Op=([+-]);SPMgt; ;SPMlt;Y=Answer;SPMgt;
12            | ;SPMlt;MATCH=Mult;SPMgt;
13
14          ;SPMlt;rule: Mult;SPMgt;
15              ;SPMlt;X=Pow;SPMgt; ;SPMlt;Op=([*/%]);SPMgt; ;SPMlt;Y=Mult;SPMgt;
16            | ;SPMlt;MATCH=Pow;SPMgt;
17
18          ;SPMlt;rule: Pow;SPMgt;
19              ;SPMlt;X=Term;SPMgt; ;SPMlt;Op=(\^);SPMgt; ;SPMlt;Y=Pow;SPMgt;
20            | ;SPMlt;MATCH=Term;SPMgt;
21
22          ;SPMlt;rule: Term;SPMgt;
23                 ;SPMlt;MATCH=Literal;SPMgt;
24            | \( ;SPMlt;MATCH=Answer;SPMgt; \)
25
26          ;SPMlt;token: Literal;SPMgt;
27              ;SPMlt;MATCH=( [+-]? \d++ (?: \. \d++ )?+ );SPMgt;
28      }xms
29  };
30
31  while (my $input = ;SPMlt;;SPMgt;) {
32      if ($input =~ $calculator) {
33          use Data::Dumper 'Dumper';
34          warn Dumper \%/;
35      }
36  }
<tex2html_mydb_mark>#1669#
$ ./demo_calc.pl
2+3*5
$VAR1 = {
          '' =;SPMgt; '2+3*5',
          'Answer' =;SPMgt; {
                        '' =;SPMgt; '2+3*5',
                        'Op' =;SPMgt; '+',
                        'X' =;SPMgt; '2',
                        'Y' =;SPMgt; {
                                 '' =;SPMgt; '3*5',
                                 'Op' =;SPMgt; '*',
                                 'X' =;SPMgt; '3',
                                 'Y' =;SPMgt; '5'
                               }
                      }
        };
4-5-2
$VAR1 = {
          '' =;SPMgt; '4-5-2',
          'Answer' =;SPMgt; {
                        '' =;SPMgt; '4-5-2',
                        'Op' =;SPMgt; '-',
                        'X' =;SPMgt; '4',
                        'Y' =;SPMgt; {
                                 '' =;SPMgt; '5-2',
                                 'Op' =;SPMgt; '-',
                                 'X' =;SPMgt; '5',
                                 'Y' =;SPMgt; '2'
                               }
                      }
        };
<tex2html_mydb_mark>#1670#
    ;SPMlt;rule: sum;SPMgt; 
        ;SPMlt;X=product;SPMgt; \+ ;SPMlt;Y=product;SPMgt;
            ;SPMlt;MATCH=(?{ $MATCH{X} + $MATCH{Y} });SPMgt;
<tex2html_mydb_mark>#1671#
    ;SPMlt;rule: sum;SPMgt; 
        ;SPMlt;X=product;SPMgt; \+ ;SPMlt;Y=product;SPMgt;
            (?{ $MATCH = $MATCH{X} + $MATCH{Y} })
<tex2html_mydb_mark>#1672#
    ;SPMlt;rule: sum;SPMgt; 
        ;SPMlt;X=product;SPMgt; \+ ;SPMlt;Y=product;SPMgt;
            (?{ if (!ref $MATCH{X} ;SPMamp;;SPMamp; !ref $MATCH{Y}) {
                    # Reduce to sum, if both terms are simple scalars...
                    $MATCH = $MATCH{X} + $MATCH{Y};
                }
                else {
                    # Return full syntax tree for non-simple case...
                    $MATCH{op} = '+';
                }
            })
<tex2html_mydb_mark>#1673#
    ;SPMlt;rule: config_line;SPMgt;
        ;SPMlt;key;SPMgt; : ;SPMlt;value;SPMgt;  ;SPMlt;comment;SPMgt;?
            (?{
                # Edit trailing comments out of ;SPMquot;matched text;SPMquot; entry...
                $MATCH = ;SPMquot;$MATCH{key} : $MATCH{value};SPMquot;;
            })
<tex2html_mydb_mark>#1674#
    ;SPMlt;rule: FuncDecl;SPMgt;
      # Keyword  Name               Keep return the name (as a string)...
        func     ;SPMlt;Identifier;SPMgt; ;     (?{ $MATCH = $MATCH{'Identifier'} })


    ;SPMlt;rule: NumList;SPMgt;
      # Numbers in square brackets...
        \[ 
            ( \d+ (?: , \d+)* )
        \]

      # Return only the numbers...
        (?{ $MATCH = $CAPTURE })


    ;SPMlt;token: Cmd;SPMgt;
      # Match standard variants then standardize the keyword...
        (?: mv | move | rename )      (?{ $MATCH = 'mv'; })
<tex2html_mydb_mark>#1675#
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_calc_inline.pl
 1  use v5.10;
 2  use warnings;
 3
 4  my $calculator = do{
 5      use Regexp::Grammars;
 6      qr{
 7          ;SPMlt;Answer;SPMgt;
 8
 9          ;SPMlt;rule: Answer;SPMgt;
10              ;SPMlt;X=Mult;SPMgt; \+ ;SPMlt;Y=Answer;SPMgt;
11                  (?{ $MATCH = $MATCH{X} + $MATCH{Y}; })
12            | ;SPMlt;X=Mult;SPMgt; - ;SPMlt;Y=Answer;SPMgt;
13                  (?{ $MATCH = $MATCH{X} - $MATCH{Y}; })
14            | ;SPMlt;MATCH=Mult;SPMgt;
15
16          ;SPMlt;rule: Mult;SPMgt;
17              ;SPMlt;X=Pow;SPMgt; \* ;SPMlt;Y=Mult;SPMgt;
18                  (?{ $MATCH = $MATCH{X} * $MATCH{Y}; })
19            | ;SPMlt;X=Pow;SPMgt;  / ;SPMlt;Y=Mult;SPMgt;
20                  (?{ $MATCH = $MATCH{X} / $MATCH{Y}; })
21            | ;SPMlt;X=Pow;SPMgt;  % ;SPMlt;Y=Mult;SPMgt;
22                  (?{ $MATCH = $MATCH{X} % $MATCH{Y}; })
23            | ;SPMlt;MATCH=Pow;SPMgt;
24
25          ;SPMlt;rule: Pow;SPMgt;
26              ;SPMlt;X=Term;SPMgt; \^ ;SPMlt;Y=Pow;SPMgt;
27                  (?{ $MATCH = $MATCH{X} ** $MATCH{Y}; })
28            | ;SPMlt;MATCH=Term;SPMgt;
29
30          ;SPMlt;rule: Term;SPMgt;
31                 ;SPMlt;MATCH=Literal;SPMgt;
32            | \( ;SPMlt;MATCH=Answer;SPMgt; \)
33
34          ;SPMlt;token: Literal;SPMgt;
35              ;SPMlt;MATCH=( [+-]? \d++ (?: \. \d++ )?+ );SPMgt;
36      }xms
37  };
38
39  while (my $input = ;SPMlt;;SPMgt;) {
40      if ($input =~ $calculator) {
41          say '--;SPMgt; ', $/{Answer};
42      }
43  }
<tex2html_mydb_mark>#1676#
     ;SPMlt;_RULENAME;SPMgt;       ;SPMlt;_ALIAS=RULENAME;SPMgt;  
    ;SPMlt;[_RULENAME];SPMgt;     ;SPMlt;[_ALIAS=RULENAME];SPMgt;
<tex2html_mydb_mark>#1677#
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      ;SPMlt;List;SPMgt;
     8
     9      ;SPMlt;rule: List;SPMgt;
    10           ;SPMlt;digit;SPMgt; ;SPMlt;List;SPMgt;
    11         | # empty
    12
    13      ;SPMlt;rule: digit;SPMgt;
    14          ;SPMlt;MATCH=(\d+);SPMgt;
    15
    16  }xms;
    17
    18  while (my $input = ;SPMlt;;SPMgt;) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn ;SPMquot;Does not match\n;SPMquot;
    26      }
    27  }
<tex2html_mydb_mark>#1678#
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list.pl
2 3 4
$VAR1 = {
          '' =;SPMgt; '2 3 4',
          'List' =;SPMgt; {
                      '' =;SPMgt; '2 3 4',
                      'digit' =;SPMgt; '2'
                      'List' =;SPMgt; {
                                  '' =;SPMgt; '3 4',
                                  'digit' =;SPMgt; '3'
                                  'List' =;SPMgt; {
                                              '' =;SPMgt; '4',
                                              'digit' =;SPMgt; '4'
                                              'List' =;SPMgt; '',
                                            },
                                },
                    }
        };
<tex2html_mydb_mark>#1679#
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_empty_first.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      ;SPMlt;List;SPMgt;
     8
     9      ;SPMlt;rule: List;SPMgt;
    10           # empty
    11         | ;SPMlt;digit;SPMgt; ;SPMlt;List;SPMgt;
    12
    13      ;SPMlt;rule: digit;SPMgt;
    14          ;SPMlt;MATCH=(\d+);SPMgt;
    15
    16  }xms;
    17
    18  while (my $input = ;SPMlt;;SPMgt;) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn ;SPMquot;Does not match\n;SPMquot;
    26      }
    27  }
<tex2html_mydb_mark>#1680#
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list_empty_first.pl
2 3 4
$VAR1 = {
          '' =;SPMgt; '',
          'List' =;SPMgt; ''
        };
<tex2html_mydb_mark>#1681#
pl@nereida:~/Lregexpgrammars/demo$ diff simple_list_empty_first.pl simple_list_empty_first_with_anchors.pl
7c7
;SPMlt;     ;SPMlt;List;SPMgt;
---
;SPMgt;     ^;SPMlt;List;SPMgt;$
<tex2html_mydb_mark>#1682#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_anchors.pl
2 3 4
$VAR1 = {
          '' =;SPMgt; '2 3 4',
          'List' =;SPMgt; {
                      'List' =;SPMgt; {
                                  'List' =;SPMgt; {
                                              'List' =;SPMgt; '',
                                              '' =;SPMgt; '4',
                                              'digit' =;SPMgt; '4'
                                            },
                                  '' =;SPMgt; '3 4',
                                  'digit' =;SPMgt; '3'
                                },
                      '' =;SPMgt; '2 3 4',
                      'digit' =;SPMgt; '2'
                    }
        };
<tex2html_mydb_mark>#1683#
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_empty_first_with_lookahead.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use strict;
     5  use Regexp::Grammars;
     6
     7  my $list = qr{
     8      ;SPMlt;List;SPMgt;
     9
    10      ;SPMlt;rule: List;SPMgt;
    11           (?! ;SPMlt;digit;SPMgt; ) # still empty production
    12         | ;SPMlt;digit;SPMgt; ;SPMlt;List;SPMgt;
    13
    14      ;SPMlt;rule: digit;SPMgt;
    15          ;SPMlt;MATCH=(\d+);SPMgt;
    16
    17  }xms;
    18
    19  while (my $input = ;SPMlt;;SPMgt;) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn ;SPMquot;Does not match\n;SPMquot;
    27      }
    28  }
<tex2html_mydb_mark>#1684#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_lookahead.pl
2 3 4
$VAR1 = {
          '' =;SPMgt; '2 3 4',
          'List' =;SPMgt; {
                      'List' =;SPMgt; {
                                  'List' =;SPMgt; {
                                              'List' =;SPMgt; '',
                                              '' =;SPMgt; '4',
                                              'digit' =;SPMgt; '4'
                                            },
                                  '' =;SPMgt; '3 4',
                                  'digit' =;SPMgt; '3'
                                },
                      '' =;SPMgt; '2 3 4',
                      'digit' =;SPMgt; '2'
                    }
        };
<tex2html_mydb_mark>#1685#
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_action.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      ;SPMlt;List;SPMgt;
     8
     9      ;SPMlt;rule: List;SPMgt;
    10           ;SPMlt;digit;SPMgt; ;SPMlt;X=List;SPMgt; ;SPMlt;MATCH= (?{ unshift @{$MATCH{X}}, $MATCH{digit}; $MATCH{X} });SPMgt;
    11         | # empty
    12           ;SPMlt;MATCH= (?{ [] });SPMgt;
    13
    14      ;SPMlt;rule: digit;SPMgt;
    15          ;SPMlt;MATCH=(\d+);SPMgt;
    16
    17  }xms;
    18
    19  while (my $input = ;SPMlt;;SPMgt;) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn ;SPMquot;Does not match\n;SPMquot;
    27      }
    28  }
<tex2html_mydb_mark>#1686#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_action.pl
2 3 4
$VAR1 = {
          '' =;SPMgt; '2 3 4',
          'List' =;SPMgt; [ '2', '3', '4' ]
        };
<tex2html_mydb_mark>#1687#
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_star.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list = qr{
 7      ;SPMlt;List;SPMgt;
 8
 9      ;SPMlt;rule: List;SPMgt;
10          (?: ;SPMlt;[digit];SPMgt;)*
11
12      ;SPMlt;rule: digit;SPMgt;
13          ;SPMlt;MATCH=(\d+);SPMgt;
14
15  }xms;
16
17  while (my $input = ;SPMlt;;SPMgt;) {
18      chomp $input;
19      if ($input =~ $list) {
20          use Data::Dumper 'Dumper';
21          warn Dumper \%/;
22      }
23      else {
24        warn ;SPMquot;Does not match\n;SPMquot;
25      }
26  }
<tex2html_mydb_mark>#1688#
    1, 2, 3 , 4 ,13, 91        # Numbers separated by commas and spaces

    g-c-a-g-t-t-a-c-a          # Bases separated by dashes

    /usr/local/bin             # Names separated by directory markers

    /usr:/usr/local:bin        # Directories separated by colons
<tex2html_mydb_mark>#1689#
    ;SPMlt;rule: list;SPMgt;

        ;SPMlt;item;SPMgt; ;SPMlt;separator;SPMgt; ;SPMlt;list               # recursive definition
      | ;SPMlt;item;SPMgt;                                 # base case
<tex2html_mydb_mark>#1690#
    ;SPMlt;rule: list;SPMgt;

        ;SPMlt;[item];SPMgt; (?: ;SPMlt;separator;SPMgt; ;SPMlt;[item];SPMgt; )*   # iterative definition
<tex2html_mydb_mark>#1691#
    ;SPMlt;rule: list;SPMgt;

        ;SPMlt;[item];SPMgt; ** ;SPMlt;separator;SPMgt;                # iterative definition
<tex2html_mydb_mark>#1692#
    ;SPMlt;[number];SPMgt; ** ;SPMlt;comma;SPMgt;

    ;SPMlt;token: number;SPMgt;  \d+
    ;SPMlt;token: comma;SPMgt;   \s* , \s*
<tex2html_mydb_mark>#1693#
    ;SPMlt;[number];SPMgt; ** ;SPMlt;[comma];SPMgt;
<tex2html_mydb_mark>#1694#
    ;SPMlt;[number];SPMgt; ** ( , )
<tex2html_mydb_mark>#1695#
    ;SPMlt;[number];SPMgt; ** ,
<tex2html_mydb_mark>#1696#
    ;SPMlt;[item=(\d+)];SPMgt; ** ( , )
<tex2html_mydb_mark>#1697#
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n demo_list.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list_nonempty = qr{
 7      ;SPMlt;List;SPMgt;
 8
 9      ;SPMlt;rule: List;SPMgt;
10          \(  ;SPMlt;[Value];SPMgt; ** (,)  \)
11
12      ;SPMlt;token: Value;SPMgt;
13          \d+
14  }xms;
15
16  my $list_empty = qr{
17      ;SPMlt;List;SPMgt;
18
19      ;SPMlt;rule: List;SPMgt;
20          \(  (?: ;SPMlt;[Value];SPMgt; ** ;SPMlt;_Sep=(,);SPMgt; )?  \)
21
22      ;SPMlt;token: Value;SPMgt;
23          \d+
24  }xms;
25
26  use Smart::Comments;
27
28
29  while (my $input = ;SPMlt;;SPMgt;) {
30      my $input2 = $input;
31      if ($input =~ $list_nonempty) {
32          ### nonempty: $/{List}
33      }
34      if ($input2 =~ $list_empty) {
35          ### empty: $/{List}
36      }
37  }
<tex2html_mydb_mark>#1698#
casiano@millo:~/src/perl/regexp-grammar-examples$ ./demo_list.pl
(3,4,5)

### nonempty: {
###             '' =;SPMgt; '(3,4,5)',
###             Value =;SPMgt; [
###                        '3',
###                        '4',
###                        '5'
###                      ]
###           }

### empty: {
###          '' =;SPMgt; '(3,4,5)',
###          Value =;SPMgt; [
###                     '3',
###                     '4',
###                     '5'
###                   ]
###        }
()

### empty: '()'
<tex2html_mydb_mark>#1699#
pl@nereida:~/Lregexpgrammars/demo$ cat -n calcaslist.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5  $Data::Dumper::Indent = 1;
 6
 7  my $rbb = do {
 8      use Regexp::Grammars;
 9
10      qr{
11        \A;SPMlt;expr;SPMgt;\z
12
13        ;SPMlt;objrule: expr;SPMgt;      ;SPMlt;[operands=term];SPMgt; ** ;SPMlt;[operators=addop];SPMgt;
14
15        ;SPMlt;objrule: term;SPMgt;      ;SPMlt;[operands=uneg];SPMgt; ** ;SPMlt;[operators=mulop];SPMgt;
16
17        ;SPMlt;objrule: uneg;SPMgt;      ;SPMlt;[operators=minus];SPMgt;* ;SPMlt;[operands=power];SPMgt;
18
19        ;SPMlt;objrule: power;SPMgt;     ;SPMlt;[operands=factorial];SPMgt; ** ;SPMlt;[operators=powerop];SPMgt;
20
21        ;SPMlt;objrule: factorial;SPMgt; ;SPMlt;[operands=factor];SPMgt;  ;SPMlt;[operators=(!)];SPMgt;*
22
23        ;SPMlt;objrule: factor;SPMgt;    ;SPMlt;val=([+-]?\d+(?:\.\d*)?);SPMgt;
24                           | \( ;SPMlt;MATCH=expr;SPMgt; \)
25
26        ;SPMlt;token: addop;SPMgt;        [+-]
27
28        ;SPMlt;token: mulop;SPMgt;        [*/]
29
30        ;SPMlt;token: powerop;SPMgt;      \*\*|\^
31
32        ;SPMlt;token: minus;SPMgt;        - ;SPMlt;MATCH=(?{ 'NEG' });SPMgt;
33
34      }x;
35  };
36
37  while (my $input = ;SPMlt;;SPMgt;) {
38      chomp($input);
39      if ($input =~ m{$rbb}) {
40          my $tree = $/{expr};
41          say Dumper $tree;
42
43      }
44      else {
45          say(;SPMquot;does not match;SPMquot;);
46      }
47  }
<tex2html_mydb_mark>#1700#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 calcaslist.pl
4-2-2
$VAR1 = bless( {
  'operands' =;SPMgt; [
    bless( {
      'operands' =;SPMgt; [
        bless( {
          'operands' =;SPMgt; [
            bless( {
              'operands' =;SPMgt; [
                bless( {
                  'operands' =;SPMgt; [
                    bless( { '' =;SPMgt; '4', 'val' =;SPMgt; '4' }, 'factor' )
                  ],
                  '' =;SPMgt; '4'
                }, 'factorial' )
              ],
              '' =;SPMgt; '4'
            }, 'power' )
          ],
          '' =;SPMgt; '4'
        }, 'uneg' )
      ],
      '' =;SPMgt; '4'
    }, 'term' ),
    bless( {
      'operands' =;SPMgt; [
        bless( {
          'operands' =;SPMgt; [
            bless( {
              'operands' =;SPMgt; [
                bless( {
                  'operands' =;SPMgt; [
                    bless( { '' =;SPMgt; '2', 'val' =;SPMgt; '2' }, 'factor' )
                  ],
                  '' =;SPMgt; '2'
                }, 'factorial' )
              ],
              '' =;SPMgt; '2'
            }, 'power' )
          ],
          '' =;SPMgt; '2'
        }, 'uneg' )
      ],
      '' =;SPMgt; '2'
    }, 'term' ),
    bless( {
      'operands' =;SPMgt; [
        bless( {
          'operands' =;SPMgt; [
            bless( {
              'operands' =;SPMgt; [
                bless( {
                  'operands' =;SPMgt; [
                    bless( { '' =;SPMgt; '2', 'val' =;SPMgt; '2' }, 'factor' )
                  ],
                  '' =;SPMgt; '2'
                }, 'factorial' )
              ],
              '' =;SPMgt; '2'
            }, 'power' )
          ],
          '' =;SPMgt; '2'
        }, 'uneg' )
      ],
      '' =;SPMgt; '2'
    }, 'term' )
  ],
  '' =;SPMgt; '4-2-2',
  'operators' =;SPMgt; [
    '-',
    '-'
  ]
}, 'expr' );
<tex2html_mydb_mark>#1701#
                        ;SPMlt;require: (?{ CODE }) ;SPMgt;
<tex2html_mydb_mark>#1702#
    ;SPMlt;rule: IPV4_Octet_Decimal;SPMgt;
        # Up three digits...
        ;SPMlt;MATCH= ( \d{1,3}+ );SPMgt;
        
        # ...but less that 256...
        ;SPMlt;require: (?{ $MATCH ;SPMlt;= 255 });SPMgt;
<tex2html_mydb_mark>#1703#
pl@nereida:~/Lregexpgrammars/demo$ cat -n ./demo_IP4.pl
 1  #!/usr//bin/env perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  use Regexp::Grammars;
 6
 7  my $grammar = qr{
 8      \A ;SPMlt;IP4_addr;SPMgt; \Z
 9
10      ;SPMlt;token: quad;SPMgt;
11          ;SPMlt;MATCH=(\d{1,3});SPMgt;
12          ;SPMlt;require: (?{ $MATCH ;SPMlt; 256 });SPMgt;
13
14      ;SPMlt;token: IP4_addr;SPMgt;
15          ;SPMlt;[MATCH=quad];SPMgt;**(\.)
16          ;SPMlt;require: (?{ @$MATCH == 4 });SPMgt;
17  }xms;
18
19  while (my $line = ;SPMlt;;SPMgt;) {
20      if ($line =~ $grammar) {
21          use Data::Dumper 'Dumper';
22          say Dumper \%/;
23      }
24      else {
25          say 'Does not match'
26      }
27  }
<tex2html_mydb_mark>#1704#
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123 . 145 . 105 . 252
Does not match
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123.145.105.252
$VAR1 = {
          '' =;SPMgt; '123.145.105.252',
          'IP4_addr' =;SPMgt; [
                          123,
                          145,
                          105,
                          252
                        ]
        };
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
148.257.128.128
Does not match
0.0.0.299
Does not match
pl@nereida:~/Lregexpgrammars/demo$  ./demo_IP4.pl
123.145.105.242.193
Does not match
<tex2html_mydb_mark>#1705#
    ;SPMlt;rule: shell_cmd;SPMgt;
        a2p | ac | apply | ar | automake | awk | ...
        # ...and 400 lines later
        ... | zdiff | zgrep | zip | zmore | zsh

    ;SPMlt;rule: valid_word;SPMgt;
        a | aa | aal | aalii | aam | aardvark | aardwolf | aba | ...
        # ...and 40,000 lines later... 
        ... | zymotize | zymotoxic | zymurgy | zythem | zythum
<tex2html_mydb_mark>#1706#
    ;SPMlt;rule: shell_cmd;SPMgt;
        ;SPMlt;%cmds;SPMgt;

    ;SPMlt;rule: valid_word;SPMgt;
        ;SPMlt;%dict;SPMgt;

<tex2html_mydb_mark>#1707#
    ;SPMlt;rule: shell_cmd;SPMgt;
        (;SPMlt;.hk;SPMgt;)  ;SPMlt;require: exists $cmds{$CAPTURE};SPMgt;

    ;SPMlt;rule: valid_word;SPMgt;
        (;SPMlt;.hk;SPMgt;)  ;SPMlt;require: exists $dict{$CAPTURE};SPMgt;
<tex2html_mydb_mark>#1708#
    ;SPMlt;rule: hk;SPMgt;
        .+            # Key may be any number of chars on a single line

    ;SPMlt;rule: hk;SPMgt;
        [ACGT]{10,}   # Key is a base sequence of at least 10 pairs
<tex2html_mydb_mark>#1709#
pl@nereida:~/Lregexpgrammars/demo$ cat -n hash.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Data::Dumper;
 6  $Data::Dumper::Deparse = 1;
 7
 8  my %cmd = map { ($_ =;SPMgt; undef ) } qw( uname pwd date );
 9
10  my $rbb = do {
11      use Regexp::Grammars;
12
13      qr{
14        ^;SPMlt;command;SPMgt;$
15
16        ;SPMlt;rule: command;SPMgt;
17          ;SPMlt;cmd=%cmd;SPMgt; (?: ;SPMlt;[arg];SPMgt; )*
18
19        ;SPMlt;token: arg;SPMgt; [^\s;SPMlt;;SPMgt;`;SPMamp;]+
20      }xms;
21  };
22
23  while (my $input = ;SPMlt;;SPMgt;) {
24      chomp($input);
25      if ($input =~ m{$rbb}) {
26          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
27          say Dumper \%/;
28          system $/{''}
29      }
30      else {
31          say(;SPMquot;does not match;SPMquot;);
32      }
33  }
<tex2html_mydb_mark>#1710#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 hash.pl
a2p f1 f2
matches: ;SPMlt;a2p f1 f2;SPMgt;
$VAR1 = {
          '' =;SPMgt; 'a2p f1 f2',
          'command' =;SPMgt; {
                         '' =;SPMgt; 'a2p f1 f2',
                         'cmd' =;SPMgt; 'a2p',
                         'arg' =;SPMgt; [
                                    'f1',
                                    'f2'
                                  ]
                       }
        };

pocho 2 5
does not match
<tex2html_mydb_mark>#1711#
        $grammar = qr{

            ;SPMlt;logfile: LaTeX_parser_log ;SPMgt;

            \A ;SPMlt;LaTeX_file;SPMgt; \Z    # Pattern to match

            ;SPMlt;rule: LaTeX_file;SPMgt;
                # etc.
        }x;
<tex2html_mydb_mark>#1712#
            ;SPMlt;logfile: - ;SPMgt;
<tex2html_mydb_mark>#1713#
pl@nereida:~/Lregexpgrammars/demo$ cat -n log.pl
     1  #!/usr/bin/env perl5.10.1
     2  use strict;
     3  use warnings;
     4  use 5.010;
     5  use Data::Dumper;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        ;SPMlt;logfile: -;SPMgt;
    12
    13        ;SPMlt;numbers;SPMgt;
    14
    15        ;SPMlt;rule: numbers;SPMgt;
    16          ;SPMlt;number;SPMgt; ** ;SPMlt;.comma;SPMgt;
    17
    18        ;SPMlt;token: number;SPMgt; \d+
    19
    20        ;SPMlt;token: comma;SPMgt;   ,
    21      }xms;
    22  };
    23
    24  while (my $input = ;SPMlt;;SPMgt;) {
    25      if ($input =~ m{$rbb}) {
    26          say(;SPMquot;matches: ;SPMlt;$;SPMamp;;SPMgt;;SPMquot;);
    27          say Dumper \%/;
    28      }
    29  }
<tex2html_mydb_mark>#1714#
pl@nereida:~/Lregexpgrammars/demo$ ./log.pl
  warn | Repeated subrule ;SPMlt;number;SPMgt;* will only capture its final match
       | (Did you mean ;SPMlt;[number];SPMgt;* instead?)
       |
  info | Processing the main regex before any rule definitions
       |    |
       |    |...Treating ;SPMlt;numbers;SPMgt; as:
       |    |      |  match the subrule ;SPMlt;numbers;SPMgt;
       |    |       \ saving the match in $MATCH{'numbers'}
       |    |
       |     \___End of main regex
       |
       | Defining a rule: ;SPMlt;numbers;SPMgt;
       |    |...Returns: a hash
       |    |
       |    |...Treating ;SPMlt;number;SPMgt; as:
       |    |      |  match the subrule ;SPMlt;number;SPMgt;
       |    |       \ saving the match in $MATCH{'number'}
       |    |
       |    |...Treating ;SPMlt;.comma;SPMgt; as:
       |    |      |  match the subrule ;SPMlt;comma;SPMgt;
       |    |       \ but don't save anything
       |    |
       |    |...Treating ;SPMlt;number;SPMgt; ** ;SPMlt;.comma;SPMgt; as:
       |    |      |  repeatedly match the subrule ;SPMlt;number;SPMgt;
       |    |       \ as long as the matches are separated by matches of ;SPMlt;.comma;SPMgt;
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: ;SPMlt;number;SPMgt;
       |    |...Returns: a hash
       |    |
       |    |...Treating '\d' as:
       |    |       \ normal Perl regex syntax
       |    |
       |    |...Treating '+ ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: ;SPMlt;comma;SPMgt;
       |    |...Returns: a hash
       |    |
       |    |...Treating ', ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
2, 3, 4
matches: ;SPMlt;2, 3, 4;SPMgt;
$VAR1 = {
          '' =;SPMgt; '2, 3, 4',
          'numbers' =;SPMgt; {
                         '' =;SPMgt; '2, 3, 4',
                         'number' =;SPMgt; '4'
                       }
        };
<tex2html_mydb_mark>#1715#
        ;SPMlt;debug: on;SPMgt;    - Enable debugging, stop when entire grammar matches
        ;SPMlt;debug: match;SPMgt; - Enable debugging, stope when a rule matches
        ;SPMlt;debug: try;SPMgt;   - Enable debugging, stope when a rule is tried
        ;SPMlt;debug: off;SPMgt;   - Disable debugging and continue parsing silently

        ;SPMlt;debug: continue;SPMgt; - Synonym for ;SPMlt;debug: on;SPMgt;
        ;SPMlt;debug: run;SPMgt;      - Synonym for ;SPMlt;debug: on;SPMgt;
        ;SPMlt;debug: step;SPMgt;     - Synonym for ;SPMlt;debug: try;SPMgt;
<tex2html_mydb_mark>#1716#
        ;SPMlt;rule: tricky;SPMgt;   # This is where we think the problem is...
            ;SPMlt;debug:step;SPMgt;
            ;SPMlt;preamble;SPMgt; ;SPMlt;text;SPMgt; ;SPMlt;postscript;SPMgt;
            ;SPMlt;debug:off;SPMgt;
<tex2html_mydb_mark>#1717#
        ===============;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 0
        ;SPMgt; cp file1 file2 |...Trying ;SPMlt;cmd;SPMgt;
                         |   |...Trying ;SPMlt;cmd=(cp);SPMgt;
                         |   |    \FAIL ;SPMlt;cmd=(cp);SPMgt;
                         |    \FAIL ;SPMlt;cmd;SPMgt;
                          \FAIL ;SPMlt;grammar;SPMgt;
        ===============;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 1
         cp file1 file2  |...Trying ;SPMlt;cmd;SPMgt;
                         |   |...Trying ;SPMlt;cmd=(cp);SPMgt;
         file1 file2     |   |    \_____;SPMlt;cmd=(cp);SPMgt; matched 'cp'
        file1 file2      |   |...Trying ;SPMlt;[file];SPMgt;+
         file2           |   |    \_____;SPMlt;[file];SPMgt;+ matched 'file1'
                         |   |...Trying ;SPMlt;[file];SPMgt;+
        [eos]            |   |    \_____;SPMlt;[file];SPMgt;+ matched ' file2'
                         |   |...Trying ;SPMlt;[file];SPMgt;+
                         |   |    \FAIL ;SPMlt;[file];SPMgt;+
                         |   |...Trying ;SPMlt;target;SPMgt;
                         |   |   |...Trying ;SPMlt;file;SPMgt;
                         |   |   |    \FAIL ;SPMlt;file;SPMgt;
                         |   |    \FAIL ;SPMlt;target;SPMgt;
         ;SPMlt;~~~~~~~~~~~~~~ |   |...Backtracking 5 chars and trying new match
        file2            |   |...Trying ;SPMlt;target;SPMgt;
                         |   |   |...Trying ;SPMlt;file;SPMgt;
                         |   |   |    \____ ;SPMlt;file;SPMgt; matched 'file2'
        [eos]            |   |    \_____;SPMlt;target;SPMgt; matched 'file2'
                         |    \_____;SPMlt;cmd;SPMgt; matched ' cp file1 file2'
                          \_____;SPMlt;grammar;SPMgt; matched ' cp file1 file2'
<tex2html_mydb_mark>#1718#
        m       - to continue until the next subrule matches
        t or s  - to continue until the next subrule is tried
        r or c  - to continue to the end of the grammar
        o       - to switch off debugging
<tex2html_mydb_mark>#1719#
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_debug.pl
     1  #!/usr/bin/env perl5.10.1
     2  use 5.010;
     3  use warnings;
     4
     5      use Regexp::Grammars;
     6
     7      my $balanced_brackets = qr{
     8          ;SPMlt;debug:on;SPMgt;
     9
    10          ;SPMlt;left_delim=(  \( );SPMgt;
    11          (?:
    12              ;SPMlt;[escape=(  \\ )];SPMgt;
    13          |   ;SPMlt;recurse=( (?R) );SPMgt;
    14          |   ;SPMlt;[simple=(  .  )];SPMgt;
    15          )*
    16          ;SPMlt;right_delim=( \) );SPMgt;
    17      }xms;
    18
    19      while (;SPMlt;;SPMgt;) {
    20          if (/$balanced_brackets/) {
    21              say 'matched:';
    22              use Data::Dumper 'Dumper';
    23              warn Dumper \%/;
    24          }
    25      }
<tex2html_mydb_mark>#1720#
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
<span class="lightblue">(a)</span>
=====;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 0
(a)\n  |...Trying ;SPMlt;left_delim=(  \( );SPMgt;

a)\n   |    \_____;SPMlt;left_delim=(  \( );SPMgt; matched '('      <span class="lightblue">c</span>
       |...Trying ;SPMlt;[escape=(  \ )];SPMgt;
       |    \FAIL ;SPMlt;[escape=(  \ )];SPMgt;
       |...Trying ;SPMlt;recurse=( (?R) );SPMgt;
=====;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 1
a)\n   |   |...Trying ;SPMlt;left_delim=(  \( );SPMgt;

       |   |    \FAIL ;SPMlt;left_delim=(  \( );SPMgt;
        \FAIL ;SPMlt;grammar;SPMgt;
       |...Trying ;SPMlt;[simple=(  .  )];SPMgt;
)\n    |    \_____;SPMlt;[simple=(  .  )];SPMgt; matched 'a'
       |...Trying ;SPMlt;[escape=(  \ )];SPMgt;

       |    \FAIL ;SPMlt;[escape=(  \ )];SPMgt;
       |...Trying ;SPMlt;recurse=( (?R) );SPMgt;
=====;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 2
)\n    |   |...Trying ;SPMlt;left_delim=(  \( );SPMgt;
       |   |    \FAIL ;SPMlt;left_delim=(  \( );SPMgt;

        \FAIL ;SPMlt;grammar;SPMgt;
       |...Trying ;SPMlt;[simple=(  .  )];SPMgt;
\n     |    \_____;SPMlt;[simple=(  .  )];SPMgt; matched ')'
       |...Trying ;SPMlt;[escape=(  \ )];SPMgt;
       |    \FAIL ;SPMlt;[escape=(  \ )];SPMgt;

       |...Trying ;SPMlt;recurse=( (?R) );SPMgt;
=====;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 3
\n     |   |...Trying ;SPMlt;left_delim=(  \( );SPMgt;
       |   |    \FAIL ;SPMlt;left_delim=(  \( );SPMgt;
        \FAIL ;SPMlt;grammar;SPMgt;

       |...Trying ;SPMlt;[simple=(  .  )];SPMgt;
[eos]  |    \_____;SPMlt;[simple=(  .  )];SPMgt; matched ''
       |...Trying ;SPMlt;[escape=(  \ )];SPMgt;
       |    \FAIL ;SPMlt;[escape=(  \ )];SPMgt;
       |...Trying ;SPMlt;recurse=( (?R) );SPMgt;

=====;SPMgt; Trying ;SPMlt;grammar;SPMgt; from position 4
[eos]  |   |...Trying ;SPMlt;left_delim=(  \( );SPMgt;
       |   |    \FAIL ;SPMlt;left_delim=(  \( );SPMgt;
        \FAIL ;SPMlt;grammar;SPMgt;
       |...Trying ;SPMlt;[simple=(  .  )];SPMgt;

       |    \FAIL ;SPMlt;[simple=(  .  )];SPMgt;
       |...Trying ;SPMlt;right_delim=( \) );SPMgt;
       |    \FAIL ;SPMlt;right_delim=( \) );SPMgt;
 ;SPMlt;~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying ;SPMlt;right_delim=( \) );SPMgt;
       |    \FAIL ;SPMlt;right_delim=( \) );SPMgt;

 ;SPMlt;~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying ;SPMlt;right_delim=( \) );SPMgt;
\n     |    \_____;SPMlt;right_delim=( \) );SPMgt; matched ')'
        \_____;SPMlt;grammar;SPMgt; matched '(a)'   <span class="lightblue">d</span>
              :         {
              :           '' =;SPMgt; '(a)',
              :           'left_delim' =;SPMgt; '(',
              :           'simple' =;SPMgt; [
              :                         'a'
              :                       ],
              :           'right_delim' =;SPMgt; ')'
              :         };      <span class="lightblue">o</span>
matched:
$VAR1 = {
          '' =;SPMgt; '(a)',
          'left_delim' =;SPMgt; '(',
          'simple' =;SPMgt; [
                        'a'
                      ],
          'right_delim' =;SPMgt; ')'
        };

</PRE>
<tex2html_mydb_mark>#1721#
        ;SPMlt;rule: ListElem;SPMgt;

            ;SPMlt;Elem=   ( [a-z]\d+) ;SPMgt;
                ;SPMlt;log: Checking for a suffix, too...;SPMgt;

            ;SPMlt;Suffix= ( : \d+   ) ;SPMgt;?
                ;SPMlt;log: (?{ ;SPMquot;ListElem: $MATCH{Elem} and $MATCH{Suffix};SPMquot; });SPMgt;
<tex2html_mydb_mark>#1722#
        ;SPMlt;rule: ListElem;SPMgt;
            ;SPMlt;Elem=   ( [a-z]\d+) ;SPMgt;
            ;SPMlt;Suffix= ( : \d+   ) ;SPMgt;?

                ;SPMlt;log: (?{
                    warn =;SPMgt; ;SPMquot;Elem was: $MATCH{Elem};SPMquot;,
                            ;SPMquot;Suffix was $MATCH{Suffix};SPMquot;,
                });SPMgt;
<tex2html_mydb_mark>#1723#
        my $balanced_brackets = qr{
            \(             # left delim
            (?:
                \\         # escape or
            |   (?R)       # recurse or
            |   .          # whatever
            )*
            \)             # right delim
        }xms;
<tex2html_mydb_mark>#1724#
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            ;SPMlt;debug:step;SPMgt;

            ;SPMlt;.left_delim=  (  \(  );SPMgt;
            (?:
                ;SPMlt;.escape=  (  \\  );SPMgt;
            |   ;SPMlt;.recurse= ( (?R) );SPMgt;
            |   ;SPMlt;.whatever=(  .   );SPMgt;
            )*
            ;SPMlt;.right_delim= (  \)  );SPMgt;
        }xms;

        while (;SPMlt;;SPMgt;) {
            say 'matched' if /$balanced_brackets/;
        }
<tex2html_mydb_mark>#1725#
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            ;SPMlt;debug:step;SPMgt;

            ;SPMlt;[left_delim=  (  \(  )];SPMgt;
            (?:
                ;SPMlt;[escape=  (  \\  )];SPMgt;
            |   ;SPMlt;[recurse= ( (?R) )];SPMgt;
            |   ;SPMlt;[whatever=(  .   )];SPMgt;
            )*
            ;SPMlt;[right_delim= (  \)  )];SPMgt;
        }xms;

        if ( '(a(bc)d)' =~ /$balanced_brackets/) {
            use Data::Dumper 'Dumper';
            warn Dumper \%/;
        }
<tex2html_mydb_mark>#1726#
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculatorwitherrmanagement.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Lingua::EN::Inflect qw(PL);
 6  use Scalar::Util qw{blessed};
 7
 8  my $rbb = do {
 9      my ($warnings, $errors);    # closure
10      sub warnings { $warnings }  # accessor
11      sub errors { $errors }      # accessor
12
13      use Regexp::Grammars;
14      qr{
15        (?{
16            $warnings = 0;
17            $errors = 0;
18        })
19        \A;SPMlt;expr;SPMgt;
20        (?:   \z
21             |
22               (.*) (?{
23                        # Accept the string but emit a warning
24                        $warnings++;
25                        local our $expr = \$MATCH{expr}{''};
26                        local our $endlegal = length($$expr) ;SPMgt; 4? ;SPMquot;... ;SPMquot;.substr($$expr, -4) : $$expr;
27                        warn ;SPMquot;Warning: Unexpected ';SPMquot;. substr($^N, 0, 10).;SPMquot;' after '$endlegal'\n;SPMquot;;
28                     })
29        )
30
31        ;SPMlt;objrule: expr;SPMgt;      ;SPMlt;[operands=term];SPMgt; ** ;SPMlt;[operators=addop];SPMgt;
32
33        ;SPMlt;objrule: term;SPMgt;      ;SPMlt;[operands=uneg];SPMgt; ** ;SPMlt;[operators=mulop];SPMgt;
34
35        ;SPMlt;objrule: uneg;SPMgt;      ;SPMlt;[operators=minus];SPMgt;* ;SPMlt;[operands=power];SPMgt;
36
37        ;SPMlt;objrule: power;SPMgt;     ;SPMlt;[operands=factorial];SPMgt; ** ;SPMlt;[operators=powerop];SPMgt;
38
39        ;SPMlt;objrule: factorial;SPMgt; ;SPMlt;[operands=factor];SPMgt;  ;SPMlt;[operators=(!)];SPMgt;*
40
41        ;SPMlt;objrule: factor;SPMgt;    (;SPMlt;val=([+-]?\d+(?:\.\d*)?);SPMgt;)
42                           | \( ;SPMlt;MATCH=expr;SPMgt; \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn ;SPMquot;Error: expecting a number or a open parenthesis, found: ';SPMquot;. substr($^N, 0, 10).;SPMquot;'\n;SPMquot;;
46                                            $warnings++;
47                                            $errors++;
48                                        }) ;SPMlt;MATCH=factor;SPMgt;
49
50        ;SPMlt;token: addop;SPMgt;        [+-]
51
52        ;SPMlt;token: mulop;SPMgt;        [*/]
53
54        ;SPMlt;token: powerop;SPMgt;      \*\*|\^
55
56        ;SPMlt;token: minus;SPMgt;        - ;SPMlt;MATCH=(?{ 'NEG' });SPMgt;
57
58      }x;
59  };
60
61  sub test_calc {
62    my $prompt = shift;
63
64    print $prompt;
65    while (my $input = ;SPMlt;;SPMgt;) {
66        chomp($input);
67
68        local %/;
69        $input =~ m{$rbb};
70
71        say warnings.;SPMquot; ;SPMquot;.PL('warning',warnings) if warnings;
72        say errors.;SPMquot; ;SPMquot;.PL('error',errors)       if errors;
73
74        my $tree = $/{expr};
75        if (blessed($tree)) {
76            do ;SPMquot;PostfixCalc.pm;SPMquot;;
77            say ;SPMquot;postfix: ;SPMquot;.$tree-;SPMgt;ceval;
78
79            do ;SPMquot;EvalCalc.pm;SPMquot;;
80            say ;SPMquot;result: ;SPMquot;.$tree-;SPMgt;ceval;
81        }
82        print $prompt;
83    }
84    say ;SPMquot;Bye!;SPMquot;
85  }
86
87  ########## main
88  test_calc(
89    'Parsing infix arithmetic expressions (CTRL-D to end in unix) ',
90  );
<tex2html_mydb_mark>#1727#
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+3
postfix: 2 3 +
result: 5
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
Error: expecting a number or a open parenthesis, found: '#'
Error: expecting a number or a open parenthesis, found: ')'
Warning: Unexpected '*(3+#)' after '2'
4 warnings
3 errors
postfix: 2
result: 2
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+#*4
Error: expecting a number or a open parenthesis, found: '#*'
1 warning
1 error
postfix: 2 4 +
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
<tex2html_mydb_mark>#1728#
41        ;SPMlt;objrule: factor;SPMgt;    (;SPMlt;val=([+-]?\d+(?:\.\d*)?);SPMgt;)
42                           | \( ;SPMlt;MATCH=expr;SPMgt; \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn ;SPMquot;Error: expecting a number or a open parenthesis, found: ';SPMquot;. substr($^N, 0, 10).;SPMquot;'\n;SPMquot;;
46                                            $warnings++;
47                                            $errors++;
48                                        }) ;SPMlt;MATCH=factor;SPMgt;
<tex2html_mydb_mark>#1729#
 41       ;SPMlt;objrule: factor;SPMgt;    (;SPMlt;val=([+-]?\d+(?:\.\d*)?);SPMgt;)
 42                          | \( ;SPMlt;MATCH=expr;SPMgt; \)
 43                          | ([^-+(0-9]+) (?{
 44                                           # is + and not * to avoid infinite recursion
 45                                           warn ;SPMquot;Error: expecting a number or a open parenthesis, found: ';SPMquot;. substr($^N, 0, 10).;SPMquot;'\n;SPMquot;;
 46                                           $warnings++;
 47                                           $errors++;
 48                                       }) (*COMMIT) ;SPMlt;MATCH=factor;SPMgt;
<tex2html_mydb_mark>#1730#
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*3
postfix: 2 3 *
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) @
Error: expecting a number or a open parenthesis, found: '@'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
<tex2html_mydb_mark>#1731#
       qr{ \A            # ...Match only at start of input
           ;SPMlt;ArithExpr;SPMgt;   # ...Match a valid arithmetic expression

           (?:
               # Should be at end of input...
               \s* \Z
             |
               # If not, report the fact but don't fail...
               ;SPMlt;warning: Expected end-of-input;SPMgt;
               ;SPMlt;warning: (?{ ;SPMquot;Extra junk at index $INDEX: $CONTEXT;SPMquot; });SPMgt;
           )

           # Rule definitions here...
       }xms;
<tex2html_mydb_mark>#1732#
pl@nereida:~/Lregexpgrammars/demo$ cat -n exprdamian.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        \A;SPMlt;expr;SPMgt;\z
    12
    13        ;SPMlt;objrule: expr;SPMgt;    ;SPMlt;MATCH=term;SPMgt; (?! ;SPMlt;addop;SPMgt; )                  # bypass
    14                         | ;SPMlt;[operands=term];SPMgt; ** ;SPMlt;[operators=addop];SPMgt;
    15
    16        ;SPMlt;objrule: term;SPMgt;    ;SPMlt;MATCH=factor;SPMgt; (?! ;SPMlt;mulop;SPMgt; )                # bypass
    17                         | ;SPMlt;[operands=factor];SPMgt; ** ;SPMlt;[operators=mulop];SPMgt;
    18
    19        ;SPMlt;objrule: factor;SPMgt;    ;SPMlt;val=([+-]?\d+(?:\.\d*)?);SPMgt;
    20                         | \( ;SPMlt;MATCH=expr;SPMgt; \)
    21
    22        ;SPMlt;token: addop;SPMgt; [+-]
    23
    24        ;SPMlt;token: mulop;SPMgt; [*/]
    25
    26      }x;
    27  };
    28
    29  while (my $input = ;SPMlt;;SPMgt;) {
    30      chomp($input);
    31      if ($input =~ m{$rbb}) {
    32          my $tree = $/{expr};
    33          say Dumper $tree;
    34          say $tree-;SPMgt;ceval;
    35
    36      }
    37      else {
    38          say(;SPMquot;does not match;SPMquot;);
    39      }
    40  }
    41
    42  BEGIN {
    43
    44    package LeftBinaryOp;
    45    use strict;
    46    use base qw(Class::Accessor);
    47
    48    LeftBinaryOp-;SPMgt;mk_accessors(qw{operators operands});
    49
    50    my %f = (
    51      '+' =;SPMgt; sub { shift() + shift() },
    52      '-' =;SPMgt; sub { shift() - shift() },
    53      '*' =;SPMgt; sub { shift() * shift() },
    54      '/' =;SPMgt; sub { shift() / shift() },
    55    );
    56
    57    sub ceval {
    58      my $self = shift;
    59
    60      # recursively evaluate the children first
    61      my @operands = map { $_-;SPMgt;ceval } @{$self-;SPMgt;operands};
    62
    63      # then combine them
    64      my $s = shift @operands;
    65      for (@{$self-;SPMgt;operators}) {
    66        $s = $f{$_}-;SPMgt;($s, shift @operands);
    67      }
    68      return $s;
    69    }
    70
    71    package term;
    72    use base qw{LeftBinaryOp};
    73
    74    package expr;
    75    use base qw{LeftBinaryOp};
    76
    77    package factor;
    78
    79    sub ceval {
    80      my $self = shift;
    81
    82      return $self-;SPMgt;{val};
    83    }
    84
    85    1;
    86  }
<tex2html_mydb_mark>#1733#
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 exprdamian.pl
4-2-2
$VAR1 = bless( {
  'operands' =;SPMgt; [
    bless( {
      '' =;SPMgt; '4',
      'val' =;SPMgt; '4'
    }, 'factor' ),
    bless( {
      '' =;SPMgt; '2',
      'val' =;SPMgt; '2'
    }, 'factor' ),
    bless( {
      '' =;SPMgt; '2',
      'val' =;SPMgt; '2'
    }, 'factor' )
  ],
  '' =;SPMgt; '4-2-2',
  'operators' =;SPMgt; [
    '-',
    '-'
  ]
}, 'expr' );

0
8/4/2
$VAR1 = bless( {
  'operands' =;SPMgt; [
    bless( {
      '' =;SPMgt; '8',
      'val' =;SPMgt; '8'
    }, 'factor' ),
    bless( {
      '' =;SPMgt; '4',
      'val' =;SPMgt; '4'
    }, 'factor' ),
    bless( {
      '' =;SPMgt; '2',
      'val' =;SPMgt; '2'
    }, 'factor' )
  ],
  '' =;SPMgt; '8/4/2',
  'operators' =;SPMgt; [
    '/',
    '/'
  ]
}, 'term' );

1
3
$VAR1 = bless( {
  '' =;SPMgt; '3',
  'val' =;SPMgt; '3'
}, 'factor' );

3
2*(3+4)
$VAR1 = bless( {
  'operands' =;SPMgt; [
    bless( {
      '' =;SPMgt; '2',
      'val' =;SPMgt; '2'
    }, 'factor' ),
    bless( {
      'operands' =;SPMgt; [
        bless( {
          '' =;SPMgt; '3',
          'val' =;SPMgt; '3'
        }, 'factor' ),
        bless( {
          '' =;SPMgt; '4',
          'val' =;SPMgt; '4'
        }, 'factor' )
      ],
      '' =;SPMgt; '3+4',
      'operators' =;SPMgt; [
        '+'
      ]
    }, 'expr' )
  ],
  '' =;SPMgt; '2*(3+4)',
  'operators' =;SPMgt; [
    '*'
  ]
}, 'term' );

14
<tex2html_mydb_mark>#1734#
    58  require EvalCalc;
    59
    60  test_calc(
    61    'Evaluating infix arithmetic expressions (CTRL-D to end in unix) ',
    62    sub { print ;SPMamp;Data::Dumper::Dumper(shift()) },
    63  );
<tex2html_mydb_mark>#1735#
<pre>
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
<span class='lightblue'>8-4-2</span>
$VAR1 = bless( {
  'operands' =;SPMgt; [
    bless( {
      'operands' =;SPMgt; [
        bless( {
          'operands' =;SPMgt; [
            bless( {
              'operands' =;SPMgt; [
                bless( {
                  'operands' =;SPMgt; [
                    bless( { '' =;SPMgt; '8', 'val' =;SPMgt; '8' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =;SPMgt; '8'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =;SPMgt; '8'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =;SPMgt; '8'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =;SPMgt; '8'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =;SPMgt; [
        bless( {
          'operands' =;SPMgt; [
            bless( {
              'operands' =;SPMgt; [
                bless( {
                  'operands' =;SPMgt; [
                    bless( { '' =;SPMgt; '4', 'val' =;SPMgt; '4' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =;SPMgt; '4'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =;SPMgt; '4'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =;SPMgt; '4'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =;SPMgt; '4'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =;SPMgt; [
        bless( {
          'operands' =;SPMgt; [
            bless( {
              'operands' =;SPMgt; [
                bless( {
                  'operands' =;SPMgt; [
                    bless( { '' =;SPMgt; '2', 'val' =;SPMgt; '2' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =;SPMgt; '2'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =;SPMgt; '2'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =;SPMgt; '2'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =;SPMgt; '2'
    }, <span class='lightblue'>'term'</span> )
  ],
  '' =;SPMgt; '8-4-2',
  <span class='red'>'operators' =;SPMgt; [
    '-',
    '-'
  ]</span>
}, <span class='lightblue'>'expr'</span> );
2
</pre>
<tex2html_mydb_mark>#1736#
 8  my $rbb = do {
 9      use Regexp::Grammars;
10
11      qr{
12        \A;SPMlt;expr;SPMgt;\z
13
14        ;SPMlt;objrule: expr;SPMgt;      ;SPMlt;[operands=term];SPMgt; ** ;SPMlt;[operators=addop];SPMgt;
15
16        ;SPMlt;objrule: term;SPMgt;      ;SPMlt;[operands=uneg];SPMgt; ** ;SPMlt;[operators=mulop];SPMgt;
17
18        ;SPMlt;objrule: uneg;SPMgt;      ;SPMlt;[operators=minus];SPMgt;* ;SPMlt;[operands=power];SPMgt;
19
20        ;SPMlt;objrule: power;SPMgt;     ;SPMlt;[operands=factorial];SPMgt; ** ;SPMlt;[operators=powerop];SPMgt;
21
22        ;SPMlt;objrule: factorial;SPMgt; ;SPMlt;[operands=factor];SPMgt;  ;SPMlt;[operators=(!)];SPMgt;*
23
24        ;SPMlt;objrule: factor;SPMgt;    ;SPMlt;val=([+-]?\d+(?:\.\d*)?);SPMgt;
25                           | \( ;SPMlt;MATCH=expr;SPMgt; \)
26
27        ;SPMlt;token: addop;SPMgt;        [+-]
28
29        ;SPMlt;token: mulop;SPMgt;        [*/]
30
31        ;SPMlt;token: powerop;SPMgt;      \*\*|\^
32
33        ;SPMlt;token: minus;SPMgt;        - ;SPMlt;MATCH=(?{ 'NEG' });SPMgt;
34
35      }x;
36  };
<tex2html_mydb_mark>#1737#
 66  require PostfixCalc;
 67  test_calc('Translating expressions to postfix (CTRL-D to end in unix) ');
<tex2html_mydb_mark>#1738#
Translating expressions to postfix (CTRL-D to end in unix)
6--3!
6 3 ! ~ -
<tex2html_mydb_mark>#1739#
pl@nereida:~/Lregexpgrammars/demo/calculator$ tree
.
|-- EvalCalc.pm            # Soporte para la evaluación de la expresión: sem
|-- Operator.pm            # Soporte a las clases nodo: recorridos
|-- PostfixCalc.pm         # Soporte para la traducción a postfijo: sem
`-- calculator.pl          # programa principal
<tex2html_mydb_mark>#1740#
<pre>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/env perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use </span><span class="synConstant">5.010</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">use </span>Data::Dumper;
<span class="synLinenum">    6</span>   <span class="synIdentifier">$</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Indent</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rbb</span> = <span class="synStatement">do</span> {
<span class="synLinenum">    9</span>       <span class="synStatement">use </span>Regexp::Grammars;
<span class="synLinenum">   10</span> 
<span class="synLinenum">   11</span>       <span class="synConstant">qr{</span>
<span class="synLinenum">   12</span> <span class="synConstant">        </span><span class="synSpecial">\A</span><span class="synConstant">;SPMlt;expr;SPMgt;</span><span class="synSpecial">\z</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">        ;SPMlt;objrule: expr;SPMgt;      ;SPMlt;</span><span class="synSpecial">[operands=term]</span><span class="synConstant">;SPMgt; </span><span class="synSpecial">**</span><span class="synConstant"> ;SPMlt;</span><span class="synSpecial">[operators=addop]</span><span class="synConstant">;SPMgt;</span>
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span> <span class="synConstant">        ;SPMlt;objrule: term;SPMgt;      ;SPMlt;</span><span class="synSpecial">[operands=uneg]</span><span class="synConstant">;SPMgt; </span><span class="synSpecial">**</span><span class="synConstant"> ;SPMlt;</span><span class="synSpecial">[operators=mulop]</span><span class="synConstant">;SPMgt;</span>
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span> <span class="synConstant">        ;SPMlt;objrule: uneg;SPMgt;      ;SPMlt;</span><span class="synSpecial">[operators=minus]</span><span class="synConstant">;SPMgt;</span><span class="synSpecial">*</span><span class="synConstant"> ;SPMlt;</span><span class="synSpecial">[operands=power]</span><span class="synConstant">;SPMgt;</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">        ;SPMlt;objrule: power;SPMgt;     ;SPMlt;</span><span class="synSpecial">[operands=factorial]</span><span class="synConstant">;SPMgt; </span><span class="synSpecial">**</span><span class="synConstant"> ;SPMlt;</span><span class="synSpecial">[operators=powerop]</span><span class="synConstant">;SPMgt;</span>
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synConstant">        ;SPMlt;objrule: factorial;SPMgt; ;SPMlt;</span><span class="synSpecial">[operands=factor]</span><span class="synConstant">;SPMgt;  ;SPMlt;</span><span class="synSpecial">[operators=(!)]</span><span class="synConstant">;SPMgt;</span><span class="synSpecial">*</span>
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span> <span class="synConstant">        ;SPMlt;objrule: factor;SPMgt;    ;SPMlt;val=</span><span class="synSpecial">([+-]?\d+(?:\.\d*)?)</span><span class="synConstant">;SPMgt;</span>
<span class="synLinenum">   25</span> <span class="synConstant">                           | </span><span class="synSpecial">\(</span><span class="synConstant"> ;SPMlt;MATCH=expr;SPMgt; </span><span class="synSpecial">\)</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">        ;SPMlt;token: addop;SPMgt;        </span><span class="synSpecial">[+-]</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        ;SPMlt;token: mulop;SPMgt;        </span><span class="synSpecial">[*/]</span>
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span> <span class="synConstant">        ;SPMlt;token: powerop;SPMgt;      </span><span class="synSpecial">\*\*</span><span class="synConstant">|</span><span class="synSpecial">\^</span>
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span> <span class="synConstant">        ;SPMlt;token: minus;SPMgt;        - ;SPMlt;MATCH=</span><span class="synSpecial">(?</span><span class="synConstant">{ 'NEG' </span>}<span class="synSpecial">)</span><span class="synConstant">;SPMgt;</span>
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span> <span class="synConstant">      }x</span>;
<span class="synLinenum">   36</span>   };
<span class="synLinenum">   37</span> 
<span class="synLinenum">   38</span>   <span class="synStatement">sub </span><span class="synIdentifier">test_calc </span>{
<span class="synLinenum">   39</span>     <span class="synStatement">my</span> <span class="synIdentifier">$prompt</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   40</span>     <span class="synStatement">my</span> <span class="synIdentifier">$handler</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>     <span class="synStatement">say</span> <span class="synIdentifier">$prompt</span>;
<span class="synLinenum">   43</span>     <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$input</span> = ;SPMlt;;SPMgt;) {
<span class="synLinenum">   44</span>         <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   45</span>         <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rbb</span><span class="synStatement">}</span>) {
<span class="synLinenum">   46</span>             <span class="synStatement">my</span> <span class="synIdentifier">$tree</span> = <span class="synIdentifier">$/</span>{expr};
<span class="synLinenum">   47</span>             <span class="synIdentifier">$handler</span>-;SPMgt;(<span class="synIdentifier">$tree</span>) <span class="synStatement">if</span> <span class="synIdentifier">$handler</span>;
<span class="synLinenum">   48</span> 
<span class="synLinenum">   49</span>             <span class="synStatement">say</span> <span class="synIdentifier">$tree-;SPMgt;ceval</span>;
<span class="synLinenum">   50</span> 
<span class="synLinenum">   51</span>         }
<span class="synLinenum">   52</span>         <span class="synStatement">else</span> {
<span class="synLinenum">   53</span>             <span class="synStatement">say</span>(<span class="synConstant">;SPMquot;does not match;SPMquot;</span>);
<span class="synLinenum">   54</span>         }
<span class="synLinenum">   55</span>     }
<span class="synLinenum">   56</span>   }
<span class="synLinenum">   57</span> 
<span class="synLinenum">   58</span>   <span class="synStatement">require</span> EvalCalc;
<span class="synLinenum">   59</span> 
<span class="synLinenum">   60</span>   test_calc(
<span class="synLinenum">   61</span>     <span class="synConstant">'Evaluating infix arithmetic expressions (CTRL-D to end in unix) '</span>,
<span class="synLinenum">   62</span>     <span class="synStatement">sub </span>{ <span class="synStatement">print</span> <span class="synIdentifier">;SPMamp;</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Dumper</span>(<span class="synStatement">shift</span>()) },
<span class="synLinenum">   63</span>   );
<span class="synLinenum">   64</span> 
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>   <span class="synStatement">require</span> PostfixCalc;
<span class="synLinenum">   67</span>   test_calc(<span class="synConstant">'Translating expressions to postfix (CTRL-D to end in unix) '</span>);
</pre>
<tex2html_mydb_mark>#1741#
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n Operator.pm
   1  #   Class hierarchy diagram:
   2  #  $ vgg -t 'Operator(LeftBinaryOp(expr,term),RightBinaryOp(power),PreUnaryOp(uneg),PostUnaryOp(factorial))'
   3  #                           +--------+
   4  #                           |Operator|
   5  #                           +--------+
   6  #          .---------------.----^--------.-------------.
   7  #    +------------+ +-------------+ +----------+ +-----------+
   8  #    |LeftBinaryOp| |RightBinaryOp| |PreUnaryOp| |PostUnaryOp|
   9  #    +------------+ +-------------+ +----------+ +-----------+
  10  #      .---^--.        |              |               |
  11  #    +----+ +----+  +-----+         +----+       +---------+
  12  #    |expr| |term|  |power|         |uneg|       |factorial|
  13  #    +----+ +----+  +-----+         +----+       +---------+
  14  #
  15  #
  16  # NOTE: package ;SPMquot;factor;SPMquot; actually implements numbers and is
  17  #       outside this hierarchy
  18  #
  19  package Operator;
  20  use strict;
  21  use Carp;
  22
  23  sub Operands {
  24    my $self = shift;
  25
  26    return () unless exists $self-;SPMgt;{operands};
  27    return @{$self-;SPMgt;{operands}};
  28  }
  29
  30  sub Operators {
  31    my $self = shift;
  32
  33    return () unless exists $self-;SPMgt;{operators};
  34    return @{$self-;SPMgt;{operators}};
  35  }
  36
  37  sub sem {
  38    confess ;SPMquot;not defined sem;SPMquot;;
  39  }
  40
  41  sub make_sem {
  42    my $class = shift;
  43    my %semdesc = @_;
  44
  45    for my $class (keys %semdesc) {
  46      my %sem = %{$semdesc{$class}};
  47
  48      # Install 'sem' method in $class
  49      no strict 'refs';
  50      no warnings 'redefine';
  51      *{$class.;SPMquot;::sem;SPMquot;} = sub {
  52        my ($self, $op) = @_;
  53        $sem{$op}
  54      };
  55    }
  56  }
  57
  58  package LeftBinaryOp;
  59  use base qw{Operator};
  60
  61  sub ceval {
  62    my $self = shift;
  63
  64    # recursively evaluate the children first
  65    my @operands = map { $_-;SPMgt;ceval } $self-;SPMgt;Operands;
  66
  67    # then combine them
  68    my $s = shift @operands;
  69    for ($self-;SPMgt;Operators) {
  70      $s = $self-;SPMgt;sem($_)-;SPMgt;($s, shift @operands);
  71    }
  72    return $s;
  73  }
  74
  75  package RightBinaryOp;
  76  use base qw{Operator};
  77
  78  sub ceval {
  79    my $self = shift;
  80
  81    # recursively evaluate the children first
  82    my @operands = map { $_-;SPMgt;ceval } $self-;SPMgt;Operands;
  83
  84    # then combine them
  85    my $s = pop @operands;
  86    for (reverse $self-;SPMgt;Operators) {
  87      $s = $self-;SPMgt;sem($_)-;SPMgt;(pop @operands, $s);
  88    }
  89    return $s;
  90  }
  91
  92  package PreUnaryOp;
  93  use base qw{Operator};
  94
  95  sub ceval {
  96    my $self = shift;
  97
  98    # recursively evaluate the children first
  99    my @operands = map { $_-;SPMgt;ceval } $self-;SPMgt;Operands;
 100
 101    # then combine them
 102    my $s = shift @operands;
 103    for (reverse $self-;SPMgt;Operators) {
 104      $s = $self-;SPMgt;sem($_)-;SPMgt;($s);
 105    }
 106    return $s;
 107  }
 108
 109  package PostUnaryOp;
 110  use base qw{Operator};
 111
 112  sub ceval {
 113    my $self = shift;
 114
 115    # recursively evaluate the children first
 116    my @operands = map { $_-;SPMgt;ceval } $self-;SPMgt;Operands;
 117
 118    # then combine them
 119    my $s = shift @operands;
 120    for ($self-;SPMgt;Operators) {
 121      $s = $self-;SPMgt;sem($_)-;SPMgt;($s);
 122    }
 123    return $s;
 124  }
 125
 126  package term;
 127  use base qw{LeftBinaryOp};
 128
 129  package expr;
 130  use base qw{LeftBinaryOp};
 131
 132  package power;
 133  use base qw{RightBinaryOp};
 134
 135  package uneg;
 136  use base qw{PreUnaryOp};
 137
 138  package factorial;
 139  use base qw{PostUnaryOp};
 140
 141  package factor;
 142
 143  sub ceval {
 144    my $self = shift;
 145
 146    return $self-;SPMgt;{val};
 147  }
 148
 149  1;
<tex2html_mydb_mark>#1742#
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n EvalCalc.pm
 1  package EvalCalc;
 2  use strict;
 3  use Carp;
 4
 5  use Operator;
 6
 7  ####
 8  sub f {
 9    $_[0];SPMgt;1?$_[0]*f($_[0]-1):1;
10  }
11
12  sub fac {
13    my $n = shift;
14
15    confess ;SPMquot;Not valid number;SPMquot; unless $n =~ /^\d+$/;
16    f($n);
17  };
18
19  my $s = sub { shift() **  shift() };
20
21  Operator-;SPMgt;make_sem(
22     expr =;SPMgt; {
23        '+' =;SPMgt; sub { shift()  +  shift() },
24        '-' =;SPMgt; sub { shift()  -  shift() },
25     },
26     term =;SPMgt; {
27       '*' =;SPMgt; sub { shift()  *  shift() },
28       '/' =;SPMgt; sub { shift()  /  shift() },
29     },
30     power =;SPMgt; {
31        '^'  =;SPMgt; $s,
32        '**' =;SPMgt; $s,
33     },
34     uneg =;SPMgt; {
35        'NEG' =;SPMgt; sub { -shift() },
36     },
37     factorial =;SPMgt; {
38        '!' =;SPMgt; \;SPMamp;fac,
39     },
40  );
41
42  1;
<tex2html_mydb_mark>#1743#
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n PostfixCalc.pm
 1  package PostfixCalc;
 2  use strict;
 3
 4  use Operator;
 5
 6  # Modify semantics: now translate to postfix
 7  my $powers = sub { shift().' '.shift().' **' };
 8
 9  Operator-;SPMgt;make_sem(
10     expr =;SPMgt; {
11        '+' =;SPMgt; sub { shift().' '.shift().' +'  },
12        '-' =;SPMgt; sub { shift().' '.shift().' -' },
13      },
14      term =;SPMgt; {
15        '*' =;SPMgt; sub { shift().' '.shift().' *'  },
16        '/' =;SPMgt; sub { shift().' '.shift().' /' },
17      },
18      power =;SPMgt; {
19        '^'  =;SPMgt; $powers,
20        '**' =;SPMgt; $powers,
21      },
22      uneg =;SPMgt; {
23         # use ~ for unary minus
24        'NEG' =;SPMgt; sub { shift().' ~' },
25      },
26      factorial =;SPMgt; {
27        '!' =;SPMgt; sub { shift().' !'},
28      },
29  );
30
31  1;
<tex2html_mydb_mark>#1744#
pl@nereida:~/Lregexpgrammars/demo$ cat -n calculator.pl
   1  #!/usr/bin/env perl5.10.1
<tex2html_mydb_mark>#1745#
  42  sub test_calc {
  43    my $prompt = shift;
  44    my $handler = shift;
  45
  46    say $prompt;
  47    while (my $input = ;SPMlt;;SPMgt;) {
  48        chomp($input);
  49        if ($input =~ m{$rbb}) {
  50            my $tree = $/{expr};
  51            $handler-;SPMgt;($tree) if $handler;
  52
  53            say $tree-;SPMgt;ceval;
  54
  55        }
  56        else {
  57            say(;SPMquot;does not match;SPMquot;);
  58        }
  59    }
  60  }
<tex2html_mydb_mark>#1746#
b = a = 4*2
<tex2html_mydb_mark>#1747#
4 2 * a = b =
<tex2html_mydb_mark>#1748#
c = { a = 4; b = 2*a }
<tex2html_mydb_mark>#1749#
a = b+2 ;SPMgt; c*4
<tex2html_mydb_mark>#1750#
a = ((b+2) ;SPMgt; (c*4))
<tex2html_mydb_mark>#1751#
b 2 + c 4 * ;SPMgt; a =
<tex2html_mydb_mark>#1752#
c = if a ;SPMgt; 0 then { a = a -1; 2*a } else { b + 2 };
d = if a ;SPMgt; 0 then { a = b -1; 2*b };
<tex2html_mydb_mark>#1753#
if (a ;SPMgt; 0) then if (b ;SPMgt; 0) then {5} else {6}
<tex2html_mydb_mark>#1754#
if (a ;SPMgt; 0) then (if (b ;SPMgt; 0) then {5} else {6})
<tex2html_mydb_mark>#1755#
if (a ;SPMgt; 0) then (if (b ;SPMgt; 0) then {5}) else {6}
<tex2html_mydb_mark>#1756#
        a
        0
        ;SPMgt;
        jz endif124
        b
        0
        ;SPMgt;
        jz else125
        5
        j endif126
:else125
        6
:endif124
:endif125
        ...
<tex2html_mydb_mark>#1757#%

<tex2html_mydb_mark>#1758#%\centerline{\epsfig{file=figures/perldoc.eps, height=14cm}}

<tex2html_mydb_mark>#1759#%symbol_table;         # La tabla de símbolos $symbol_table{x} contiene

<tex2html_mydb_mark>#1760#%symbol_table = (); 

<tex2html_mydb_mark>#1761#%\parrafo{Reconstrucci\'on de la aplicaciÃ³n}

<tex2html_mydb_mark>#1762#%h| de clave \verb|k|?

<tex2html_mydb_mark>#1763#%Muestre un ejemplo en el que no funcione la expresión regular: 

<tex2html_mydb_mark>#1764#%

<tex2html_mydb_mark>#1765#%\begin{verbatim}

<tex2html_mydb_mark>#1766#% $program =~ m{

<tex2html_mydb_mark>#1767#%   /\*  # Abrir comentario

<tex2html_mydb_mark>#1768#%   .*   # Consumir caracteres

<tex2html_mydb_mark>#1769#%   \*/  # Cerrar comentario

<tex2html_mydb_mark>#1770#%}gsx

<tex2html_mydb_mark>#1771#%\end{verbatim}

<tex2html_mydb_mark>#1772#%RE| directamente 

<tex2html_mydb_mark>#1773#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<tex2html_mydb_mark>#1774#%symbol_table = ();

<tex2html_mydb_mark>#1775#%Esa es la función del programa \verb|test.pl| que se generó

<tex2html_mydb_mark>#1776#%automáticamente con \verb|h2xs|.

<tex2html_mydb_mark>#1777#%\item

<tex2html_mydb_mark>#1778#%\htmladdnormallink{Testing Files and Test Modules}

<tex2html_mydb_mark>#1779#%{http://www.perl.com/lpt/a/966}

<tex2html_mydb_mark>#1780#%por Phil Crow. 

<tex2html_mydb_mark>#1781#%{$parser-;SPMgt;{GRAMMAR}{NULLABLE}}), 43, ;SPMquot;43 nullable productions;SPMquot;);

<tex2html_mydb_mark>#1782#%{$parser-;SPMgt;{GRAMMAR}{NTERM}}), 233, ;SPMquot;233 syntactic variables;SPMquot;);

<tex2html_mydb_mark>#1783#%{$parser-;SPMgt;{GRAMMAR}{TERM}})), 108, ;SPMquot;108 terminals;SPMquot;);

<tex2html_mydb_mark>#1784#%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 
<tex2html_mydb_mark>#1785#%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 
<tex2html_mydb_mark>#1786#%
 
<tex2html_mydb_mark>#1787#%

<tex2html_mydb_mark>#1788#%%| en una línea aparte. Así, el \verb|%%| de la línea 1

<tex2html_mydb_mark>#1789#%token|), 

<tex2html_mydb_mark>#1790#%start|), etc.

<tex2html_mydb_mark>#1791#%
       
<tex2html_mydb_mark>#1792#%
       
<tex2html_mydb_mark>#1793#% ]
  
<tex2html_mydb_mark>#1794#%
 
<tex2html_mydb_mark>#1795#%;SPMlt;', '%;SPMgt;'];
  
<tex2html_mydb_mark>#1796#%;SPMlt;'|

<tex2html_mydb_mark>#1797#%;SPMgt;'|.

<tex2html_mydb_mark>#1798#%;SPMlt;$separator%;SPMgt;
 
<tex2html_mydb_mark>#1799#%;SPMlt;$label%;SPMgt;}
 
<tex2html_mydb_mark>#1800#%;SPMlt;$prefix%;SPMgt;
 
<tex2html_mydb_mark>#1801#%;SPMlt;$sufix%;SPMgt;

<tex2html_mydb_mark>#1802#%;SPMlt;$separator%;SPMgt;

<tex2html_mydb_mark>#1803#%;SPMlt;$label%;SPMgt;}

<tex2html_mydb_mark>#1804#%;SPMlt;$prefix%;SPMgt;

<tex2html_mydb_mark>#1805#%;SPMlt;$label%;SPMgt;} ;SPMamp; TRUE ;SPMamp;

<tex2html_mydb_mark>#1806#%;SPMlt;$label%;SPMgt;} ;SPMamp; FALSE

<tex2html_mydb_mark>#1807#%;SPMlt;$sufix%;SPMgt;

<tex2html_mydb_mark>#1808#% %%%%%%%%%%%%%%%%TODO: COMENTAR

<tex2html_mydb_mark>#1809#% \section{Esquemas de Traducción con {\tt Parse::Eyapp}}

<tex2html_mydb_mark>#1810#% 

<tex2html_mydb_mark>#1811#% La distribución \tei{Parse::Eyapp} debida al autor de estos apuntes (i.e. Casiano Rodriguez-Leon)

<tex2html_mydb_mark>#1812#% permite la escritura de esquemas de traducción. El módulo no esta aún disponible

<tex2html_mydb_mark>#1813#% en CPAN: estoy a la espera de completar las pruebas y la documentación.

<tex2html_mydb_mark>#1814#% 

<tex2html_mydb_mark>#1815#% El ejemplo simple que sigue ilustra como construir un esquema de traducción. 

<tex2html_mydb_mark>#1816#% El código completo puede encontrarlo en la página

<tex2html_mydb_mark>#1817#% \pageref{apendice:transschemesimple}.

<tex2html_mydb_mark>#1818#% Un ejemplo de ejecución del programa se encuentra en la página 

<tex2html_mydb_mark>#1819#% \ref{apendice:ejecuciondetrans_scheme_simple}.

<tex2html_mydb_mark>#1820#% 

<tex2html_mydb_mark>#1821#% Comencemos por el principio:

<tex2html_mydb_mark>#1822#% \label{codigo:trans_scheme_simple2}

<tex2html_mydb_mark>#1823#% \begin{verbatim}

<tex2html_mydb_mark>#1824#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; head -n79 trans_scheme_simple2.pl | cat -n

<tex2html_mydb_mark>#1825#%  1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#1826#%  2  use strict;

<tex2html_mydb_mark>#1827#%  3  use Data::Dumper;

<tex2html_mydb_mark>#1828#%  4  use Parse::Eyapp;

<tex2html_mydb_mark>#1829#%  5  use IO::Interactive qw(is_interactive);

<tex2html_mydb_mark>#1830#%  6

<tex2html_mydb_mark>#1831#%  7  my $translationscheme = q{

<tex2html_mydb_mark>#1832#%  8  %{

<tex2html_mydb_mark>#1833#%  9  # head code is available at tree construction time

<tex2html_mydb_mark>#1834#% 10  use Data::Dumper;

<tex2html_mydb_mark>#1835#% 11

<tex2html_mydb_mark>#1836#% 12  our %sym; # symbol table

<tex2html_mydb_mark>#1837#% 13  %}

<tex2html_mydb_mark>#1838#% 14

<tex2html_mydb_mark>#1839#% 15  %metatree

<tex2html_mydb_mark>#1840#% 16

<tex2html_mydb_mark>#1841#% 17  %right   '='

<tex2html_mydb_mark>#1842#% 18  %left   '-' '+'

<tex2html_mydb_mark>#1843#% 19  %left   '*' '/'

<tex2html_mydb_mark>#1844#% 20

<tex2html_mydb_mark>#1845#% 21  %%

<tex2html_mydb_mark>#1846#% 22  line:       %name EXP

<tex2html_mydb_mark>#1847#% 23                exp ;SPMlt;+ ';';SPMgt; /* Expressions separated by semicolons */

<tex2html_mydb_mark>#1848#% 24                  { $lhs-;SPMgt;{n} = [ map { $_-;SPMgt;{n}} $_[1]-;SPMgt;Children() ]; }

<tex2html_mydb_mark>#1849#% 25  ;

<tex2html_mydb_mark>#1850#% 26

<tex2html_mydb_mark>#1851#% 27  exp:

<tex2html_mydb_mark>#1852#% 28              %name PLUS

<tex2html_mydb_mark>#1853#% 29                exp.left '+'  exp.right

<tex2html_mydb_mark>#1854#% 30                  { $lhs-;SPMgt;{n} = $left-;SPMgt;{n} + $right-;SPMgt;{n} }

<tex2html_mydb_mark>#1855#% 31          |   %name MINUS

<tex2html_mydb_mark>#1856#% 32                exp.left '-' exp.right

<tex2html_mydb_mark>#1857#% 33                  { $lhs-;SPMgt;{n} = $left-;SPMgt;{n} - $right-;SPMgt;{n} }

<tex2html_mydb_mark>#1858#% 34          |   %name TIMES

<tex2html_mydb_mark>#1859#% 35                exp.left '*' exp.right

<tex2html_mydb_mark>#1860#% 36                  { $lhs-;SPMgt;{n} = $left-;SPMgt;{n} * $right-;SPMgt;{n} }

<tex2html_mydb_mark>#1861#% 37          |   %name DIV

<tex2html_mydb_mark>#1862#% 38                exp.left '/' exp.right

<tex2html_mydb_mark>#1863#% 39                  { $lhs-;SPMgt;{n} = $left-;SPMgt;{n} / $right-;SPMgt;{n} }

<tex2html_mydb_mark>#1864#% 40          |   %name NUM   $NUM

<tex2html_mydb_mark>#1865#% 41                  { $lhs-;SPMgt;{n} = $NUM-;SPMgt;{attr} }

<tex2html_mydb_mark>#1866#% 42          |   '(' $exp ')'  %begin { $exp }

<tex2html_mydb_mark>#1867#% 43          |   %name VAR

<tex2html_mydb_mark>#1868#% 44                $VAR

<tex2html_mydb_mark>#1869#% 45                  { $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} }

<tex2html_mydb_mark>#1870#% 46          |   %name ASSIGN

<tex2html_mydb_mark>#1871#% 47                $VAR '=' $exp

<tex2html_mydb_mark>#1872#% 48                  { $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} = $exp-;SPMgt;{n} }

<tex2html_mydb_mark>#1873#% 49

<tex2html_mydb_mark>#1874#% 50  ;

<tex2html_mydb_mark>#1875#% 51

<tex2html_mydb_mark>#1876#% 52  %%

<tex2html_mydb_mark>#1877#% 53  # tail code is available at tree construction time

<tex2html_mydb_mark>#1878#% 54  sub _Error {

<tex2html_mydb_mark>#1879#% 55    my($token)=$_[0]-;SPMgt;YYCurval;

<tex2html_mydb_mark>#1880#% 56    my($what)= $token ? ;SPMquot;input: '$token';SPMquot; : ;SPMquot;end of input;SPMquot;;

<tex2html_mydb_mark>#1881#% 57

<tex2html_mydb_mark>#1882#% 58    die ;SPMquot;Syntax error near $what.\n;SPMquot;;

<tex2html_mydb_mark>#1883#% 59  }

<tex2html_mydb_mark>#1884#% 60

<tex2html_mydb_mark>#1885#% 61  sub _Lexer {

<tex2html_mydb_mark>#1886#% 62      my($parser)=shift;

<tex2html_mydb_mark>#1887#% 63

<tex2html_mydb_mark>#1888#% 64      for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {

<tex2html_mydb_mark>#1889#% 65          $_ or  return('',undef);

<tex2html_mydb_mark>#1890#% 66

<tex2html_mydb_mark>#1891#% 67          s/^\s*//;

<tex2html_mydb_mark>#1892#% 68          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);

<tex2html_mydb_mark>#1893#% 69          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);

<tex2html_mydb_mark>#1894#% 70          s/^(.)// and return($1,$1);

<tex2html_mydb_mark>#1895#% 71          s/^\s*//;

<tex2html_mydb_mark>#1896#% 72      }

<tex2html_mydb_mark>#1897#% 73  }

<tex2html_mydb_mark>#1898#% 74

<tex2html_mydb_mark>#1899#% 75  sub Run {

<tex2html_mydb_mark>#1900#% 76      my($self)=shift;

<tex2html_mydb_mark>#1901#% 77      return $self-;SPMgt;YYParse( yylex =;SPMgt; \&_Lexer, yyerror =;SPMgt; \&_Error );

<tex2html_mydb_mark>#1902#% 78  }

<tex2html_mydb_mark>#1903#% 79  }; # end translation scheme

<tex2html_mydb_mark>#1904#% \end{verbatim}

<tex2html_mydb_mark>#1905#% 

<tex2html_mydb_mark>#1906#% Las líneas 7-79 no hacen otra cosa que iniciar una cadena conteniendo el esquema de

<tex2html_mydb_mark>#1907#% traducción. También podríamos haberlo escrito en un fichero y compilarlo con 

<tex2html_mydb_mark>#1908#% \tei{eyapp}. 

<tex2html_mydb_mark>#1909#% 

<tex2html_mydb_mark>#1910#% \paragraph{Partes de un programa {\tt eyapp}}

<tex2html_mydb_mark>#1911#% 

<tex2html_mydb_mark>#1912#% Un programa \verb|eyapp| es similar en muchos aspectos a 

<tex2html_mydb_mark>#1913#% un programa \tei{yapp}/\tei{yacc} y se divide en tres partes:

<tex2html_mydb_mark>#1914#% la cabeza, el cuerpo

<tex2html_mydb_mark>#1915#% y la cola. Cada una de las partes va separada de las otras por el

<tex2html_mydb_mark>#1916#% símbolo \verb|%%| en una línea aparte. Así, el \verb|%%| de la línea 21

<tex2html_mydb_mark>#1917#% separa la cabeza del cuerpo. En la cabecera se colocan el

<tex2html_mydb_mark>#1918#% código de inicialización, las declaraciones de terminales, las reglas

<tex2html_mydb_mark>#1919#% de precedencia, etc.  El cuerpo contiene las reglas de la gramática y

<tex2html_mydb_mark>#1920#% las acciones asociadas. Por último, la cola de un program \verb|eyapp|

<tex2html_mydb_mark>#1921#% se separa del cuerpo por otro \verb|%%| en una línea aparte.

<tex2html_mydb_mark>#1922#% La cola contiene las rutinas de soporte al código que aparece en las acciones 

<tex2html_mydb_mark>#1923#% asi como, posiblemente, rutinas para el análisis léxico  (subrutina \verb|_Lexer|

<tex2html_mydb_mark>#1924#% en la línea 58)

<tex2html_mydb_mark>#1925#% y el tratamiento de errores (subrutina \verb|_Error| en la línea 54).

<tex2html_mydb_mark>#1926#% Puede encontrar una descripción de la gramática de \verb|eyapp| 

<tex2html_mydb_mark>#1927#% usando su propia notación en la página

<tex2html_mydb_mark>#1928#% \pageref{apendice:eyappgrammar}.

<tex2html_mydb_mark>#1929#% 

<tex2html_mydb_mark>#1930#% \paragraph{Esquemas de Traducción con {\tt \%metatree}}

<tex2html_mydb_mark>#1931#% Por defecto \verb|Parse::Eyapp| se comporta de manera similar a \verb|yapp|

<tex2html_mydb_mark>#1932#% y \verb|yacc| generando un analizador sintáctico LALR(1) y ejecutando 

<tex2html_mydb_mark>#1933#% las acciones empotradas según una antiderivación a derechas, esto es en un

<tex2html_mydb_mark>#1934#% recorrido del árbol de análisis sintáctico 

<tex2html_mydb_mark>#1935#% de abajo hacia arriba y de izquierda a derecha. 

<tex2html_mydb_mark>#1936#% 

<tex2html_mydb_mark>#1937#% Mediante la directiva \tei{\%metatree} en la línea 15 

<tex2html_mydb_mark>#1938#% le indicamos a \verb|Parse::Eyapp| que debe generar un 

<tex2html_mydb_mark>#1939#% esquema de traducción. En tal caso, al llamar al analizador

<tex2html_mydb_mark>#1940#% el código empotrado no es ejecutado sino que se genera un árbol

<tex2html_mydb_mark>#1941#% de análisis sintáctico con los correspondientes nodos de código

<tex2html_mydb_mark>#1942#% colgando del árbol en las posiciones que les corresponden.

<tex2html_mydb_mark>#1943#% 

<tex2html_mydb_mark>#1944#% \paragraph{Las reglas}

<tex2html_mydb_mark>#1945#% 

<tex2html_mydb_mark>#1946#% Las reglas de producción de la gramática están entre 

<tex2html_mydb_mark>#1947#% las líneas 21 y 52. Cada entrada comienza con el nombre de la variable sintáctica

<tex2html_mydb_mark>#1948#% y va seguida de las partes derechas de sus reglas de producción separadas por barras

<tex2html_mydb_mark>#1949#% verticales. Opcionalmente se le puede dar un nombre a la regla de producción

<tex2html_mydb_mark>#1950#% usando la directiva \tei{\%name}. El efecto que tiene esta directiva 

<tex2html_mydb_mark>#1951#% es bendecir - durante la fase tree construction time - 

<tex2html_mydb_mark>#1952#% el nodo del árbol sintáctico en una clase con nombre el

<tex2html_mydb_mark>#1953#% argumento de \verb|%name| (los nodos del árbol sintáctico son objetos).

<tex2html_mydb_mark>#1954#% El código - entre llaves - puede ocupar cualquier lugar en el lado

<tex2html_mydb_mark>#1955#% derecho. 

<tex2html_mydb_mark>#1956#% 

<tex2html_mydb_mark>#1957#% \paragraph{Nombres de los atributos}

<tex2html_mydb_mark>#1958#% 

<tex2html_mydb_mark>#1959#% En las acciones los atributos de los nodos pueden ser accedidos usando 

<tex2html_mydb_mark>#1960#% el array mágico \verb|@_|. De hecho, los códigos insertados en el árbol

<tex2html_mydb_mark>#1961#% sintáctico son convertidos en subrutinas anónimas. 

<tex2html_mydb_mark>#1962#% Así \verb|$_[0]| es una referencia al nodo 

<tex2html_mydb_mark>#1963#% padre asociado con el lado izquierdo, \verb|$_[1]| el asociado

<tex2html_mydb_mark>#1964#% con el primer símbolo de la parte derecha, etc. {\it Esta \cei{notación posicional}

<tex2html_mydb_mark>#1965#% es confusa e induce a error: si el programador cambia la regla posteriormente insertando

<tex2html_mydb_mark>#1966#% acciones o símbolos en la parte derecha, ¡todas las apariciones de índices en

<tex2html_mydb_mark>#1967#% el código que se refieran a nodos a la derecha del insertado

<tex2html_mydb_mark>#1968#% deben ser modificadas!}. Algo similar ocurre si decide suprimir una acción o un 

<tex2html_mydb_mark>#1969#% símbolo. Por ello \verb|Parse::Eyapp| 

<tex2html_mydb_mark>#1970#% proporciona mediante la \cei{notación punto} la posibilidad de

<tex2html_mydb_mark>#1971#% hacer una copia automática con nombre del atributo: la notación

<tex2html_mydb_mark>#1972#% \verb|exp.left| indica que la variable léxica \verb|$left|

<tex2html_mydb_mark>#1973#% guardará una referencia al nodo que corresponde a esta instanciación de la variable

<tex2html_mydb_mark>#1974#% sintáctica \verb|exp|. Además \verb|Parse::Eyapp| provee la variable

<tex2html_mydb_mark>#1975#% léxica especial \verb|$|\tei{lhs} donde se guarda una referencia al nodo padre.

<tex2html_mydb_mark>#1976#% Así la regla:

<tex2html_mydb_mark>#1977#% 

<tex2html_mydb_mark>#1978#% \begin{verbatim}

<tex2html_mydb_mark>#1979#%                 exp.left '-' exp.right

<tex2html_mydb_mark>#1980#%                   { $lhs-;SPMgt;{n} = $left-;SPMgt;{n} - $right-;SPMgt;{n} }

<tex2html_mydb_mark>#1981#% \end{verbatim}

<tex2html_mydb_mark>#1982#% equivale al siguiente código:

<tex2html_mydb_mark>#1983#% \begin{verbatim}

<tex2html_mydb_mark>#1984#%                  exp '-' exp

<tex2html_mydb_mark>#1985#%                   { 

<tex2html_mydb_mark>#1986#%                     my $lhs = shift; 

<tex2html_mydb_mark>#1987#%                     my ($left, $right) = @_[1, 3];

<tex2html_mydb_mark>#1988#%                     $lhs-;SPMgt;{n} = $left-;SPMgt;{n} - $right-;SPMgt;{n} 

<tex2html_mydb_mark>#1989#%                   }

<tex2html_mydb_mark>#1990#% \end{verbatim}

<tex2html_mydb_mark>#1991#% Si se desea usar el propio nombre de la variable sintáctica como 

<tex2html_mydb_mark>#1992#% nombre del atributo se usa la \cei{notación dolar}. Asi la notación

<tex2html_mydb_mark>#1993#% \verb|$exp| puede considerarse una abreviación a la notación \verb|exp.exp|. 

<tex2html_mydb_mark>#1994#% El código:

<tex2html_mydb_mark>#1995#% \begin{verbatim}

<tex2html_mydb_mark>#1996#%                 $VAR '=' $exp

<tex2html_mydb_mark>#1997#%                   { $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} = $exp-;SPMgt;{n} }

<tex2html_mydb_mark>#1998#% \end{verbatim}

<tex2html_mydb_mark>#1999#% equivale a este otro:

<tex2html_mydb_mark>#2000#% \begin{verbatim}

<tex2html_mydb_mark>#2001#%                   VAR '=' exp

<tex2html_mydb_mark>#2002#%                   { 

<tex2html_mydb_mark>#2003#%                     my $lhs = shift;

<tex2html_mydb_mark>#2004#%                     my ($VAR, $exp) = @_[1, 3];

<tex2html_mydb_mark>#2005#%                     $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} = $exp-;SPMgt;{n} 

<tex2html_mydb_mark>#2006#%                   }

<tex2html_mydb_mark>#2007#% \end{verbatim}

<tex2html_mydb_mark>#2008#% 

<tex2html_mydb_mark>#2009#% \paragraph{Fases de un Esquema de Traducción}

<tex2html_mydb_mark>#2010#% 

<tex2html_mydb_mark>#2011#% La ejecución de un esquema de traducción por \verb|Parse::Eyapp| 

<tex2html_mydb_mark>#2012#% ocurre en tres tiempos. 

<tex2html_mydb_mark>#2013#% 

<tex2html_mydb_mark>#2014#% \paragraph{Class Construction Time}

<tex2html_mydb_mark>#2015#% 

<tex2html_mydb_mark>#2016#% En una primera parte - que denominaremos

<tex2html_mydb_mark>#2017#% \cei{Class Construction Time} - se analiza la gramática y se crea 

<tex2html_mydb_mark>#2018#% la clase que contendrá el analizador sintáctico. 

<tex2html_mydb_mark>#2019#% Esto se hace llamando al método de clase \tei{new\_grammar}

<tex2html_mydb_mark>#2020#% el cual devuelve una cadena conteniendo información

<tex2html_mydb_mark>#2021#% sobre las ambiguedades, conflictos y errores

<tex2html_mydb_mark>#2022#% que pueda tener la gramática:

<tex2html_mydb_mark>#2023#% 

<tex2html_mydb_mark>#2024#% \begin{verbatim}

<tex2html_mydb_mark>#2025#% 84  my $warnings = Parse::Eyapp-;SPMgt;new_grammar(

<tex2html_mydb_mark>#2026#% 85    input=;SPMgt;$translationscheme,

<tex2html_mydb_mark>#2027#% 86    classname=;SPMgt;'main',

<tex2html_mydb_mark>#2028#% 87    firstline =;SPMgt; 6,

<tex2html_mydb_mark>#2029#% 88    outputfile =;SPMgt; 'main.pm');

<tex2html_mydb_mark>#2030#% 89  die ;SPMquot;$warnings\nSolve Ambiguities. See file main.output\n;SPMquot;  if $warnings;

<tex2html_mydb_mark>#2031#% \end{verbatim}

<tex2html_mydb_mark>#2032#% 

<tex2html_mydb_mark>#2033#% El nombre de la clase  o package en el que se crea el analizador

<tex2html_mydb_mark>#2034#% se especifica mediante el argumento \tei{classname}.

<tex2html_mydb_mark>#2035#% 

<tex2html_mydb_mark>#2036#% El argumento \tei{firstline} facilita la emisión de errores 

<tex2html_mydb_mark>#2037#% y warnings indicando la línea en que comienza la cadena que contiene

<tex2html_mydb_mark>#2038#% el esquema de traducción.

<tex2html_mydb_mark>#2039#% 

<tex2html_mydb_mark>#2040#% Si se especifica el argumento \tei{outputfile}\verb| =;SPMgt; filename| los resultados

<tex2html_mydb_mark>#2041#% del análisis se volcarán en los ficheros \verb|filename.pm| y \verb|filename.output|

<tex2html_mydb_mark>#2042#% los cuales contienen respectivamente el código del analizador e información

<tex2html_mydb_mark>#2043#% pormenorizada sobre las tablas usadas por el analizador y los conflictos

<tex2html_mydb_mark>#2044#% y ambiguedades encontradas durante el estudio de la gramática.

<tex2html_mydb_mark>#2045#% 

<tex2html_mydb_mark>#2046#% Una vez creada la clase es posible instanciar objetos del tipo analizador

<tex2html_mydb_mark>#2047#% llamando al constructor \verb|new| de la clase creada:

<tex2html_mydb_mark>#2048#% 

<tex2html_mydb_mark>#2049#% \begin{verbatim}

<tex2html_mydb_mark>#2050#% 90  my $parser = main-;SPMgt;new();

<tex2html_mydb_mark>#2051#% \end{verbatim}

<tex2html_mydb_mark>#2052#% 

<tex2html_mydb_mark>#2053#% \paragraph{Tree Construction Time}

<tex2html_mydb_mark>#2054#% 

<tex2html_mydb_mark>#2055#% En una segunda parte - que denominaremos 

<tex2html_mydb_mark>#2056#% \cei{Tree Construction Time} - se toma la entrada (usando para ello el analizador 

<tex2html_mydb_mark>#2057#% léxico y las rutinas de error proveídas por el programador) 

<tex2html_mydb_mark>#2058#% y se procede a la construcción del árbol. 

<tex2html_mydb_mark>#2059#% \emph{Las acciones

<tex2html_mydb_mark>#2060#% especificadas por el programador en el esquema no son ejecutadas} sino

<tex2html_mydb_mark>#2061#% que se añaden al árbol como referencias a subrutinas (nodos de tipo \verb|CODE|). 

<tex2html_mydb_mark>#2062#% 

<tex2html_mydb_mark>#2063#% El programador

<tex2html_mydb_mark>#2064#% puede influir en la construcción del árbol por medio de diversas directivas.

<tex2html_mydb_mark>#2065#% De estas explicaremos tres:

<tex2html_mydb_mark>#2066#% 

<tex2html_mydb_mark>#2067#% \paragraph{La directiva {\tt \%name class}}

<tex2html_mydb_mark>#2068#% Como se ha dicho, la directiva \verb|%name class| hace que el nodo asociado con la 

<tex2html_mydb_mark>#2069#% instanciación  de la regla de producción se bendiga en la clase dada por la cadena

<tex2html_mydb_mark>#2070#% \verb|class|. 

<tex2html_mydb_mark>#2071#% 

<tex2html_mydb_mark>#2072#% \paragraph{La directiva {\tt \%begin}}

<tex2html_mydb_mark>#2073#% 

<tex2html_mydb_mark>#2074#% La directiva \tei{\%begin} \verb|{ ... code ...}| usada en la línea 42 hace que el

<tex2html_mydb_mark>#2075#% código usado como argumento \verb|{ ... code ...}| se ejecute en {\it Tree Construction Time}.

<tex2html_mydb_mark>#2076#% \begin{verbatim}

<tex2html_mydb_mark>#2077#% 27  exp:

<tex2html_mydb_mark>#2078#% 28              %name PLUS

<tex2html_mydb_mark>#2079#% 29                exp.left '+'  exp.right

<tex2html_mydb_mark>#2080#% 30                  { $lhs-;SPMgt;{n} = $left-;SPMgt;{n} + $right-;SPMgt;{n} }

<tex2html_mydb_mark>#2081#% 31          |   %name MINUS

<tex2html_mydb_mark>#2082#% ..          .   ............................................

<tex2html_mydb_mark>#2083#% 42          |   '(' $exp ')'  %begin { $exp }

<tex2html_mydb_mark>#2084#% \end{verbatim}

<tex2html_mydb_mark>#2085#% 

<tex2html_mydb_mark>#2086#% En el ejemplo la directiva \verb|%begin { $exp }| hace que nos saltemos

<tex2html_mydb_mark>#2087#% el nodo asociado con el paréntesis enlazando directamente la raíz del árbol

<tex2html_mydb_mark>#2088#% referenciado por \verb|$exp| con el padre de la regla actual.

<tex2html_mydb_mark>#2089#% Si no se hubiera insertado esta directiva el árbol construido para

<tex2html_mydb_mark>#2090#% la entrada \verb|2*(3+4)| sería similar a este:

<tex2html_mydb_mark>#2091#% \begin{verbatim}

<tex2html_mydb_mark>#2092#% TIMES

<tex2html_mydb_mark>#2093#%   |-- NUM -- TERMINAL( attr =;SPMgt; 2 )

<tex2html_mydb_mark>#2094#%   |-- '*'

<tex2html_mydb_mark>#2095#%   `-- E_7

<tex2html_mydb_mark>#2096#%        |-- '('

<tex2html_mydb_mark>#2097#%        |-- PLUS

<tex2html_mydb_mark>#2098#%        |    |-- NUM -- TERMINAL( attr =;SPMgt; 3 )

<tex2html_mydb_mark>#2099#%        |    |-- '+'

<tex2html_mydb_mark>#2100#%        |    `-- NUM -- TERMINAL( attr =;SPMgt; 4 )

<tex2html_mydb_mark>#2101#%        `--  ')'

<tex2html_mydb_mark>#2102#% 

<tex2html_mydb_mark>#2103#% \end{verbatim}

<tex2html_mydb_mark>#2104#% El efecto de la directiva \verb|%begin { $exp }| es retornar la referencia

<tex2html_mydb_mark>#2105#% a la expresión parentizada dando lugar al siguiente árbol:

<tex2html_mydb_mark>#2106#% \begin{verbatim}

<tex2html_mydb_mark>#2107#% TIMES

<tex2html_mydb_mark>#2108#%   |-- NUM -- TERMINAL( attr =;SPMgt; 2 )

<tex2html_mydb_mark>#2109#%   |-- '*'

<tex2html_mydb_mark>#2110#%   `-- PLUS

<tex2html_mydb_mark>#2111#%        |-- NUM -- TERMINAL( attr =;SPMgt; 3 )

<tex2html_mydb_mark>#2112#%        |-- '+'

<tex2html_mydb_mark>#2113#%        `-- NUM -- TERMINAL( attr =;SPMgt; 4 )

<tex2html_mydb_mark>#2114#% \end{verbatim}

<tex2html_mydb_mark>#2115#% 

<tex2html_mydb_mark>#2116#% En general, 

<tex2html_mydb_mark>#2117#% las acciones asociadas con directivas \verb|%begin| 

<tex2html_mydb_mark>#2118#% modifican la construcción del árbol sintáctico

<tex2html_mydb_mark>#2119#% concreto para dar lugar a un árbol de análisis sintáctico abstracto adecuado

<tex2html_mydb_mark>#2120#% a los requerimientos de las fases posteriores. 

<tex2html_mydb_mark>#2121#% 

<tex2html_mydb_mark>#2122#% Las acciones en Tree Construction Time insertadas mediante \verb|%begin|

<tex2html_mydb_mark>#2123#% se ejecutan colaborativamente con las acciones de construcción del árbol 

<tex2html_mydb_mark>#2124#% en el orden 

<tex2html_mydb_mark>#2125#% usual de los analizadores LR: según una antiderivación a derechas, 

<tex2html_mydb_mark>#2126#% esto es, en un

<tex2html_mydb_mark>#2127#% recorrido del árbol de análisis sintáctico 

<tex2html_mydb_mark>#2128#% de abajo hacia arriba (de las hojas hacia la raíz) y de izquierda a derecha. 

<tex2html_mydb_mark>#2129#% 

<tex2html_mydb_mark>#2130#% Las acciones en Tree Construction Time

<tex2html_mydb_mark>#2131#% reciben como argumentos en \verb|$_[1]|, \verb|$_[2]|, etc. las referencias a los

<tex2html_mydb_mark>#2132#% nodos del árbol asociadas con los elementos de la parte derecha. 

<tex2html_mydb_mark>#2133#% {\it En Tree Construction Time el argumento \verb|$_[0]|

<tex2html_mydb_mark>#2134#% es una referencia al objeto analizador sintáctico}.

<tex2html_mydb_mark>#2135#% 

<tex2html_mydb_mark>#2136#% La segunda fase en nuestro ejemplo ocurre en las líneas 90-92

<tex2html_mydb_mark>#2137#% en las que leemos la entrada y llamamos al método 

<tex2html_mydb_mark>#2138#% \verb|Run| el cual construye el árbol:

<tex2html_mydb_mark>#2139#% 

<tex2html_mydb_mark>#2140#% \begin{verbatim}

<tex2html_mydb_mark>#2141#% 90  print ;SPMquot;Write a sequence of arithmetic expressions: ;SPMquot; if is_interactive();

<tex2html_mydb_mark>#2142#% 91  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;;SPMgt;;

<tex2html_mydb_mark>#2143#% 92  my $t = $parser-;SPMgt;Run() or die ;SPMquot;Syntax Error analyzing input;SPMquot;;

<tex2html_mydb_mark>#2144#% \end{verbatim}

<tex2html_mydb_mark>#2145#% 

<tex2html_mydb_mark>#2146#% El método \verb|Run| se limita a llamar al método \verb|YYParse| que es quien 

<tex2html_mydb_mark>#2147#% realiza el análisis:

<tex2html_mydb_mark>#2148#% 

<tex2html_mydb_mark>#2149#% \begin{verbatim}

<tex2html_mydb_mark>#2150#% 74  sub Run {

<tex2html_mydb_mark>#2151#% 75      my($self)=shift;

<tex2html_mydb_mark>#2152#% 76      return $self-;SPMgt;YYParse( yylex =;SPMgt; \&_Lexer, yyerror =;SPMgt; \&_Error );

<tex2html_mydb_mark>#2153#% 77  }

<tex2html_mydb_mark>#2154#% \end{verbatim}

<tex2html_mydb_mark>#2155#% 

<tex2html_mydb_mark>#2156#% Cuando el método \verb|YYParse| proveido por \verb|Parse::Eyapp| es llamado

<tex2html_mydb_mark>#2157#% es necesario que hayan sido especificadas las correspondientes 

<tex2html_mydb_mark>#2158#% referencias a las rutinas de análisis léxico

<tex2html_mydb_mark>#2159#% (argumento con clave \verb|yylex|) 

<tex2html_mydb_mark>#2160#% y de tratamiento de errores (argumento con clave \verb|yyerror|).

<tex2html_mydb_mark>#2161#% 

<tex2html_mydb_mark>#2162#% Despues de esta fase tenemos el árbol de análisis extendido con los

<tex2html_mydb_mark>#2163#% nodos de tipo \verb|CODE|.

<tex2html_mydb_mark>#2164#% 

<tex2html_mydb_mark>#2165#% \paragraph{Execution Time} 

<tex2html_mydb_mark>#2166#% 

<tex2html_mydb_mark>#2167#% En una tercera parte - que denominaremos \cei{Execution Time} - el árbol es recorrido

<tex2html_mydb_mark>#2168#% en orden primero-profundo y los nodos de la clase \verb|CODE| son ejecutados. El

<tex2html_mydb_mark>#2169#% árbol será modificado y decorado como consecuencia de las acciones

<tex2html_mydb_mark>#2170#% y podremos examinar los resultados:

<tex2html_mydb_mark>#2171#% \begin{verbatim}

<tex2html_mydb_mark>#2172#% 93  $t-;SPMgt;translation_scheme;

<tex2html_mydb_mark>#2173#% 94  my $treestring = Dumper($t);

<tex2html_mydb_mark>#2174#% 95  our %sym;

<tex2html_mydb_mark>#2175#% 96  my $symboltable = Dumper(\%sym);

<tex2html_mydb_mark>#2176#% 97  print ;SPMlt;;SPMlt;;SPMquot;EOR;SPMquot;;

<tex2html_mydb_mark>#2177#% 98  ***********Tree*************

<tex2html_mydb_mark>#2178#% 99  $treestring

<tex2html_mydb_mark>#2179#% 100  ******Symbol table**********

<tex2html_mydb_mark>#2180#% 101  $symboltable

<tex2html_mydb_mark>#2181#% 102  ************Result**********

<tex2html_mydb_mark>#2182#% 103  $t-;SPMgt;{n}

<tex2html_mydb_mark>#2183#% 104

<tex2html_mydb_mark>#2184#% 105  EOR

<tex2html_mydb_mark>#2185#% \end{verbatim}

<tex2html_mydb_mark>#2186#% 

<tex2html_mydb_mark>#2187#% El método \verb|translation_scheme| tiene una estructura simple

<tex2html_mydb_mark>#2188#% y tiene un código similar a este:

<tex2html_mydb_mark>#2189#% 

<tex2html_mydb_mark>#2190#% \begin{verbatim}

<tex2html_mydb_mark>#2191#% sub translation_scheme {

<tex2html_mydb_mark>#2192#%   my $self = shift; # root of the subtree

<tex2html_mydb_mark>#2193#%   my @children = $self-;SPMgt;children();

<tex2html_mydb_mark>#2194#%   for (@children) {

<tex2html_mydb_mark>#2195#%     if (ref($_) eq 'CODE') {

<tex2html_mydb_mark>#2196#%       $_-;SPMgt;($self, @children);

<tex2html_mydb_mark>#2197#%     }

<tex2html_mydb_mark>#2198#%     elsif (defined($_)) {

<tex2html_mydb_mark>#2199#%       translation_scheme($_);

<tex2html_mydb_mark>#2200#%     }

<tex2html_mydb_mark>#2201#%   }

<tex2html_mydb_mark>#2202#% }

<tex2html_mydb_mark>#2203#% \end{verbatim}

<tex2html_mydb_mark>#2204#% Como se ve en el código de \verb|translation_scheme| la subrutina

<tex2html_mydb_mark>#2205#% asociada se le pasan como argumentos referencias al nodo y a los hijos del nodo.

<tex2html_mydb_mark>#2206#% 

<tex2html_mydb_mark>#2207#% \paragraph{Los Terminales}

<tex2html_mydb_mark>#2208#% Durante la fase de construcción del árbol sintáctico

<tex2html_mydb_mark>#2209#% los nodos que corresponden a terminales o tokens de la gramática 

<tex2html_mydb_mark>#2210#% son -por defecto - bendecidos en la clase \verb|;SPMquot;${PREFIX}|\tei{TERMINAL}\verb|;SPMquot;|.

<tex2html_mydb_mark>#2211#% Si el programador no ha indicado lo contrario en la llamada al analizador,

<tex2html_mydb_mark>#2212#% \verb|$PREFIX| es la cadena vacía. 

<tex2html_mydb_mark>#2213#% (Véase el párrafo en la página \ref{paragraph:prefix} sobre el argumento \verb|yyprefix|

<tex2html_mydb_mark>#2214#% del método constructor del analizador).

<tex2html_mydb_mark>#2215#% 

<tex2html_mydb_mark>#2216#% Los nodos de la clase \verb|TERMINAL| poseen 

<tex2html_mydb_mark>#2217#% al menos dos atributos \verb'token' y \verb|attr|. El atributo 

<tex2html_mydb_mark>#2218#% \verb'token' indica que clase de terminal es (\verb|NUM|, \verb|IDENTIFIER|, etc.).

<tex2html_mydb_mark>#2219#% El atributo \verb|attr| nos da el valor semántico del terminal tal y como

<tex2html_mydb_mark>#2220#% fué recibido del analizador léxico.

<tex2html_mydb_mark>#2221#% 

<tex2html_mydb_mark>#2222#% \paragraph{Listas y Opcionales}

<tex2html_mydb_mark>#2223#% El fragmento del esquema de traducción entre las líneas 26 y 30:

<tex2html_mydb_mark>#2224#% 

<tex2html_mydb_mark>#2225#% \begin{verbatim}

<tex2html_mydb_mark>#2226#% 26  line: %name PROG

<tex2html_mydb_mark>#2227#% 27         exp ;SPMlt;%name EXP + ';';SPMgt;

<tex2html_mydb_mark>#2228#% 28           { @{$lhs-;SPMgt;{t}} = map { $_-;SPMgt;{t}} ($lhs-;SPMgt;child(0)-;SPMgt;Children()); }

<tex2html_mydb_mark>#2229#% 29

<tex2html_mydb_mark>#2230#% 30  ;

<tex2html_mydb_mark>#2231#% \end{verbatim}

<tex2html_mydb_mark>#2232#% 

<tex2html_mydb_mark>#2233#% expresa que el lenguaje generado por el no terminal \verb|line| esta formado por

<tex2html_mydb_mark>#2234#% secuencias no vacías de frases generadas a partir de \verb|exp| separadas por

<tex2html_mydb_mark>#2235#% puntos y comas. En concreto, el analizador generado por \verb|eyapp| transforma

<tex2html_mydb_mark>#2236#% la regla \verb|line: exp ;SPMlt;%name EXP + ';';SPMgt;| en:

<tex2html_mydb_mark>#2237#% \begin{verbatim}

<tex2html_mydb_mark>#2238#% line:       %name EXP

<tex2html_mydb_mark>#2239#%               PLUS-1

<tex2html_mydb_mark>#2240#% ;

<tex2html_mydb_mark>#2241#% PLUS-1:     %name _PLUS_LIST

<tex2html_mydb_mark>#2242#%               PLUS-1 ';'  exp

<tex2html_mydb_mark>#2243#%         |     exp      

<tex2html_mydb_mark>#2244#% ;

<tex2html_mydb_mark>#2245#% \end{verbatim}

<tex2html_mydb_mark>#2246#% 

<tex2html_mydb_mark>#2247#% La expresión \verb|exp ;SPMlt;+ ';';SPMgt;| es tratada como un único elemento de la parte 

<tex2html_mydb_mark>#2248#% derecha y su atributo es un nodo de la clase \tei{\_PLUS\_LIST} cuyos

<tex2html_mydb_mark>#2249#% hijos son los elementos de la lista. Por ejemplo, para la entrada

<tex2html_mydb_mark>#2250#% \verb|a=2; b = 2*a| el analizador construye un árbol similar a este:

<tex2html_mydb_mark>#2251#% \begin{verbatim}

<tex2html_mydb_mark>#2252#% bless( {

<tex2html_mydb_mark>#2253#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#2254#%     bless( {              # _PLUS_LIST

<tex2html_mydb_mark>#2255#%     | 'children' =;SPMgt; [

<tex2html_mydb_mark>#2256#%     |   bless( {          # ASSIGN a = 2

<tex2html_mydb_mark>#2257#%     |   | 'children' =;SPMgt; [

<tex2html_mydb_mark>#2258#%     |   |   bless( { 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2259#%     |   |   bless( { 'attr' =;SPMgt; '=', 'token' =;SPMgt; '=' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2260#%     |   |   bless( {      # NUM 2

<tex2html_mydb_mark>#2261#%     |   |     'children' =;SPMgt; [

<tex2html_mydb_mark>#2262#%     |   |       bless( { 'attr' =;SPMgt; '2', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2263#%     |   |       sub { my $lhs = $_[0]; my $NUM = $_[1];  $lhs-;SPMgt;{n} = $NUM-;SPMgt;{attr}  }

<tex2html_mydb_mark>#2264#%     |   |     ]

<tex2html_mydb_mark>#2265#%     |   |   }, 'NUM' ),

<tex2html_mydb_mark>#2266#%     |   |   sub { my ($lhs, $exp, $VAR) = ($_[0], $_[3], $_[1]);  

<tex2html_mydb_mark>#2267#%     |   |         $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} = $exp-;SPMgt;{n}  }

<tex2html_mydb_mark>#2268#%     |   | ]

<tex2html_mydb_mark>#2269#%     |   }, 'ASSIGN' ),

<tex2html_mydb_mark>#2270#%     |   bless( {         # ASSIGN b = 2*a

<tex2html_mydb_mark>#2271#%     |   | 'children' =;SPMgt; [

<tex2html_mydb_mark>#2272#%     |   |   bless( { 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2273#%     |   |   bless( { 'attr' =;SPMgt; '=', 'token' =;SPMgt; '=' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2274#%     |   |   bless( {     # TIMES 2*a

<tex2html_mydb_mark>#2275#%     |   |     'children' =;SPMgt; [

<tex2html_mydb_mark>#2276#%     |   |       bless( { .... }, 'NUM' ),

<tex2html_mydb_mark>#2277#%     |   |       bless( { 'attr' =;SPMgt; '*', 'token' =;SPMgt; '*' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2278#%     |   |       bless( { .... }, 'VAR' ),

<tex2html_mydb_mark>#2279#%     |   |       sub { ... }

<tex2html_mydb_mark>#2280#%     |   |     ]

<tex2html_mydb_mark>#2281#%     |   |   }, 'TIMES' ),

<tex2html_mydb_mark>#2282#%     |   |   sub { ... }

<tex2html_mydb_mark>#2283#%     |   | ]

<tex2html_mydb_mark>#2284#%     |   }, 'ASSIGN' )

<tex2html_mydb_mark>#2285#%     | ]

<tex2html_mydb_mark>#2286#%     }, '_PLUS_LIST' ),

<tex2html_mydb_mark>#2287#%     sub { ... }

<tex2html_mydb_mark>#2288#%   ]

<tex2html_mydb_mark>#2289#% }, 'EXP' )

<tex2html_mydb_mark>#2290#% \end{verbatim}

<tex2html_mydb_mark>#2291#% 

<tex2html_mydb_mark>#2292#% \emph{Observe que, por defecto, los nodos punto y coma ({\tt ;}) son eliminados del nodo

<tex2html_mydb_mark>#2293#% lista de hijos del nodo} \verb|_PLUS_LIST|. Por defecto, en los

<tex2html_mydb_mark>#2294#% nodos creados por \verb|Parse::Eyapp| desde listas 

<tex2html_mydb_mark>#2295#% declaradas mediante operadores de brackets (por ejemplo \verb|St ;SPMlt;+ ';';SPMgt;|

<tex2html_mydb_mark>#2296#% o \verb|ID ;SPMlt;* ',';SPMgt;|) se 

<tex2html_mydb_mark>#2297#% elimina el separador si este fué definido mediante una cadena (uso de apostrofes).

<tex2html_mydb_mark>#2298#% 

<tex2html_mydb_mark>#2299#% Diremos que un terminal es un \cei{terminal sintáctico} o

<tex2html_mydb_mark>#2300#% \cei{syntax token} si fue definido en el programa \verb|eyapp|

<tex2html_mydb_mark>#2301#% mediante una cadena delimitada por

<tex2html_mydb_mark>#2302#% apóstrofes.

<tex2html_mydb_mark>#2303#% 

<tex2html_mydb_mark>#2304#% Si queremos cambiar el estatus de un syntax token, por ejemplo

<tex2html_mydb_mark>#2305#% si queremos 

<tex2html_mydb_mark>#2306#% que el separador \verb|';'| del ejemplo forme parte de la lista deberemos añadir a la cabecera

<tex2html_mydb_mark>#2307#% la declaración \verb|%semantic token ';'|. 

<tex2html_mydb_mark>#2308#% 

<tex2html_mydb_mark>#2309#% Si creamos una nueva versión

<tex2html_mydb_mark>#2310#% de nuestro programa \verb|trans_scheme_simple3.pl| añadiendo esta declaración:

<tex2html_mydb_mark>#2311#% 

<tex2html_mydb_mark>#2312#% \begin{verbatim}

<tex2html_mydb_mark>#2313#% %semantic token ';'

<tex2html_mydb_mark>#2314#% %right   '='

<tex2html_mydb_mark>#2315#% ....

<tex2html_mydb_mark>#2316#% \end{verbatim}

<tex2html_mydb_mark>#2317#% Las listas contendran los puntos y comas. 

<tex2html_mydb_mark>#2318#% En tal caso, la línea 24 dará lugar a un 

<tex2html_mydb_mark>#2319#% error\footnote{

<tex2html_mydb_mark>#2320#% El código de la línea 24

<tex2html_mydb_mark>#2321#% 

<tex2html_mydb_mark>#2322#% 

<tex2html_mydb_mark>#2323#% 24\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \$lhs-;SPMgt;\{n\}\ =\ [\ map\ \{\ \$\_-;SPMgt;\{n\}\}\ \$\_[1]-;SPMgt;Children()\ ];\ \}

<tex2html_mydb_mark>#2324#% \end{alltt}

<tex2html_mydb_mark>#2325#% 

<tex2html_mydb_mark>#2326#% funciona como sigue:

<tex2html_mydb_mark>#2327#% obtiene la lista de hijos verdaderos (aquellos que no son

<tex2html_mydb_mark>#2328#% referencias a subrutinas) mediante el método {\tt Children}.

<tex2html_mydb_mark>#2329#% La aplicación posterior de {\tt map} crea una lista con los atributos {\tt n}

<tex2html_mydb_mark>#2330#% de esos nodos. Por último la inclusión entre corchetes 

<tex2html_mydb_mark>#2331#% crea una lista anónima con dichos números. La referencia

<tex2html_mydb_mark>#2332#% resultante es asignada al atributo {\tt n} del lado

<tex2html_mydb_mark>#2333#% izquierdo

<tex2html_mydb_mark>#2334#% }

<tex2html_mydb_mark>#2335#% ya que los nodos 

<tex2html_mydb_mark>#2336#% punto y coma carecen del atributo \verb|n|:

<tex2html_mydb_mark>#2337#% \begin{verbatim}

<tex2html_mydb_mark>#2338#% 24                  { $lhs-;SPMgt;{n} = [ map { $_-;SPMgt;{n}} $_[1]-;SPMgt;Children() ]; }

<tex2html_mydb_mark>#2339#% \end{verbatim}

<tex2html_mydb_mark>#2340#% 

<tex2html_mydb_mark>#2341#% En efecto:

<tex2html_mydb_mark>#2342#% 

<tex2html_mydb_mark>#2343#% \begin{verbatim}

<tex2html_mydb_mark>#2344#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; trans_scheme_simple3.pl ;SPMgt; salida

<tex2html_mydb_mark>#2345#% a=2*3; b = a+1; c = a-b

<tex2html_mydb_mark>#2346#% Use of uninitialized value in join or string at trans_scheme_simple3.pl line 99, ;SPMlt;;SPMgt; line 1.

<tex2html_mydb_mark>#2347#% Use of uninitialized value in join or string at trans_scheme_simple3.pl line 99, ;SPMlt;;SPMgt; line 1.

<tex2html_mydb_mark>#2348#% \end{verbatim}

<tex2html_mydb_mark>#2349#% Al usar la declaración \tei{\%semantic token} la nueva estructura del árbol es:

<tex2html_mydb_mark>#2350#% \begin{verbatim}

<tex2html_mydb_mark>#2351#% less( {

<tex2html_mydb_mark>#2352#%   'n' =;SPMgt; [ 6, undef, 7, undef, -1 ],

<tex2html_mydb_mark>#2353#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#2354#%     bless( {

<tex2html_mydb_mark>#2355#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#2356#%         bless( { 'n' =;SPMgt; 6, ................  ] }, 'ASSIGN' ),

<tex2html_mydb_mark>#2357#%         bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; ';', 'token' =;SPMgt; ';' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2358#%         bless( { 'n' =;SPMgt; 7, ................  }, 'ASSIGN' ),

<tex2html_mydb_mark>#2359#%         bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; ';', 'token' =;SPMgt; ';' }, 'TERMINAL' ),

<tex2html_mydb_mark>#2360#%         bless( { 'n' =;SPMgt; -1, ................  }, 'ASSIGN' )

<tex2html_mydb_mark>#2361#%       ]

<tex2html_mydb_mark>#2362#%     }, '_PLUS_LIST' ),

<tex2html_mydb_mark>#2363#%     sub { ;SPMquot;DUMMY;SPMquot; }

<tex2html_mydb_mark>#2364#%   ]

<tex2html_mydb_mark>#2365#% }, 'EXP' )

<tex2html_mydb_mark>#2366#% \end{verbatim}

<tex2html_mydb_mark>#2367#% \verb|Parse::Eyapp| extiende \tei{Parse::Yapp} con listas vacías y no vacías

<tex2html_mydb_mark>#2368#% usando los operadores \verb|*|, \verb|+|:

<tex2html_mydb_mark>#2369#% 

<tex2html_mydb_mark>#2370#% \noindent La regla:

<tex2html_mydb_mark>#2371#% \begin{verbatim}

<tex2html_mydb_mark>#2372#%                           A : B C * 'd' 

<tex2html_mydb_mark>#2373#% \end{verbatim}

<tex2html_mydb_mark>#2374#% \noindent es equivalente a:

<tex2html_mydb_mark>#2375#% 

<tex2html_mydb_mark>#2376#% \begin{verbatim}

<tex2html_mydb_mark>#2377#%                           A : B L 'd' 

<tex2html_mydb_mark>#2378#%                           L : /* vacío */

<tex2html_mydb_mark>#2379#%                             | P

<tex2html_mydb_mark>#2380#%                           P : C P

<tex2html_mydb_mark>#2381#%                             | C

<tex2html_mydb_mark>#2382#% \end{verbatim}

<tex2html_mydb_mark>#2383#% 

<tex2html_mydb_mark>#2384#% \noindent Es posible especificar la presencia de símbolos

<tex2html_mydb_mark>#2385#% opcionales usando \verb|?|. 

<tex2html_mydb_mark>#2386#% 

<tex2html_mydb_mark>#2387#% Observe que el operador de concatenación tiene menor prioridad que 

<tex2html_mydb_mark>#2388#% los operadores de listas, esto es la expresión \verb|AB*| es interpretada

<tex2html_mydb_mark>#2389#% como \verb|A(B*)|.

<tex2html_mydb_mark>#2390#% 

<tex2html_mydb_mark>#2391#% Una secuencia de 

<tex2html_mydb_mark>#2392#% símbolos en la parte derecha de una regla de producción

<tex2html_mydb_mark>#2393#% puede ser agrupada mediante el uso de paréntesis.

<tex2html_mydb_mark>#2394#% Al agrupar una secuencia se crea una variable sintáctica intermedia

<tex2html_mydb_mark>#2395#% que produce dicha secuencia. Por ejemplo, la regla:

<tex2html_mydb_mark>#2396#% 

<tex2html_mydb_mark>#2397#% \begin{verbatim}

<tex2html_mydb_mark>#2398#%                     A : B (C { dosomething(@_) })? D 

<tex2html_mydb_mark>#2399#% \end{verbatim}

<tex2html_mydb_mark>#2400#% 

<tex2html_mydb_mark>#2401#% \noindent es equivalente a:

<tex2html_mydb_mark>#2402#% \begin{verbatim}

<tex2html_mydb_mark>#2403#%                     A  : B T1 D 

<tex2html_mydb_mark>#2404#%                     T1 :  /* vacío */

<tex2html_mydb_mark>#2405#%                        | T2

<tex2html_mydb_mark>#2406#%                     T2 : C { dosomething(@_) }

<tex2html_mydb_mark>#2407#% \end{verbatim}

<tex2html_mydb_mark>#2408#% 

<tex2html_mydb_mark>#2409#% \paragraph{Ambiguedades}

<tex2html_mydb_mark>#2410#% 

<tex2html_mydb_mark>#2411#% Hay numerosas ambiguedades en la gramática asociada con el

<tex2html_mydb_mark>#2412#% esquema de traducción presentado en la página 

<tex2html_mydb_mark>#2413#% \pageref{codigo:trans_scheme_simple2}.

<tex2html_mydb_mark>#2414#% Las ambiguedades se resuelven exactamente igual

<tex2html_mydb_mark>#2415#% que en \verb|yacc| usando directivas en la \cei{cabecera} o

<tex2html_mydb_mark>#2416#% primera parte que indiquen como resolverlas. 

<tex2html_mydb_mark>#2417#% 

<tex2html_mydb_mark>#2418#% Entre las ambiguedades presentes en la gramática del ejemplo

<tex2html_mydb_mark>#2419#% estan las siguientes:

<tex2html_mydb_mark>#2420#% 

<tex2html_mydb_mark>#2421#% \begin{itemize}

<tex2html_mydb_mark>#2422#% \item

<tex2html_mydb_mark>#2423#% ¿Como debo interpretar la expresión \verb|e - e - e|?

<tex2html_mydb_mark>#2424#% ¿Como \verb|(e - e) - e|? ¿o bien \verb|e - (e - e)|?

<tex2html_mydb_mark>#2425#% La respuesta la da la asignación de asociatividad a los operadores

<tex2html_mydb_mark>#2426#% que hicimos en la cabecera.

<tex2html_mydb_mark>#2427#% Al declarar como asociativo a izquierdas al terminal \verb|-| 

<tex2html_mydb_mark>#2428#% hemos resuelto este tipo de ambiguedad. Lo que estamos haciendo es

<tex2html_mydb_mark>#2429#% indicarle al analizador que a la hora de elegir entre 

<tex2html_mydb_mark>#2430#% los árboles abstractos elija siempre el árbol que se hunde a izquierdas.

<tex2html_mydb_mark>#2431#% \item

<tex2html_mydb_mark>#2432#% ¿Como debo interpretar la expresión \verb|e - e * e|?

<tex2html_mydb_mark>#2433#% ¿Como \verb|(e - e) * e|? ¿o bien \verb|e - (e * e)|?

<tex2html_mydb_mark>#2434#% 

<tex2html_mydb_mark>#2435#% En \verb|eyapp| los terminales declarados mediante directivas

<tex2html_mydb_mark>#2436#% \verb|%left|, \verb|%right| y \verb|%nonassoc|

<tex2html_mydb_mark>#2437#% tienen asociada \underline{una prioridad}. \emph{Esa prioridad es 

<tex2html_mydb_mark>#2438#% mayor cuanto mas abajo en el texto está la línea 

<tex2html_mydb_mark>#2439#% de su declaración}. 

<tex2html_mydb_mark>#2440#% Un terminal puede ser también declarado con la directiva \verb|%token| en

<tex2html_mydb_mark>#2441#% cuyo caso no se le asocia prioridad.

<tex2html_mydb_mark>#2442#% 

<tex2html_mydb_mark>#2443#% Al declarar que el operador \verb|*| tiene mayor prioridad que el operador \verb|-| 

<tex2html_mydb_mark>#2444#% estamos resolviendo esta otra fuente de ambiguedad. Esto es así pues

<tex2html_mydb_mark>#2445#% el operador \verb|*| fué declarado después que el operador \verb|-|.

<tex2html_mydb_mark>#2446#% Le indicamos así al analizador que construya el árbol asociado con

<tex2html_mydb_mark>#2447#% la interpretación \verb|e - (e * e)|.

<tex2html_mydb_mark>#2448#% 

<tex2html_mydb_mark>#2449#% 

<tex2html_mydb_mark>#2450#% \emph{En {\tt eyapp} La prioridad asociada con una regla de producción

<tex2html_mydb_mark>#2451#% es la del \underline{último terminal} que aparece en dicha regla}.

<tex2html_mydb_mark>#2452#% 

<tex2html_mydb_mark>#2453#% Una regla de producción puede ir seguida de una directiva

<tex2html_mydb_mark>#2454#% \tei{\%prec} la cual le da una prioridad explícita.  

<tex2html_mydb_mark>#2455#% Esto puede ser de gran ayuda en ciertos casos de 

<tex2html_mydb_mark>#2456#% ambiguedad.

<tex2html_mydb_mark>#2457#% Por ejemplo, si quisieramos introducir el uso el menos unario en

<tex2html_mydb_mark>#2458#% la gramática surgiría una ambiguedad:

<tex2html_mydb_mark>#2459#% 

<tex2html_mydb_mark>#2460#% \begin{verbatim}

<tex2html_mydb_mark>#2461#%   39         |   %name UMINUS

<tex2html_mydb_mark>#2462#%   40               '-' $exp %prec NEG

<tex2html_mydb_mark>#2463#%   41                 { $lhs-;SPMgt;{n} = -$exp-;SPMgt;{n} }

<tex2html_mydb_mark>#2464#% \end{verbatim}

<tex2html_mydb_mark>#2465#% ¿Cual es la ambiguedad que surge con esta regla? 

<tex2html_mydb_mark>#2466#% Una de las ambiguedades de esta regla 

<tex2html_mydb_mark>#2467#% esta relacionada con el doble significado

<tex2html_mydb_mark>#2468#% del menos como operador unario y binario: hay frases

<tex2html_mydb_mark>#2469#% como \verb|-e-e| que tiene dos posibles interpretaciones:

<tex2html_mydb_mark>#2470#% Podemos verla como \verb|(-e)-e| o bien como \verb|-(e-e)|.

<tex2html_mydb_mark>#2471#% Hay dos árboles posibles. El analizador, cuando este analizando

<tex2html_mydb_mark>#2472#% la entrada \verb|-e-e| y vea el

<tex2html_mydb_mark>#2473#% segundo \verb|-| deberá escoger uno de los dos árboles. 

<tex2html_mydb_mark>#2474#% ¿Cuál?. 

<tex2html_mydb_mark>#2475#% 

<tex2html_mydb_mark>#2476#% El conflicto puede verse como una ``lucha'' entre

<tex2html_mydb_mark>#2477#% la regla \verb|exp: '-' exp| la cual interpreta la frase como

<tex2html_mydb_mark>#2478#% \verb|(-e)-e| y la segunda aparición del terminal \verb|-| 

<tex2html_mydb_mark>#2479#% el cuál ``quiere entrar'' para que gane la regla \verb|exp: exp '-' exp|

<tex2html_mydb_mark>#2480#% y dar lugar a la interpretación \verb|-(e-e)|.

<tex2html_mydb_mark>#2481#% 

<tex2html_mydb_mark>#2482#% En este caso, si atendemos a la norma enunciada de que

<tex2html_mydb_mark>#2483#% la prioridad asociada con una regla de producción

<tex2html_mydb_mark>#2484#% es la del \underline{último terminal} que aparece en dicha regla,

<tex2html_mydb_mark>#2485#% las dos reglas 

<tex2html_mydb_mark>#2486#% $E \rightarrow - E$ y $E \rightarrow E - E$ tienen

<tex2html_mydb_mark>#2487#% la prioridad del terminal \verb|-|.

<tex2html_mydb_mark>#2488#% 

<tex2html_mydb_mark>#2489#% Lo que hace la declaración \verb|%prec NEG| de la línea

<tex2html_mydb_mark>#2490#% 40 es modificar la prioridad de la regla $E \rightarrow - E$

<tex2html_mydb_mark>#2491#% para que tenga la 

<tex2html_mydb_mark>#2492#% del terminal \verb|NEG|. El terminal \verb|NEG| lo declaramos

<tex2html_mydb_mark>#2493#% en la cabecera del programa, dándole la prioridad adecuada:

<tex2html_mydb_mark>#2494#% \begin{verbatim}

<tex2html_mydb_mark>#2495#% 17  %right   '='

<tex2html_mydb_mark>#2496#% 18  %left   '-' '+'

<tex2html_mydb_mark>#2497#% 19  %left   '*' '/'

<tex2html_mydb_mark>#2498#% 20  $right NEG

<tex2html_mydb_mark>#2499#% 21  %%

<tex2html_mydb_mark>#2500#% \end{verbatim}

<tex2html_mydb_mark>#2501#% 

<tex2html_mydb_mark>#2502#% \begin{exercise}

<tex2html_mydb_mark>#2503#% ¿Cómo se hubiera interpretado la expresion \verb|- e - e| si no

<tex2html_mydb_mark>#2504#% se hubiese introducido el terminal de desempate \verb|NEG|?

<tex2html_mydb_mark>#2505#% \end{exercise}

<tex2html_mydb_mark>#2506#% 

<tex2html_mydb_mark>#2507#% \begin{exercise}

<tex2html_mydb_mark>#2508#% ¿Cómo se interpretará una expresion como \verb|e = e - e|?

<tex2html_mydb_mark>#2509#% \end{exercise}

<tex2html_mydb_mark>#2510#% 

<tex2html_mydb_mark>#2511#% \item

<tex2html_mydb_mark>#2512#% Tenga en cuenta que algunas funcionalidades proveídas por \verb|Parse::Eyapp|

<tex2html_mydb_mark>#2513#% (por ejemplo las listas) suponen la inserción de reglas dentro de la gramática

<tex2html_mydb_mark>#2514#% de entrada y por tanto pueden dar lugar a ambiguedades.

<tex2html_mydb_mark>#2515#% 

<tex2html_mydb_mark>#2516#% \item

<tex2html_mydb_mark>#2517#% Una fuente de ambiguedad puede aparecer como consecuencia de la aparición de acciones

<tex2html_mydb_mark>#2518#% semánticas. Cuando se  inserta una acción $\left \{ action_1\right \}$

<tex2html_mydb_mark>#2519#% en medio de una regla $A \rightarrow \alpha \beta$ :

<tex2html_mydb_mark>#2520#% \begin{center}

<tex2html_mydb_mark>#2521#% $A \rightarrow \alpha \left \{ action_1 \right \} \beta \left \{ action_2\right \}$ 

<tex2html_mydb_mark>#2522#% \end{center}

<tex2html_mydb_mark>#2523#% \verb|eyapp| crea una variable sintáctica temporal $T$ e introduce una nueva regla:

<tex2html_mydb_mark>#2524#% 

<tex2html_mydb_mark>#2525#% \begin{center}

<tex2html_mydb_mark>#2526#% \begin{enumerate}

<tex2html_mydb_mark>#2527#% \item

<tex2html_mydb_mark>#2528#% $A \rightarrow \alpha T \beta \left \{ action_2\right \}$ 

<tex2html_mydb_mark>#2529#% \item

<tex2html_mydb_mark>#2530#% $T \rightarrow \epsilon \left \{ action_1 \right \}$ 

<tex2html_mydb_mark>#2531#% \end{enumerate}

<tex2html_mydb_mark>#2532#% \end{center}

<tex2html_mydb_mark>#2533#% 

<tex2html_mydb_mark>#2534#% esta modificación puede dar lugar a conflictos.

<tex2html_mydb_mark>#2535#% 

<tex2html_mydb_mark>#2536#% \end{itemize}

<tex2html_mydb_mark>#2537#% 

<tex2html_mydb_mark>#2538#% \paragraph{La rutina de Tratamiento de Errores}

<tex2html_mydb_mark>#2539#% Recuerde que la fase de análisis sintáctico y léxico de 

<tex2html_mydb_mark>#2540#% la entrada ocurre en Tree Construction Time.

<tex2html_mydb_mark>#2541#% En consecuencia el primer argumento que recibe el método \verb|_Error| 

<tex2html_mydb_mark>#2542#% (líneas 53-59) cuando es llamado

<tex2html_mydb_mark>#2543#% por el analizador sintáctico es una referencia al objeto analizador 

<tex2html_mydb_mark>#2544#% sintáctico. Dicho objeto dispone de un conjunto de métodos, muchos de los cuales

<tex2html_mydb_mark>#2545#% ya existían en \verb|Parse::Yapp|. Entre estos últimos se encuentra  el método

<tex2html_mydb_mark>#2546#% \tei{YYCurval} que es llamado en la línea 55 y que devuelve

<tex2html_mydb_mark>#2547#% el terminal/token que estaba siendo analizado en el momento en el que 

<tex2html_mydb_mark>#2548#% se produjo el error. Si dicho token no está definido es que hemos alcanzado el

<tex2html_mydb_mark>#2549#% final del fichero (línea 56).

<tex2html_mydb_mark>#2550#% 

<tex2html_mydb_mark>#2551#% \begin{verbatim}

<tex2html_mydb_mark>#2552#% 54  sub _Error {

<tex2html_mydb_mark>#2553#% 55    my($token)=$_[0]-;SPMgt;YYCurval;

<tex2html_mydb_mark>#2554#% 56    my($what)= $token ? ;SPMquot;input: '$token';SPMquot; : ;SPMquot;end of input;SPMquot;;

<tex2html_mydb_mark>#2555#% 57

<tex2html_mydb_mark>#2556#% 58    die ;SPMquot;Syntax error near $what.\n;SPMquot;;

<tex2html_mydb_mark>#2557#% 59  }

<tex2html_mydb_mark>#2558#% \end{verbatim}

<tex2html_mydb_mark>#2559#% 

<tex2html_mydb_mark>#2560#% Otros métodos que pueden ser de ayuda en el diagnóstico de 

<tex2html_mydb_mark>#2561#% errores son \tei{YYCurval} que devuelve el atributo del 

<tex2html_mydb_mark>#2562#% token actual y \tei{YYExpect} que devuelve una lista

<tex2html_mydb_mark>#2563#% con los terminales esperados en el momento en el que se produjo

<tex2html_mydb_mark>#2564#% el error.

<tex2html_mydb_mark>#2565#% 

<tex2html_mydb_mark>#2566#% \paragraph{El Analizador Léxico}

<tex2html_mydb_mark>#2567#% El analizador léxico esta tomado de los ejemplos 

<tex2html_mydb_mark>#2568#% que acompañan a \verb|Parse::Yapp|. Se supone que la entrada

<tex2html_mydb_mark>#2569#% se ha dejado dentro del objeto analizador en \verb|$parser-;SPMgt;YYData-;SPMgt;{INPUT}|.

<tex2html_mydb_mark>#2570#% Recuerde que el análisis léxico de la entrada ocurre en Tree Construction Time.

<tex2html_mydb_mark>#2571#% En consecuencia el primer argumento que recibe \verb|_Lexer| cuando es llamado

<tex2html_mydb_mark>#2572#% por el analizador sintáctico es la referencia al objeto analizador 

<tex2html_mydb_mark>#2573#% sintáctico. De ahí que lo primero que se hace, en la línea 59, sea 

<tex2html_mydb_mark>#2574#% crear en \verb|$parser| una variable léxica que referencia dicho objeto.

<tex2html_mydb_mark>#2575#% 

<tex2html_mydb_mark>#2576#% \begin{verbatim}

<tex2html_mydb_mark>#2577#% 58  sub _Lexer {

<tex2html_mydb_mark>#2578#% 59      my($parser)=shift;

<tex2html_mydb_mark>#2579#% 60

<tex2html_mydb_mark>#2580#% 61          $parser-;SPMgt;YYData-;SPMgt;{INPUT}

<tex2html_mydb_mark>#2581#% 62      or  return('',undef);

<tex2html_mydb_mark>#2582#% 63

<tex2html_mydb_mark>#2583#% 64      $parser-;SPMgt;YYData-;SPMgt;{INPUT}=~s/^\s*//;

<tex2html_mydb_mark>#2584#% 65

<tex2html_mydb_mark>#2585#% 66      for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {

<tex2html_mydb_mark>#2586#% 67          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);

<tex2html_mydb_mark>#2587#% 68          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);

<tex2html_mydb_mark>#2588#% 69          s/^(.)// and return($1,$1);

<tex2html_mydb_mark>#2589#% 70          s/^\s*//;

<tex2html_mydb_mark>#2590#% 71      }

<tex2html_mydb_mark>#2591#% 72  }

<tex2html_mydb_mark>#2592#% \end{verbatim}

<tex2html_mydb_mark>#2593#% 

<tex2html_mydb_mark>#2594#% \begin{exercise}

<tex2html_mydb_mark>#2595#% ¿Cuantos elementos tiene la lista sobre la que se hace el bucle 

<tex2html_mydb_mark>#2596#% \verb|for| de la línea 66?

<tex2html_mydb_mark>#2597#% \end{exercise}

<tex2html_mydb_mark>#2598#% 

<tex2html_mydb_mark>#2599#% Obsérvese el \cei{falso bucle {\tt for}} en la línea 66. 

<tex2html_mydb_mark>#2600#% Es un truco que constituye una de esas frases hechas o \cei{idioms}

<tex2html_mydb_mark>#2601#% que aunque la primera vez resultan extrañas,

<tex2html_mydb_mark>#2602#% a fuerza de verlas repetidas se convierten en familiares.

<tex2html_mydb_mark>#2603#% 

<tex2html_mydb_mark>#2604#% El bucle de hecho se ejecutará una sóla vez en cada llamada 

<tex2html_mydb_mark>#2605#% a \verb|_Lexer|. El objetivo es evitar las costosas indirecciones

<tex2html_mydb_mark>#2606#% a las que obliga almacenar la entrada en \verb|$parser-;SPMgt;YYData-;SPMgt;{INPUT}|.

<tex2html_mydb_mark>#2607#% Para ello se aprovecha la capacidad del bucle \verb|for| sin índice

<tex2html_mydb_mark>#2608#% \emph{de crear en} \verb|$_| \emph{un alias del elemento visitado en la iteración}.

<tex2html_mydb_mark>#2609#% 

<tex2html_mydb_mark>#2610#% \begin{exercise}

<tex2html_mydb_mark>#2611#% \ 

<tex2html_mydb_mark>#2612#% \begin{enumerate}

<tex2html_mydb_mark>#2613#% \item

<tex2html_mydb_mark>#2614#% ¿Puedo cambiar el binding de la línea 64 por uno sobre

<tex2html_mydb_mark>#2615#% \verb|$_| dentro del falso \verb|for|? ¿Ganamos algo con ello?

<tex2html_mydb_mark>#2616#% 

<tex2html_mydb_mark>#2617#% \item

<tex2html_mydb_mark>#2618#% ¿Puedo cambiar la comprobación en las líneas 61-62

<tex2html_mydb_mark>#2619#% por una primera línea dentro del falso \verb|for| que diga

<tex2html_mydb_mark>#2620#% \verb|$_ or return('',undef);|?

<tex2html_mydb_mark>#2621#% 

<tex2html_mydb_mark>#2622#% \item

<tex2html_mydb_mark>#2623#% ¿Cuántas veces se ejecuta el falso bucle si \verb|$parser-;SPMgt;YYData-;SPMgt;{INPUT}|

<tex2html_mydb_mark>#2624#% contiene la cadena vacía?

<tex2html_mydb_mark>#2625#% 

<tex2html_mydb_mark>#2626#% %Las líneas 61-62 contienen un sutil error ¿Cual es?.

<tex2html_mydb_mark>#2627#% %

<tex2html_mydb_mark>#2628#% \item

<tex2html_mydb_mark>#2629#% ¿Que ocurrirá en las líneas 61-62 

<tex2html_mydb_mark>#2630#% si \verb|$parser-;SPMgt;YYData-;SPMgt;{INPUT}| contiene sólamente la cadena '0'?

<tex2html_mydb_mark>#2631#% \end{enumerate}

<tex2html_mydb_mark>#2632#% 

<tex2html_mydb_mark>#2633#% \end{exercise}

<tex2html_mydb_mark>#2634#% 

<tex2html_mydb_mark>#2635#% \paragraph{Acciones por Defecto}

<tex2html_mydb_mark>#2636#% 

<tex2html_mydb_mark>#2637#% En el ejemplo anterior la acción es asociada con los nodos

<tex2html_mydb_mark>#2638#% \verb|PLUS|, \verb|MINUS|, \verb|TIMES| y \verb|DIV| es similar.

<tex2html_mydb_mark>#2639#% \verb|Parse::Eyapp| proporciona una directiva \verb|%|\tei{defaultaction}

<tex2html_mydb_mark>#2640#% la cual permite especificar la acción por defecto. Esta acción es asociada

<tex2html_mydb_mark>#2641#% con las reglas que no tienen una acción asociada explícita. El siguiente

<tex2html_mydb_mark>#2642#% ejemplo muestra su uso:

<tex2html_mydb_mark>#2643#% 

<tex2html_mydb_mark>#2644#% \begin{verbatim}

<tex2html_mydb_mark>#2645#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; cat -n trans_scheme_default_action.pl

<tex2html_mydb_mark>#2646#%  1  #!/usr/bin/perl

<tex2html_mydb_mark>#2647#%  2  use strict;

<tex2html_mydb_mark>#2648#%  3  use warnings;

<tex2html_mydb_mark>#2649#%  4  use Data::Dumper;

<tex2html_mydb_mark>#2650#%  5  use Parse::Eyapp;

<tex2html_mydb_mark>#2651#%  6  use IO::Interactive qw(interactive);

<tex2html_mydb_mark>#2652#%  7

<tex2html_mydb_mark>#2653#%  8  my $translationscheme = q{

<tex2html_mydb_mark>#2654#%  9    %{

<tex2html_mydb_mark>#2655#% 10    # head code is available at tree construction time

<tex2html_mydb_mark>#2656#% 11    use Data::Dumper;

<tex2html_mydb_mark>#2657#% 12

<tex2html_mydb_mark>#2658#% 13    our %sym; # symbol table

<tex2html_mydb_mark>#2659#% 14    %}

<tex2html_mydb_mark>#2660#% 15

<tex2html_mydb_mark>#2661#% 16    %defaultaction { $lhs-;SPMgt;{n} = eval ;SPMquot; $left-;SPMgt;{n} $_[2]-;SPMgt;{attr} $right-;SPMgt;{n} ;SPMquot; }

<tex2html_mydb_mark>#2662#% 17

<tex2html_mydb_mark>#2663#% 18    %metatree

<tex2html_mydb_mark>#2664#% 19

<tex2html_mydb_mark>#2665#% 20    %right   '='

<tex2html_mydb_mark>#2666#% 21    %left   '-' '+'

<tex2html_mydb_mark>#2667#% 22    %left   '*' '/'

<tex2html_mydb_mark>#2668#% 23

<tex2html_mydb_mark>#2669#% 24    %%

<tex2html_mydb_mark>#2670#% 25    line:       %name EXP

<tex2html_mydb_mark>#2671#% 26                  exp ;SPMlt;+ ';';SPMgt; /* Expressions separated by semicolons */

<tex2html_mydb_mark>#2672#% 27                    { $lhs-;SPMgt;{n} = $_[1]-;SPMgt;Last_child-;SPMgt;{n} }

<tex2html_mydb_mark>#2673#% 28    ;

<tex2html_mydb_mark>#2674#% 29

<tex2html_mydb_mark>#2675#% 30    exp:

<tex2html_mydb_mark>#2676#% 31                %name PLUS

<tex2html_mydb_mark>#2677#% 32                  exp.left '+' exp.right

<tex2html_mydb_mark>#2678#% 33            |   %name MINUS

<tex2html_mydb_mark>#2679#% 34                  exp.left '-' exp.right

<tex2html_mydb_mark>#2680#% 35            |   %name TIMES

<tex2html_mydb_mark>#2681#% 36                  exp.left '*' exp.right

<tex2html_mydb_mark>#2682#% 37            |   %name DIV

<tex2html_mydb_mark>#2683#% 38                  exp.left '/' exp.right

<tex2html_mydb_mark>#2684#% 39            |   %name NUM   $NUM

<tex2html_mydb_mark>#2685#% 40                    { $lhs-;SPMgt;{n} = $NUM-;SPMgt;{attr} }

<tex2html_mydb_mark>#2686#% 41            |   '(' $exp ')'  %begin { $exp }

<tex2html_mydb_mark>#2687#% 42            |   %name VAR

<tex2html_mydb_mark>#2688#% 43                  $VAR

<tex2html_mydb_mark>#2689#% 44                    { $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} }

<tex2html_mydb_mark>#2690#% 45            |   %name ASSIGN

<tex2html_mydb_mark>#2691#% 46                  $VAR '=' $exp

<tex2html_mydb_mark>#2692#% 47                    { $lhs-;SPMgt;{n} = $sym{$VAR-;SPMgt;{attr}}-;SPMgt;{n} = $exp-;SPMgt;{n} }

<tex2html_mydb_mark>#2693#% 48

<tex2html_mydb_mark>#2694#% 49    ;

<tex2html_mydb_mark>#2695#% 50

<tex2html_mydb_mark>#2696#% 51    %%

<tex2html_mydb_mark>#2697#% 52    sub Error {

<tex2html_mydb_mark>#2698#% 53      die ;SPMquot;Syntax error near ;SPMquot;.($_[0]-;SPMgt;YYCurval?$_[0]-;SPMgt;YYCurval:;SPMquot;end of file;SPMquot;).;SPMquot;\n;SPMquot;;

<tex2html_mydb_mark>#2699#% 54    }

<tex2html_mydb_mark>#2700#% 55

<tex2html_mydb_mark>#2701#% 56    sub Lexer {

<tex2html_mydb_mark>#2702#% 57      my($parser)=shift;

<tex2html_mydb_mark>#2703#% 58

<tex2html_mydb_mark>#2704#% 59      for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {

<tex2html_mydb_mark>#2705#% 60        s/^\s*//;

<tex2html_mydb_mark>#2706#% 61        $_ eq '' and  return('',undef);

<tex2html_mydb_mark>#2707#% 62        s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);

<tex2html_mydb_mark>#2708#% 63        s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);

<tex2html_mydb_mark>#2709#% 64        s/^(.)// and return($1,$1);

<tex2html_mydb_mark>#2710#% 65      }

<tex2html_mydb_mark>#2711#% 66    }

<tex2html_mydb_mark>#2712#% 67  }; # end translation scheme

<tex2html_mydb_mark>#2713#% 68

<tex2html_mydb_mark>#2714#% 69  $Data::Dumper::Indent = 1;

<tex2html_mydb_mark>#2715#% 70  $Data::Dumper::Terse = 1;

<tex2html_mydb_mark>#2716#% 71  $Data::Dumper::Deepcopy  = 1;

<tex2html_mydb_mark>#2717#% 72  my $warnings = Parse::Eyapp-;SPMgt;new_grammar(

<tex2html_mydb_mark>#2718#% 73    input=;SPMgt;$translationscheme,

<tex2html_mydb_mark>#2719#% 74    classname=;SPMgt;'Calc',

<tex2html_mydb_mark>#2720#% 75    firstline =;SPMgt; 6,

<tex2html_mydb_mark>#2721#% 76    outputfile =;SPMgt; 'Calc.pm');

<tex2html_mydb_mark>#2722#% 77  die ;SPMquot;$warnings\nSolve Ambiguities. See file main.output\n;SPMquot;  if $warnings;

<tex2html_mydb_mark>#2723#% 78  my $parser = Calc-;SPMgt;new();

<tex2html_mydb_mark>#2724#% 79  print {interactive} ;SPMquot;Write a sequence of arithmetic expressions: ;SPMquot;;

<tex2html_mydb_mark>#2725#% 80  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;;SPMgt;;

<tex2html_mydb_mark>#2726#% 81  my $t = $parser-;SPMgt;YYParse( yylex =;SPMgt; \&Calc::Lexer, yyerror =;SPMgt; \&Calc::Error );

<tex2html_mydb_mark>#2727#% 82  $t-;SPMgt;translation_scheme;

<tex2html_mydb_mark>#2728#% 83  my $treestring = Dumper($t);

<tex2html_mydb_mark>#2729#% 84  my $symboltable;

<tex2html_mydb_mark>#2730#% 85  {

<tex2html_mydb_mark>#2731#% 86    no warnings;

<tex2html_mydb_mark>#2732#% 87    $symboltable = Dumper(\%Calc::sym);

<tex2html_mydb_mark>#2733#% 88  }

<tex2html_mydb_mark>#2734#% 89  print ;SPMlt;;SPMlt;;SPMquot;EOR;SPMquot;;

<tex2html_mydb_mark>#2735#% 90  ***********Tree*************

<tex2html_mydb_mark>#2736#% 91  $treestring

<tex2html_mydb_mark>#2737#% 92  ******Symbol table**********

<tex2html_mydb_mark>#2738#% 93  $symboltable

<tex2html_mydb_mark>#2739#% 94  ************Result**********

<tex2html_mydb_mark>#2740#% 95  $t-;SPMgt;{n}

<tex2html_mydb_mark>#2741#% 96

<tex2html_mydb_mark>#2742#% 97  EOR

<tex2html_mydb_mark>#2743#% \end{verbatim}

<tex2html_mydb_mark>#2744#% 

<tex2html_mydb_mark>#2745#% El método \tei{Last\_child} usado en la línea 27 devuelve una referencia al

<tex2html_mydb_mark>#2746#% último hijo no código del nodo.

<tex2html_mydb_mark>#2747#% Al ser \verb|$_[1]| un nodo de tipo \tei{'\_PLUS\_LIST'} queda garantizado que

<tex2html_mydb_mark>#2748#% el último hijo no es una referencia a una subrutina asi que podría haberse 

<tex2html_mydb_mark>#2749#% usado el método \tei{last\_child} el cual devuelve el último hijo 

<tex2html_mydb_mark>#2750#% del nodo, sea este código o no.

<tex2html_mydb_mark>#2751#% 

<tex2html_mydb_mark>#2752#% La línea 86 tiene por efecto desactivar los avisos. De otra manera se produciría 

<tex2html_mydb_mark>#2753#% un \tei{warning} con respecto al uso único de la variable \verb|%Calc::sym|:

<tex2html_mydb_mark>#2754#% \begin{verbatim}

<tex2html_mydb_mark>#2755#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; echo ;SPMquot;a=2*3; b=a+1;SPMquot; | trans_scheme_default_action.pl

<tex2html_mydb_mark>#2756#% Name ;SPMquot;Calc::sym;SPMquot; used only once: possible typo at trans_scheme_default_action.pl line 85.

<tex2html_mydb_mark>#2757#% ***********Tree*************

<tex2html_mydb_mark>#2758#% bless( {

<tex2html_mydb_mark>#2759#%   'n' =;SPMgt; 7,

<tex2html_mydb_mark>#2760#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#2761#%     ............

<tex2html_mydb_mark>#2762#%   ]

<tex2html_mydb_mark>#2763#% }, 'EXP' )

<tex2html_mydb_mark>#2764#% 

<tex2html_mydb_mark>#2765#% ******Symbol table**********

<tex2html_mydb_mark>#2766#% {

<tex2html_mydb_mark>#2767#%   'a' =;SPMgt; { 'n' =;SPMgt; 6 },

<tex2html_mydb_mark>#2768#%   'b' =;SPMgt; { 'n' =;SPMgt; 7 }

<tex2html_mydb_mark>#2769#% }

<tex2html_mydb_mark>#2770#% 

<tex2html_mydb_mark>#2771#% ************Result**********

<tex2html_mydb_mark>#2772#% 7

<tex2html_mydb_mark>#2773#% \end{verbatim}

<tex2html_mydb_mark>#2774#% 

<tex2html_mydb_mark>#2775#% \paragraph{Un Esquema  de Traducción para las Declaraciones de Variables}

<tex2html_mydb_mark>#2776#% En el siguiente ejemplo se muestra la implementación en \verb|eyapp| del ejemplo

<tex2html_mydb_mark>#2777#% \ref{example:typesandts}. El código es similar salvo por la presencia 

<tex2html_mydb_mark>#2778#% de flechas de referenciado:

<tex2html_mydb_mark>#2779#% 

<tex2html_mydb_mark>#2780#% \begin{verbatim}

<tex2html_mydb_mark>#2781#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n trans_scheme_simple_decls2.pl

<tex2html_mydb_mark>#2782#%  1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#2783#%  2  use strict;

<tex2html_mydb_mark>#2784#%  3  use Data::Dumper;

<tex2html_mydb_mark>#2785#%  4  use Parse::Eyapp;

<tex2html_mydb_mark>#2786#%  5  our %s; # symbol table

<tex2html_mydb_mark>#2787#%  6

<tex2html_mydb_mark>#2788#%  7  my $ts = q{

<tex2html_mydb_mark>#2789#%  8    %token FLOAT INTEGER NAME

<tex2html_mydb_mark>#2790#%  9

<tex2html_mydb_mark>#2791#% 10    %{

<tex2html_mydb_mark>#2792#% 11    our %s;

<tex2html_mydb_mark>#2793#% 12    %}

<tex2html_mydb_mark>#2794#% 13

<tex2html_mydb_mark>#2795#% 14    %metatree

<tex2html_mydb_mark>#2796#% 15

<tex2html_mydb_mark>#2797#% 16    %%

<tex2html_mydb_mark>#2798#% 17    Dl:  D ;SPMlt;* ';';SPMgt;

<tex2html_mydb_mark>#2799#% 18    ;

<tex2html_mydb_mark>#2800#% 19

<tex2html_mydb_mark>#2801#% 20    D : $T { $L-;SPMgt;{t} = $T-;SPMgt;{t} } $L

<tex2html_mydb_mark>#2802#% 21    ;

<tex2html_mydb_mark>#2803#% 22

<tex2html_mydb_mark>#2804#% 23    T : FLOAT    { $lhs-;SPMgt;{t} = ;SPMquot;FLOAT;SPMquot; }

<tex2html_mydb_mark>#2805#% 24      | INTEGER  { $lhs-;SPMgt;{t} = ;SPMquot;INTEGER;SPMquot; }

<tex2html_mydb_mark>#2806#% 25    ;

<tex2html_mydb_mark>#2807#% 26

<tex2html_mydb_mark>#2808#% 27    L : $NAME

<tex2html_mydb_mark>#2809#% 28          { $NAME-;SPMgt;{t} = $lhs-;SPMgt;{t}; $s{$NAME-;SPMgt;{attr}} = $NAME }

<tex2html_mydb_mark>#2810#% 29      | $NAME { $NAME-;SPMgt;{t} = $lhs-;SPMgt;{t}; $L-;SPMgt;{t} = $lhs-;SPMgt;{t} } ',' $L

<tex2html_mydb_mark>#2811#% 30          { $s{$NAME-;SPMgt;{attr}} = $NAME }

<tex2html_mydb_mark>#2812#% 31    ;

<tex2html_mydb_mark>#2813#% 32    %%

<tex2html_mydb_mark>#2814#% 33  };

<tex2html_mydb_mark>#2815#% 34

<tex2html_mydb_mark>#2816#% 35  sub Error { die ;SPMquot;Error sintáctico\n;SPMquot;; }

<tex2html_mydb_mark>#2817#% 36

<tex2html_mydb_mark>#2818#% 37  { # Closure of $input, %reserved_words and $validchars

<tex2html_mydb_mark>#2819#% 38    my $input = ;SPMquot;;SPMquot;;

<tex2html_mydb_mark>#2820#% 39    my %reserved_words = ();

<tex2html_mydb_mark>#2821#% 40    my $validchars = ;SPMquot;;SPMquot;;

<tex2html_mydb_mark>#2822#% 41

<tex2html_mydb_mark>#2823#% 42    sub parametrize__scanner {

<tex2html_mydb_mark>#2824#% 43      $input = shift;

<tex2html_mydb_mark>#2825#% 44      %reserved_words = %{shift()};

<tex2html_mydb_mark>#2826#% 45      $validchars = shift;

<tex2html_mydb_mark>#2827#% 46    }

<tex2html_mydb_mark>#2828#% 47

<tex2html_mydb_mark>#2829#% 48    sub scanner {

<tex2html_mydb_mark>#2830#% 49      $input =~ m{\G\s+}gc;                     # skip whites

<tex2html_mydb_mark>#2831#% 50      if ($input =~ m{\G([a-z_A_Z]\w*)\b}gc) {

<tex2html_mydb_mark>#2832#% 51        my $w = uc($1);                 # upper case the word

<tex2html_mydb_mark>#2833#% 52        return ($w, $w) if exists $reserved_words{$w};

<tex2html_mydb_mark>#2834#% 53        return ('NAME', $1);            # not a reserved word

<tex2html_mydb_mark>#2835#% 54      }

<tex2html_mydb_mark>#2836#% 55      return ($1, $1) if ($input =~ m/\G([$validchars])/gc);

<tex2html_mydb_mark>#2837#% 56      die ;SPMquot;Caracter invalido: $1\n;SPMquot; if ($input =~ m/\G(\S)/gc);

<tex2html_mydb_mark>#2838#% 57      return ('', undef); # end of file

<tex2html_mydb_mark>#2839#% 58    }

<tex2html_mydb_mark>#2840#% 59  } # end closure

<tex2html_mydb_mark>#2841#% 60

<tex2html_mydb_mark>#2842#% 61  Parse::Eyapp-;SPMgt;new_grammar(input=;SPMgt;$ts, classname=;SPMgt;'main', outputfile=;SPMgt;'Types.pm');

<tex2html_mydb_mark>#2843#% 62  my $parser = main-;SPMgt;new(yylex =;SPMgt; \&scanner, yyerror =;SPMgt; \&Error); # Create the parser

<tex2html_mydb_mark>#2844#% 63

<tex2html_mydb_mark>#2845#% 64  parametrize__scanner(

<tex2html_mydb_mark>#2846#% 65    ;SPMquot;float x,y;\ninteger a,b\n;SPMquot;,

<tex2html_mydb_mark>#2847#% 66    { INTEGER =;SPMgt; 'INTEGER', FLOAT =;SPMgt; 'FLOAT'},

<tex2html_mydb_mark>#2848#% 67    ;SPMquot;,;;SPMquot;

<tex2html_mydb_mark>#2849#% 68  );

<tex2html_mydb_mark>#2850#% 69

<tex2html_mydb_mark>#2851#% 70  my $t = $parser-;SPMgt;YYParse() or die ;SPMquot;Syntax Error analyzing input;SPMquot;;

<tex2html_mydb_mark>#2852#% 71

<tex2html_mydb_mark>#2853#% 72  $t-;SPMgt;translation_scheme;

<tex2html_mydb_mark>#2854#% 73

<tex2html_mydb_mark>#2855#% 74  $Data::Dumper::Indent = 1;

<tex2html_mydb_mark>#2856#% 75  $Data::Dumper::Terse = 1;

<tex2html_mydb_mark>#2857#% 76  $Data::Dumper::Deepcopy  = 1;

<tex2html_mydb_mark>#2858#% 77  $Data::Dumper::Deparse = 1;

<tex2html_mydb_mark>#2859#% 78  print Dumper($t);

<tex2html_mydb_mark>#2860#% 79  print Dumper(\%s);

<tex2html_mydb_mark>#2861#% \end{verbatim}

<tex2html_mydb_mark>#2862#% Al ejecutarlo con la entrada \verb|;SPMquot;float x,y;\ninteger a,b\n;SPMquot;|

<tex2html_mydb_mark>#2863#% los contenidos finales del arbol son:

<tex2html_mydb_mark>#2864#% \begin{verbatim}

<tex2html_mydb_mark>#2865#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; trans_scheme_simple_decls2.pl

<tex2html_mydb_mark>#2866#% bless({'children'=;SPMgt;[

<tex2html_mydb_mark>#2867#%    bless({'children'=;SPMgt;[

<tex2html_mydb_mark>#2868#%    |   bless({'children'=;SPMgt;[

<tex2html_mydb_mark>#2869#%    |   |   bless({'children'=;SPMgt;[

<tex2html_mydb_mark>#2870#%    |   |   |   bless({'children'=;SPMgt;[],'attr'=;SPMgt;'FLOAT','token'=;SPMgt;'FLOAT'},'TERMINAL'),

<tex2html_mydb_mark>#2871#%    |   |   |   sub {use strict 'refs'; my $lhs=$_[0]; $$lhs{'t'}='FLOAT'; }

<tex2html_mydb_mark>#2872#%    |   |   | ],

<tex2html_mydb_mark>#2873#%    |   |   | 't'=;SPMgt;'FLOAT'

<tex2html_mydb_mark>#2874#%    |   |   },'T_8'),       # T -;SPMgt; FLOAT

<tex2html_mydb_mark>#2875#%    |   |   sub { ... },

<tex2html_mydb_mark>#2876#%    |   |   bless({'children'=;SPMgt;[

<tex2html_mydb_mark>#2877#%    |   |   |   bless({'children'=;SPMgt;[],'attr'=;SPMgt;'x','token'=;SPMgt;'NAME','t'=;SPMgt;'FLOAT'},'TERMINAL'),

<tex2html_mydb_mark>#2878#%    |   |   |   sub{ ... },

<tex2html_mydb_mark>#2879#%    |   |   |   bless({'children'=;SPMgt;[],'attr'=;SPMgt;',','token'=;SPMgt;','},'TERMINAL'),

<tex2html_mydb_mark>#2880#%    |   |   |   bless({'children'=;SPMgt;[

<tex2html_mydb_mark>#2881#%    |   |   |   |   bless({'children'=;SPMgt;[],'attr'=;SPMgt;'y','token'=;SPMgt;'NAME','t'=;SPMgt;'FLOAT'},

<tex2html_mydb_mark>#2882#%    |   |   |   |         'TERMINAL'),

<tex2html_mydb_mark>#2883#%    |   |   |   |   sub{ ... }

<tex2html_mydb_mark>#2884#%    |   |   |   | ],

<tex2html_mydb_mark>#2885#%    |   |   |   | 't'=;SPMgt;'FLOAT'

<tex2html_mydb_mark>#2886#%    |   |   |   },'L_10'), # L -;SPMgt; NAME

<tex2html_mydb_mark>#2887#%    |   |   |   sub{ ... }

<tex2html_mydb_mark>#2888#%    |   |   | ],

<tex2html_mydb_mark>#2889#%    |   |   | 't'=;SPMgt;'FLOAT'

<tex2html_mydb_mark>#2890#%    |   |   },'L_11'),     # L -;SPMgt; NAME ',' L 

<tex2html_mydb_mark>#2891#%    |   |   undef

<tex2html_mydb_mark>#2892#%    |   | ]

<tex2html_mydb_mark>#2893#%    |   },'D_6'),          # D -;SPMgt; T L

<tex2html_mydb_mark>#2894#%    |   bless({ 

<tex2html_mydb_mark>#2895#%    |    ... # tree for integer a, b

<tex2html_mydb_mark>#2896#%    |   },'D_6')           # D -;SPMgt; T L

<tex2html_mydb_mark>#2897#%    | ]

<tex2html_mydb_mark>#2898#%    },'_STAR_LIST_1'),

<tex2html_mydb_mark>#2899#%  ]

<tex2html_mydb_mark>#2900#% },'Dl_5')   # Dl : D ;SPMlt;* ';';SPMgt; equivale a: Dl : /* empty */ | S_2; S_2: S_1; S_1: S_1 ';' D | D 

<tex2html_mydb_mark>#2901#% \end{verbatim}

<tex2html_mydb_mark>#2902#% Los contenidos de la tabla de símbolos \verb|%s| quedan como sigue:

<tex2html_mydb_mark>#2903#% \begin{verbatim}

<tex2html_mydb_mark>#2904#% {

<tex2html_mydb_mark>#2905#%  'y'=;SPMgt;bless({'children'=;SPMgt;[],'attr'=;SPMgt;'y','token'=;SPMgt;'NAME','t'=;SPMgt;'FLOAT'},'TERMINAL'),

<tex2html_mydb_mark>#2906#%  'a'=;SPMgt;bless({'children'=;SPMgt;[],'attr'=;SPMgt;'a','token'=;SPMgt;'NAME','t'=;SPMgt;'INTEGER'},'TERMINAL'),

<tex2html_mydb_mark>#2907#%  'b'=;SPMgt;bless({'children'=;SPMgt;[],'attr'=;SPMgt;'b','token'=;SPMgt;'NAME','t'=;SPMgt;'INTEGER'},'TERMINAL'),

<tex2html_mydb_mark>#2908#%  'x'=;SPMgt;bless({'children'=;SPMgt;[],'attr'=;SPMgt;'x','token'=;SPMgt;'NAME','t'=;SPMgt;'FLOAT'},'TERMINAL')

<tex2html_mydb_mark>#2909#% }

<tex2html_mydb_mark>#2910#% \end{verbatim}

<tex2html_mydb_mark>#2911#% 

<tex2html_mydb_mark>#2912#% \paragraph{Prefijos}

<tex2html_mydb_mark>#2913#% \label{paragraph:prefix}

<tex2html_mydb_mark>#2914#% Como se ha mencionado, durante la fase \emph{Tree Construction}

<tex2html_mydb_mark>#2915#% los nodos son bendecidos en el nombre de la regla

<tex2html_mydb_mark>#2916#% de producción. \cei{El nombre de una regla de producción} es, por defecto,

<tex2html_mydb_mark>#2917#% la concatenación de la variable en el lado izquierdo

<tex2html_mydb_mark>#2918#% (\cei{LHS}) con el número de orden de la regla. 

<tex2html_mydb_mark>#2919#% Es  posible modificar el nombre por defecto usando

<tex2html_mydb_mark>#2920#% la directiva \tei{\%name}. 

<tex2html_mydb_mark>#2921#% 

<tex2html_mydb_mark>#2922#% {\it Si se desean evitar posibles colisiones con clases existentes

<tex2html_mydb_mark>#2923#% es posible prefijar todos los nombres de las clases

<tex2html_mydb_mark>#2924#% con un prefijo dado usando el parámetro \tei{yyprefix} en la llamada

<tex2html_mydb_mark>#2925#% al constructor del analizador}:

<tex2html_mydb_mark>#2926#% 

<tex2html_mydb_mark>#2927#% \begin{verbatim}

<tex2html_mydb_mark>#2928#% my $warnings = Parse::Eyapp-;SPMgt;new_grammar(

<tex2html_mydb_mark>#2929#%   input=;SPMgt;$translationscheme,

<tex2html_mydb_mark>#2930#%   classname=;SPMgt;'main',

<tex2html_mydb_mark>#2931#%   firstline =;SPMgt; 6,

<tex2html_mydb_mark>#2932#%   outputfile =;SPMgt; 'main.pm');

<tex2html_mydb_mark>#2933#% die ;SPMquot;$warnings\nSolve Ambiguities. See file main.output\n;SPMquot;  if $warnings;

<tex2html_mydb_mark>#2934#% 

<tex2html_mydb_mark>#2935#% # Prefix all the classes with 'Calc::'

<tex2html_mydb_mark>#2936#% my $parser = main-;SPMgt;new(yyprefix =;SPMgt; 'Calc::');

<tex2html_mydb_mark>#2937#% \end{verbatim}

<tex2html_mydb_mark>#2938#% El resultado de esta llamada a \verb|new| es que las clases de los nodos 

<tex2html_mydb_mark>#2939#% quedan prefijadas con \verb|Calc::|. Por ejemplo el árbol creado

<tex2html_mydb_mark>#2940#% para la frase \verb|a=1| será:

<tex2html_mydb_mark>#2941#% \begin{verbatim}

<tex2html_mydb_mark>#2942#% bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#2943#%     bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#2944#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#2945#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'Calc::TERMINAL' ),

<tex2html_mydb_mark>#2946#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '=', 'token' =;SPMgt; '=' }, 'Calc::TERMINAL' ),

<tex2html_mydb_mark>#2947#%             bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#2948#%                 bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '1', 'token' =;SPMgt; 'NUM' }, 'Calc::TERMINAL' ),

<tex2html_mydb_mark>#2949#%               ]

<tex2html_mydb_mark>#2950#%             }, 'Calc::NUM' ),

<tex2html_mydb_mark>#2951#%           ]

<tex2html_mydb_mark>#2952#%         }, 'Calc::ASSIGN' )

<tex2html_mydb_mark>#2953#%       ]

<tex2html_mydb_mark>#2954#%     }, 'Calc::_PLUS_LIST' ),

<tex2html_mydb_mark>#2955#%   ]

<tex2html_mydb_mark>#2956#% }, 'Calc::EXP' )

<tex2html_mydb_mark>#2957#% \end{verbatim}

<tex2html_mydb_mark>#2958#% 

<tex2html_mydb_mark>#2959#% \paragraph{Modo Standalone}

<tex2html_mydb_mark>#2960#% Es mas eficiente aislar el código del esquema de traducción en un fichero 

<tex2html_mydb_mark>#2961#% (se asume por defecto el tipo \verb|.eyp|) y generar el módulo que contiene

<tex2html_mydb_mark>#2962#% el código del analizador usando el guión \tei{eyapp}.

<tex2html_mydb_mark>#2963#% 

<tex2html_mydb_mark>#2964#% El siguiente ejemplo muestra un ejemplo de compilación separada.

<tex2html_mydb_mark>#2965#% El esquema de traducción convierte expresiones

<tex2html_mydb_mark>#2966#% en infijo a postfijo. De un lado tenemos el fichero \verb|TSPostfix2.eyp|

<tex2html_mydb_mark>#2967#% conteniendo el esquema:

<tex2html_mydb_mark>#2968#% 

<tex2html_mydb_mark>#2969#% \begin{verbatim}

<tex2html_mydb_mark>#2970#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n TSPostfix2.eyp

<tex2html_mydb_mark>#2971#%  1  # File TSPostfix2.eyp

<tex2html_mydb_mark>#2972#%  2  %right  '='

<tex2html_mydb_mark>#2973#%  3  %left   '-' '+'

<tex2html_mydb_mark>#2974#%  4  %left   '*' '/'

<tex2html_mydb_mark>#2975#%  5  %left   NEG

<tex2html_mydb_mark>#2976#%  6

<tex2html_mydb_mark>#2977#%  7  %{

<tex2html_mydb_mark>#2978#%  8    use Data::Dumper;

<tex2html_mydb_mark>#2979#%  9    $Data::Dumper::Indent = 1;

<tex2html_mydb_mark>#2980#% 10    $Data::Dumper::Deepcopy = 1;

<tex2html_mydb_mark>#2981#% 11    #$Data::Dumper::Deparse = 1;

<tex2html_mydb_mark>#2982#% 12    use IO::Interactive qw(interactive);

<tex2html_mydb_mark>#2983#% 13  %}

<tex2html_mydb_mark>#2984#% 14

<tex2html_mydb_mark>#2985#% 15  %metatree

<tex2html_mydb_mark>#2986#% 16

<tex2html_mydb_mark>#2987#% 17  %defaultaction {

<tex2html_mydb_mark>#2988#% 18    if (@_==4) { # binary operations: 4 = lhs, left, operand, right

<tex2html_mydb_mark>#2989#% 19      $lhs-;SPMgt;{t} = ;SPMquot;$_[1]-;SPMgt;{t} $_[3]-;SPMgt;{t} $_[2]-;SPMgt;{attr};SPMquot;;

<tex2html_mydb_mark>#2990#% 20      return

<tex2html_mydb_mark>#2991#% 21    }

<tex2html_mydb_mark>#2992#% 22    die ;SPMquot;Fatal Error. Unexpected input\n;SPMquot;.Dumper(@_);

<tex2html_mydb_mark>#2993#% 23  }

<tex2html_mydb_mark>#2994#% 24

<tex2html_mydb_mark>#2995#% 25  %%

<tex2html_mydb_mark>#2996#% 26  line: %name PROG

<tex2html_mydb_mark>#2997#% 27         exp ;SPMlt;%name EXP + ';';SPMgt;

<tex2html_mydb_mark>#2998#% 28           { @{$lhs-;SPMgt;{t}} = map { $_-;SPMgt;{t}} ($lhs-;SPMgt;child(0)-;SPMgt;Children()); }

<tex2html_mydb_mark>#2999#% 29

<tex2html_mydb_mark>#3000#% 30  ;

<tex2html_mydb_mark>#3001#% 31

<tex2html_mydb_mark>#3002#% 32  exp:        NUM         { $lhs-;SPMgt;{t} = $_[1]-;SPMgt;{attr}; }

<tex2html_mydb_mark>#3003#% 33          |   VAR         { $lhs-;SPMgt;{t} = $_[1]-;SPMgt;{attr}; }

<tex2html_mydb_mark>#3004#% 34          |   VAR '=' exp { $lhs-;SPMgt;{t} = ;SPMquot;$_[1]-;SPMgt;{attr} $_[3]-;SPMgt;{t} =;SPMquot; }

<tex2html_mydb_mark>#3005#% 35          |   exp '+' exp

<tex2html_mydb_mark>#3006#% 36          |   exp '-' exp

<tex2html_mydb_mark>#3007#% 37          |   exp '*' exp

<tex2html_mydb_mark>#3008#% 38          |   exp '/' exp

<tex2html_mydb_mark>#3009#% 39          |   '-' exp %prec NEG { $_[0]-;SPMgt;{t} = ;SPMquot;$_[2]-;SPMgt;{t} NEG;SPMquot; }

<tex2html_mydb_mark>#3010#% 40          |   '(' exp ')' %begin { $_[2] }

<tex2html_mydb_mark>#3011#% 41  ;

<tex2html_mydb_mark>#3012#% 42

<tex2html_mydb_mark>#3013#% 43  %%

<tex2html_mydb_mark>#3014#% 44

<tex2html_mydb_mark>#3015#% 45  sub _Error {

<tex2html_mydb_mark>#3016#% 46      my($token)=$_[0]-;SPMgt;YYCurval;

<tex2html_mydb_mark>#3017#% 47

<tex2html_mydb_mark>#3018#% 48      my($what)= $token ? ;SPMquot;input: '$token';SPMquot; : ;SPMquot;end of input;SPMquot;;

<tex2html_mydb_mark>#3019#% 49      die ;SPMquot;Syntax error near $what.\n;SPMquot;;

<tex2html_mydb_mark>#3020#% 50  }

<tex2html_mydb_mark>#3021#% 51

<tex2html_mydb_mark>#3022#% 52  my $x; # Used for input

<tex2html_mydb_mark>#3023#% 53

<tex2html_mydb_mark>#3024#% 54  sub _Lexer {

<tex2html_mydb_mark>#3025#% 55      my($parser)=shift;

<tex2html_mydb_mark>#3026#% 56

<tex2html_mydb_mark>#3027#% 57      $x =~ s/^\s+//;

<tex2html_mydb_mark>#3028#% 58      return('',undef) if $x eq '';

<tex2html_mydb_mark>#3029#% 59

<tex2html_mydb_mark>#3030#% 60

<tex2html_mydb_mark>#3031#% 61      $x =~ s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);

<tex2html_mydb_mark>#3032#% 62      $x =~ s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);

<tex2html_mydb_mark>#3033#% 63      $x =~ s/^(.)//s                    and return($1,$1);

<tex2html_mydb_mark>#3034#% 64  }

<tex2html_mydb_mark>#3035#% 65

<tex2html_mydb_mark>#3036#% 66  sub Run {

<tex2html_mydb_mark>#3037#% 67      my($self)=shift;

<tex2html_mydb_mark>#3038#% 68      $x = ;SPMlt;;SPMgt;;

<tex2html_mydb_mark>#3039#% 69      my $tree = $self-;SPMgt;YYParse( yylex =;SPMgt; \&_Lexer, yyerror =;SPMgt; \&_Error,

<tex2html_mydb_mark>#3040#% 70        #yydebug =;SPMgt; 0xFF

<tex2html_mydb_mark>#3041#% 71      );

<tex2html_mydb_mark>#3042#% 72

<tex2html_mydb_mark>#3043#% 73      print Dumper($tree);

<tex2html_mydb_mark>#3044#% 74      $tree-;SPMgt;translation_scheme();

<tex2html_mydb_mark>#3045#% 75      print Dumper($tree);

<tex2html_mydb_mark>#3046#% 76      {

<tex2html_mydb_mark>#3047#% 77        local $;SPMquot; = ;SPMquot;;;SPMquot;;

<tex2html_mydb_mark>#3048#% 78        print ;SPMquot;Translation:\n@{$tree-;SPMgt;{t}}\n;SPMquot;;

<tex2html_mydb_mark>#3049#% 79      }

<tex2html_mydb_mark>#3050#% 80  }

<tex2html_mydb_mark>#3051#% 81

<tex2html_mydb_mark>#3052#% \end{verbatim}

<tex2html_mydb_mark>#3053#% Observe el uso del método \tei{Children} - con {\tt C} mayúscula -

<tex2html_mydb_mark>#3054#% en la línea 28: 

<tex2html_mydb_mark>#3055#% \emph{devuelve los hijos del nodo no incluyendo las referencias

<tex2html_mydb_mark>#3056#% a subrutinas}.

<tex2html_mydb_mark>#3057#% A diferencia de su homólogo con {\tt c}  minúscula  \tei{children} 

<tex2html_mydb_mark>#3058#% el cual devuelve todos los hijos del nodo, 

<tex2html_mydb_mark>#3059#% incluyendo las referencias al código empotrado.

<tex2html_mydb_mark>#3060#% 

<tex2html_mydb_mark>#3061#% Compilamos con \verb|eyapp|:

<tex2html_mydb_mark>#3062#% \begin{verbatim}

<tex2html_mydb_mark>#3063#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; eyapp TSPostfix2

<tex2html_mydb_mark>#3064#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; ls -ltr | tail -2

<tex2html_mydb_mark>#3065#% -rw-r-----  1 pl users   1781 2006-10-30 13:08 TSPostfix2.eyp

<tex2html_mydb_mark>#3066#% -rw-r--r--  1 pl users   7611 2006-10-30 13:12 TSPostfix2.pm

<tex2html_mydb_mark>#3067#% \end{verbatim}

<tex2html_mydb_mark>#3068#% 

<tex2html_mydb_mark>#3069#% De otro lado tenemos el programa cliente 

<tex2html_mydb_mark>#3070#% el cual  se limita a cargar el módulo y llamar

<tex2html_mydb_mark>#3071#% al método \verb|Run|:

<tex2html_mydb_mark>#3072#% 

<tex2html_mydb_mark>#3073#% \begin{verbatim}

<tex2html_mydb_mark>#3074#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n usetspostfix2.pl

<tex2html_mydb_mark>#3075#%      1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#3076#%      2  use strict;

<tex2html_mydb_mark>#3077#%      3  use TSPostfix2;

<tex2html_mydb_mark>#3078#%      4

<tex2html_mydb_mark>#3079#%      5  my $parser = new TSPostfix2();

<tex2html_mydb_mark>#3080#%      6  $parser-;SPMgt;Run;

<tex2html_mydb_mark>#3081#% \end{verbatim}

<tex2html_mydb_mark>#3082#% Al ejecutar el programa se produce una salida similar a esta

<tex2html_mydb_mark>#3083#% (la salida ha sido editada para darle mayor claridad):

<tex2html_mydb_mark>#3084#% 

<tex2html_mydb_mark>#3085#% \begin{verbatim}

<tex2html_mydb_mark>#3086#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; usetspostfix2.pl

<tex2html_mydb_mark>#3087#%  1  a=2

<tex2html_mydb_mark>#3088#%  2  ...

<tex2html_mydb_mark>#3089#%  3  $VAR1 = bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3090#%  4      bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3091#%  5      |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3092#%  6      |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3093#%  7      |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '=', 'token' =;SPMgt; '=' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3094#%  8      |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3095#%  9      |   |       bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '2', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3096#% 10      |   |       sub { ;SPMquot;DUMMY;SPMquot; }

<tex2html_mydb_mark>#3097#% 11      |   |     ],

<tex2html_mydb_mark>#3098#% 12      |   |     't' =;SPMgt; '2'

<tex2html_mydb_mark>#3099#% 13      |   |   }, 'exp_4' ),

<tex2html_mydb_mark>#3100#% 14      |   |   sub { ;SPMquot;DUMMY;SPMquot; }

<tex2html_mydb_mark>#3101#% 15      |   | ],

<tex2html_mydb_mark>#3102#% 16      |   | 't' =;SPMgt; 'a 2 ='

<tex2html_mydb_mark>#3103#% 17      |   }, 'exp_6' )

<tex2html_mydb_mark>#3104#% 18      | ]

<tex2html_mydb_mark>#3105#% 19      }, 'EXP' ),

<tex2html_mydb_mark>#3106#% 20      sub { ;SPMquot;DUMMY;SPMquot; }

<tex2html_mydb_mark>#3107#% 21    ],

<tex2html_mydb_mark>#3108#% 22    't' =;SPMgt; [ 'a 2 =' ]

<tex2html_mydb_mark>#3109#% 23  }, 'PROG' );

<tex2html_mydb_mark>#3110#% 24  Translation:

<tex2html_mydb_mark>#3111#% 25  a 2 =

<tex2html_mydb_mark>#3112#% \end{verbatim}

<tex2html_mydb_mark>#3113#% 

<tex2html_mydb_mark>#3114#% Como puede verse en la salida, cuando no se especifica el nombre del nodo asociado

<tex2html_mydb_mark>#3115#% con la regla de producción se genera un \cei{nombre por defecto} que consiste en la concatenación

<tex2html_mydb_mark>#3116#% del nombre de la variable sintáctica en el lado izquierdo y el número de orden 

<tex2html_mydb_mark>#3117#% de la regla de producción. Así el nodo descrito en las líneas 5-17 tiene por nombre 

<tex2html_mydb_mark>#3118#% \verb|exp_6| indicando que corresponde a la sexta regla de producción de \verb|exp|.

<tex2html_mydb_mark>#3119#% 

<tex2html_mydb_mark>#3120#% El nodo en las líneas 4-19 tiene por nombre \verb|EXP|. Su nombre

<tex2html_mydb_mark>#3121#% le fué dado mediante la directiva \verb|%name| en la línea

<tex2html_mydb_mark>#3122#% \begin{verbatim}

<tex2html_mydb_mark>#3123#% 27         exp ;SPMlt;%name EXP + ';';SPMgt;

<tex2html_mydb_mark>#3124#% \end{verbatim}

<tex2html_mydb_mark>#3125#% Es posible insertar una directiva \tei{\%name en una lista} usando esta

<tex2html_mydb_mark>#3126#% sintáxis.

<tex2html_mydb_mark>#3127#% 

<tex2html_mydb_mark>#3128#% Nótese también que si hubieramos usado la opción \tei{Data::Dumper::Deparse} (línea 11) podríamos

<tex2html_mydb_mark>#3129#% hacer que \verb|Data::Dumper| nos informe no sólo de la presencia de código

<tex2html_mydb_mark>#3130#% sino que nos muestre el código fuente que ocupa esa posición.

<tex2html_mydb_mark>#3131#% 

<tex2html_mydb_mark>#3132#% \section{Manipulación del Árbol Sintáctico}

<tex2html_mydb_mark>#3133#% El

<tex2html_mydb_mark>#3134#% módulo \verb|Parse::Eyapp::Treeregexp| permite la transformación de

<tex2html_mydb_mark>#3135#% árboles mediante el uso de \cei{Expresiones Regulares Arbol}.

<tex2html_mydb_mark>#3136#% Las expresiones regulares árbol serán introducidas en mas detalle en la 

<tex2html_mydb_mark>#3137#% sección 

<tex2html_mydb_mark>#3138#% \ref{section:aat}.

<tex2html_mydb_mark>#3139#% 

<tex2html_mydb_mark>#3140#% \paragraph{Optimización del Traductor de Infijo a Postfijo}

<tex2html_mydb_mark>#3141#% 

<tex2html_mydb_mark>#3142#% El siguiente ejemplo modifica el anterior esquema de traducción

<tex2html_mydb_mark>#3143#% de infijo a postfijo para producir un código de postfijo

<tex2html_mydb_mark>#3144#% mas eficiente. Para ello se transforma el árbol generado 

<tex2html_mydb_mark>#3145#% durante la fase  {\it Tree Construction Time} y antes de la fase 

<tex2html_mydb_mark>#3146#% {\it Execution Time}. El código \cei{Treeregexp} 

<tex2html_mydb_mark>#3147#% que define el conjunto de transformaciones

<tex2html_mydb_mark>#3148#% se encuentra en las líneas 74-103.

<tex2html_mydb_mark>#3149#% 

<tex2html_mydb_mark>#3150#% Las transformaciones consisten en

<tex2html_mydb_mark>#3151#% \begin{enumerate}

<tex2html_mydb_mark>#3152#% \item

<tex2html_mydb_mark>#3153#% Compactar los árboles \verb|UMINUS| a un número negativo

<tex2html_mydb_mark>#3154#% \item

<tex2html_mydb_mark>#3155#% Realizar \cei{plegado de constantes}: sustituir 

<tex2html_mydb_mark>#3156#% los árboles de constantes por su evaluación

<tex2html_mydb_mark>#3157#% \item

<tex2html_mydb_mark>#3158#% Sustituir los árboles producto en los que uno de los factores es cero

<tex2html_mydb_mark>#3159#% por el número cero.

<tex2html_mydb_mark>#3160#% \end{enumerate}

<tex2html_mydb_mark>#3161#% 

<tex2html_mydb_mark>#3162#% Después de ello se realiza la traducción quedando la misma

<tex2html_mydb_mark>#3163#% como el atributo \verb|t| del 

<tex2html_mydb_mark>#3164#% nodo raíz (línea 120). 

<tex2html_mydb_mark>#3165#% 

<tex2html_mydb_mark>#3166#% A partir de este momento, 

<tex2html_mydb_mark>#3167#% si el traductor tuviera un mayor número de fases

<tex2html_mydb_mark>#3168#% de posterior tratamiento del árbol, 

<tex2html_mydb_mark>#3169#% los nodos de tipo código y los nodos hoja cuya funcionalidad es

<tex2html_mydb_mark>#3170#% puramente sintáctica como los terminales \verb|=|, \verb|*| etc.

<tex2html_mydb_mark>#3171#% pueden ser eliminados. Es por eso que los suprimimos en las

<tex2html_mydb_mark>#3172#% líneas 122-123.

<tex2html_mydb_mark>#3173#% 

<tex2html_mydb_mark>#3174#% Veamos primero el código y luego lo discutiremos en mas detalle:

<tex2html_mydb_mark>#3175#% 

<tex2html_mydb_mark>#3176#% \begin{verbatim}

<tex2html_mydb_mark>#3177#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n TSwithtreetransformations.eyp

<tex2html_mydb_mark>#3178#%    1  # File TSwithtreetransformations.eyp

<tex2html_mydb_mark>#3179#%    2  %right  '='

<tex2html_mydb_mark>#3180#%    3  %left   '-' '+'

<tex2html_mydb_mark>#3181#%    4  %left   '*' '/'

<tex2html_mydb_mark>#3182#%    5  %left   NEG

<tex2html_mydb_mark>#3183#%    6

<tex2html_mydb_mark>#3184#%    7  %{

<tex2html_mydb_mark>#3185#%    8    # Treeregexp is the engine for tree transformations

<tex2html_mydb_mark>#3186#%    9    use Parse::Eyapp::Treeregexp;

<tex2html_mydb_mark>#3187#%   10    use Data::Dumper;

<tex2html_mydb_mark>#3188#%   11    $Data::Dumper::Indent = 1;

<tex2html_mydb_mark>#3189#%   12    $Data::Dumper::Deepcopy = 1;

<tex2html_mydb_mark>#3190#%   13    $Data::Dumper::Deparse = 1;

<tex2html_mydb_mark>#3191#%   14  %}

<tex2html_mydb_mark>#3192#%   15

<tex2html_mydb_mark>#3193#%   16  %metatree

<tex2html_mydb_mark>#3194#%   17

<tex2html_mydb_mark>#3195#%   18  %defaultaction {

<tex2html_mydb_mark>#3196#%   19    if (@_==4) { # binary operations: 4 = lhs, left, operand, right

<tex2html_mydb_mark>#3197#%   20      $lhs-;SPMgt;{t} = ;SPMquot;$_[1]-;SPMgt;{t} $_[3]-;SPMgt;{t} $_[2]-;SPMgt;{attr};SPMquot;;

<tex2html_mydb_mark>#3198#%   21      return

<tex2html_mydb_mark>#3199#%   22    }

<tex2html_mydb_mark>#3200#%   23    die ;SPMquot;Fatal Error. Unexpected input\n;SPMquot;.Dumper(@_);

<tex2html_mydb_mark>#3201#%   24  }

<tex2html_mydb_mark>#3202#%   25

<tex2html_mydb_mark>#3203#%   26  %%

<tex2html_mydb_mark>#3204#%   27  line: %name PROG

<tex2html_mydb_mark>#3205#%   28         exp ;SPMlt;%name EXP + ';';SPMgt;

<tex2html_mydb_mark>#3206#%   29           { @{$lhs-;SPMgt;{t}} = map { $_-;SPMgt;{t}} ($lhs-;SPMgt;child(0)-;SPMgt;Children()); }

<tex2html_mydb_mark>#3207#%   30

<tex2html_mydb_mark>#3208#%   31  ;

<tex2html_mydb_mark>#3209#%   32

<tex2html_mydb_mark>#3210#%   33  exp:      %name NUM     NUM         { $lhs-;SPMgt;{t} = $_[1]-;SPMgt;{attr}; }

<tex2html_mydb_mark>#3211#%   34          | %name VAR     VAR         { $lhs-;SPMgt;{t} = $_[1]-;SPMgt;{attr}; }

<tex2html_mydb_mark>#3212#%   35          | %name ASSIGN  VAR '=' exp { $lhs-;SPMgt;{t} = ;SPMquot;$_[1]-;SPMgt;{attr} $_[3]-;SPMgt;{t} =;SPMquot; }

<tex2html_mydb_mark>#3213#%   36          | %name PLUS    exp '+' exp

<tex2html_mydb_mark>#3214#%   37          | %name MINUS   exp '-' exp

<tex2html_mydb_mark>#3215#%   38          | %name TIMES   exp '*' exp

<tex2html_mydb_mark>#3216#%   39          | %name DIV     exp '/' exp

<tex2html_mydb_mark>#3217#%   40          | %name UMINUS  '-' exp %prec NEG { $_[0]-;SPMgt;{t} = ;SPMquot;$_[2]-;SPMgt;{t} NEG;SPMquot; }

<tex2html_mydb_mark>#3218#%   41          |               '(' exp ')' %begin { $_[2] } /* skip parenthesis */

<tex2html_mydb_mark>#3219#%   42  ;

<tex2html_mydb_mark>#3220#%   43

<tex2html_mydb_mark>#3221#%   44  %%

<tex2html_mydb_mark>#3222#%   45

<tex2html_mydb_mark>#3223#%   46  # subroutines  _Error and _Lexer

<tex2html_mydb_mark>#3224#%   ..  ................................

<tex2html_mydb_mark>#3225#%   66

<tex2html_mydb_mark>#3226#%   67  sub Run {

<tex2html_mydb_mark>#3227#%   68      my($self)=shift;

<tex2html_mydb_mark>#3228#%   69      print ;SPMquot;input: ;SPMquot;; $x = ;SPMlt;;SPMgt;;

<tex2html_mydb_mark>#3229#%   70      my $tree = $self-;SPMgt;YYParse( yylex =;SPMgt; \&_Lexer, yyerror =;SPMgt; \&_Error,

<tex2html_mydb_mark>#3230#%   71        #yydebug =;SPMgt; 0xFF

<tex2html_mydb_mark>#3231#%   72      );

<tex2html_mydb_mark>#3232#%   73

<tex2html_mydb_mark>#3233#%   74      my $transform = Parse::Eyapp::Treeregexp-;SPMgt;new( STRING =;SPMgt; q{

<tex2html_mydb_mark>#3234#%   75

<tex2html_mydb_mark>#3235#%   76        delete_code : CODE =;SPMgt; { $delete_code-;SPMgt;delete() }

<tex2html_mydb_mark>#3236#%   77

<tex2html_mydb_mark>#3237#%   78        {

<tex2html_mydb_mark>#3238#%   79          sub not_semantic {

<tex2html_mydb_mark>#3239#%   80            my $self = shift;

<tex2html_mydb_mark>#3240#%   81            return  1 if $self-;SPMgt;{token} eq $self-;SPMgt;{attr};

<tex2html_mydb_mark>#3241#%   82            return 0;

<tex2html_mydb_mark>#3242#%   83          }

<tex2html_mydb_mark>#3243#%   84        }

<tex2html_mydb_mark>#3244#%   85

<tex2html_mydb_mark>#3245#%   86        delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =;SPMgt; { $delete_tokens-;SPMgt;delete() }

<tex2html_mydb_mark>#3246#%   87

<tex2html_mydb_mark>#3247#%   88        delete = delete_code delete_tokens;

<tex2html_mydb_mark>#3248#%   89

<tex2html_mydb_mark>#3249#%   90        uminus: UMINUS(., NUM($x), .) =;SPMgt; { $x-;SPMgt;{attr} = -$x-;SPMgt;{attr}; $_[0] = $NUM }

<tex2html_mydb_mark>#3250#%   91

<tex2html_mydb_mark>#3251#%   92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))

<tex2html_mydb_mark>#3252#%   93           =;SPMgt; {

<tex2html_mydb_mark>#3253#%   94          $x-;SPMgt;{attr} = eval  ;SPMquot;$x-;SPMgt;{attr} $W-;SPMgt;{attr} $y-;SPMgt;{attr};SPMquot;;

<tex2html_mydb_mark>#3254#%   95          $_[0] = $NUM[0];

<tex2html_mydb_mark>#3255#%   96        }

<tex2html_mydb_mark>#3256#%   97

<tex2html_mydb_mark>#3257#%   98        zero_times: TIMES(NUM($x), ., .) and { $x-;SPMgt;{attr} == 0 } =;SPMgt; { $_[0] = $NUM }

<tex2html_mydb_mark>#3258#%   99        times_zero: TIMES(., ., NUM($x)) and { $x-;SPMgt;{attr} == 0 } =;SPMgt; { $_[0] = $NUM }

<tex2html_mydb_mark>#3259#%  100

<tex2html_mydb_mark>#3260#%  101        algebraic_transformations = constantfold zero_times times_zero;

<tex2html_mydb_mark>#3261#%  102

<tex2html_mydb_mark>#3262#%  103      },

<tex2html_mydb_mark>#3263#%  104      PACKAGE =;SPMgt; 'TSwithtreetransformations',

<tex2html_mydb_mark>#3264#%  105      OUTPUTFILE =;SPMgt; 'main.pm',

<tex2html_mydb_mark>#3265#%  106      SEVERITY =;SPMgt; 0,

<tex2html_mydb_mark>#3266#%  107      NUMBERS =;SPMgt; 0,

<tex2html_mydb_mark>#3267#%  108      );

<tex2html_mydb_mark>#3268#%  109

<tex2html_mydb_mark>#3269#%  110      # Create the transformer

<tex2html_mydb_mark>#3270#%  111      $transform-;SPMgt;generate();

<tex2html_mydb_mark>#3271#%  112      # Get the AST

<tex2html_mydb_mark>#3272#%  113

<tex2html_mydb_mark>#3273#%  114      our ($uminus);

<tex2html_mydb_mark>#3274#%  115      $uminus-;SPMgt;s($tree);

<tex2html_mydb_mark>#3275#%  116

<tex2html_mydb_mark>#3276#%  117      our (@algebraic_transformations);

<tex2html_mydb_mark>#3277#%  118      $tree-;SPMgt;s(@algebraic_transformations);

<tex2html_mydb_mark>#3278#%  119

<tex2html_mydb_mark>#3279#%  120      $tree-;SPMgt;translation_scheme();

<tex2html_mydb_mark>#3280#%  121

<tex2html_mydb_mark>#3281#%  122      our (@delete);

<tex2html_mydb_mark>#3282#%  123      $tree-;SPMgt;s(@delete);

<tex2html_mydb_mark>#3283#%  124      print Dumper($tree);

<tex2html_mydb_mark>#3284#%  125  }

<tex2html_mydb_mark>#3285#% \end{verbatim}

<tex2html_mydb_mark>#3286#% 

<tex2html_mydb_mark>#3287#% \paragraph{La Estructura de un Programa {\tt Treeregexp}}

<tex2html_mydb_mark>#3288#% 

<tex2html_mydb_mark>#3289#% La estructura de un programa \tei{Treeregexp} es sencilla. Consiste en la repetición

<tex2html_mydb_mark>#3290#% de tres tipos de expresiones regulares árbol: las \cei{treeregexp} propiamente

<tex2html_mydb_mark>#3291#% dichas, \cei{código auxiliar para las transformaciones} y 

<tex2html_mydb_mark>#3292#% \cei{definiciones de familias de transformaciones}.

<tex2html_mydb_mark>#3293#% 

<tex2html_mydb_mark>#3294#% \begin{verbatim}

<tex2html_mydb_mark>#3295#% treeregexplist:  

<tex2html_mydb_mark>#3296#%     treeregexp* 

<tex2html_mydb_mark>#3297#% ;

<tex2html_mydb_mark>#3298#% 

<tex2html_mydb_mark>#3299#% treeregexp: 

<tex2html_mydb_mark>#3300#%     IDENT ':' treereg ('=;SPMgt;' CODE)?  # Treeregexp 

<tex2html_mydb_mark>#3301#%   | CODE                            # Código auxiliar

<tex2html_mydb_mark>#3302#%   | IDENT '=' IDENT + ';'           # Familia de transformaciones

<tex2html_mydb_mark>#3303#% ;

<tex2html_mydb_mark>#3304#% \end{verbatim}

<tex2html_mydb_mark>#3305#% 

<tex2html_mydb_mark>#3306#% Las expresiones regulares árbol propiamente dichas siguen la regla 

<tex2html_mydb_mark>#3307#% 

<tex2html_mydb_mark>#3308#% \begin{verbatim}

<tex2html_mydb_mark>#3309#%                   IDENT ':' treereg ('=;SPMgt;' CODE)?

<tex2html_mydb_mark>#3310#% \end{verbatim}

<tex2html_mydb_mark>#3311#% 

<tex2html_mydb_mark>#3312#% Podemos ver ejemplos de instancias de esta regla en las líneas 

<tex2html_mydb_mark>#3313#% 76, 86, 90, 92-96, 98 y 99. El identificador \verb|IDENT| da el nombre

<tex2html_mydb_mark>#3314#% a la regla. Actualmente (2006) existen estos tipos de \tei{treereg}:

<tex2html_mydb_mark>#3315#% 

<tex2html_mydb_mark>#3316#% \begin{verbatim}

<tex2html_mydb_mark>#3317#% treereg: 

<tex2html_mydb_mark>#3318#%       /* patrones con hijos */

<tex2html_mydb_mark>#3319#%     IDENT '(' childlist ')' ('and' CODE)? 

<tex2html_mydb_mark>#3320#%   | REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)? 

<tex2html_mydb_mark>#3321#%   | SCALAR '(' childlist ')' ('and' CODE)?  

<tex2html_mydb_mark>#3322#%   | '.' '(' childlist ')' ('and' CODE)? 

<tex2html_mydb_mark>#3323#%         /* hojas */

<tex2html_mydb_mark>#3324#%   | IDENT ('and' CODE)? 

<tex2html_mydb_mark>#3325#%   | REGEXP (':' IDENT)? ('and' CODE)? 

<tex2html_mydb_mark>#3326#%   | '.' ('and' CODE)? 

<tex2html_mydb_mark>#3327#%   | SCALAR ('and' CODE)? 

<tex2html_mydb_mark>#3328#%   | ARRAY 

<tex2html_mydb_mark>#3329#%   | '*' 

<tex2html_mydb_mark>#3330#% \end{verbatim}

<tex2html_mydb_mark>#3331#% 

<tex2html_mydb_mark>#3332#% \paragraph{Las Reglas Treeregexp}

<tex2html_mydb_mark>#3333#% 

<tex2html_mydb_mark>#3334#% Una regla como

<tex2html_mydb_mark>#3335#% \begin{verbatim}

<tex2html_mydb_mark>#3336#%             zero_times: TIMES(NUM($x), ., .) and { $x-;SPMgt;{attr} == 0 } =;SPMgt; { $_[0] = $NUM }

<tex2html_mydb_mark>#3337#% \end{verbatim}

<tex2html_mydb_mark>#3338#% crea un objeto transformación (concretamente un objeto de la clase \tei{Parse::Eyapp:YATW})

<tex2html_mydb_mark>#3339#% que puede ser referido a través de la variable escalar \verb|$zero_times|.

<tex2html_mydb_mark>#3340#% La primera parte de la regla \verb|zero_times| indica que 

<tex2html_mydb_mark>#3341#% para que se produzca el emparejamiento es necesario que el nodo visitado sea

<tex2html_mydb_mark>#3342#% del tipo \verb|TIMES| y su primer

<tex2html_mydb_mark>#3343#% hijo es de tipo \verb|NUM|. Una referencia al nodo hijo de \verb|NUM| será automáticamente

<tex2html_mydb_mark>#3344#% guardada en la variable \underline{léxica} \verb|$x|. 

<tex2html_mydb_mark>#3345#% 

<tex2html_mydb_mark>#3346#% \paragraph{Escalares}

<tex2html_mydb_mark>#3347#% 

<tex2html_mydb_mark>#3348#% El efecto de un escalar en una treeregexp 

<tex2html_mydb_mark>#3349#% es casar con cualquier nodo y almacenar su referencia en la variable.

<tex2html_mydb_mark>#3350#% 

<tex2html_mydb_mark>#3351#% La aparición de \verb|$x| en la treeregexp anterior 

<tex2html_mydb_mark>#3352#% casará con cualquier nodo. La referencia al nodo que ha casado queda en \verb|$x|.

<tex2html_mydb_mark>#3353#% Asi \verb|$x| podrá ser usado en el \cei{patrón árbol semántico} 

<tex2html_mydb_mark>#3354#% o \cei{condición semántica}(esto es,

<tex2html_mydb_mark>#3355#% en el código opcional que va precedido de la palabra reservada \verb|and|) 

<tex2html_mydb_mark>#3356#% y en la \cei{acción de transformación árbol} (el código opcional que va precedido de la 

<tex2html_mydb_mark>#3357#% flecha gorda \verb|=;SPMgt;|).

<tex2html_mydb_mark>#3358#% 

<tex2html_mydb_mark>#3359#% \paragraph{El Punto}

<tex2html_mydb_mark>#3360#% 

<tex2html_mydb_mark>#3361#% Un punto también casa con cualquier nodo. Puede verse como una abreviación de 

<tex2html_mydb_mark>#3362#% la expresión regular árbol escalar. Una referencia al nodo que casa

<tex2html_mydb_mark>#3363#% queda almacenada en la variable

<tex2html_mydb_mark>#3364#% léxica especial \tei{\$W}. Si la expresión regular árbol tiene

<tex2html_mydb_mark>#3365#% varios puntos sus referencias quedan almacenadas en la variable array \verb|@W|.

<tex2html_mydb_mark>#3366#% Es un error usar el identificador \verb|W| en una expresión regular escalar 

<tex2html_mydb_mark>#3367#% escalar. Por ejemplo, una treeregexp como:

<tex2html_mydb_mark>#3368#% 

<tex2html_mydb_mark>#3369#% \begin{verbatim}

<tex2html_mydb_mark>#3370#% constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($W), ., NUM($y))

<tex2html_mydb_mark>#3371#% \end{verbatim}

<tex2html_mydb_mark>#3372#% 

<tex2html_mydb_mark>#3373#% da lugar al error:

<tex2html_mydb_mark>#3374#% 

<tex2html_mydb_mark>#3375#% \begin{verbatim}

<tex2html_mydb_mark>#3376#% *Error* Can't use $W to identify an scalar treeregexp at line 100.

<tex2html_mydb_mark>#3377#% \end{verbatim}

<tex2html_mydb_mark>#3378#% 

<tex2html_mydb_mark>#3379#% \paragraph{Condiciones Semánticas}

<tex2html_mydb_mark>#3380#% 

<tex2html_mydb_mark>#3381#% \emph{La segunda parte de la regla} es opcional y comienza con la palabra reservada \verb|and|

<tex2html_mydb_mark>#3382#% seguida de un código que \emph{explicita las condiciones semánticas que debe cumplir el nodo

<tex2html_mydb_mark>#3383#% para que se produzca el casamiento}. En el ejemplo se explicita que el attributo del nodo 

<tex2html_mydb_mark>#3384#% (forzosamente del tipo \verb|TERMINAL| en este caso) referenciado por \verb|$x| debe ser cero.

<tex2html_mydb_mark>#3385#% 

<tex2html_mydb_mark>#3386#% \paragraph{Referenciado de los Nodos del Arbol}

<tex2html_mydb_mark>#3387#% 

<tex2html_mydb_mark>#3388#% Es posible dentro de las partes de código referirse a los nodos del árbol.

<tex2html_mydb_mark>#3389#% Cuando la rutina de transformación generada por el compilador para una 

<tex2html_mydb_mark>#3390#% treeregexp es llamada, el primer argumento \verb|$_[0]| contiene la referencia al nodo 

<tex2html_mydb_mark>#3391#% que esta siendo visitado. 

<tex2html_mydb_mark>#3392#% 

<tex2html_mydb_mark>#3393#% \verb|Parse::Eyapp::Treeregexp| crea variables léxicas con nombres

<tex2html_mydb_mark>#3394#% los tipos de los nodos a los que referencian. 

<tex2html_mydb_mark>#3395#% Así la subrutina generada para la transformación \verb|zero_times| 

<tex2html_mydb_mark>#3396#% 

<tex2html_mydb_mark>#3397#% \begin{verbatim}

<tex2html_mydb_mark>#3398#%      zero_times: TIMES(NUM($x), ., .) and { $x-;SPMgt;{attr} == 0 } =;SPMgt; { $_[0] = $NUM }

<tex2html_mydb_mark>#3399#% \end{verbatim}

<tex2html_mydb_mark>#3400#% 

<tex2html_mydb_mark>#3401#% guarda en la variable lexica \verb|$TIMES| una copia de \verb|$_[0]| y en 

<tex2html_mydb_mark>#3402#% la variable léxica \verb|$NUM| una referencia al nodo \verb|$TIMES-;SPMgt;child(0)| .

<tex2html_mydb_mark>#3403#% 

<tex2html_mydb_mark>#3404#% Si un tipo de nodo se repite en la treeregexp la variable léxica

<tex2html_mydb_mark>#3405#% asociada con dicho tipo se autodeclara como un array. Este es el caso de 

<tex2html_mydb_mark>#3406#% la transformación \verb|constantfold|

<tex2html_mydb_mark>#3407#% en la cual aparecen dos nodos de tipo \verb|NUM|:

<tex2html_mydb_mark>#3408#% \begin{verbatim}

<tex2html_mydb_mark>#3409#% 92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))

<tex2html_mydb_mark>#3410#% 93           =;SPMgt; {

<tex2html_mydb_mark>#3411#% 94          $x-;SPMgt;{attr} = eval  ;SPMquot;$x-;SPMgt;{attr} $W-;SPMgt;{attr} $y-;SPMgt;{attr};SPMquot;;

<tex2html_mydb_mark>#3412#% 95          $_[0] = $NUM[0];

<tex2html_mydb_mark>#3413#% 96        }

<tex2html_mydb_mark>#3414#% \end{verbatim}

<tex2html_mydb_mark>#3415#% La variable \verb|@NUM| es automáticamente declarada: \verb|$NUM[0]| es una

<tex2html_mydb_mark>#3416#% referencia al primer nodo \verb|NUM| y \verb|$NUM[1]| es una referencia

<tex2html_mydb_mark>#3417#% al segundo.

<tex2html_mydb_mark>#3418#% 

<tex2html_mydb_mark>#3419#% \paragraph{Código de Transformación}

<tex2html_mydb_mark>#3420#% 

<tex2html_mydb_mark>#3421#% \emph{La tercera parte de la regla} es también opcional y viene precedida de la \cei{flecha gorda}.

<tex2html_mydb_mark>#3422#% Habitualmente {contiene el código que transforma el árbol}.

<tex2html_mydb_mark>#3423#% Para lograr la modificación del nodo del árbol visitado el programador

<tex2html_mydb_mark>#3424#% \verb|Treeregexp| deberá usar \verb|$_[0]|. Recuerde que

<tex2html_mydb_mark>#3425#% los elementos en \verb|@_| son alias de los argumentos. Si el código 

<tex2html_mydb_mark>#3426#% de la tercera parte fuera reescrito como:

<tex2html_mydb_mark>#3427#% \begin{verbatim}

<tex2html_mydb_mark>#3428#%                             { $TIMES = $NUM }

<tex2html_mydb_mark>#3429#% \end{verbatim}

<tex2html_mydb_mark>#3430#% no funcionaría ya que estaríamos modificando la variable léxica que referencia al

<tex2html_mydb_mark>#3431#% nodo raíz del subarbol que ha casado.

<tex2html_mydb_mark>#3432#% 

<tex2html_mydb_mark>#3433#% \paragraph{Expresiones Regulares}

<tex2html_mydb_mark>#3434#% Es posible usar una expresión regular clásica lineal (\cei{regexp}) para 

<tex2html_mydb_mark>#3435#% explicitar el tipo de un nodo como indica la regla de producción:

<tex2html_mydb_mark>#3436#% 

<tex2html_mydb_mark>#3437#% \begin{verbatim}

<tex2html_mydb_mark>#3438#%       treereg: REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)? 

<tex2html_mydb_mark>#3439#% \end{verbatim}

<tex2html_mydb_mark>#3440#% 

<tex2html_mydb_mark>#3441#% La treeregexp para el plegado de constantes constituye un ejemplo:

<tex2html_mydb_mark>#3442#% 

<tex2html_mydb_mark>#3443#% \begin{verbatim}

<tex2html_mydb_mark>#3444#%   92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))

<tex2html_mydb_mark>#3445#%   93           =;SPMgt; {

<tex2html_mydb_mark>#3446#%   94                $x-;SPMgt;{attr} = eval  ;SPMquot;$x-;SPMgt;{attr} $W-;SPMgt;{attr} $y-;SPMgt;{attr};SPMquot;;

<tex2html_mydb_mark>#3447#%   95                $_[0] = $NUM[0];

<tex2html_mydb_mark>#3448#%   96              }

<tex2html_mydb_mark>#3449#% \end{verbatim}

<tex2html_mydb_mark>#3450#% 

<tex2html_mydb_mark>#3451#% La expresión regular deberá especificarse entre barras de división (\verb|/|)

<tex2html_mydb_mark>#3452#% y es posible especificar opciones después del segundo slash (\verb|e|, \verb|i|, etc.).

<tex2html_mydb_mark>#3453#% El identificador opcional después de la regexp indica el nombre para la

<tex2html_mydb_mark>#3454#% variable léxica que almacenará una copia de la referencia al nodo del árbol.

<tex2html_mydb_mark>#3455#% En el ejemplo \verb|$bin| podría usarse para referenciar al nodo apuntado por \verb|$_[0]|.

<tex2html_mydb_mark>#3456#% Si no se especifica identificador quedará almacenado en la variable léxica

<tex2html_mydb_mark>#3457#% especial \verb|$W|.  Si la expresión regular árbol tiene

<tex2html_mydb_mark>#3458#% varias regexp (y/o puntos) sus referencias quedan almacenadas en la variable array \verb|@W|.

<tex2html_mydb_mark>#3459#% 

<tex2html_mydb_mark>#3460#% \paragraph{Familias de Transformaciones}

<tex2html_mydb_mark>#3461#% Las transformaciones creadas por \verb|Parse::Eyapp::Treeregexp| pueden agruparse por familias.

<tex2html_mydb_mark>#3462#% Esta es la función de la regla de producción:

<tex2html_mydb_mark>#3463#% \begin{verbatim}

<tex2html_mydb_mark>#3464#%                     treeregexp: IDENT '=' IDENT + ';' 

<tex2html_mydb_mark>#3465#% \end{verbatim}

<tex2html_mydb_mark>#3466#% En el ejemplo creamos una nueva familia denominada \verb|algebraic_transformations|

<tex2html_mydb_mark>#3467#% mediante la asignación de la línea 101:

<tex2html_mydb_mark>#3468#% \begin{verbatim}

<tex2html_mydb_mark>#3469#% algebraic_transformations = constantfold zero_times times_zero;

<tex2html_mydb_mark>#3470#% \end{verbatim}

<tex2html_mydb_mark>#3471#% Las transformaciones en esa familia pueden ser accedidas posteriormente

<tex2html_mydb_mark>#3472#% para su aplicación mediante la

<tex2html_mydb_mark>#3473#% variable de paquete \verb|@algebraic_transformations| (véanse las líneas 

<tex2html_mydb_mark>#3474#% 117-118).

<tex2html_mydb_mark>#3475#% 

<tex2html_mydb_mark>#3476#% \paragraph{Codigo de Apoyo}

<tex2html_mydb_mark>#3477#% En medio de la definición de cualquier regla treeregexp es posible insertar 

<tex2html_mydb_mark>#3478#% código de apoyo siempre que se sitúe entre llaves:

<tex2html_mydb_mark>#3479#% 

<tex2html_mydb_mark>#3480#% \begin{verbatim}

<tex2html_mydb_mark>#3481#%   78        {

<tex2html_mydb_mark>#3482#%   79          sub not_semantic {

<tex2html_mydb_mark>#3483#%   80            my $self = shift;

<tex2html_mydb_mark>#3484#%   81            return  1 if $self-;SPMgt;{token} eq $self-;SPMgt;{attr};

<tex2html_mydb_mark>#3485#%   82            return 0;

<tex2html_mydb_mark>#3486#%   83          }

<tex2html_mydb_mark>#3487#%   84        }

<tex2html_mydb_mark>#3488#%   85

<tex2html_mydb_mark>#3489#%   86        delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =;SPMgt; { $delete_tokens-;SPMgt;delete() }

<tex2html_mydb_mark>#3490#% \end{verbatim}

<tex2html_mydb_mark>#3491#% 

<tex2html_mydb_mark>#3492#% \paragraph{El método {\tt delete} de los objetos {\tt YATW}}

<tex2html_mydb_mark>#3493#% 

<tex2html_mydb_mark>#3494#% Los objetos de la clase \tei{Parse::Eyapp::YATW} como \verb|$delete_tokens| disponen

<tex2html_mydb_mark>#3495#% de un método \tei{delete} que permite eliminar con seguridad un hijo de la raíz del 

<tex2html_mydb_mark>#3496#% subárbol que ha casado. En este caso los nodos que casan son los de la clase \verb|TERMINAL| 

<tex2html_mydb_mark>#3497#% en los que el valor de la clave \verb|token| coincide con el valor de la clave \verb|attr|.

<tex2html_mydb_mark>#3498#% 

<tex2html_mydb_mark>#3499#% \paragraph{Fases en la Ejecución de un Programa {\tt Treeregexp}}

<tex2html_mydb_mark>#3500#% Un programa {\tt Treeregexp} puede - como en el ejemplo - proporcionarse como una

<tex2html_mydb_mark>#3501#% cadena de entrada al método \verb|new| de la clase \verb|Parse::Eyapp::Treeregexp|

<tex2html_mydb_mark>#3502#% o bien escribirse en un fichero separado (la extensión \verb|.trg| es usada por

<tex2html_mydb_mark>#3503#% defecto) y compilado con el script \tei{treereg} que acompaña a la distribución de

<tex2html_mydb_mark>#3504#% \verb|Parse::Eyapp|.

<tex2html_mydb_mark>#3505#% 

<tex2html_mydb_mark>#3506#% La primera fase en la ejecución de un programa \tei{Treeregexp}

<tex2html_mydb_mark>#3507#% es la \cei{fase de creación del paquete {\tt Treeregexp}}

<tex2html_mydb_mark>#3508#% que contendrá las subrutinas

<tex2html_mydb_mark>#3509#% de reconocimiento de los patrones árbol definidos en el programa {\tt Treeregexp}.

<tex2html_mydb_mark>#3510#% En el ejemplo esta fase tiene lugar en las líneas

<tex2html_mydb_mark>#3511#% 74-111 con las llamadas a \verb|new| (que crea el objeto programa {\tt Treeregexp})

<tex2html_mydb_mark>#3512#% y \tei{generate} (que crea el paquete conteniendo las subrutinas reconocedoras).

<tex2html_mydb_mark>#3513#% \begin{verbatim}

<tex2html_mydb_mark>#3514#%   74      my $transform = Parse::Eyapp::Treeregexp-;SPMgt;new( STRING =;SPMgt; q{

<tex2html_mydb_mark>#3515#%   75

<tex2html_mydb_mark>#3516#%   76        delete_code : CODE =;SPMgt; { $delete_code-;SPMgt;delete() }

<tex2html_mydb_mark>#3517#%  ...        ................................................

<tex2html_mydb_mark>#3518#%  103      },

<tex2html_mydb_mark>#3519#%  104      PACKAGE =;SPMgt; 'TSwithtreetransformations',

<tex2html_mydb_mark>#3520#%  105      OUTPUTFILE =;SPMgt; 'main.pm',

<tex2html_mydb_mark>#3521#%  106      SEVERITY =;SPMgt; 0,

<tex2html_mydb_mark>#3522#%  107      NUMBERS =;SPMgt; 0,

<tex2html_mydb_mark>#3523#%  108      );

<tex2html_mydb_mark>#3524#%  109

<tex2html_mydb_mark>#3525#%  110      # Create the transformer

<tex2html_mydb_mark>#3526#%  111      $transform-;SPMgt;generate();

<tex2html_mydb_mark>#3527#% \end{verbatim}

<tex2html_mydb_mark>#3528#% 

<tex2html_mydb_mark>#3529#% Durante esta fase se crea un \cei{objeto transformación} i(perteneciente a la clase \tei{Parse::Eyapp::YATW})

<tex2html_mydb_mark>#3530#% por cada expresión regular árbol que aparece en el programa {\tt Treeregexp}.

<tex2html_mydb_mark>#3531#% Las variables contenedor de cada uno de esos objetos tienen por nombre el que se

<tex2html_mydb_mark>#3532#% les dió a las correspondientes expresiones regulares árbol. En nuestro ejemplo, y después

<tex2html_mydb_mark>#3533#% de esta fase habrán sido creadas variables escalares de paquete 

<tex2html_mydb_mark>#3534#% \verb|$delete_tokens|, \verb|$delete|, \verb|$uminus|, \verb|$constantfold|, \verb|$zero_times| 

<tex2html_mydb_mark>#3535#% y \verb|$times_zero|

<tex2html_mydb_mark>#3536#% asociadas con cada una de las expresiones regulares árbol definidas.

<tex2html_mydb_mark>#3537#% También se crearán variables array para cada una de las

<tex2html_mydb_mark>#3538#% familias de transformaciones especificadas: Asi  la variable

<tex2html_mydb_mark>#3539#% \verb|@delete| contiene \verb|($delete_tokens, $delete)| y la variable

<tex2html_mydb_mark>#3540#% \verb|@algebraic_transformations|

<tex2html_mydb_mark>#3541#% es igual a \verb|($constantfold, $zero_times, $times_zero)|. La variable de paquete especial

<tex2html_mydb_mark>#3542#% \verb|@all| es un array que contiene todas las transformaciones definidas en el programa.

<tex2html_mydb_mark>#3543#% 

<tex2html_mydb_mark>#3544#% Una vez creados los objetos transformación y las familias de transformaciones

<tex2html_mydb_mark>#3545#% \verb|Parse::Eyapp::YATW| podemos proceder a transformar el árbol

<tex2html_mydb_mark>#3546#% mediante su uso.

<tex2html_mydb_mark>#3547#% Esto puede hacerse mediante el método \tei{s} el cual procede 

<tex2html_mydb_mark>#3548#% a modificar el árbol pasado como parámetro.

<tex2html_mydb_mark>#3549#% \begin{verbatim}

<tex2html_mydb_mark>#3550#%  114      our ($uminus);

<tex2html_mydb_mark>#3551#%  115      $uminus-;SPMgt;s($tree);

<tex2html_mydb_mark>#3552#% \end{verbatim}

<tex2html_mydb_mark>#3553#% En el ejemplo la llamada \verb|$uminus-;SPMgt;s($tree)| da lugar al 

<tex2html_mydb_mark>#3554#% recorrido  primero-profundo de \verb|$tree|. Cada vez que un nodo 

<tex2html_mydb_mark>#3555#% casa con la regla:

<tex2html_mydb_mark>#3556#% \begin{verbatim}

<tex2html_mydb_mark>#3557#% UMINUS(., NUM($x), .) # first child is '-', second the number and third the code

<tex2html_mydb_mark>#3558#% \end{verbatim}

<tex2html_mydb_mark>#3559#% se le aplica la transformación:

<tex2html_mydb_mark>#3560#% \begin{verbatim}

<tex2html_mydb_mark>#3561#% { $x-;SPMgt;{attr} = -$x-;SPMgt;{attr}; $_[0] = $NUM }

<tex2html_mydb_mark>#3562#% \end{verbatim}

<tex2html_mydb_mark>#3563#% Esta transformación hace que el nodo \verb|UMINUS| visitado sea sustituido 

<tex2html_mydb_mark>#3564#% por un nodo de tipo \verb|NUM| cuyo atributo sea el número de su hijo

<tex2html_mydb_mark>#3565#% \verb|NUM| cambiado de signo.

<tex2html_mydb_mark>#3566#% 

<tex2html_mydb_mark>#3567#% Las líneas 117-118 nos muestran como someter un árbol a un conjunto 

<tex2html_mydb_mark>#3568#% de transformaciones:

<tex2html_mydb_mark>#3569#% \begin{verbatim}

<tex2html_mydb_mark>#3570#%  117      our (@algebraic_transformations);

<tex2html_mydb_mark>#3571#%  118      $tree-;SPMgt;s(@algebraic_transformations);

<tex2html_mydb_mark>#3572#% \end{verbatim}

<tex2html_mydb_mark>#3573#% Los objetos nodo (esto es, los que pertenecen a la clase \tei{Parse::Eyapp::Node})

<tex2html_mydb_mark>#3574#% disponen del método \tei{s} que recibe como argumentos una familia de 

<tex2html_mydb_mark>#3575#% transformaciones. La familia de transformaciones es aplicada iterativamente

<tex2html_mydb_mark>#3576#% al árbol hasta que este no cambia. 

<tex2html_mydb_mark>#3577#% 

<tex2html_mydb_mark>#3578#% Nótese que consecuencia de esta definición es que es posible escribir transformaciones

<tex2html_mydb_mark>#3579#% que dan lugar a bucles infinitos. Por ejemplo si en \verb|@algebraic_transformations|

<tex2html_mydb_mark>#3580#% incluimos una transformación que aplique las propiedades conmutativas de la 

<tex2html_mydb_mark>#3581#% suma:

<tex2html_mydb_mark>#3582#% \begin{verbatim}

<tex2html_mydb_mark>#3583#%  commutative_add: PLUS($x, ., $y, .)

<tex2html_mydb_mark>#3584#%         =;SPMgt; { my $t = $x; $_[0]-;SPMgt;child(0, $y); $_[0]-;SPMgt;child(2, $t)}

<tex2html_mydb_mark>#3585#% \end{verbatim}

<tex2html_mydb_mark>#3586#% el programa podría caer en un bucle infinito ya que la transformación es

<tex2html_mydb_mark>#3587#% susceptible de ser aplicada indefinidamente. Sin embargo no se produce bucle infinito

<tex2html_mydb_mark>#3588#% si llamamos al código asociado a la transformación:

<tex2html_mydb_mark>#3589#% \begin{verbatim}

<tex2html_mydb_mark>#3590#% $commutative_add-;SPMgt;($tree);

<tex2html_mydb_mark>#3591#% \end{verbatim}

<tex2html_mydb_mark>#3592#% 

<tex2html_mydb_mark>#3593#% ya que en este caso se produce un sólo recursivo descendente aplicando la transformación

<tex2html_mydb_mark>#3594#% \verb|$commutative_add|.

<tex2html_mydb_mark>#3595#% 

<tex2html_mydb_mark>#3596#% El uso de transformaciones conmutativas no tiene porque dar lugar a 

<tex2html_mydb_mark>#3597#% la no finalización del programa. La parada del programa se puede

<tex2html_mydb_mark>#3598#% garantizar si \emph{podemos asegurar que la aplicación reiterada

<tex2html_mydb_mark>#3599#% del patrón implica la desaparición del mismo}. Por ejemplo,

<tex2html_mydb_mark>#3600#% la transformación \verb|comasocfold| puede ser añadida

<tex2html_mydb_mark>#3601#% a la familia \verb|algebraic_transformations| sin introducir

<tex2html_mydb_mark>#3602#% problemas de parada:

<tex2html_mydb_mark>#3603#% \begin{verbatim}

<tex2html_mydb_mark>#3604#% comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))

<tex2html_mydb_mark>#3605#%    =;SPMgt; {

<tex2html_mydb_mark>#3606#%   $x-;SPMgt;{attr} = $x-;SPMgt;{attr} * $y-;SPMgt;{attr};

<tex2html_mydb_mark>#3607#%   $_[0] = $DIV;

<tex2html_mydb_mark>#3608#% }

<tex2html_mydb_mark>#3609#% 

<tex2html_mydb_mark>#3610#% algebraic_transformations = constantfold zero_times times_zero comasocfold;

<tex2html_mydb_mark>#3611#% \end{verbatim}

<tex2html_mydb_mark>#3612#% La introducción de esta transformación permite el plegado de entradas como \verb|a=2;b=2/a*3|:

<tex2html_mydb_mark>#3613#% \begin{verbatim}

<tex2html_mydb_mark>#3614#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; usetswithtreetransformations3.pl

<tex2html_mydb_mark>#3615#% a=2;b=2/a*3

<tex2html_mydb_mark>#3616#% $VAR1 = bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3617#%     bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3618#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3619#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3620#%             bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3621#%                 bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 2, 'token' =;SPMgt; 'NUM' }, 'TERMINAL' ) ],

<tex2html_mydb_mark>#3622#%               't' =;SPMgt; 2

<tex2html_mydb_mark>#3623#%             }, 'NUM' )

<tex2html_mydb_mark>#3624#%           ],

<tex2html_mydb_mark>#3625#%           't' =;SPMgt; 'a 2 ='

<tex2html_mydb_mark>#3626#%         }, 'ASSIGN' ),

<tex2html_mydb_mark>#3627#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3628#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3629#%             bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3630#%                 bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3631#%                     bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 6, 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3632#%                   ],

<tex2html_mydb_mark>#3633#%                   't' =;SPMgt; 6

<tex2html_mydb_mark>#3634#%                 }, 'NUM' ),

<tex2html_mydb_mark>#3635#%                 bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3636#%                     bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3637#%                   ],

<tex2html_mydb_mark>#3638#%                   't' =;SPMgt; 'a'

<tex2html_mydb_mark>#3639#%                 }, 'VAR' )

<tex2html_mydb_mark>#3640#%               ],

<tex2html_mydb_mark>#3641#%               't' =;SPMgt; '6 a /'

<tex2html_mydb_mark>#3642#%             }, 'DIV' )

<tex2html_mydb_mark>#3643#%           ],

<tex2html_mydb_mark>#3644#%           't' =;SPMgt; 'b 6 a / ='

<tex2html_mydb_mark>#3645#%         }, 'ASSIGN' )

<tex2html_mydb_mark>#3646#%       ]

<tex2html_mydb_mark>#3647#%     }, 'EXP' )

<tex2html_mydb_mark>#3648#%   ],

<tex2html_mydb_mark>#3649#%   't' =;SPMgt; [ 'a 2 =', 'b 6 a / =' ]

<tex2html_mydb_mark>#3650#% }, 'PROG' );

<tex2html_mydb_mark>#3651#% \end{verbatim}

<tex2html_mydb_mark>#3652#% 

<tex2html_mydb_mark>#3653#% \paragraph{Ejecución del Ejemplo}

<tex2html_mydb_mark>#3654#% 

<tex2html_mydb_mark>#3655#% Una vez compilado el analizador, escribimos 

<tex2html_mydb_mark>#3656#% el programa que usa el módulo generado:

<tex2html_mydb_mark>#3657#% \begin{verbatim}

<tex2html_mydb_mark>#3658#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n usetswithtreetransformations.pl

<tex2html_mydb_mark>#3659#%      1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#3660#%      2  use strict;

<tex2html_mydb_mark>#3661#%      3  use TSwithtreetransformations;

<tex2html_mydb_mark>#3662#%      4  use Parse::Eyapp::Treeregexp;

<tex2html_mydb_mark>#3663#%      5

<tex2html_mydb_mark>#3664#%      6  my $parser = TSwithtreetransformations-;SPMgt;new();

<tex2html_mydb_mark>#3665#%      7  $parser-;SPMgt;Run;

<tex2html_mydb_mark>#3666#% \end{verbatim}

<tex2html_mydb_mark>#3667#% Al ejecutarlo obtenemos la siguiente salida:

<tex2html_mydb_mark>#3668#% \begin{verbatim}

<tex2html_mydb_mark>#3669#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; eyapp TSwithtreetransformations.eyp ; \\ 

<tex2html_mydb_mark>#3670#%                                                    usetswithtreetransformations.pl

<tex2html_mydb_mark>#3671#% input: a=2*-3;b=a*(2-1-1);c=a+b

<tex2html_mydb_mark>#3672#% $VAR1 = bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3673#%     bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3674#%     |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3675#%     |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3676#%     |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3677#%     |   |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; -6, 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3678#%     |   |   | ],

<tex2html_mydb_mark>#3679#%     |   |   | 't' =;SPMgt; -6

<tex2html_mydb_mark>#3680#%     |   |   }, 'NUM' )

<tex2html_mydb_mark>#3681#%     |   | ],

<tex2html_mydb_mark>#3682#%     |   | 't' =;SPMgt; 'a -6 ='

<tex2html_mydb_mark>#3683#%     |   }, 'ASSIGN' ),

<tex2html_mydb_mark>#3684#%     |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3685#%     |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3686#%     |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3687#%     |   |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 0, 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3688#%     |   |   | ],

<tex2html_mydb_mark>#3689#%     |   |   | 't' =;SPMgt; 0

<tex2html_mydb_mark>#3690#%     |   |   }, 'NUM' )

<tex2html_mydb_mark>#3691#%     |   | ],

<tex2html_mydb_mark>#3692#%     |   | 't' =;SPMgt; 'b 0 ='

<tex2html_mydb_mark>#3693#%     |   }, 'ASSIGN' ),

<tex2html_mydb_mark>#3694#%     |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3695#%     |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'c', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3696#%     |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3697#%     |   |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3698#%     |   |   |       bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3699#%     |   |   |     ],

<tex2html_mydb_mark>#3700#%     |   |   |     't' =;SPMgt; 'a'

<tex2html_mydb_mark>#3701#%     |   |   |   }, 'VAR' ),

<tex2html_mydb_mark>#3702#%     |   |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3703#%     |   |   |       bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3704#%     |   |   |     ],

<tex2html_mydb_mark>#3705#%     |   |   |     't' =;SPMgt; 'b'

<tex2html_mydb_mark>#3706#%     |   |   |   }, 'VAR' )

<tex2html_mydb_mark>#3707#%     |   |   | ],

<tex2html_mydb_mark>#3708#%     |   |   | 't' =;SPMgt; 'a b +'

<tex2html_mydb_mark>#3709#%     |   |   }, 'PLUS' )

<tex2html_mydb_mark>#3710#%     |   | ],

<tex2html_mydb_mark>#3711#%     |   | 't' =;SPMgt; 'c a b + ='

<tex2html_mydb_mark>#3712#%     |   }, 'ASSIGN' )

<tex2html_mydb_mark>#3713#%     | ]

<tex2html_mydb_mark>#3714#%     }, 'EXP' )

<tex2html_mydb_mark>#3715#%   ],

<tex2html_mydb_mark>#3716#%   't' =;SPMgt; [ 'a -6 =', 'b 0 =', 'c a b + =' ]

<tex2html_mydb_mark>#3717#% }, 'PROG' );

<tex2html_mydb_mark>#3718#% \end{verbatim}

<tex2html_mydb_mark>#3719#% Como puede verse la traducción de la frase de

<tex2html_mydb_mark>#3720#% entrada \verb|a=2*-3;b=a*(2-1-1);c=a+b| 

<tex2html_mydb_mark>#3721#% queda como atributo \verb|t| del nodo raíz \verb|PROG|.

<tex2html_mydb_mark>#3722#% 

<tex2html_mydb_mark>#3723#% \paragraph{Expresiones Regulares Arbol Array}

<tex2html_mydb_mark>#3724#% Una expresión regular árbol array se escribe insertando un array Perl

<tex2html_mydb_mark>#3725#% en la expresión regular árbol, por ejemplo \verb|@a|. 

<tex2html_mydb_mark>#3726#% Una \cei{expresión regular árbol array} \verb|@a| casa con la secuencia mas corta de hijos del nodo

<tex2html_mydb_mark>#3727#% tal que la siguiente expresión regular árbol (\underline{no array}) casa. 

<tex2html_mydb_mark>#3728#% La lista de nodos

<tex2html_mydb_mark>#3729#% que han casado con la expresión regular árbol array quedará en la variable

<tex2html_mydb_mark>#3730#% léxica \verb|@a|. 

<tex2html_mydb_mark>#3731#% Por ejemplo, despúes de un casamiento de un árbol \verb|$t| con la expresión regular árbol 

<tex2html_mydb_mark>#3732#% \verb|BLOCK(@a, ASSIGN($x, $e), @b)|, la variable léxica  

<tex2html_mydb_mark>#3733#% \verb|@a| contendrá la lista de nodos hijos de  \verb|$t| 

<tex2html_mydb_mark>#3734#% que precede a la primera aparición de \verb|ASSIGN($x, $e)|.

<tex2html_mydb_mark>#3735#% Si no 

<tex2html_mydb_mark>#3736#% existe expresión regular árbol siguiente - el caso de \verb|@b| en el ejemplo -

<tex2html_mydb_mark>#3737#% la expresión regular

<tex2html_mydb_mark>#3738#% array casará con todos los nodos hijo a partir del último casamiento (\underline{no array}). 

<tex2html_mydb_mark>#3739#% Asi \verb|@b| contendrá la lista de referencias a los nodos hijos

<tex2html_mydb_mark>#3740#% de \verb|$t| posteriores al nodo \verb|ASSIGN($x, $e)|.

<tex2html_mydb_mark>#3741#% 

<tex2html_mydb_mark>#3742#% Es \underline{ilegal} escribir dos expresiones regulares arbol array

<tex2html_mydb_mark>#3743#% seguidas (por ejemplo \verb|A(@a, @b)|).

<tex2html_mydb_mark>#3744#% 

<tex2html_mydb_mark>#3745#% El siguiente ejemplo muestra como usar las expresiones árbol array 

<tex2html_mydb_mark>#3746#% para mover las asignaciones invariantes de un bucle fuera

<tex2html_mydb_mark>#3747#% del mismo (líneas 104-116):

<tex2html_mydb_mark>#3748#% 

<tex2html_mydb_mark>#3749#% \begin{verbatim}

<tex2html_mydb_mark>#3750#% nereida:~/src/perl/YappWithDefaultAction/t;SPMgt; cat -n 34moveinvariantoutofloopcomplexformula.t

<tex2html_mydb_mark>#3751#%   1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#3752#%   2  use strict;

<tex2html_mydb_mark>#3753#%   5  use Parse::Eyapp;

<tex2html_mydb_mark>#3754#%   6  use Data::Dumper;

<tex2html_mydb_mark>#3755#%   7  use Parse::Eyapp::Treeregexp;

<tex2html_mydb_mark>#3756#%   8

<tex2html_mydb_mark>#3757#%   9  my $grammar = q{

<tex2html_mydb_mark>#3758#%  10  %{

<tex2html_mydb_mark>#3759#%  11  use Data::Dumper;

<tex2html_mydb_mark>#3760#%  12  %}

<tex2html_mydb_mark>#3761#%  13  %right  '='

<tex2html_mydb_mark>#3762#%  14  %left   '-' '+'

<tex2html_mydb_mark>#3763#%  15  %left   '*' '/'

<tex2html_mydb_mark>#3764#%  16  %left   NEG

<tex2html_mydb_mark>#3765#%  17  %tree

<tex2html_mydb_mark>#3766#%  18

<tex2html_mydb_mark>#3767#%  19  %%

<tex2html_mydb_mark>#3768#%  20  block:  exp ;SPMlt;%name BLOCK + ';';SPMgt; { $_[1] }

<tex2html_mydb_mark>#3769#%  21  ;

<tex2html_mydb_mark>#3770#%  22

<tex2html_mydb_mark>#3771#%  23  exp:      %name NUM

<tex2html_mydb_mark>#3772#%  24              NUM

<tex2html_mydb_mark>#3773#%  25          | %name WHILE

<tex2html_mydb_mark>#3774#%  26              'while'   exp  '{' block '}'

<tex2html_mydb_mark>#3775#%  27          | %name VAR

<tex2html_mydb_mark>#3776#%  28              VAR

<tex2html_mydb_mark>#3777#%  29          | %name ASSIGN

<tex2html_mydb_mark>#3778#%  30              VAR '=' exp

<tex2html_mydb_mark>#3779#%  31          | %name PLUS

<tex2html_mydb_mark>#3780#%  32              exp '+' exp

<tex2html_mydb_mark>#3781#%  33          | %name MINUS

<tex2html_mydb_mark>#3782#%  34              exp '-' exp

<tex2html_mydb_mark>#3783#%  35          | %name TIMES

<tex2html_mydb_mark>#3784#%  36              exp '*' exp

<tex2html_mydb_mark>#3785#%  37          | %name DIV

<tex2html_mydb_mark>#3786#%  38              exp '/' exp

<tex2html_mydb_mark>#3787#%  39          | %name UMINUS

<tex2html_mydb_mark>#3788#%  40              '-' exp %prec NEG

<tex2html_mydb_mark>#3789#%  41          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */

<tex2html_mydb_mark>#3790#%  42  ;

<tex2html_mydb_mark>#3791#%  43

<tex2html_mydb_mark>#3792#%  44  %%

<tex2html_mydb_mark>#3793#%  ..  .......................................................................

<tex2html_mydb_mark>#3794#%  87  }; # end grammar

<tex2html_mydb_mark>#3795#%  88

<tex2html_mydb_mark>#3796#%  ..    ..................

<tex2html_mydb_mark>#3797#%  99  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMquot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n;SPMquot;;

<tex2html_mydb_mark>#3798#% 100  my $t = $parser-;SPMgt;Run;

<tex2html_mydb_mark>#3799#% 101  print ;SPMquot;\n***** Before ******\n;SPMquot;;

<tex2html_mydb_mark>#3800#% 102  print Dumper($t);

<tex2html_mydb_mark>#3801#% 104  my $p = Parse::Eyapp::Treeregexp-;SPMgt;new( STRING =;SPMgt; q{

<tex2html_mydb_mark>#3802#% 105    moveinvariant: 

<tex2html_mydb_mark>#3803#% 106      BLOCK(@prests, WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)), @possts )

<tex2html_mydb_mark>#3804#% 107        and { is_invariant($ASSIGN, $WHILE) } /* Check if ASSIGN is invariant relative */

<tex2html_mydb_mark>#3805#% 108      =;SPMgt; {                                    /* to the while loop                     */

<tex2html_mydb_mark>#3806#% 109           my $assign = $ASSIGN;   

<tex2html_mydb_mark>#3807#% 110           $BLOCK[1]-;SPMgt;delete($ASSIGN);

<tex2html_mydb_mark>#3808#% 111           $BLOCK[0]-;SPMgt;insert_before($WHILE, $assign);

<tex2html_mydb_mark>#3809#% 112         }

<tex2html_mydb_mark>#3810#% 113    },

<tex2html_mydb_mark>#3811#% 114    #outputfile =;SPMgt; 'main.pm',

<tex2html_mydb_mark>#3812#% 115    firstline =;SPMgt; 104,

<tex2html_mydb_mark>#3813#% 116  );

<tex2html_mydb_mark>#3814#% \end{verbatim}

<tex2html_mydb_mark>#3815#% Al ejecutar el programa con la entrada

<tex2html_mydb_mark>#3816#% \verb|;SPMquot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n;SPMquot;|

<tex2html_mydb_mark>#3817#% obtenemos el árbol modificado:

<tex2html_mydb_mark>#3818#% \begin{verbatim}

<tex2html_mydb_mark>#3819#% bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3820#%     bless( { 'children' =;SPMgt; [ # a = 1000

<tex2html_mydb_mark>#3821#%     |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3822#%     |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3823#%     |       bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '1000', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3824#%     |     ]

<tex2html_mydb_mark>#3825#%     |   }, 'NUM' )

<tex2html_mydb_mark>#3826#%     | ]

<tex2html_mydb_mark>#3827#%     }, 'ASSIGN' ),

<tex2html_mydb_mark>#3828#%     bless( { 'children' =;SPMgt; [ # c = 1

<tex2html_mydb_mark>#3829#%     |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'c', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3830#%     |   bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '1', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3831#%     |     ]

<tex2html_mydb_mark>#3832#%     |   }, 'NUM' )

<tex2html_mydb_mark>#3833#%     | ]

<tex2html_mydb_mark>#3834#%     }, 'ASSIGN' ),

<tex2html_mydb_mark>#3835#%     bless( { 'children' =;SPMgt; [ # b = 5 moved out of loop

<tex2html_mydb_mark>#3836#%     |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3837#%     |   bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '5', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3838#%     |     ]

<tex2html_mydb_mark>#3839#%     |   }, 'NUM' )

<tex2html_mydb_mark>#3840#%     | ]

<tex2html_mydb_mark>#3841#%     }, 'ASSIGN' ),

<tex2html_mydb_mark>#3842#%     bless( { 'children' =;SPMgt; [ # while

<tex2html_mydb_mark>#3843#%     |   bless( { 'children' =;SPMgt; [ #   ( a )

<tex2html_mydb_mark>#3844#%     |       bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3845#%     |     ]

<tex2html_mydb_mark>#3846#%     |   }, 'VAR' ),

<tex2html_mydb_mark>#3847#%     |   bless( { 'children' =;SPMgt; [ # BLOCK {}

<tex2html_mydb_mark>#3848#%     |   |   bless( { 'children' =;SPMgt; [ # c = c * a

<tex2html_mydb_mark>#3849#%     |   |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'c', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3850#%     |   |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3851#%     |   |   |       bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3852#%     |   |   |           bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'c', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3853#%     |   |   |         ]

<tex2html_mydb_mark>#3854#%     |   |   |       }, 'VAR' ),

<tex2html_mydb_mark>#3855#%     |   |   |       bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3856#%     |   |   |           bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3857#%     |   |   |         ]

<tex2html_mydb_mark>#3858#%     |   |   |       }, 'VAR' )

<tex2html_mydb_mark>#3859#%     |   |   |     ]

<tex2html_mydb_mark>#3860#%     |   |   |   }, 'TIMES' )

<tex2html_mydb_mark>#3861#%     |   |   | ]

<tex2html_mydb_mark>#3862#%     |   |   }, 'ASSIGN' ),

<tex2html_mydb_mark>#3863#%     |   |   bless( { 'children' =;SPMgt; [ # a = a - 1

<tex2html_mydb_mark>#3864#%     |   |   |   bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#3865#%     |   |   |   bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3866#%     |   |   |       bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3867#%     |   |   |           bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#3868#%     |   |   |         ]

<tex2html_mydb_mark>#3869#%     |   |   |       }, 'VAR' ),

<tex2html_mydb_mark>#3870#%     |   |   |       bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#3871#%     |   |   |           bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '1', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#3872#%     |   |   |         ]

<tex2html_mydb_mark>#3873#%     |   |   |       }, 'NUM' )

<tex2html_mydb_mark>#3874#%     |   |   |     ]

<tex2html_mydb_mark>#3875#%     |   |   |   }, 'MINUS' )

<tex2html_mydb_mark>#3876#%     |   |   | ]

<tex2html_mydb_mark>#3877#%     |   |   }, 'ASSIGN' )

<tex2html_mydb_mark>#3878#%     |   | ]

<tex2html_mydb_mark>#3879#%     |   }, 'BLOCK' )

<tex2html_mydb_mark>#3880#%     | ]

<tex2html_mydb_mark>#3881#%     }, 'WHILE' )

<tex2html_mydb_mark>#3882#%   ]

<tex2html_mydb_mark>#3883#% }, 'BLOCK' );

<tex2html_mydb_mark>#3884#% \end{verbatim}

<tex2html_mydb_mark>#3885#% 

<tex2html_mydb_mark>#3886#% \paragraph{Expresión regular árbol estrella}

<tex2html_mydb_mark>#3887#% Una \cei{expresión regular árbol estrella} casa con la secuencia mas corta de hijos del nodos

<tex2html_mydb_mark>#3888#% tal que la siguiente expresión regular árbol casa. Si no

<tex2html_mydb_mark>#3889#% existe expresión regular árbol siguiente - esto es, la expresión regular

<tex2html_mydb_mark>#3890#% estrella es la última de la lista como en \verb|A(B(C,.), *)|- la expresión regular

<tex2html_mydb_mark>#3891#% estrella casará con todos los nodos hijo a partir del último casamiento.

<tex2html_mydb_mark>#3892#% Una expresión regular árbol array se escribe insertando el símbolo \verb|*|

<tex2html_mydb_mark>#3893#% en la expresión regular árbol. Las listas de nodos

<tex2html_mydb_mark>#3894#% que han casado con la expresiones regulares árbol estrella quedaran en las variables

<tex2html_mydb_mark>#3895#% léxicas \verb|@W_0|, \verb|@W_1|, \verb|@W_2|, etc.

<tex2html_mydb_mark>#3896#% En este sentido una expresión regular árbol estrella no es mas que

<tex2html_mydb_mark>#3897#% una abreviación para la expresión regular árbol \verb|@W_#| 

<tex2html_mydb_mark>#3898#% siendo \verb|#| el número de orden de aparición.

<tex2html_mydb_mark>#3899#% 

<tex2html_mydb_mark>#3900#% \paragraph{Parámetros Pasados a una Subrutina de Transformación Árbol}

<tex2html_mydb_mark>#3901#% Como se ha mencionado anteriormente el compilador de expresiones

<tex2html_mydb_mark>#3902#% regulares árbol traduce cada transformación árbol en una subrutina Perl.

<tex2html_mydb_mark>#3903#% Con mayor precisión: se crea un objeto \verb|Parse::Eyapp:YATW| que es el

<tex2html_mydb_mark>#3904#% encargado de gestionar la transformación. Para que una subrutina pueda

<tex2html_mydb_mark>#3905#% ser convertida en un objeto YATW deben ajustarse al \cei{Protocolo YATW de LLamada}. 

<tex2html_mydb_mark>#3906#% Actualmente (2006) la subrutina asociada con un objeto YATW es llamada como sigue:

<tex2html_mydb_mark>#3907#% 

<tex2html_mydb_mark>#3908#% \begin{verbatim}

<tex2html_mydb_mark>#3909#%   pattern_sub(

<tex2html_mydb_mark>#3910#%         $_[0],  # Node being visited

<tex2html_mydb_mark>#3911#%         $_[1],  # Father of this node

<tex2html_mydb_mark>#3912#%         $index, # Index of this node in @Father-;SPMgt;children

<tex2html_mydb_mark>#3913#%         $self,  # The YATW pattern object

<tex2html_mydb_mark>#3914#%  );

<tex2html_mydb_mark>#3915#% \end{verbatim}

<tex2html_mydb_mark>#3916#% 

<tex2html_mydb_mark>#3917#% Los cuatro argumentos tienen el siguiente significado:

<tex2html_mydb_mark>#3918#% 

<tex2html_mydb_mark>#3919#% \begin{enumerate}

<tex2html_mydb_mark>#3920#% \item

<tex2html_mydb_mark>#3921#% El nódo del árbol que esta siendo visitado

<tex2html_mydb_mark>#3922#% \item

<tex2html_mydb_mark>#3923#% El padre de dicho nodo

<tex2html_mydb_mark>#3924#% \item

<tex2html_mydb_mark>#3925#% El índice del nodo (\verb|$_[0]|) en la lista de nodos del padre

<tex2html_mydb_mark>#3926#% \item

<tex2html_mydb_mark>#3927#% Una referencia al objeto YATW

<tex2html_mydb_mark>#3928#% \end{enumerate}

<tex2html_mydb_mark>#3929#% 

<tex2html_mydb_mark>#3930#% La subrutina debe devolver cierto (TRUE) si se produce matching

<tex2html_mydb_mark>#3931#% y falso en otro caso. Recuerde que el método \verb|s| de los nodos (no así 

<tex2html_mydb_mark>#3932#% el de los objetos YATW) permancerá aplicando las transformaciones

<tex2html_mydb_mark>#3933#% hasta que no se produzcan emparejamientos. Por tanto es importante 

<tex2html_mydb_mark>#3934#% asegurarse cuando se usa la forma \verb|$node-;SPMgt;s(@transformations)|

<tex2html_mydb_mark>#3935#% que la aplicación reiterada de las transformaciones conduce

<tex2html_mydb_mark>#3936#% a situaciones en las que eventualmente las subrutinas retornan

<tex2html_mydb_mark>#3937#% el valor falso.

<tex2html_mydb_mark>#3938#% 

<tex2html_mydb_mark>#3939#% Es posible que el protocolo de llamada YATW cambie en un futuro próximo.

<tex2html_mydb_mark>#3940#% 

<tex2html_mydb_mark>#3941#% %TODO: examples que figuran en el tutorial en MANIFEST

<tex2html_mydb_mark>#3942#% %TODO: las opciones de new

<tex2html_mydb_mark>#3943#% 

<tex2html_mydb_mark>#3944#% \section{Árbol Sintáctico Abstracto con {\tt Parse::Eyapp}}

<tex2html_mydb_mark>#3945#% 

<tex2html_mydb_mark>#3946#% \paragraph{La directiva {\tt \%tree}}

<tex2html_mydb_mark>#3947#% La directiva \tei{\%tree} permite que {\tt Parse::Eyapp}

<tex2html_mydb_mark>#3948#% genere al árbol sintáctico. Haciendo uso de las directivas

<tex2html_mydb_mark>#3949#% adecuadas podemos controlar la forma del árbol. La directiva

<tex2html_mydb_mark>#3950#% \verb|%tree| es una alternativa a la directiva \verb|%metatree|

<tex2html_mydb_mark>#3951#% y es incompatible con esta última. El objetivo es lograr

<tex2html_mydb_mark>#3952#% una representación adecuada del árbol sintáctico y dejar

<tex2html_mydb_mark>#3953#% para fases posteriores la decoración del mismo.

<tex2html_mydb_mark>#3954#% 

<tex2html_mydb_mark>#3955#% \label{code:rule6}

<tex2html_mydb_mark>#3956#% \begin{verbatim}

<tex2html_mydb_mark>#3957#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n Rule6.yp

<tex2html_mydb_mark>#3958#%  1  %{

<tex2html_mydb_mark>#3959#%  2  use Data::Dumper;

<tex2html_mydb_mark>#3960#%  3  %}

<tex2html_mydb_mark>#3961#%  4  %right  '='

<tex2html_mydb_mark>#3962#%  5  %left   '-' '+'

<tex2html_mydb_mark>#3963#%  6  %left   '*' '/'

<tex2html_mydb_mark>#3964#%  7  %left   NEG

<tex2html_mydb_mark>#3965#%  8  %tree

<tex2html_mydb_mark>#3966#%  9

<tex2html_mydb_mark>#3967#% 10  %%

<tex2html_mydb_mark>#3968#% 11  line: exp  { $_[1] }

<tex2html_mydb_mark>#3969#% 12  ;

<tex2html_mydb_mark>#3970#% 13

<tex2html_mydb_mark>#3971#% 14  exp:      %name NUM

<tex2html_mydb_mark>#3972#% 15              NUM

<tex2html_mydb_mark>#3973#% 16          | %name VAR

<tex2html_mydb_mark>#3974#% 17            VAR

<tex2html_mydb_mark>#3975#% 18          | %name ASSIGN

<tex2html_mydb_mark>#3976#% 19            VAR '=' exp

<tex2html_mydb_mark>#3977#% 20          | %name PLUS

<tex2html_mydb_mark>#3978#% 21            exp '+' exp

<tex2html_mydb_mark>#3979#% 22          | %name MINUS

<tex2html_mydb_mark>#3980#% 23            exp '-' exp

<tex2html_mydb_mark>#3981#% 24          | %name TIMES

<tex2html_mydb_mark>#3982#% 25            exp '*' exp

<tex2html_mydb_mark>#3983#% 26          | %name DIV

<tex2html_mydb_mark>#3984#% 27            exp '/' exp

<tex2html_mydb_mark>#3985#% 28          | %name UMINUS

<tex2html_mydb_mark>#3986#% 29            '-' exp %prec NEG

<tex2html_mydb_mark>#3987#% 30          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */

<tex2html_mydb_mark>#3988#% 31  ;

<tex2html_mydb_mark>#3989#% 32

<tex2html_mydb_mark>#3990#% 33  %%

<tex2html_mydb_mark>#3991#% 34

<tex2html_mydb_mark>#3992#% 35  sub _Error {

<tex2html_mydb_mark>#3993#% ..    ..........

<tex2html_mydb_mark>#3994#% 43  }

<tex2html_mydb_mark>#3995#% 44

<tex2html_mydb_mark>#3996#% 45  sub _Lexer {

<tex2html_mydb_mark>#3997#% ..    ..........

<tex2html_mydb_mark>#3998#% 62  }

<tex2html_mydb_mark>#3999#% 63

<tex2html_mydb_mark>#4000#% 64  sub Run {

<tex2html_mydb_mark>#4001#% 65      my($self)=shift;

<tex2html_mydb_mark>#4002#% 66      $self-;SPMgt;YYParse( yylex =;SPMgt; \&_Lexer, yyerror =;SPMgt; \&_Error,

<tex2html_mydb_mark>#4003#% 67                      #yyprefix =;SPMgt; ;SPMquot;Rule6::;SPMquot;,

<tex2html_mydb_mark>#4004#% 68                      #yydebug =;SPMgt;0xFF

<tex2html_mydb_mark>#4005#% 69                    );

<tex2html_mydb_mark>#4006#% 70  }

<tex2html_mydb_mark>#4007#% \end{verbatim}

<tex2html_mydb_mark>#4008#% 

<tex2html_mydb_mark>#4009#% \paragraph{Compilación Separada}

<tex2html_mydb_mark>#4010#% Para compilar un programa separado \tei{Parse::Eyapp} usamos el guión \tei{eyapp}:

<tex2html_mydb_mark>#4011#% \begin{verbatim}

<tex2html_mydb_mark>#4012#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; eyapp Rule6

<tex2html_mydb_mark>#4013#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; ls -ltr | tail -1

<tex2html_mydb_mark>#4014#% -rw-rw----  1 pl users   5475 2006-11-06 13:53 Rule6.pm

<tex2html_mydb_mark>#4015#% \end{verbatim}

<tex2html_mydb_mark>#4016#% 

<tex2html_mydb_mark>#4017#% \paragraph{Terminales sintácticos y Terminales Semánticos}

<tex2html_mydb_mark>#4018#% A diferencia de lo que ocurre cuando se usa la directiva \tei{\%metatree}

<tex2html_mydb_mark>#4019#% la construcción del árbol solicitado mediante la directiva \tei{\%tree}

<tex2html_mydb_mark>#4020#% implícitamente considera token sintácticos aquellos terminales que aparecen en 

<tex2html_mydb_mark>#4021#% definidos en el programa \verb|eyapp| mediante el uso de apóstrofes.

<tex2html_mydb_mark>#4022#% Los token sintácticos no forman parte del árbol construido.

<tex2html_mydb_mark>#4023#% Asi pues -en el ejemplo que nos ocupa - los terminales \verb|'='|,

<tex2html_mydb_mark>#4024#% \verb|'-'|,

<tex2html_mydb_mark>#4025#% \verb|'+'|,

<tex2html_mydb_mark>#4026#% \verb|'*'| y

<tex2html_mydb_mark>#4027#% \verb|'/'|

<tex2html_mydb_mark>#4028#% serán -por defecto - eliminados del árbol sintáctico. 

<tex2html_mydb_mark>#4029#% Por ejemplo, para la entrada \verb|a=b*32| el siguiente árbol es construido:

<tex2html_mydb_mark>#4030#% \begin{verbatim}

<tex2html_mydb_mark>#4031#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; useruleandshift.pl

<tex2html_mydb_mark>#4032#% a=b*32

<tex2html_mydb_mark>#4033#% $VAR1 = bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4034#%     bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#4035#%     bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4036#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4037#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#4038#%           ]

<tex2html_mydb_mark>#4039#%         }, 'VAR' ),

<tex2html_mydb_mark>#4040#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4041#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '32', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#4042#%           ]

<tex2html_mydb_mark>#4043#%         }, 'NUM' )

<tex2html_mydb_mark>#4044#%       ]

<tex2html_mydb_mark>#4045#%     }, 'TIMES' )

<tex2html_mydb_mark>#4046#%   ]

<tex2html_mydb_mark>#4047#% }, 'ASSIGN' );

<tex2html_mydb_mark>#4048#% \end{verbatim}

<tex2html_mydb_mark>#4049#% Esta conducta puede cambiarse usando la directiva \tei{\%semantic token}

<tex2html_mydb_mark>#4050#% la cual declara una lista de terminales como semánticos. En tal caso 

<tex2html_mydb_mark>#4051#% dichos terminales formarán parte del árbol construido. Si por el contrario

<tex2html_mydb_mark>#4052#% lo que queremos es cambiar el estatus de un terminal

<tex2html_mydb_mark>#4053#% - por ejemplo \verb|NUM| o \verb|ID| - a sintáctico usaremos

<tex2html_mydb_mark>#4054#% la directiva \tei{\%syntactic token}.

<tex2html_mydb_mark>#4055#% 

<tex2html_mydb_mark>#4056#% \paragraph{Compilación Separada de Transformaciones Arbol}

<tex2html_mydb_mark>#4057#% Como se mencionó en la sección anterior es también posible 

<tex2html_mydb_mark>#4058#% aislar el programa de transformaciones árbol en un fichero

<tex2html_mydb_mark>#4059#% separado. El tipo \verb|.trg| se asume por defecto.

<tex2html_mydb_mark>#4060#% El ejemplo que sigue sustituye nodos producto por un número potencia de

<tex2html_mydb_mark>#4061#% dos por nodos unarios de desplazamiento a izquierda. De este modo

<tex2html_mydb_mark>#4062#% facilitamos la tarea de la generación de un código mas eficiente:

<tex2html_mydb_mark>#4063#% 

<tex2html_mydb_mark>#4064#% \begin{verbatim}

<tex2html_mydb_mark>#4065#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n Shift.trg

<tex2html_mydb_mark>#4066#%  1  # File: Shift.trg

<tex2html_mydb_mark>#4067#%  2  {

<tex2html_mydb_mark>#4068#%  3    sub log2 {

<tex2html_mydb_mark>#4069#%  4      my $n = shift;

<tex2html_mydb_mark>#4070#%  5      return log($n)/log(2);

<tex2html_mydb_mark>#4071#%  6    }

<tex2html_mydb_mark>#4072#%  7

<tex2html_mydb_mark>#4073#%  8    my $power;

<tex2html_mydb_mark>#4074#%  9  }

<tex2html_mydb_mark>#4075#% 10  mult2shift: TIMES($e, NUM($m)) and { $power = log2($m-;SPMgt;{attr}); (1 ;SPMlt;;SPMlt; $power) == $m-;SPMgt;{attr} }

<tex2html_mydb_mark>#4076#% 11    =;SPMgt; {

<tex2html_mydb_mark>#4077#% 12      $_[0]-;SPMgt;delete(1);

<tex2html_mydb_mark>#4078#% 13      $_[0]-;SPMgt;{shift} = $power;

<tex2html_mydb_mark>#4079#% 14      bless $_[0], 'SHIFTLEFT';

<tex2html_mydb_mark>#4080#% 15    }

<tex2html_mydb_mark>#4081#% \end{verbatim}

<tex2html_mydb_mark>#4082#% Obsérvese que la variable léxica \verb|$power| es visible en la definición

<tex2html_mydb_mark>#4083#% de la transformación \verb|mult2shift|.

<tex2html_mydb_mark>#4084#% Compilamos el programa de transformaciones usando el guión \tei{treereg}:

<tex2html_mydb_mark>#4085#% \begin{verbatim}

<tex2html_mydb_mark>#4086#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; treereg Shift

<tex2html_mydb_mark>#4087#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; ls -ltr | tail -1

<tex2html_mydb_mark>#4088#% -rw-rw----  1 pl users   1405 2006-11-06 14:09 Shift.pm

<tex2html_mydb_mark>#4089#% \end{verbatim}

<tex2html_mydb_mark>#4090#% Como se ve, la compilación produce un módulo que \verb|Shift.pm|

<tex2html_mydb_mark>#4091#% que contiene el código de los

<tex2html_mydb_mark>#4092#% analizadores.

<tex2html_mydb_mark>#4093#% El código generado por la versión 0.2 de \tei{treereg} es el siguiente:

<tex2html_mydb_mark>#4094#% \begin{verbatim}

<tex2html_mydb_mark>#4095#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n Shift.pm

<tex2html_mydb_mark>#4096#%  1  package Shift;

<tex2html_mydb_mark>#4097#%  2

<tex2html_mydb_mark>#4098#%  3  # This module has been generated using Parse::Eyapp::Treereg

<tex2html_mydb_mark>#4099#%  4  # from file Shift.trg. Don't modify it.

<tex2html_mydb_mark>#4100#%  5  # Change Shift.trg instead.

<tex2html_mydb_mark>#4101#%  6  # Copyright (c) Casiano Rodriguez-Leon 2006. Universidad de La Laguna.

<tex2html_mydb_mark>#4102#%  7  # You may use it and distribute it under the terms of either

<tex2html_mydb_mark>#4103#%  8  # the GNU General Public License or the Artistic License,

<tex2html_mydb_mark>#4104#%  9  # as specified in the Perl README file.

<tex2html_mydb_mark>#4105#% 10

<tex2html_mydb_mark>#4106#% 11  use strict;

<tex2html_mydb_mark>#4107#% 12  use warnings;

<tex2html_mydb_mark>#4108#% 13  use Carp;

<tex2html_mydb_mark>#4109#% 14  use Parse::Eyapp::_TreeregexpSupport qw(until_first_match checknumchildren);

<tex2html_mydb_mark>#4110#% 15

<tex2html_mydb_mark>#4111#% 16  our @all = ( our $mult2shift, ) = Parse::Eyapp::YATW-;SPMgt;buildpatterns(\&mult2shift, );

<tex2html_mydb_mark>#4112#% 17

<tex2html_mydb_mark>#4113#% 18  #line 2 ;SPMquot;Shift.trg;SPMquot;

<tex2html_mydb_mark>#4114#% 19

<tex2html_mydb_mark>#4115#% 20    sub log2 {

<tex2html_mydb_mark>#4116#% 21      my $n = shift;

<tex2html_mydb_mark>#4117#% 22      return log($n)/log(2);

<tex2html_mydb_mark>#4118#% 23    }

<tex2html_mydb_mark>#4119#% 24

<tex2html_mydb_mark>#4120#% 25    my $power;

<tex2html_mydb_mark>#4121#% 26

<tex2html_mydb_mark>#4122#% 27    sub mult2shift {

<tex2html_mydb_mark>#4123#% 28      my $mult2shift = $_[3]; # reference to the YATW pattern object

<tex2html_mydb_mark>#4124#% 29      my $e;

<tex2html_mydb_mark>#4125#% 30      my $NUM;

<tex2html_mydb_mark>#4126#% 31      my $TIMES;

<tex2html_mydb_mark>#4127#% 32      my $m;

<tex2html_mydb_mark>#4128#% 33

<tex2html_mydb_mark>#4129#% 34      {

<tex2html_mydb_mark>#4130#% 35        my $child_index = 0;

<tex2html_mydb_mark>#4131#% 36

<tex2html_mydb_mark>#4132#% 37        return 0 unless (ref($TIMES = $_[$child_index]) eq 'TIMES');

<tex2html_mydb_mark>#4133#% 38        return 0 unless defined($e = $TIMES-;SPMgt;child(0+$child_index));

<tex2html_mydb_mark>#4134#% 39        return 0 unless (ref($NUM = $TIMES-;SPMgt;child(1+$child_index)) eq 'NUM');

<tex2html_mydb_mark>#4135#% 40        return 0 unless defined($m = $NUM-;SPMgt;child(0+$child_index));

<tex2html_mydb_mark>#4136#% 41        return 0 unless do

<tex2html_mydb_mark>#4137#% 42  #line 10 ;SPMquot;Shift.trg;SPMquot;

<tex2html_mydb_mark>#4138#% 43        { $power = log2($m-;SPMgt;{attr}); (1 ;SPMlt;;SPMlt; $power) == $m-;SPMgt;{attr} };

<tex2html_mydb_mark>#4139#% 44

<tex2html_mydb_mark>#4140#% 45      } # end block of child_index

<tex2html_mydb_mark>#4141#% 46  #line 11 ;SPMquot;Shift.trg;SPMquot;

<tex2html_mydb_mark>#4142#% 47      {

<tex2html_mydb_mark>#4143#% 48        $_[0]-;SPMgt;delete(1);

<tex2html_mydb_mark>#4144#% 49        $_[0]-;SPMgt;{shift} = $power;

<tex2html_mydb_mark>#4145#% 50        bless $_[0], 'SHIFTLEFT';

<tex2html_mydb_mark>#4146#% 51      }

<tex2html_mydb_mark>#4147#% 52    } # end of mult2shift

<tex2html_mydb_mark>#4148#% 53

<tex2html_mydb_mark>#4149#% 54  1;

<tex2html_mydb_mark>#4150#% \end{verbatim}

<tex2html_mydb_mark>#4151#% 

<tex2html_mydb_mark>#4152#% \paragraph{Uso de los Módulos Generados}

<tex2html_mydb_mark>#4153#% El programa de análisis se limita a cargar los dos módulos generados,

<tex2html_mydb_mark>#4154#% crear el analizador (línea 8), llamar al método \verb|Run| 

<tex2html_mydb_mark>#4155#% para crear el árbol y proceder a las sustituciones (línea 12):

<tex2html_mydb_mark>#4156#% \begin{verbatim}

<tex2html_mydb_mark>#4157#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n useruleandshift.pl

<tex2html_mydb_mark>#4158#%  1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#4159#%  2  use strict;

<tex2html_mydb_mark>#4160#%  3  use Rule6;

<tex2html_mydb_mark>#4161#%  4  use Data::Dumper;

<tex2html_mydb_mark>#4162#%  5  use Shift;

<tex2html_mydb_mark>#4163#%  6

<tex2html_mydb_mark>#4164#%  7  $Data::Dumper::Indent = 1;

<tex2html_mydb_mark>#4165#%  8  my $parser = new Rule6();

<tex2html_mydb_mark>#4166#%  9  my $t = $parser-;SPMgt;Run;

<tex2html_mydb_mark>#4167#% 10  print Dumper($t);

<tex2html_mydb_mark>#4168#% 11  print ;SPMquot;\n***********\n;SPMquot;;

<tex2html_mydb_mark>#4169#% 12  $t-;SPMgt;s(@Shift::all);

<tex2html_mydb_mark>#4170#% 13  print Dumper($t);

<tex2html_mydb_mark>#4171#% \end{verbatim}

<tex2html_mydb_mark>#4172#% Cuando alimentamos el programa con la entrada \verb|a=b*32| obtenemos la

<tex2html_mydb_mark>#4173#% siguiente salida:

<tex2html_mydb_mark>#4174#% \begin{verbatim}

<tex2html_mydb_mark>#4175#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; useruleandshift.pl

<tex2html_mydb_mark>#4176#% a=b*32

<tex2html_mydb_mark>#4177#% $VAR1 = bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4178#%     bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#4179#%     bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4180#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4181#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#4182#%           ]

<tex2html_mydb_mark>#4183#%         }, 'VAR' ),

<tex2html_mydb_mark>#4184#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4185#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; '32', 'token' =;SPMgt; 'NUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#4186#%           ]

<tex2html_mydb_mark>#4187#%         }, 'NUM' )

<tex2html_mydb_mark>#4188#%       ]

<tex2html_mydb_mark>#4189#%     }, 'TIMES' )

<tex2html_mydb_mark>#4190#%   ]

<tex2html_mydb_mark>#4191#% }, 'ASSIGN' );

<tex2html_mydb_mark>#4192#% 

<tex2html_mydb_mark>#4193#% ***********

<tex2html_mydb_mark>#4194#% $VAR1 = bless( {

<tex2html_mydb_mark>#4195#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#4196#%     bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' ),

<tex2html_mydb_mark>#4197#%     bless( {

<tex2html_mydb_mark>#4198#%       'shift' =;SPMgt; 5,

<tex2html_mydb_mark>#4199#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#4200#%         bless( { 'children' =;SPMgt; [

<tex2html_mydb_mark>#4201#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'b', 'token' =;SPMgt; 'VAR' }, 'TERMINAL' )

<tex2html_mydb_mark>#4202#%           ]

<tex2html_mydb_mark>#4203#%         }, 'VAR' )

<tex2html_mydb_mark>#4204#%       ]

<tex2html_mydb_mark>#4205#%     }, 'SHIFTLEFT' )

<tex2html_mydb_mark>#4206#%   ]

<tex2html_mydb_mark>#4207#% }, 'ASSIGN' );

<tex2html_mydb_mark>#4208#% \end{verbatim}

<tex2html_mydb_mark>#4209#% 

<tex2html_mydb_mark>#4210#% \section{La opción {\tt SEVERITY}}

<tex2html_mydb_mark>#4211#% La opción \tei{SEVERITY} del constructor \tei{Parse::Eyapp::Treeregexp::new}

<tex2html_mydb_mark>#4212#% controla la forma en la que se interpreta el éxito de un casamiento

<tex2html_mydb_mark>#4213#% en lo que se refiere al número de hijos del nodo.

<tex2html_mydb_mark>#4214#% Para ilustrar su uso consideremos el siguiente ejemplo que 

<tex2html_mydb_mark>#4215#% hace uso de \verb|Rule6| la gramática que fue introducida 

<tex2html_mydb_mark>#4216#% en la sección \ref{code:rule6} (página \pageref{code:rule6}).

<tex2html_mydb_mark>#4217#% \begin{verbatim}

<tex2html_mydb_mark>#4218#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; cat -n numchildren.pl

<tex2html_mydb_mark>#4219#%  1  #!/usr/bin/perl -w

<tex2html_mydb_mark>#4220#%  2  use strict;

<tex2html_mydb_mark>#4221#%  3  use Rule6;

<tex2html_mydb_mark>#4222#%  4  use Data::Dumper;

<tex2html_mydb_mark>#4223#%  5  use Parse::Eyapp::Treeregexp;

<tex2html_mydb_mark>#4224#%  6  use Parse::Eyapp::Node;

<tex2html_mydb_mark>#4225#%  7

<tex2html_mydb_mark>#4226#%  8  our @all;

<tex2html_mydb_mark>#4227#%  9  my $severity = shift || 0;

<tex2html_mydb_mark>#4228#% 10

<tex2html_mydb_mark>#4229#% 11  my $transform = Parse::Eyapp::Treeregexp-;SPMgt;new( STRING =;SPMgt; q{

<tex2html_mydb_mark>#4230#% 12    zero_times_whatever: TIMES(NUM($x)) and { $x-;SPMgt;{attr} == 0 } =;SPMgt; { $_[0] = $NUM }

<tex2html_mydb_mark>#4231#% 13  },

<tex2html_mydb_mark>#4232#% 14  SEVERITY =;SPMgt; $severity,

<tex2html_mydb_mark>#4233#% 15  );

<tex2html_mydb_mark>#4234#% 16

<tex2html_mydb_mark>#4235#% 17  $transform-;SPMgt;generate;

<tex2html_mydb_mark>#4236#% 18  $Data::Dumper::Indent = 1;

<tex2html_mydb_mark>#4237#% 19  my $parser = new Rule6();

<tex2html_mydb_mark>#4238#% 20  my $t = $parser-;SPMgt;Run;

<tex2html_mydb_mark>#4239#% 21  $t-;SPMgt;s(@all);

<tex2html_mydb_mark>#4240#% 22  print Dumper($t);

<tex2html_mydb_mark>#4241#% \end{verbatim}

<tex2html_mydb_mark>#4242#% Este programa obtiene el nivel de severidad a usar desde la línea de comandos

<tex2html_mydb_mark>#4243#% (línea 9). Nótese que la especificación de \verb|TIMES| 

<tex2html_mydb_mark>#4244#% en la transformación \verb|zero_times_whatever| este aparece con un único hijo.

<tex2html_mydb_mark>#4245#% Existen varias interpretaciones de la expresión que se corresponden con los

<tex2html_mydb_mark>#4246#% niveles de \tei{SEVERITY}: 

<tex2html_mydb_mark>#4247#% \begin{itemize}

<tex2html_mydb_mark>#4248#% \item

<tex2html_mydb_mark>#4249#% Quiero decir que tiene al menos un hijo. No me importa si tiene mas

<tex2html_mydb_mark>#4250#% \item

<tex2html_mydb_mark>#4251#% Para que case tiene que tener exactamente un hijo

<tex2html_mydb_mark>#4252#% \item

<tex2html_mydb_mark>#4253#% Para que case tiene que tener exactamente un hijo. Si aparece un nodo 

<tex2html_mydb_mark>#4254#% \verb|TIMES| con un número de hijos diferente quiero ser avisado

<tex2html_mydb_mark>#4255#% \item

<tex2html_mydb_mark>#4256#% Para que case tiene que tener exactamente un hijo. Si aparece un nodo 

<tex2html_mydb_mark>#4257#% \verb|TIMES| con un número de hijos diferente 

<tex2html_mydb_mark>#4258#% quiero que se considere un error 

<tex2html_mydb_mark>#4259#% (mis nodos tiene aridad fija)

<tex2html_mydb_mark>#4260#% \end{itemize}

<tex2html_mydb_mark>#4261#% En la siguiente ejecución

<tex2html_mydb_mark>#4262#% el nivel especificado es cero. La expresión \verb|0*2| casa y es modificada.

<tex2html_mydb_mark>#4263#% \begin{verbatim}

<tex2html_mydb_mark>#4264#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; numchildren.pl 0

<tex2html_mydb_mark>#4265#% 0*2

<tex2html_mydb_mark>#4266#% $VAR1 = bless( {

<tex2html_mydb_mark>#4267#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#4268#%     bless( {

<tex2html_mydb_mark>#4269#%       'children' =;SPMgt; [],

<tex2html_mydb_mark>#4270#%       'attr' =;SPMgt; 0,

<tex2html_mydb_mark>#4271#%       'token' =;SPMgt; 'NUM'

<tex2html_mydb_mark>#4272#%     }, 'TERMINAL' )

<tex2html_mydb_mark>#4273#%   ]

<tex2html_mydb_mark>#4274#% }, 'NUM' );

<tex2html_mydb_mark>#4275#% \end{verbatim}

<tex2html_mydb_mark>#4276#% En la siguiente ejecución el nivel especificado es uno.

<tex2html_mydb_mark>#4277#% La expresión \verb|0*2| no casa pero no se avisa ni se considera un 

<tex2html_mydb_mark>#4278#% error la presencia de un nodo \verb|TIMES| con una aridad distinta.

<tex2html_mydb_mark>#4279#% \begin{verbatim}

<tex2html_mydb_mark>#4280#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; numchildren.pl 1

<tex2html_mydb_mark>#4281#% 0*2

<tex2html_mydb_mark>#4282#% $VAR1 = bless( {

<tex2html_mydb_mark>#4283#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#4284#%     bless( {

<tex2html_mydb_mark>#4285#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#4286#%         bless( {

<tex2html_mydb_mark>#4287#%           'children' =;SPMgt; [],

<tex2html_mydb_mark>#4288#%           'attr' =;SPMgt; '0',

<tex2html_mydb_mark>#4289#%           'token' =;SPMgt; 'NUM'

<tex2html_mydb_mark>#4290#%         }, 'TERMINAL' )

<tex2html_mydb_mark>#4291#%       ]

<tex2html_mydb_mark>#4292#%     }, 'NUM' ),

<tex2html_mydb_mark>#4293#%     bless( {

<tex2html_mydb_mark>#4294#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#4295#%         bless( {

<tex2html_mydb_mark>#4296#%           'children' =;SPMgt; [],

<tex2html_mydb_mark>#4297#%           'attr' =;SPMgt; '2',

<tex2html_mydb_mark>#4298#%           'token' =;SPMgt; 'NUM'

<tex2html_mydb_mark>#4299#%         }, 'TERMINAL' )

<tex2html_mydb_mark>#4300#%       ]

<tex2html_mydb_mark>#4301#%     }, 'NUM' )

<tex2html_mydb_mark>#4302#%   ]

<tex2html_mydb_mark>#4303#% }, 'TIMES' );

<tex2html_mydb_mark>#4304#% \end{verbatim}

<tex2html_mydb_mark>#4305#% En la siguiente ejecución el nivel especificado es dos.

<tex2html_mydb_mark>#4306#% La expresión \verb|0*2| no casa y se avisa 

<tex2html_mydb_mark>#4307#% de la presencia de un nodo \verb|TIMES| con una aridad distinta:

<tex2html_mydb_mark>#4308#% \begin{verbatim}

<tex2html_mydb_mark>#4309#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; numchildren.pl 2

<tex2html_mydb_mark>#4310#% 0*2

<tex2html_mydb_mark>#4311#% Warning! found node TIMES with 2 children.

<tex2html_mydb_mark>#4312#% Expected 1 children (see line 12 of numchildren.pl);SPMquot;

<tex2html_mydb_mark>#4313#% $VAR1 = bless( {

<tex2html_mydb_mark>#4314#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#4315#%     bless( {

<tex2html_mydb_mark>#4316#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#4317#%         bless( {

<tex2html_mydb_mark>#4318#%           'children' =;SPMgt; [],

<tex2html_mydb_mark>#4319#%           'attr' =;SPMgt; '0',

<tex2html_mydb_mark>#4320#%           'token' =;SPMgt; 'NUM'

<tex2html_mydb_mark>#4321#%         }, 'TERMINAL' )

<tex2html_mydb_mark>#4322#%       ]

<tex2html_mydb_mark>#4323#%     }, 'NUM' ),

<tex2html_mydb_mark>#4324#%     bless( {

<tex2html_mydb_mark>#4325#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#4326#%         bless( {

<tex2html_mydb_mark>#4327#%           'children' =;SPMgt; [],

<tex2html_mydb_mark>#4328#%           'attr' =;SPMgt; '2',

<tex2html_mydb_mark>#4329#%           'token' =;SPMgt; 'NUM'

<tex2html_mydb_mark>#4330#%         }, 'TERMINAL' )

<tex2html_mydb_mark>#4331#%       ]

<tex2html_mydb_mark>#4332#%     }, 'NUM' )

<tex2html_mydb_mark>#4333#%   ]

<tex2html_mydb_mark>#4334#% }, 'TIMES' );

<tex2html_mydb_mark>#4335#% \end{verbatim}

<tex2html_mydb_mark>#4336#% En la última ejecución el nivel especificado es tres.

<tex2html_mydb_mark>#4337#% El programa se detiene ante

<tex2html_mydb_mark>#4338#% la presencia de un nodo \verb|TIMES| con una aridad distinta:

<tex2html_mydb_mark>#4339#% \begin{verbatim}

<tex2html_mydb_mark>#4340#% nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; numchildren.pl 3

<tex2html_mydb_mark>#4341#% 0*2

<tex2html_mydb_mark>#4342#% Error! found node TIMES with 2 children.

<tex2html_mydb_mark>#4343#% Expected 1 children (see line 12 of numchildren.pl);SPMquot;

<tex2html_mydb_mark>#4344#%  at (eval 3) line 28

<tex2html_mydb_mark>#4345#% \end{verbatim}

<tex2html_mydb_mark>#4346#% 

<tex2html_mydb_mark>#4347#% \subsectionpractica{Esquema de Traducción para un Lenguaje Simple}

<tex2html_mydb_mark>#4348#% \label{practica:esquemadetradsimple}

<tex2html_mydb_mark>#4349#% Utilice 

<tex2html_mydb_mark>#4350#% \htmladdnormallink{Parse::Eyapp}{Parse-Eyapp.tar.gz}

<tex2html_mydb_mark>#4351#% para construir un árbol de análisis sintáctico abstracto 

<tex2html_mydb_mark>#4352#% para la siguiente gramática:

<tex2html_mydb_mark>#4353#% 

<tex2html_mydb_mark>#4354#% \vspace{0.5cm}

<tex2html_mydb_mark>#4355#% \begin{tabular}{lll}

<tex2html_mydb_mark>#4356#% program      ;SPMamp;$\rightarrow$;SPMamp; definitions \{ definitions \}\\ 

<tex2html_mydb_mark>#4357#% definitions  ;SPMamp;$\rightarrow$;SPMamp; datadefinition $|$ functiondefinition\\ 

<tex2html_mydb_mark>#4358#% datadefinition   ;SPMamp;$\rightarrow$;SPMamp; basictype declarator \{ ',' declarator \} ';'\\ 

<tex2html_mydb_mark>#4359#% declarator  ;SPMamp;$\rightarrow$;SPMamp; ID \{ '$[$' constantexp '$]$' \}\\ 

<tex2html_mydb_mark>#4360#% functiondefinition ;SPMamp;$\rightarrow$;SPMamp; $[$ basictype $]$ functionheader functionbody\\ 

<tex2html_mydb_mark>#4361#% basictype    ;SPMamp;$\rightarrow$;SPMamp; INT  $|$ CHAR\\ 

<tex2html_mydb_mark>#4362#% functionheader ;SPMamp;$\rightarrow$;SPMamp; ID '(' $[$ parameters $]$ ')'\\ 

<tex2html_mydb_mark>#4363#% parameters ;SPMamp;$\rightarrow$;SPMamp; basictype declarator \{ ',' basictype declarator \} \\ 

<tex2html_mydb_mark>#4364#% functionbody ;SPMamp;$\rightarrow$;SPMamp; '\{' \{ datadefinition \} \{ statement \} '\}'\\ 

<tex2html_mydb_mark>#4365#% statement ;SPMamp;$\rightarrow$;SPMamp; $[$ exp $]$ ';'\\ 

<tex2html_mydb_mark>#4366#%           ;SPMamp;;SPMamp;$|$ '\{' \{ datadefinition \} \{ statement \} '\}'\\ 

<tex2html_mydb_mark>#4367#%           ;SPMamp;;SPMamp;$|$  IF '(' exp ')' statement $[$ ELSE statement $]$\\ 

<tex2html_mydb_mark>#4368#%           ;SPMamp;;SPMamp;$|$  WHILE '(' exp ')' statement\\ 

<tex2html_mydb_mark>#4369#%           ;SPMamp;;SPMamp;$|$  RETURN $[$ exp $]$ ';'\\ 

<tex2html_mydb_mark>#4370#% constantexp  ;SPMamp;$\rightarrow$;SPMamp; exp \\ 

<tex2html_mydb_mark>#4371#% exp       ;SPMamp;$\rightarrow$;SPMamp; lvalue '=' exp $|$ lvalue '+=' exp \\ 

<tex2html_mydb_mark>#4372#%           ;SPMamp;;SPMamp;$|$ exp '\&\&' exp $|$ exp '$||$' exp  $|$\\ 

<tex2html_mydb_mark>#4373#%           ;SPMamp;;SPMamp;$|$ exp '==' exp $|$ exp '!=' exp  $|$\\ 

<tex2html_mydb_mark>#4374#%           ;SPMamp;;SPMamp;$|$ exp '$;SPMlt;$' exp $|$ exp '$;SPMgt;$' exp  $|$ exp '$;SPMlt;=$' exp $|$ exp '$;SPMgt;=$' exp  $|$\\ 

<tex2html_mydb_mark>#4375#%           ;SPMamp;;SPMamp;$|$ exp '+' exp $|$ exp '-' exp  $|$\\ 

<tex2html_mydb_mark>#4376#%           ;SPMamp;;SPMamp;$|$ exp '*' exp $|$ exp '/' exp $|$\\ 

<tex2html_mydb_mark>#4377#%           ;SPMamp;;SPMamp;$|$ unary\\ 

<tex2html_mydb_mark>#4378#% unary     ;SPMamp;$\rightarrow$;SPMamp; '$++$' lvalue  $|$ '$--$' lvalue $|$ primary\\ 

<tex2html_mydb_mark>#4379#% primary   ;SPMamp;$\rightarrow$;SPMamp; '(' exp ')' $|$ ID '(' $[$ argumentlist $]$ ')' $|$ lvalue\\ 

<tex2html_mydb_mark>#4380#%           ;SPMamp;             ;SPMamp; $|$ NUM $|$ CHARACTER $|$ STRING\\ 

<tex2html_mydb_mark>#4381#% lvalue   ;SPMamp;$\rightarrow$;SPMamp; ID  \{ '$[$' exp '$]$' \}\\ 

<tex2html_mydb_mark>#4382#% argumentlist ;SPMamp;$\rightarrow$;SPMamp; exp \{ ',' exp \}

<tex2html_mydb_mark>#4383#% \end{tabular}

<tex2html_mydb_mark>#4384#% \vspace{0.25cm}

<tex2html_mydb_mark>#4385#% 

<tex2html_mydb_mark>#4386#% La descripción utiliza una notación tipo BNF: las llaves indican 

<tex2html_mydb_mark>#4387#% 0 o mas repeticiones y los corchetes opcionalidad.

<tex2html_mydb_mark>#4388#% Su analizador, además de seguir los consejos explícitados en la 

<tex2html_mydb_mark>#4389#% sección \ref{section:consejosyapp},

<tex2html_mydb_mark>#4390#% deberá cumplir las siguientes especificaciones:

<tex2html_mydb_mark>#4391#% 

<tex2html_mydb_mark>#4392#% \begin{enumerate}

<tex2html_mydb_mark>#4393#% \item

<tex2html_mydb_mark>#4394#% Comienze trabajando en el cuerpo de la gramática.

<tex2html_mydb_mark>#4395#% \item

<tex2html_mydb_mark>#4396#% Olvídese del 

<tex2html_mydb_mark>#4397#% analizador léxico por ahora. Su objetivo es tener una gramática limpia

<tex2html_mydb_mark>#4398#% de conflictos y que reconozca el lenguaje dado. 

<tex2html_mydb_mark>#4399#% \item

<tex2html_mydb_mark>#4400#% Sustituya las repeticiones

<tex2html_mydb_mark>#4401#% BNF por listas usando los operadores \verb|eyapp| \verb|+|, \verb|*| y sus variantes con separadores. 

<tex2html_mydb_mark>#4402#% Si una variable describe una lista de \verb|cosas| pongale un adjetivo adecuado como

<tex2html_mydb_mark>#4403#% \verb|cosaslist|. 

<tex2html_mydb_mark>#4404#% \underline{Ponga nombres significativos a las variables y terminales}. 

<tex2html_mydb_mark>#4405#% No los llame \verb|d1|, \verb|d2|, etc.

<tex2html_mydb_mark>#4406#% \item

<tex2html_mydb_mark>#4407#% Si tiene un elemento opcional en la BNF, por ejemplo, en la regla: 

<tex2html_mydb_mark>#4408#% 

<tex2html_mydb_mark>#4409#% functiondefinition $\rightarrow$ $[$ basictype $]$ functionheader functionbody

<tex2html_mydb_mark>#4410#% 

<tex2html_mydb_mark>#4411#% use el operador \verb|?|.

<tex2html_mydb_mark>#4412#% \item

<tex2html_mydb_mark>#4413#% Cada par de reglas que introduzca vuelva a recompilar con \verb|eyapp| la gramática

<tex2html_mydb_mark>#4414#% para ver si se introducido ambiguedad. Cuando estoy editando la gramática

<tex2html_mydb_mark>#4415#% suelo escribir a menudo la orden 

<tex2html_mydb_mark>#4416#% 

<tex2html_mydb_mark>#4417#% \verb|:!eyapp %| 

<tex2html_mydb_mark>#4418#% 

<tex2html_mydb_mark>#4419#% para recompilar:

<tex2html_mydb_mark>#4420#% 

<tex2html_mydb_mark>#4421#% \vspace{0.5cm}

<tex2html_mydb_mark>#4422#% \begin{tabular}{|p{14.5cm}|}

<tex2html_mydb_mark>#4423#% \hline

<tex2html_mydb_mark>#4424#% \begin{verbatim}

<tex2html_mydb_mark>#4425#%      15

<tex2html_mydb_mark>#4426#%      16 declaratorlist: declarator +

<tex2html_mydb_mark>#4427#%      17 ;

<tex2html_mydb_mark>#4428#%      18 functiondefinition: 

<tex2html_mydb_mark>#4429#%      19    basictype functionheader functionbody

<tex2html_mydb_mark>#4430#%      20  | functionheader functionbody

<tex2html_mydb_mark>#4431#%      21 ;

<tex2html_mydb_mark>#4432#%      22

<tex2html_mydb_mark>#4433#%      23 %%

<tex2html_mydb_mark>#4434#% ~

<tex2html_mydb_mark>#4435#% ~

<tex2html_mydb_mark>#4436#% ~

<tex2html_mydb_mark>#4437#% ~

<tex2html_mydb_mark>#4438#% ~

<tex2html_mydb_mark>#4439#% ~

<tex2html_mydb_mark>#4440#% ~

<tex2html_mydb_mark>#4441#% ~

<tex2html_mydb_mark>#4442#% ~

<tex2html_mydb_mark>#4443#% ~

<tex2html_mydb_mark>#4444#% :!eyapp %

<tex2html_mydb_mark>#4445#% \end{verbatim}\\ 

<tex2html_mydb_mark>#4446#% \hline

<tex2html_mydb_mark>#4447#% \end{tabular}

<tex2html_mydb_mark>#4448#% \vspace{0.5cm}

<tex2html_mydb_mark>#4449#% 

<tex2html_mydb_mark>#4450#% Esto llama a \verb|eyapp| con el fichero bajo edición. Si hay errores o conflictos (esto es,

<tex2html_mydb_mark>#4451#% hemos introducido ambiguedad) los detectarémos enseguida.

<tex2html_mydb_mark>#4452#% Procure detectar la aparición de un conflicto lo antes posible.

<tex2html_mydb_mark>#4453#% Observe el sangrado del ejemplo. Es el que le recomiendo.

<tex2html_mydb_mark>#4454#% \item

<tex2html_mydb_mark>#4455#% Cuando esté en el proceso de construcción de la gramática y aún le queden

<tex2html_mydb_mark>#4456#% por rellenar variables sintácticas, declárelas como terminales mediante

<tex2html_mydb_mark>#4457#% \verb|%token| como en el código que aparece encima. De esta manera

<tex2html_mydb_mark>#4458#% evitará las quejas de \verb|eyapp|.

<tex2html_mydb_mark>#4459#% 

<tex2html_mydb_mark>#4460#% \item {\bf Resolución de Ambiguedades y Conflictos}

<tex2html_mydb_mark>#4461#% 

<tex2html_mydb_mark>#4462#% Las operaciones de asignación tienen la prioridad mas baja,

<tex2html_mydb_mark>#4463#% seguidas  de las lógicas, los test de igualdad y después 

<tex2html_mydb_mark>#4464#% de los de comparación, a continuación las aditivas, multiplicativas y por 

<tex2html_mydb_mark>#4465#% último los \verb|unary| y \verb|primary|. Exprese la asociatividad natural y la

<tex2html_mydb_mark>#4466#% prioridad especificada usando

<tex2html_mydb_mark>#4467#% los mecanismos que \verb|eyapp| provee al efecto: \verb|%left|, \verb|%right|,

<tex2html_mydb_mark>#4468#% \verb|%nonassoc| y \verb|%prec|.

<tex2html_mydb_mark>#4469#% 

<tex2html_mydb_mark>#4470#% \item

<tex2html_mydb_mark>#4471#% La gramática es ambigua, ya que para una sentencia como 

<tex2html_mydb_mark>#4472#% 

<tex2html_mydb_mark>#4473#% \begin{center}

<tex2html_mydb_mark>#4474#% if $E_1$ then if $E_2$ then $S_1$ else $S_2$

<tex2html_mydb_mark>#4475#% \end{center}

<tex2html_mydb_mark>#4476#% 

<tex2html_mydb_mark>#4477#% existen dos árboles posibles: uno que asocia el ``else'' con el primer ``if'' y otra

<tex2html_mydb_mark>#4478#% que lo asocia con el segundo. Los dos árboles corresponden a las

<tex2html_mydb_mark>#4479#% dos posibles parentizaciones:

<tex2html_mydb_mark>#4480#% 

<tex2html_mydb_mark>#4481#% \begin{center}

<tex2html_mydb_mark>#4482#% if $E_1$ then (if $E_2$ then $S_1$ else $S_2$)

<tex2html_mydb_mark>#4483#% \end{center}

<tex2html_mydb_mark>#4484#% 

<tex2html_mydb_mark>#4485#% Esta es la regla de prioridad usada en la mayor parte de los lenguajes:

<tex2html_mydb_mark>#4486#% un ``else'' casa con el ``if'' mas cercano. La otra posible parentización

<tex2html_mydb_mark>#4487#% es:

<tex2html_mydb_mark>#4488#% 

<tex2html_mydb_mark>#4489#% \begin{center}

<tex2html_mydb_mark>#4490#% if $E_1$ then (if $E_2$ then $S_1$) else $S_2$

<tex2html_mydb_mark>#4491#% \end{center}

<tex2html_mydb_mark>#4492#% 

<tex2html_mydb_mark>#4493#% \emph{La conducta por defecto de {\tt eyapp} es parentizar a derechas}.

<tex2html_mydb_mark>#4494#% El generador  {\tt eyapp}  nos informará del conflicto pero si no se le indica 

<tex2html_mydb_mark>#4495#% como resolverlo parentizará a derechas.

<tex2html_mydb_mark>#4496#% Resuelva este conflicto.

<tex2html_mydb_mark>#4497#% 

<tex2html_mydb_mark>#4498#% \item {\bf Analizador Léxico}

<tex2html_mydb_mark>#4499#% 

<tex2html_mydb_mark>#4500#% Además del tipo de terminal y su valor el analizador

<tex2html_mydb_mark>#4501#% léxico deberá devolver el número de línea.

<tex2html_mydb_mark>#4502#% El analizador léxico deberá aceptar comentarios C.

<tex2html_mydb_mark>#4503#% En la gramática, el terminal \verb|CHARACTER| se refiere a 

<tex2html_mydb_mark>#4504#% caracteres entre comillas simples (por ejemplo \verb|'a'|).

<tex2html_mydb_mark>#4505#% El terminal \verb|STRING| se refiere a 

<tex2html_mydb_mark>#4506#% caracteres entre comillas dobles (por ejemplo \verb|;SPMquot;hola;SPMquot;|).

<tex2html_mydb_mark>#4507#% 

<tex2html_mydb_mark>#4508#% Se aconseja que las palabras reservadas del lenguaje

<tex2html_mydb_mark>#4509#% no se traten con expresiones regulares específicas sino que se

<tex2html_mydb_mark>#4510#% capturen en el patrón de identificador \verb|[a-z_]\w+|. 

<tex2html_mydb_mark>#4511#% Se mantiene para ello un hash con las palabras reservadas 

<tex2html_mydb_mark>#4512#% que es inicializado al comienzo del programa. Cuando 

<tex2html_mydb_mark>#4513#% el analizador léxico encuentra un identificador

<tex2html_mydb_mark>#4514#% mira en primer lugar en dicho hash 

<tex2html_mydb_mark>#4515#% para ver si es una palabra reservada y,

<tex2html_mydb_mark>#4516#% si lo es, devuelve el terminal correspondiente.

<tex2html_mydb_mark>#4517#% En caso contrario se trata de un identificador.

<tex2html_mydb_mark>#4518#% 

<tex2html_mydb_mark>#4519#% \item {\it ¿Que clase de árbol debe producir el analizador?}

<tex2html_mydb_mark>#4520#% La respuesta es que sea lo mas abstracto posible.

<tex2html_mydb_mark>#4521#% Debe 

<tex2html_mydb_mark>#4522#% \begin{itemize}

<tex2html_mydb_mark>#4523#% \item

<tex2html_mydb_mark>#4524#% Contener toda la información necesaria para el manejo eficiente

<tex2html_mydb_mark>#4525#% de las fases subsiguientes: Análisis de ámbito, Comprobación de tipos,

<tex2html_mydb_mark>#4526#% Optimización independiente de la máquina, etc.

<tex2html_mydb_mark>#4527#% \item 

<tex2html_mydb_mark>#4528#% Ser uniforme

<tex2html_mydb_mark>#4529#% \item

<tex2html_mydb_mark>#4530#% Legible (human-friendly)

<tex2html_mydb_mark>#4531#% \item

<tex2html_mydb_mark>#4532#% No contener nodos que no portan información. 

<tex2html_mydb_mark>#4533#% \end{itemize}

<tex2html_mydb_mark>#4534#% 

<tex2html_mydb_mark>#4535#% El siguiente ejemplo muestra una versión aceptable de árbol abstracto.

<tex2html_mydb_mark>#4536#% Cuando se le proporciona el programa de entrada:

<tex2html_mydb_mark>#4537#% 

<tex2html_mydb_mark>#4538#% \begin{verbatim}

<tex2html_mydb_mark>#4539#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; cat -n prueba5.c

<tex2html_mydb_mark>#4540#%      1  int f(int a)

<tex2html_mydb_mark>#4541#%      2  {

<tex2html_mydb_mark>#4542#%      3    if (a;SPMgt;0)

<tex2html_mydb_mark>#4543#%      4      a = f(a-1);

<tex2html_mydb_mark>#4544#%      5  }

<tex2html_mydb_mark>#4545#% \end{verbatim}

<tex2html_mydb_mark>#4546#% 

<tex2html_mydb_mark>#4547#% el analizador produce un árbol parecido a este (se ha simplificado 

<tex2html_mydb_mark>#4548#% por razones de espacio):

<tex2html_mydb_mark>#4549#% 

<tex2html_mydb_mark>#4550#% \begin{small}

<tex2html_mydb_mark>#4551#% \begin{verbatim}

<tex2html_mydb_mark>#4552#% $VAR1=bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4553#%     bless({ 'children'=;SPMgt;[ # TYPEDFUNC

<tex2html_mydb_mark>#4554#%     |   bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4555#%     |       bless({'attr'=;SPMgt;['INT',1],'token'=;SPMgt;'INT'},'TERMINAL')

<tex2html_mydb_mark>#4556#%     |     ]

<tex2html_mydb_mark>#4557#%     |   },'INT'),

<tex2html_mydb_mark>#4558#%     |   bless({ 'children'=;SPMgt;[ # FUNCTION

<tex2html_mydb_mark>#4559#%     |   |   bless({'attr'=;SPMgt;['f',1],'token'=;SPMgt;'ID'},'TERMINAL'),

<tex2html_mydb_mark>#4560#%     |   |   bless({ 'children'=;SPMgt;[ # PARAMS

<tex2html_mydb_mark>#4561#%     |   |       bless({ 'children'=;SPMgt;[ # PARAM

<tex2html_mydb_mark>#4562#%     |   |           bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4563#%     |   |               bless({'attr'=;SPMgt;['INT',1],'token'=;SPMgt;'INT'},'TERMINAL')

<tex2html_mydb_mark>#4564#%     |   |             ]

<tex2html_mydb_mark>#4565#%     |   |           },'INT'),

<tex2html_mydb_mark>#4566#%     |   |           bless({'attr'=;SPMgt;['a',1],'token'=;SPMgt;'ID'},'TERMINAL'),

<tex2html_mydb_mark>#4567#%     |   |           bless({'children'=;SPMgt;[]},'ARRAYSPEC')

<tex2html_mydb_mark>#4568#%     |   |         ]

<tex2html_mydb_mark>#4569#%     |   |       },'PARAM')

<tex2html_mydb_mark>#4570#%     |   |     ]

<tex2html_mydb_mark>#4571#%     |   |   },'PARAMS'),

<tex2html_mydb_mark>#4572#%     |   |   bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4573#%     |   |       bless({'children'=;SPMgt;[]},'DECLARATIONS'),

<tex2html_mydb_mark>#4574#%     |   |       bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4575#%     |   |       |   bless({ # IF

<tex2html_mydb_mark>#4576#%     |   |       |     'children'=;SPMgt;[

<tex2html_mydb_mark>#4577#%     |   |       |       bless({ # GT

<tex2html_mydb_mark>#4578#%     |   |       |         'children'=;SPMgt;[

<tex2html_mydb_mark>#4579#%     |   |       |           bless({ # VAR

<tex2html_mydb_mark>#4580#%     |   |       |             'children'=;SPMgt;[

<tex2html_mydb_mark>#4581#%     |   |       |               bless({'attr'=;SPMgt;['a',3],'token'=;SPMgt;'ID'},'TERMINAL')

<tex2html_mydb_mark>#4582#%     |   |       |             ]

<tex2html_mydb_mark>#4583#%     |   |       |           },'VAR'),

<tex2html_mydb_mark>#4584#%     |   |       |           bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4585#%     |   |       |               bless({'attr'=;SPMgt;['0',3],'token'=;SPMgt;'INUM'},'TERMINAL')

<tex2html_mydb_mark>#4586#%     |   |       |             ]

<tex2html_mydb_mark>#4587#%     |   |       |           },'INUM')

<tex2html_mydb_mark>#4588#%     |   |       |         ]

<tex2html_mydb_mark>#4589#%     |   |       |       },'GT'),

<tex2html_mydb_mark>#4590#%     |   |       |       bless({ # ASSIGN

<tex2html_mydb_mark>#4591#%     |   |       |         'children'=;SPMgt;[

<tex2html_mydb_mark>#4592#%     |   |       |           bless({ # VAR

<tex2html_mydb_mark>#4593#%     |   |       |             'children'=;SPMgt;[

<tex2html_mydb_mark>#4594#%     |   |       |               bless({'attr'=;SPMgt;['a',4],'token'=;SPMgt;'ID'},'TERMINAL')

<tex2html_mydb_mark>#4595#%     |   |       |             ]

<tex2html_mydb_mark>#4596#%     |   |       |           },'VAR'),

<tex2html_mydb_mark>#4597#%     |   |       |           bless({ # FUNCTIONCALL

<tex2html_mydb_mark>#4598#%     |   |       |           | 'children'=;SPMgt;[

<tex2html_mydb_mark>#4599#%     |   |       |           |   bless({'attr'=;SPMgt;['f',4],'token'=;SPMgt;'ID'},'TERMINAL'),

<tex2html_mydb_mark>#4600#%     |   |       |           |   bless({ # ARGLIST

<tex2html_mydb_mark>#4601#%     |   |       |           |     'children'=;SPMgt;[

<tex2html_mydb_mark>#4602#%     |   |       |           |       bless({ # MINUS

<tex2html_mydb_mark>#4603#%     |   |       |           |         'children'=;SPMgt;[

<tex2html_mydb_mark>#4604#%     |   |       |           |           bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4605#%     |   |       |           |               bless({'attr'=;SPMgt;['a',4],'token'=;SPMgt;'ID'},'TERMINAL')

<tex2html_mydb_mark>#4606#%     |   |       |           |             ]

<tex2html_mydb_mark>#4607#%     |   |       |           |           },'VAR'),

<tex2html_mydb_mark>#4608#%     |   |       |           |           bless({ 'children'=;SPMgt;[

<tex2html_mydb_mark>#4609#%     |   |       |           |               bless({'attr'=;SPMgt;['1',4],'token'=;SPMgt;'INUM'},'TERMINAL')

<tex2html_mydb_mark>#4610#%     |   |       |           |             ]

<tex2html_mydb_mark>#4611#%     |   |       |           |           },'INUM')

<tex2html_mydb_mark>#4612#%     |   |       |           |         ]

<tex2html_mydb_mark>#4613#%     |   |       |           |       },'MINUS')

<tex2html_mydb_mark>#4614#%     |   |       |           |     ]

<tex2html_mydb_mark>#4615#%     |   |       |           |   },'ARGLIST')

<tex2html_mydb_mark>#4616#%     |   |       |           | ]

<tex2html_mydb_mark>#4617#%     |   |       |           },'FUNCTIONCALL')

<tex2html_mydb_mark>#4618#%     |   |       |         ]

<tex2html_mydb_mark>#4619#%     |   |       |       },'ASSIGN')

<tex2html_mydb_mark>#4620#%     |   |       |     ]

<tex2html_mydb_mark>#4621#%     |   |       |   },'IF')

<tex2html_mydb_mark>#4622#%     |   |       | ]

<tex2html_mydb_mark>#4623#%     |   |       },'STATEMENTS')

<tex2html_mydb_mark>#4624#%     |   |     ]

<tex2html_mydb_mark>#4625#%     |   |   },'BLOCK')

<tex2html_mydb_mark>#4626#%     |   | ]

<tex2html_mydb_mark>#4627#%     |   },'FUNCTION')

<tex2html_mydb_mark>#4628#%     | ]

<tex2html_mydb_mark>#4629#%     },'TYPEDFUNC')

<tex2html_mydb_mark>#4630#%   ]

<tex2html_mydb_mark>#4631#% },'PROGRAM');

<tex2html_mydb_mark>#4632#% \end{verbatim}

<tex2html_mydb_mark>#4633#% \end{small}

<tex2html_mydb_mark>#4634#% 

<tex2html_mydb_mark>#4635#% Es deseable  darle una estructura uniforme al árbol. Por ejemplo, como consecuencia 

<tex2html_mydb_mark>#4636#% de que la gramática admite funciones con declaración implícita del tipo retornado cuando este es entero

<tex2html_mydb_mark>#4637#% 

<tex2html_mydb_mark>#4638#% \begin{verbatim}

<tex2html_mydb_mark>#4639#%  1  definition:

<tex2html_mydb_mark>#4640#%  2      funcDef { $_[1]-;SPMgt;type(;SPMquot;INTFUNC;SPMquot;); $_[1] }

<tex2html_mydb_mark>#4641#%  3    | %name TYPEDFUNC

<tex2html_mydb_mark>#4642#%  4      basictype funcDef

<tex2html_mydb_mark>#4643#%  5    | declaration { $_[1] }

<tex2html_mydb_mark>#4644#%  6  ;

<tex2html_mydb_mark>#4645#% \end{verbatim}

<tex2html_mydb_mark>#4646#% \end{enumerate}

<tex2html_mydb_mark>#4647#% 

<tex2html_mydb_mark>#4648#% se producen dos tipos de árboles. Es conveniente

<tex2html_mydb_mark>#4649#% convertir las definiciones de función con declaración 

<tex2html_mydb_mark>#4650#% implícita en el mismo árbol que se obtiene con 

<tex2html_mydb_mark>#4651#% declaración explícita. Para ello puede usar una expresión regular

<tex2html_mydb_mark>#4652#% árbol.

<tex2html_mydb_mark>#4653#% 

<tex2html_mydb_mark>#4654#% \section{Análisis de Ámbito}

<tex2html_mydb_mark>#4655#% Los lenguajes de programación suelen permitir el uso del mismo 

<tex2html_mydb_mark>#4656#% \cei{nombre}\footnote{Usamos el término nombre y no identificador ya que este último

<tex2html_mydb_mark>#4657#% tiene una connotación mas precisa}

<tex2html_mydb_mark>#4658#% para denotar distintos objetos de un programa. Es por ello que es necesario

<tex2html_mydb_mark>#4659#% determinar que definición o declaración se aplica a una determinada

<tex2html_mydb_mark>#4660#% ocurrencia de un objeto.

<tex2html_mydb_mark>#4661#% 

<tex2html_mydb_mark>#4662#% \begin{definition}

<tex2html_mydb_mark>#4663#% Una \cei{declaración} es un constructo sintáctico que define y provee información 

<tex2html_mydb_mark>#4664#% sobre un nombre.

<tex2html_mydb_mark>#4665#% \end{definition}

<tex2html_mydb_mark>#4666#% 

<tex2html_mydb_mark>#4667#% \begin{definition}

<tex2html_mydb_mark>#4668#% Las \cei{reglas de ámbito} de un lenguaje determinan que declaración

<tex2html_mydb_mark>#4669#% del nombre es la que se \emph{aplica} cuando el nombre es usado.

<tex2html_mydb_mark>#4670#% \end{definition}

<tex2html_mydb_mark>#4671#% 

<tex2html_mydb_mark>#4672#% En la definición anterior la frase final \emph{cuando el nombre es usado}

<tex2html_mydb_mark>#4673#% puede referirse al texto del programa a su uso durante la ejecución

<tex2html_mydb_mark>#4674#% del programa. Se habla de \cei{static binding} o \cei{reglas de ámbito estático} 

<tex2html_mydb_mark>#4675#% cuando las reglas de ámbito se refieren al uso en el texto y determinan 

<tex2html_mydb_mark>#4676#% consiguientemente su uso en ejecución. Las aplicaciones de las reglas de ámbito estático

<tex2html_mydb_mark>#4677#% pueden ser calculadas en tiempo de compilación.

<tex2html_mydb_mark>#4678#% 

<tex2html_mydb_mark>#4679#% Por contrario cuando se usa \cei{dynamic binding} o \cei{reglas de ámbito dinámico}

<tex2html_mydb_mark>#4680#% el acceso a una determinada variable puede suceder en términos de una regla 

<tex2html_mydb_mark>#4681#% establecida en tiempo de ejecución y el ámbito de la regla puede no tener 

<tex2html_mydb_mark>#4682#% una asignación clara a una zona léxica de texto. Un ejemplo: la declaración \tei{local}

<tex2html_mydb_mark>#4683#% de Perl modifica el ámbito de una variable de paquete, de manera que el valor

<tex2html_mydb_mark>#4684#% visible a través del nombre será el último dado. Cuando el ámbito (estático) de 

<tex2html_mydb_mark>#4685#% la declaración de \verb|local| termina se podrá acceder al antiguo valor de la variable.

<tex2html_mydb_mark>#4686#% 

<tex2html_mydb_mark>#4687#% \begin{definition}

<tex2html_mydb_mark>#4688#% Cuando se usa \emph{static binding},

<tex2html_mydb_mark>#4689#% la parte del texto del programa al cual se aplica la declaración de un 

<tex2html_mydb_mark>#4690#% nombre se denomina \cei{ámbito de la declaración}

<tex2html_mydb_mark>#4691#% \end{definition}

<tex2html_mydb_mark>#4692#% 

<tex2html_mydb_mark>#4693#% 

<tex2html_mydb_mark>#4694#% \begin{definition}

<tex2html_mydb_mark>#4695#% La tarea de asignar las ocurrencias de las declaraciones de nombres a las 

<tex2html_mydb_mark>#4696#% ocurrencias de uso  de los nombres de acuerdo a las reglas de ámbito

<tex2html_mydb_mark>#4697#% del lenguaje se denomina \cei{identificación de los nombres}

<tex2html_mydb_mark>#4698#% \end{definition}

<tex2html_mydb_mark>#4699#% 

<tex2html_mydb_mark>#4700#% \begin{definition}

<tex2html_mydb_mark>#4701#% Una ocurrencia de un nombre se dice \cei{local} si está en el ámbito 

<tex2html_mydb_mark>#4702#% de una declaración que no se aplica desde el comienzo de la declaración 

<tex2html_mydb_mark>#4703#% hasta el final del texto del programa. Tal declaración

<tex2html_mydb_mark>#4704#% es una \cei{declaración local}.

<tex2html_mydb_mark>#4705#% \end{definition}

<tex2html_mydb_mark>#4706#% 

<tex2html_mydb_mark>#4707#% \begin{definition}

<tex2html_mydb_mark>#4708#% Si, por el contrario, una ocurrencia de un nombre está en el ámbito

<tex2html_mydb_mark>#4709#% de una declaración que no se aplica desde el comienzo de la declaración 

<tex2html_mydb_mark>#4710#% hasta el final del texto del programa se dice que la declaración

<tex2html_mydb_mark>#4711#% es una \cei{declaración global}.

<tex2html_mydb_mark>#4712#% \end{definition}

<tex2html_mydb_mark>#4713#% 

<tex2html_mydb_mark>#4714#% \begin{definition}

<tex2html_mydb_mark>#4715#% Aunque la definición anterior establece el \cei{atributo ámbito}

<tex2html_mydb_mark>#4716#% como un atributo de la declaración es usual y conveniente

<tex2html_mydb_mark>#4717#% hablar del 

<tex2html_mydb_mark>#4718#% \begin{quote}

<tex2html_mydb_mark>#4719#% ;SPMquot;\emph{ámbito del nombre {\tt x}};SPMquot; 

<tex2html_mydb_mark>#4720#% \end{quote}

<tex2html_mydb_mark>#4721#% como una abreviación

<tex2html_mydb_mark>#4722#% de 

<tex2html_mydb_mark>#4723#% \begin{quote}

<tex2html_mydb_mark>#4724#% ;SPMquot;\emph{el ámbito de la declaración del nombre {\tt x}

<tex2html_mydb_mark>#4725#% que se aplica a esta ocurrencia de {\tt x}};SPMquot;

<tex2html_mydb_mark>#4726#% \end{quote}

<tex2html_mydb_mark>#4727#% \end{definition}

<tex2html_mydb_mark>#4728#% 

<tex2html_mydb_mark>#4729#% Como ya sabemos, es falso que en el ámbito de una declaración que define a \verb|x| 

<tex2html_mydb_mark>#4730#% dicha declaración se aplique a todas las ocurrencias de \verb|x| en su ámbito.

<tex2html_mydb_mark>#4731#% En un ámbito estático, una declaración local a la anterior puede \cei{ocultar la visibilidad} de 

<tex2html_mydb_mark>#4732#% la declaración anterior de \verb|x|.

<tex2html_mydb_mark>#4733#% 

<tex2html_mydb_mark>#4734#% \begin{definition}

<tex2html_mydb_mark>#4735#% Las \cei{reglas de visibilidad} de un lenguaje especifican como se relacionan los nombres

<tex2html_mydb_mark>#4736#% con las declaraciones que se les aplican.

<tex2html_mydb_mark>#4737#% \end{definition}

<tex2html_mydb_mark>#4738#% Por ejemplo en Pascal es posible hacer visible el nombre de un campo de un registro

<tex2html_mydb_mark>#4739#% extendiéndolo con el nombre del registro. En Perl es posible acceder a una variable de paquete

<tex2html_mydb_mark>#4740#% ocultada por una léxica usando su nombre completo.

<tex2html_mydb_mark>#4741#% 

<tex2html_mydb_mark>#4742#% También es posible hacer visible un nombre escondido -sin necesidad como en el ejemplo anterior

<tex2html_mydb_mark>#4743#% de extender el identificador - mediante alguna directiva

<tex2html_mydb_mark>#4744#% que lo haga visible: Son ejemplos la declaración \verb|with| the Pascal y la declaración

<tex2html_mydb_mark>#4745#% \tei{our} de Perl (via uso del módulo y exportación del símbolo).

<tex2html_mydb_mark>#4746#% 

<tex2html_mydb_mark>#4747#% En el ejemplo del lenguaje Simple introducido en la práctica 

<tex2html_mydb_mark>#4748#% \ref{practica:esquemadetradsimple}

<tex2html_mydb_mark>#4749#% hay una única declaración que se aplica a cada 

<tex2html_mydb_mark>#4750#% ocurrencia correcta de un nombre en un programa.

<tex2html_mydb_mark>#4751#% Esto no tiene porque ser siempre así: en ciertos lenguajes 

<tex2html_mydb_mark>#4752#% una redeclaración de un cierto nombre \verb|x| puede que sólo oculte 

<tex2html_mydb_mark>#4753#% a otra declaración previa de \verb|x| si las dos declaraciones

<tex2html_mydb_mark>#4754#% asignan el mismo tipo a \verb|x|. Esta idea suele conocerse

<tex2html_mydb_mark>#4755#% como \cei{sobrecarga de identificadores}. De todos modos, sigue 

<tex2html_mydb_mark>#4756#% siendo cierto que para que el programa

<tex2html_mydb_mark>#4757#% sea considerado correcto es necesario que sea posible determinar

<tex2html_mydb_mark>#4758#% para cada ocurrencia de un identificador que definición se

<tex2html_mydb_mark>#4759#% aplica. Así una llamada  a una cierta función

<tex2html_mydb_mark>#4760#% \verb|min(x,y)| llamaría a diferentes 

<tex2html_mydb_mark>#4761#% funciones \verb|min| según fueran los tipos de \verb|x| e \verb|y|.

<tex2html_mydb_mark>#4762#% En Perl tenemos que es 

<tex2html_mydb_mark>#4763#% legal tener variables \verb|$x|, \verb|@x|, \verb|%x|, \verb|;SPMamp;x|, \verb|*x|,

<tex2html_mydb_mark>#4764#% etc. ya que corresponden a tipos distintos. Si bien el ejemplo 

<tex2html_mydb_mark>#4765#% de sobrecarga de identificadores en Perl 

<tex2html_mydb_mark>#4766#% podría considerarse un poco forzado ya 

<tex2html_mydb_mark>#4767#% que encaja también con la idea de hacer visible

<tex2html_mydb_mark>#4768#% el nombre mediante la extensión del mismo 

<tex2html_mydb_mark>#4769#% (en este caso el prefijo o \cei{sigil} \verb|$|, \verb|@|, etc.).

<tex2html_mydb_mark>#4770#% 

<tex2html_mydb_mark>#4771#% 

<tex2html_mydb_mark>#4772#% El proceso de identificar los nombres conlleva establecer enlaces

<tex2html_mydb_mark>#4773#% entre las ocurrencias y sus declaraciones o bien - en caso de error -

<tex2html_mydb_mark>#4774#% determinar que dicho enlace no existe. El resultado de este proceso

<tex2html_mydb_mark>#4775#% de identificación (o análisis de ámbito y visibilidad)

<tex2html_mydb_mark>#4776#% será utilizado durante las fases posteriores.

<tex2html_mydb_mark>#4777#% 

<tex2html_mydb_mark>#4778#% 

<tex2html_mydb_mark>#4779#% \subsectionpractica{Análisis de Ámbito}

<tex2html_mydb_mark>#4780#% \label{practica:ambitoytipossamplec}

<tex2html_mydb_mark>#4781#% Haga el análisis de ámbito del lenguaje presentado

<tex2html_mydb_mark>#4782#% en la práctica

<tex2html_mydb_mark>#4783#% \ref{practica:esquemadetradsimple}.

<tex2html_mydb_mark>#4784#% Para esta práctica use una revisión de la distribución de 

<tex2html_mydb_mark>#4785#% Parse::Eyapp posterior a la 348.

<tex2html_mydb_mark>#4786#% 

<tex2html_mydb_mark>#4787#% \paragraph{La tabla de Símbolos}

<tex2html_mydb_mark>#4788#% Comenzaremos describiendo las estructuras de datos que van a conformar la tabla de símbolos

<tex2html_mydb_mark>#4789#% de nuestro compilador:

<tex2html_mydb_mark>#4790#% 

<tex2html_mydb_mark>#4791#% \begin{enumerate}

<tex2html_mydb_mark>#4792#% \item

<tex2html_mydb_mark>#4793#% Dote de los siguientes atributos a los nodos de tipo ;SPMquot;bloque;SPMquot;, 

<tex2html_mydb_mark>#4794#% esto es a aquellos nodos que definen ámbito. Por ejemplo, los nodos asociados

<tex2html_mydb_mark>#4795#% con la variable sintáctica \verb|block| son de tipo ;SPMquot;bloque;SPMquot;:

<tex2html_mydb_mark>#4796#% \begin{verbatim}

<tex2html_mydb_mark>#4797#% block:

<tex2html_mydb_mark>#4798#%     %name BLOCK

<tex2html_mydb_mark>#4799#%     '{' declaration %name DECLARATIONS * statement %name STATEMENTS * '}'

<tex2html_mydb_mark>#4800#% \end{verbatim}

<tex2html_mydb_mark>#4801#% 

<tex2html_mydb_mark>#4802#%   \begin{enumerate}

<tex2html_mydb_mark>#4803#%   \item

<tex2html_mydb_mark>#4804#%   Atributo \verb|symboltable|: referencia a la tabla de símbolos asociada con el bloque

<tex2html_mydb_mark>#4805#%   \item

<tex2html_mydb_mark>#4806#%   Atributo \verb|fatherblock|: referencia al nodo \verb|BLOCK| que inmediatamente anida a este.

<tex2html_mydb_mark>#4807#%   Los nodos de tipo bloque quedan enlazados según el árbol de anidamiento de bloques

<tex2html_mydb_mark>#4808#%   \item

<tex2html_mydb_mark>#4809#%   Los bloques con declaraciones vacías pueden ser simplificados en el árbol de bloques

<tex2html_mydb_mark>#4810#%   \end{enumerate}

<tex2html_mydb_mark>#4811#% 

<tex2html_mydb_mark>#4812#% \item

<tex2html_mydb_mark>#4813#% Los nodos \verb|FUNCTION| asociados con las

<tex2html_mydb_mark>#4814#% funciones son nodos de tipo bloque y

<tex2html_mydb_mark>#4815#% serán tratados de manera similar a los nodos  \verb|BLOCK|, esto es, 

<tex2html_mydb_mark>#4816#% tendrán su tabla de símbolos asociada en la cual se guardarán los parámetros 

<tex2html_mydb_mark>#4817#% de la función. Este bloque es el bloque padre del bloque formado por

<tex2html_mydb_mark>#4818#% el cuerpo de la función.

<tex2html_mydb_mark>#4819#% 

<tex2html_mydb_mark>#4820#% \begin{verbatim}

<tex2html_mydb_mark>#4821#% funcDef:

<tex2html_mydb_mark>#4822#%     %name FUNCTION

<tex2html_mydb_mark>#4823#%     ID '('  param ;SPMlt;%name PARAMS * ',';SPMgt; ')' 

<tex2html_mydb_mark>#4824#%       block

<tex2html_mydb_mark>#4825#% \end{verbatim}

<tex2html_mydb_mark>#4826#% 

<tex2html_mydb_mark>#4827#% \item

<tex2html_mydb_mark>#4828#% Los identificadores de funciones van en la tabla de símbolos global, asociada con el nodo

<tex2html_mydb_mark>#4829#% \verb|PROGRAM|:

<tex2html_mydb_mark>#4830#% 

<tex2html_mydb_mark>#4831#% \begin{verbatim}

<tex2html_mydb_mark>#4832#% program:

<tex2html_mydb_mark>#4833#%     definition %name PROGRAM+ 

<tex2html_mydb_mark>#4834#%       { $_[1] }

<tex2html_mydb_mark>#4835#% \end{verbatim}

<tex2html_mydb_mark>#4836#% Observe que en C una función puede ser usada antes de que aparezca su definición.

<tex2html_mydb_mark>#4837#% 

<tex2html_mydb_mark>#4838#% \item

<tex2html_mydb_mark>#4839#%   Atributos de un nodo \verb|VAR|:

<tex2html_mydb_mark>#4840#%   \begin{enumerate}

<tex2html_mydb_mark>#4841#%   \item

<tex2html_mydb_mark>#4842#%   Atributo \verb|entry|: Su entrada en la tabla de símbolos a la que pertenece

<tex2html_mydb_mark>#4843#%   \item

<tex2html_mydb_mark>#4844#%   Atributo \verb|scope|: Una referencia al nodo \verb|BLOCK| en el que fué declarada la variable

<tex2html_mydb_mark>#4845#%   \end{enumerate}

<tex2html_mydb_mark>#4846#% 

<tex2html_mydb_mark>#4847#% \item

<tex2html_mydb_mark>#4848#% La tabla de símbolos tiene una entrada para cada identificador que pertenece a su espacio

<tex2html_mydb_mark>#4849#% de nombres. Aqui figuran los atributos del identificador: entre estos 

<tex2html_mydb_mark>#4850#% últimos la línea en la que fue declarado y su tipo.

<tex2html_mydb_mark>#4851#% 

<tex2html_mydb_mark>#4852#% \end{enumerate}

<tex2html_mydb_mark>#4853#% 

<tex2html_mydb_mark>#4854#% \paragraph{Conoce tus árboles}

<tex2html_mydb_mark>#4855#% Para la realización de esta práctica 

<tex2html_mydb_mark>#4856#% deberá tener clara la forma de los árboles generados por su analizador sintáctico y

<tex2html_mydb_mark>#4857#% especialmente la parte que se refiere a las declaraciones. Para un ejemplo de lo que

<tex2html_mydb_mark>#4858#% es razonable esperar que un analizador sintáctico construido con \verb|eyapp| 

<tex2html_mydb_mark>#4859#% genere para el programa fuente 

<tex2html_mydb_mark>#4860#% \begin{verbatim}

<tex2html_mydb_mark>#4861#% f() {

<tex2html_mydb_mark>#4862#%   int a,b[1][2],a[1][2][3];

<tex2html_mydb_mark>#4863#%   char d[10];

<tex2html_mydb_mark>#4864#%   b[0][1] = a;

<tex2html_mydb_mark>#4865#% }

<tex2html_mydb_mark>#4866#% \end{verbatim}

<tex2html_mydb_mark>#4867#% vea el apéndice en la página \pageref{apendice:arbolensimplec}.

<tex2html_mydb_mark>#4868#% 

<tex2html_mydb_mark>#4869#% Esta práctica se divide en dos partes. 

<tex2html_mydb_mark>#4870#% 

<tex2html_mydb_mark>#4871#% En una primera parte

<tex2html_mydb_mark>#4872#% se construyen las declaraciones y las tablas de símbolos de cada bloque. 

<tex2html_mydb_mark>#4873#% En la segunda parte (véase la siguiente práctica) 

<tex2html_mydb_mark>#4874#% se resuelve el problema de la identificación de los

<tex2html_mydb_mark>#4875#% nombres estableciendo la relación entre el uso de un nombre y la declaración

<tex2html_mydb_mark>#4876#% que se le aplica (dada por los atributos \verb|scope| y \verb|entry|):

<tex2html_mydb_mark>#4877#% 

<tex2html_mydb_mark>#4878#% \paragraph{¿Que es una declaración?}

<tex2html_mydb_mark>#4879#% Las declaraciones tal y como aparecen en el AST no permiten

<tex2html_mydb_mark>#4880#% una comprobación de tipos eficiente. La comprobación de tipos

<tex2html_mydb_mark>#4881#% es la fase que sigue al análisis de ámbito.

<tex2html_mydb_mark>#4882#% Por ello, debemos modificar la fase de construcción del AST para

<tex2html_mydb_mark>#4883#% producir declaraciones que permitan comprobar con facilidad

<tex2html_mydb_mark>#4884#% la \cei{equivalencia de tipos}

<tex2html_mydb_mark>#4885#% 

<tex2html_mydb_mark>#4886#% La equivalencia de tipos se realiza habitualmente mediante 

<tex2html_mydb_mark>#4887#% \cei{expresiones de tipo}. En nuestro caso vamos a

<tex2html_mydb_mark>#4888#% elegir una representación mediante cadenas y árboles 

<tex2html_mydb_mark>#4889#% las expresiones de tipo. Las cadenas serán términos

<tex2html_mydb_mark>#4890#% árbol. Como primera aproximación, entenderemos

<tex2html_mydb_mark>#4891#% que dos tipos son equivalentes si las cadenas que representan

<tex2html_mydb_mark>#4892#% sus expresiones de tipo son iguales. Como tenemos dos tipos 

<tex2html_mydb_mark>#4893#% básicos \verb|INT| y \verb|CHAR| declararemos en nuestro

<tex2html_mydb_mark>#4894#% programa \verb|Simple.yp|:

<tex2html_mydb_mark>#4895#% 

<tex2html_mydb_mark>#4896#% \begin{verbatim}

<tex2html_mydb_mark>#4897#% %{

<tex2html_mydb_mark>#4898#% use List::Util qw(reduce);

<tex2html_mydb_mark>#4899#% use List::MoreUtils qw(firstval);

<tex2html_mydb_mark>#4900#% 

<tex2html_mydb_mark>#4901#% my %reserved = (

<tex2html_mydb_mark>#4902#%   ..... .. .......

<tex2html_mydb_mark>#4903#% );

<tex2html_mydb_mark>#4904#% 

<tex2html_mydb_mark>#4905#% my %lexeme = (

<tex2html_mydb_mark>#4906#%   .... .. .....

<tex2html_mydb_mark>#4907#% );

<tex2html_mydb_mark>#4908#%  .............. # support functions

<tex2html_mydb_mark>#4909#% 

<tex2html_mydb_mark>#4910#% my ($tokenbegin, $tokenend) = (1, 1);

<tex2html_mydb_mark>#4911#% my %type = (

<tex2html_mydb_mark>#4912#%   INT  =;SPMgt; 1,

<tex2html_mydb_mark>#4913#%   CHAR =;SPMgt; 1,

<tex2html_mydb_mark>#4914#% );

<tex2html_mydb_mark>#4915#% 

<tex2html_mydb_mark>#4916#% my %st; # Global symbol table

<tex2html_mydb_mark>#4917#% %}

<tex2html_mydb_mark>#4918#% \end{verbatim}

<tex2html_mydb_mark>#4919#% 

<tex2html_mydb_mark>#4920#% \paragraph{El código asociado con {\tt declaration}}

<tex2html_mydb_mark>#4921#% Veamos como modificamos la construcción del AST durante las declaraciones:

<tex2html_mydb_mark>#4922#% 

<tex2html_mydb_mark>#4923#% \begin{verbatim}

<tex2html_mydb_mark>#4924#% declaration:

<tex2html_mydb_mark>#4925#%     %name DECLARATION

<tex2html_mydb_mark>#4926#%     $basictype $declList ';' 

<tex2html_mydb_mark>#4927#%       {  

<tex2html_mydb_mark>#4928#%          my %st; # Symbol table local to this declaration

<tex2html_mydb_mark>#4929#%          my $bt = $basictype-;SPMgt;type;

<tex2html_mydb_mark>#4930#%          my @decs = $declList-;SPMgt;children(); 

<tex2html_mydb_mark>#4931#%          while (my ($id, $arrspec) = splice(@decs, 0, 2)) {

<tex2html_mydb_mark>#4932#%            my $name = $id-;SPMgt;{attr}[0];

<tex2html_mydb_mark>#4933#%            my $type = build_type($bt, $arrspec);

<tex2html_mydb_mark>#4934#%            $type{$type} = 1; 

<tex2html_mydb_mark>#4935#% 

<tex2html_mydb_mark>#4936#%            # control duplicated declarations

<tex2html_mydb_mark>#4937#%            die ;SPMquot;Duplicated declaration of $name at line $id-;SPMgt;{attr}[1]\n;SPMquot; if exists($st{$name});

<tex2html_mydb_mark>#4938#%            $st{$name}-;SPMgt;{type} = $type;

<tex2html_mydb_mark>#4939#%            $st{$name}-;SPMgt;{line} = $id-;SPMgt;{attr}[1];

<tex2html_mydb_mark>#4940#%          }

<tex2html_mydb_mark>#4941#%          return \%st;

<tex2html_mydb_mark>#4942#%       }

<tex2html_mydb_mark>#4943#% \end{verbatim}

<tex2html_mydb_mark>#4944#% 

<tex2html_mydb_mark>#4945#% El código de la función \verb|build_type| es como sigue:

<tex2html_mydb_mark>#4946#% 

<tex2html_mydb_mark>#4947#% \begin{verbatim}

<tex2html_mydb_mark>#4948#% sub build_type {

<tex2html_mydb_mark>#4949#%   my $bt = shift;

<tex2html_mydb_mark>#4950#%   my @arrayspec = shift()-;SPMgt;children();

<tex2html_mydb_mark>#4951#% 

<tex2html_mydb_mark>#4952#%   my $type = '';

<tex2html_mydb_mark>#4953#%   for my $s (@arrayspec) {

<tex2html_mydb_mark>#4954#%     $type .= ;SPMquot;A_$s-;SPMgt;{attr}[0](;SPMquot;;

<tex2html_mydb_mark>#4955#%   }

<tex2html_mydb_mark>#4956#%   if ($type) {

<tex2html_mydb_mark>#4957#%     $type = ;SPMquot;$type$bt;SPMquot;.(;SPMquot;);SPMquot;x@arrayspec);

<tex2html_mydb_mark>#4958#%   }

<tex2html_mydb_mark>#4959#%   else {

<tex2html_mydb_mark>#4960#%     $type = $bt;

<tex2html_mydb_mark>#4961#%   }

<tex2html_mydb_mark>#4962#%   return $type;

<tex2html_mydb_mark>#4963#% }

<tex2html_mydb_mark>#4964#% \end{verbatim}

<tex2html_mydb_mark>#4965#% 

<tex2html_mydb_mark>#4966#% \paragraph{Tratamiento de los Bloques}

<tex2html_mydb_mark>#4967#% La variable sintáctica \verb|bloque|

<tex2html_mydb_mark>#4968#% genera el lenguaje de las definiciones seguidas de sentencias,

<tex2html_mydb_mark>#4969#% tal y como aparece en la definición EBNF del lenguaje:

<tex2html_mydb_mark>#4970#% 

<tex2html_mydb_mark>#4971#% \begin{tabular}{c}

<tex2html_mydb_mark>#4972#%       '\{' \{ datadefinition \} \{ statement \} '\}'

<tex2html_mydb_mark>#4973#% \end{tabular}

<tex2html_mydb_mark>#4974#% 

<tex2html_mydb_mark>#4975#% El lenguaje de los bloques es modificado en consonancia:

<tex2html_mydb_mark>#4976#% 

<tex2html_mydb_mark>#4977#% \begin{verbatim}

<tex2html_mydb_mark>#4978#% block:

<tex2html_mydb_mark>#4979#%     '{'.bracket 

<tex2html_mydb_mark>#4980#%        { $depth++ } /* intermediate action! */

<tex2html_mydb_mark>#4981#%      declaration;SPMlt;%name DECLARATIONS *;SPMgt;.decs statement;SPMlt;%name STATEMENTS *;SPMgt;.sts '}'

<tex2html_mydb_mark>#4982#%        { 

<tex2html_mydb_mark>#4983#%          my %st;

<tex2html_mydb_mark>#4984#% 

<tex2html_mydb_mark>#4985#%          for my $lst ($decs-;SPMgt;children) {

<tex2html_mydb_mark>#4986#% 

<tex2html_mydb_mark>#4987#%            # control duplicated declarations

<tex2html_mydb_mark>#4988#%            my $message;

<tex2html_mydb_mark>#4989#%            die $message if $message = is_duplicated(\%st, $lst);

<tex2html_mydb_mark>#4990#% 

<tex2html_mydb_mark>#4991#%            %st = (%st, %$lst);

<tex2html_mydb_mark>#4992#%          }

<tex2html_mydb_mark>#4993#%          $sts-;SPMgt;{symboltable} = \%st;

<tex2html_mydb_mark>#4994#%          $sts-;SPMgt;{line} = $bracket-;SPMgt;[1];

<tex2html_mydb_mark>#4995#%          $sts-;SPMgt;{depth} = $depth--;

<tex2html_mydb_mark>#4996#%          $sts-;SPMgt;type(;SPMquot;BLOCK;SPMquot;);

<tex2html_mydb_mark>#4997#%          push @pending_blocks, $sts;

<tex2html_mydb_mark>#4998#%          return $sts; 

<tex2html_mydb_mark>#4999#%        }

<tex2html_mydb_mark>#5000#% \end{verbatim}

<tex2html_mydb_mark>#5001#% 

<tex2html_mydb_mark>#5002#% El código de la función \verb|is_duplicated| es como sigue:

<tex2html_mydb_mark>#5003#% 

<tex2html_mydb_mark>#5004#% \begin{verbatim}

<tex2html_mydb_mark>#5005#% sub is_duplicated {

<tex2html_mydb_mark>#5006#%   my ($st1, $st2) = @_;

<tex2html_mydb_mark>#5007#% 

<tex2html_mydb_mark>#5008#%   my $id;

<tex2html_mydb_mark>#5009#% 

<tex2html_mydb_mark>#5010#%     defined($id=firstval{exists $st1-;SPMgt;{$_}} keys %$st2)

<tex2html_mydb_mark>#5011#%   and return ;SPMquot;Error. Variable $id at line $st2-;SPMgt;{$id}-;SPMgt;{line} declared twice.\n;SPMquot;;

<tex2html_mydb_mark>#5012#%   return 0;

<tex2html_mydb_mark>#5013#% }

<tex2html_mydb_mark>#5014#% \end{verbatim}

<tex2html_mydb_mark>#5015#% 

<tex2html_mydb_mark>#5016#% \paragraph{Tratamiento de las Funciones}

<tex2html_mydb_mark>#5017#% 

<tex2html_mydb_mark>#5018#% El código para las funciones es similar.

<tex2html_mydb_mark>#5019#% Unimos la tabla de símbolos

<tex2html_mydb_mark>#5020#% de los parámetros a la del bloque para posteriormente reconvertir el

<tex2html_mydb_mark>#5021#% bloque en un nodo \verb|FUNCTION|:

<tex2html_mydb_mark>#5022#% 

<tex2html_mydb_mark>#5023#% \begin{verbatim}

<tex2html_mydb_mark>#5024#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; sed -ne '195,218p' Simple4.eyp | cat -n

<tex2html_mydb_mark>#5025#%  1  funcDef:

<tex2html_mydb_mark>#5026#%  2      $ID '('  $params  ')'

<tex2html_mydb_mark>#5027#%  3        $block

<tex2html_mydb_mark>#5028#%  4      {

<tex2html_mydb_mark>#5029#%  5         my $st = $block-;SPMgt;{symboltable};

<tex2html_mydb_mark>#5030#%  6         my @decs = $params-;SPMgt;children();

<tex2html_mydb_mark>#5031#%  7         $block-;SPMgt;{parameters} = [];

<tex2html_mydb_mark>#5032#%  8         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {

<tex2html_mydb_mark>#5033#%  9             my $bt = ref($bt); # The string 'INT', 'CHAR', etc.

<tex2html_mydb_mark>#5034#% 10             my $name = $id-;SPMgt;{attr}[0];

<tex2html_mydb_mark>#5035#% 11             my $type = build_type($bt, $arrspec);

<tex2html_mydb_mark>#5036#% 12             $type{$type} = 1; 

<tex2html_mydb_mark>#5037#% 13

<tex2html_mydb_mark>#5038#% 14             # control duplicated declarations

<tex2html_mydb_mark>#5039#% 15             die ;SPMquot;Duplicated declaration of $name at line $id-;SPMgt;{attr}[1]\n;SPMquot; if exists($st-;SPMgt;{$name});

<tex2html_mydb_mark>#5040#% 16             $st-;SPMgt;{$name}-;SPMgt;{type} = $type;

<tex2html_mydb_mark>#5041#% 17             $st-;SPMgt;{$name}-;SPMgt;{param} = 1;

<tex2html_mydb_mark>#5042#% 18             $st-;SPMgt;{$name}-;SPMgt;{line} = $id-;SPMgt;{attr}[1];

<tex2html_mydb_mark>#5043#% 19             push @{$block-;SPMgt;{parameters}}, $name;

<tex2html_mydb_mark>#5044#% 20         }

<tex2html_mydb_mark>#5045#% 21         $block-;SPMgt;{function_name} = $ID;

<tex2html_mydb_mark>#5046#% 22         $block-;SPMgt;type(;SPMquot;FUNCTION;SPMquot;);

<tex2html_mydb_mark>#5047#% 23         return $block;

<tex2html_mydb_mark>#5048#% 24      }

<tex2html_mydb_mark>#5049#% \end{verbatim}

<tex2html_mydb_mark>#5050#% 

<tex2html_mydb_mark>#5051#% En una segunda fase, a la altura de \verb|definition| 

<tex2html_mydb_mark>#5052#% se construye la entrada para la función en la tabla de símbolos global:

<tex2html_mydb_mark>#5053#% 

<tex2html_mydb_mark>#5054#% \begin{verbatim}

<tex2html_mydb_mark>#5055#% definition:

<tex2html_mydb_mark>#5056#%     $funcDef 

<tex2html_mydb_mark>#5057#%       { 

<tex2html_mydb_mark>#5058#%         build_function_scope($funcDef, 'INT');

<tex2html_mydb_mark>#5059#%       }

<tex2html_mydb_mark>#5060#%   | %name FUNCTION

<tex2html_mydb_mark>#5061#%     $basictype $funcDef

<tex2html_mydb_mark>#5062#%       { 

<tex2html_mydb_mark>#5063#%         build_function_scope($funcDef, $basictype-;SPMgt;type);

<tex2html_mydb_mark>#5064#%       }

<tex2html_mydb_mark>#5065#%   | declaration 

<tex2html_mydb_mark>#5066#%      { 

<tex2html_mydb_mark>#5067#%        #control duplicated declarations

<tex2html_mydb_mark>#5068#%        my $message;

<tex2html_mydb_mark>#5069#%        die $message if $message = is_duplicated(\%st, $_[1]);

<tex2html_mydb_mark>#5070#%        %st = (%st,  %{$_[1]}); # improve this code

<tex2html_mydb_mark>#5071#%        return undef; # will not be inserted in the AST

<tex2html_mydb_mark>#5072#%      }

<tex2html_mydb_mark>#5073#% \end{verbatim}

<tex2html_mydb_mark>#5074#% El código de la función \verb|build_function_scope| es como sigue:

<tex2html_mydb_mark>#5075#% 

<tex2html_mydb_mark>#5076#% \begin{verbatim}

<tex2html_mydb_mark>#5077#% sub build_function_scope { 

<tex2html_mydb_mark>#5078#%   my ($funcDef, $returntype) = @_;

<tex2html_mydb_mark>#5079#% 

<tex2html_mydb_mark>#5080#%   my $function_name = $funcDef-;SPMgt;{function_name}[0];

<tex2html_mydb_mark>#5081#%   my @parameters = @{$funcDef-;SPMgt;{parameters}};

<tex2html_mydb_mark>#5082#%   my $lst = $funcDef-;SPMgt;{symboltable};

<tex2html_mydb_mark>#5083#%   my $numargs = scalar(@parameters);

<tex2html_mydb_mark>#5084#% 

<tex2html_mydb_mark>#5085#%   #compute type

<tex2html_mydb_mark>#5086#%   my ($partype, $sep) = (;SPMquot;;SPMquot;, ;SPMquot;;SPMquot;);

<tex2html_mydb_mark>#5087#%   if (@parameters) {

<tex2html_mydb_mark>#5088#%     $partype .= reduce { ;SPMquot;$lst-;SPMgt;{$a}{type},$lst-;SPMgt;{$b}{type};SPMquot; } @parameters;

<tex2html_mydb_mark>#5089#%     $sep =',';

<tex2html_mydb_mark>#5090#%   }

<tex2html_mydb_mark>#5091#%   my $type = ;SPMquot;F_$numargs($partype$sep$returntype);SPMquot;;

<tex2html_mydb_mark>#5092#% 

<tex2html_mydb_mark>#5093#%   #insert it in the hash of types

<tex2html_mydb_mark>#5094#%   $type{$type} = 1;

<tex2html_mydb_mark>#5095#% 

<tex2html_mydb_mark>#5096#%   #insert it in the global symbol table

<tex2html_mydb_mark>#5097#%   die ;SPMquot;Duplicated declaration of $function_name at line $funcDef--;SPMgt;{attr}[1]\n;SPMquot; 

<tex2html_mydb_mark>#5098#%     if exists($st{$function_name});

<tex2html_mydb_mark>#5099#%   $st{$function_name}-;SPMgt;{type} = $type;

<tex2html_mydb_mark>#5100#%   $st{$function_name}-;SPMgt;{line} = $funcDef-;SPMgt;{function_name}[1];

<tex2html_mydb_mark>#5101#% 

<tex2html_mydb_mark>#5102#%   return $funcDef;

<tex2html_mydb_mark>#5103#% }

<tex2html_mydb_mark>#5104#% \end{verbatim}

<tex2html_mydb_mark>#5105#% 

<tex2html_mydb_mark>#5106#% \paragraph{Procesado de las Listas de Parámetros}

<tex2html_mydb_mark>#5107#% Como puede verse en el apéndice 

<tex2html_mydb_mark>#5108#% en la página \pageref{apendice:simplecastparametros}

<tex2html_mydb_mark>#5109#% el nodo \verb|PARAMS| para la entrada

<tex2html_mydb_mark>#5110#% \verb|int f(int a,char b[10],int c[10][20]) { a = b[1]; }| tiene

<tex2html_mydb_mark>#5111#% la estructura:

<tex2html_mydb_mark>#5112#% \begin{verbatim}

<tex2html_mydb_mark>#5113#% PS(P(T(int), T(a), AS(T([]))), P(T(chr),T(b),AS(T(10))), P(T(int), T(c), AS(T(10),T(20))))

<tex2html_mydb_mark>#5114#% \end{verbatim}

<tex2html_mydb_mark>#5115#% La lista de parámetros estaba definida por:

<tex2html_mydb_mark>#5116#% \begin{verbatim}

<tex2html_mydb_mark>#5117#% params: 

<tex2html_mydb_mark>#5118#%     ( basictype ID arraySpec);SPMlt;%name PARAMS * ',';SPMgt;

<tex2html_mydb_mark>#5119#%       { $_[1] }

<tex2html_mydb_mark>#5120#% \end{verbatim}

<tex2html_mydb_mark>#5121#% 

<tex2html_mydb_mark>#5122#% \paragraph{El Tratamiento del Programa Principal}

<tex2html_mydb_mark>#5123#% Sigue el código (incompleto) asociado con la variable sintáctica de

<tex2html_mydb_mark>#5124#% arranque:

<tex2html_mydb_mark>#5125#% \begin{verbatim}

<tex2html_mydb_mark>#5126#% program:

<tex2html_mydb_mark>#5127#%     definition;SPMlt;%name PROGRAM +;SPMgt;.program

<tex2html_mydb_mark>#5128#%       { 

<tex2html_mydb_mark>#5129#%         $program-;SPMgt;{symboltable} = { %st };  # creates a copy of the s.t.

<tex2html_mydb_mark>#5130#%         for (keys %type) {

<tex2html_mydb_mark>#5131#%           $type{$_} = Parse::Eyapp::Node-;SPMgt;new($_);

<tex2html_mydb_mark>#5132#%         }

<tex2html_mydb_mark>#5133#%         $program-;SPMgt;{depth} = 0;

<tex2html_mydb_mark>#5134#%         $program-;SPMgt;{line}  = 1;

<tex2html_mydb_mark>#5135#%         $program-;SPMgt;{types} = { %type };  

<tex2html_mydb_mark>#5136#%         $program-;SPMgt;{lines} = $tokenend;  

<tex2html_mydb_mark>#5137#% 

<tex2html_mydb_mark>#5138#%         # Reset file scope variables

<tex2html_mydb_mark>#5139#%         %st = (); # reset symbol table

<tex2html_mydb_mark>#5140#%         ($tokenbegin, $tokenend) = (1, 1);

<tex2html_mydb_mark>#5141#%         %type = (INT =;SPMgt; ;SPMquot;INT;SPMquot;, CHAR =;SPMgt; ;SPMquot;CHAR;SPMquot;);

<tex2html_mydb_mark>#5142#%         $program;

<tex2html_mydb_mark>#5143#%       }

<tex2html_mydb_mark>#5144#% \end{verbatim}

<tex2html_mydb_mark>#5145#% 

<tex2html_mydb_mark>#5146#% \paragraph{Nombres de atributos de expresiones complejas Eyapp}

<tex2html_mydb_mark>#5147#% Un inciso para explicar la parte derecha de la regla de producción

<tex2html_mydb_mark>#5148#% usada en el párrafo anterior:

<tex2html_mydb_mark>#5149#% 

<tex2html_mydb_mark>#5150#% \verb|program: definition;SPMlt;%name PROGRAM +;SPMgt;.program|

<tex2html_mydb_mark>#5151#% 

<tex2html_mydb_mark>#5152#% observe los siguientes detalles:

<tex2html_mydb_mark>#5153#% 

<tex2html_mydb_mark>#5154#% \begin{enumerate}

<tex2html_mydb_mark>#5155#% \item

<tex2html_mydb_mark>#5156#% Es posible usar los símbolos menor/mayor para incidir en el hecho de que la especificación

<tex2html_mydb_mark>#5157#% del tipo del nodo construido como nodo \verb|PROGRAM| se le da a la lista no vacía 

<tex2html_mydb_mark>#5158#% de repeticiones de \verb|definition|. 

<tex2html_mydb_mark>#5159#% Funciona como un paréntesis de agrupamiento y es opcional. Podríamos haber escrito:

<tex2html_mydb_mark>#5160#% 

<tex2html_mydb_mark>#5161#% \verb|program: definition %name PROGRAM +.program|

<tex2html_mydb_mark>#5162#% 

<tex2html_mydb_mark>#5163#% pero es, sin duda, mas confuso para el lector.

<tex2html_mydb_mark>#5164#% 

<tex2html_mydb_mark>#5165#% \item

<tex2html_mydb_mark>#5166#% Si queremos darle nombre al nodo asociado con el único elemento en la parte derecha

<tex2html_mydb_mark>#5167#% de la regla:

<tex2html_mydb_mark>#5168#% 

<tex2html_mydb_mark>#5169#% \verb|program: definition %name PROGRAM +.program|

<tex2html_mydb_mark>#5170#% 

<tex2html_mydb_mark>#5171#% no podemos usar la \cei{notación dolar}. Este código que pretende ser equivalente al anterior:

<tex2html_mydb_mark>#5172#% \begin{verbatim}

<tex2html_mydb_mark>#5173#% program:

<tex2html_mydb_mark>#5174#%     $definition;SPMlt;%name PROGRAM +;SPMgt;

<tex2html_mydb_mark>#5175#% \end{verbatim}

<tex2html_mydb_mark>#5176#% produce un mensaje de error:

<tex2html_mydb_mark>#5177#% \begin{verbatim}

<tex2html_mydb_mark>#5178#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; eyapp Simple4

<tex2html_mydb_mark>#5179#% *Fatal* $ is allowed for identifiers only, at line 144 at file Simple4.eyp

<tex2html_mydb_mark>#5180#% \end{verbatim}

<tex2html_mydb_mark>#5181#% La razón del mensaje es que la expresión \verb|$definition;SPMlt;%name PROGRAM +;SPMgt;| es interpretada

<tex2html_mydb_mark>#5182#% como \verb|$(definition;SPMlt;%name PROGRAM +;SPMgt;)|, esto es el dolar esta actuando sobre 

<tex2html_mydb_mark>#5183#% la expresión \verb|definition;SPMlt;%name PROGRAM +;SPMgt;| que no es un identificador sino

<tex2html_mydb_mark>#5184#% una expresión compleja.

<tex2html_mydb_mark>#5185#% 

<tex2html_mydb_mark>#5186#% \emph{En vez del dolar deberemos usar la \cei{notación punto} para darle

<tex2html_mydb_mark>#5187#% nombre al atributo, como se ha hecho en el ejemplo}.

<tex2html_mydb_mark>#5188#% \end{enumerate}

<tex2html_mydb_mark>#5189#% 

<tex2html_mydb_mark>#5190#% \paragraph{La Jerarquía de Bloques}

<tex2html_mydb_mark>#5191#% Para construir la jerarquía de bloques usaremos treeregexps. 

<tex2html_mydb_mark>#5192#% Aún cuando el programa árbol es trivial, vamos a aislarlo

<tex2html_mydb_mark>#5193#% en un fichero \verb|SimpleTrans.trg| en la esperanza de que irá 

<tex2html_mydb_mark>#5194#% creciendo en complejidad conforme avancemos en las sucesivas

<tex2html_mydb_mark>#5195#% etapas del compilador:

<tex2html_mydb_mark>#5196#% 

<tex2html_mydb_mark>#5197#% \begin{verbatim}

<tex2html_mydb_mark>#5198#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; cat -n SimpleTrans.trg

<tex2html_mydb_mark>#5199#%      1  blocks:  /BLOCK|FUNCTION|PROGRAM/

<tex2html_mydb_mark>#5200#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; make

<tex2html_mydb_mark>#5201#% treereg SimpleTrans

<tex2html_mydb_mark>#5202#% eyapp Simple4

<tex2html_mydb_mark>#5203#% nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; ls -ltr | tail -4

<tex2html_mydb_mark>#5204#% -rw-rw----  1 pl users 12465 2006-11-23 16:21 Simple4.eyp

<tex2html_mydb_mark>#5205#% -rw-rw----  1 pl users    34 2006-11-23 16:25 SimpleTrans.trg

<tex2html_mydb_mark>#5206#% -rw-rw----  1 pl users   860 2006-11-23 16:25 SimpleTrans.pm

<tex2html_mydb_mark>#5207#% -rw-rw----  1 pl users 44463 2006-11-23 16:25 Simple4.pm

<tex2html_mydb_mark>#5208#% \end{verbatim}

<tex2html_mydb_mark>#5209#% 

<tex2html_mydb_mark>#5210#% ello significa que en el fichero \verb|Simple4.eyp| 

<tex2html_mydb_mark>#5211#% tenemos que explicitar el uso 

<tex2html_mydb_mark>#5212#% del módulo generado por \verb|treereg|. 

<tex2html_mydb_mark>#5213#% Además importaremos la función \verb|lastval|:

<tex2html_mydb_mark>#5214#% 

<tex2html_mydb_mark>#5215#% \begin{verbatim}

<tex2html_mydb_mark>#5216#% %{

<tex2html_mydb_mark>#5217#% use strict;

<tex2html_mydb_mark>#5218#% use Data::Dumper;

<tex2html_mydb_mark>#5219#% use List::Util qw(reduce);

<tex2html_mydb_mark>#5220#% use List::MoreUtils qw(firstval lastval);

<tex2html_mydb_mark>#5221#% use SimpleTrans;

<tex2html_mydb_mark>#5222#% ...............

<tex2html_mydb_mark>#5223#% 

<tex2html_mydb_mark>#5224#% sub Run {

<tex2html_mydb_mark>#5225#%  my($self)=shift;

<tex2html_mydb_mark>#5226#%  my ($a, $t);

<tex2html_mydb_mark>#5227#%  for (@tests) {

<tex2html_mydb_mark>#5228#%    $self-;SPMgt;YYData-;SPMgt;{INPUT} = $_;

<tex2html_mydb_mark>#5229#%    eval {

<tex2html_mydb_mark>#5230#%      $t = $self-;SPMgt;YYParse( yylex =;SPMgt; \&_Lexer, yyerror =;SPMgt; \&_Error, #yydebug =;SPMgt; 0x1F 

<tex2html_mydb_mark>#5231#%      );

<tex2html_mydb_mark>#5232#%    };

<tex2html_mydb_mark>#5233#%    if ($@) { print ;SPMquot;Error in test program\n$@;SPMquot;; }

<tex2html_mydb_mark>#5234#%    else {

<tex2html_mydb_mark>#5235#%      $t-;SPMgt;build_blocks_tree();

<tex2html_mydb_mark>#5236#%      push @$a, $t;

<tex2html_mydb_mark>#5237#%    }

<tex2html_mydb_mark>#5238#%  }

<tex2html_mydb_mark>#5239#%  return $a;

<tex2html_mydb_mark>#5240#% }

<tex2html_mydb_mark>#5241#% \end{verbatim}

<tex2html_mydb_mark>#5242#% 

<tex2html_mydb_mark>#5243#% Observe que \verb|build_blocks_tree| es llamado como si fuera un método

<tex2html_mydb_mark>#5244#% del objeto nodo \verb|$t|. Lo que hemos hecho es alargar el nombre

<tex2html_mydb_mark>#5245#% de \verb|build_blocks_tree| para que pertenezca a la clase \verb|Parse::Eyapp::Node|:

<tex2html_mydb_mark>#5246#% 

<tex2html_mydb_mark>#5247#% \begin{verbatim}

<tex2html_mydb_mark>#5248#% sub Parse::Eyapp::Node::build_blocks_tree {

<tex2html_mydb_mark>#5249#%   my $t = shift; # tree

<tex2html_mydb_mark>#5250#% 

<tex2html_mydb_mark>#5251#%   my (@b, @blocks);

<tex2html_mydb_mark>#5252#%   @b = @blocks = $SimpleTrans::blocks-;SPMgt;m($t);

<tex2html_mydb_mark>#5253#%   while (@blocks) {     

<tex2html_mydb_mark>#5254#%     my $b = pop @blocks;

<tex2html_mydb_mark>#5255#%     my $d = $b-;SPMgt;{depth};

<tex2html_mydb_mark>#5256#%     my $f = lastval { $_-;SPMgt;{depth} ;SPMlt; $d} @blocks; 

<tex2html_mydb_mark>#5257#%     last unless $f;

<tex2html_mydb_mark>#5258#%     $b-;SPMgt;{fatherblock} = $f;

<tex2html_mydb_mark>#5259#%   }

<tex2html_mydb_mark>#5260#%   wantarray? @b : $t;

<tex2html_mydb_mark>#5261#% }

<tex2html_mydb_mark>#5262#% \end{verbatim}

<tex2html_mydb_mark>#5263#% 

<tex2html_mydb_mark>#5264#% El método \verb|build_blocks_tree| usa el método \verb|m| (por \emph{m}atch)

<tex2html_mydb_mark>#5265#% del objeto transformación \verb|$SimpleTrans|. Cuando es llamado

<tex2html_mydb_mark>#5266#% en un contexto de lista

<tex2html_mydb_mark>#5267#% \verb|m| devuelve la lista de nodos que casan en orden primero profundo de 

<tex2html_mydb_mark>#5268#% recorrido del árbol \verb|$t|.

<tex2html_mydb_mark>#5269#% 

<tex2html_mydb_mark>#5270#% Nótese que - por la forma del recorrido - 

<tex2html_mydb_mark>#5271#% el padre de un nódo \verb|$b| es el primer nodo a la izquierda de este 

<tex2html_mydb_mark>#5272#% en el array devuelto que tiene menor profundidad

<tex2html_mydb_mark>#5273#% que \verb|$b|. Esta propiedad es aprovechada para hilvanar 

<tex2html_mydb_mark>#5274#% los nodos bloque en un árbol ascendente.

<tex2html_mydb_mark>#5275#% 

<tex2html_mydb_mark>#5276#% Este sub-árbol de bloques puede ayudarnos en la fase de ubicar que declaración

<tex2html_mydb_mark>#5277#% se aplica a una aparición de un objeto dado en el texto del programa.

<tex2html_mydb_mark>#5278#% Para cada ocurrencia debemos determinar si fué declarada en el bloque

<tex2html_mydb_mark>#5279#% en el que ocurre o bien en uno de los nodos bloque antepasados 

<tex2html_mydb_mark>#5280#% de este.

<tex2html_mydb_mark>#5281#% 

<tex2html_mydb_mark>#5282#% \paragraph{Ejemplo de Salida:  La estructura de datos resultante}

<tex2html_mydb_mark>#5283#% Veamos un ejemplo de la estructura de como queda el árbol

<tex2html_mydb_mark>#5284#% para el programa de entrada:

<tex2html_mydb_mark>#5285#% \begin{verbatim}

<tex2html_mydb_mark>#5286#% int a,b[1][2],c[1][2][3]; 

<tex2html_mydb_mark>#5287#% char d,e[1][2]; 

<tex2html_mydb_mark>#5288#% char f(int a, char b[10]) {

<tex2html_mydb_mark>#5289#%   int c[1][2];

<tex2html_mydb_mark>#5290#%   char d[10], e[9];

<tex2html_mydb_mark>#5291#% 

<tex2html_mydb_mark>#5292#%   return b[0];

<tex2html_mydb_mark>#5293#% }

<tex2html_mydb_mark>#5294#% \end{verbatim}

<tex2html_mydb_mark>#5295#% Al volcarlo con \verb|Data::Dumper| obtenemos:

<tex2html_mydb_mark>#5296#% \begin{verbatim}

<tex2html_mydb_mark>#5297#% $VAR1 = bless( {

<tex2html_mydb_mark>#5298#%   'types' =;SPMgt; {

<tex2html_mydb_mark>#5299#%     'A_1(A_2(CHAR))' =;SPMgt; bless( {

<tex2html_mydb_mark>#5300#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5301#%         bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'CHAR' ) ] }, 'A_2' )

<tex2html_mydb_mark>#5302#%       ]

<tex2html_mydb_mark>#5303#%     }, 'A_1' ),

<tex2html_mydb_mark>#5304#%     'F_2(INT,A_10(CHAR),CHAR)' =;SPMgt; bless( {

<tex2html_mydb_mark>#5305#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5306#%         bless( { 'children' =;SPMgt; [] }, 'INT' ), # Type of the first arg

<tex2html_mydb_mark>#5307#%         bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'CHAR' ) ] }, 'A_10' ),

<tex2html_mydb_mark>#5308#%         bless( { 'children' =;SPMgt; [] }, 'CHAR' ) # Returns CHAR

<tex2html_mydb_mark>#5309#%       ]

<tex2html_mydb_mark>#5310#%     }, 'F_2' ),

<tex2html_mydb_mark>#5311#%     'CHAR' =;SPMgt; bless( { 'children' =;SPMgt; [] }, 'CHAR' ),

<tex2html_mydb_mark>#5312#%     'A_1(A_2(A_3(INT)))' =;SPMgt; bless( { # A_1

<tex2html_mydb_mark>#5313#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5314#%         bless( { # A_2

<tex2html_mydb_mark>#5315#%           'children' =;SPMgt; [

<tex2html_mydb_mark>#5316#%             bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'INT' ) ] }, 'A_3' )

<tex2html_mydb_mark>#5317#%           ]

<tex2html_mydb_mark>#5318#%         }, 'A_2' )

<tex2html_mydb_mark>#5319#%       ]

<tex2html_mydb_mark>#5320#%     }, 'A_1' ),

<tex2html_mydb_mark>#5321#%     'INT' =;SPMgt; bless( { 'children' =;SPMgt; [] }, 'INT' ),

<tex2html_mydb_mark>#5322#%     'A_1(A_2(INT))' =;SPMgt; bless( {

<tex2html_mydb_mark>#5323#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5324#%         bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'INT' ) ] }, 'A_2' )

<tex2html_mydb_mark>#5325#%       ]

<tex2html_mydb_mark>#5326#%     }, 'A_1' ),

<tex2html_mydb_mark>#5327#%     'A_9(CHAR)' =;SPMgt; bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'CHAR' ) ] }, 'A_9' ),

<tex2html_mydb_mark>#5328#%     'A_10(CHAR)' =;SPMgt; bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'CHAR' ) ] }, 'A_10' )

<tex2html_mydb_mark>#5329#%   },

<tex2html_mydb_mark>#5330#%   'symboltable' =;SPMgt; {

<tex2html_mydb_mark>#5331#%     'e' =;SPMgt; { 'type' =;SPMgt; 'A_1(A_2(CHAR))', 'line' =;SPMgt; 2 },

<tex2html_mydb_mark>#5332#%     'c' =;SPMgt; { 'type' =;SPMgt; 'A_1(A_2(A_3(INT)))', 'line' =;SPMgt; 1 },

<tex2html_mydb_mark>#5333#%     'a' =;SPMgt; { 'type' =;SPMgt; 'INT', 'line' =;SPMgt; 1 },

<tex2html_mydb_mark>#5334#%     'b' =;SPMgt; { 'type' =;SPMgt; 'A_1(A_2(INT))', 'line' =;SPMgt; 1 },

<tex2html_mydb_mark>#5335#%     'd' =;SPMgt; { 'type' =;SPMgt; 'CHAR', 'line' =;SPMgt; 2 },

<tex2html_mydb_mark>#5336#%     'f' =;SPMgt; { 'type' =;SPMgt; 'F_2(INT,A_10(CHAR),CHAR)', 'line' =;SPMgt; 3 }

<tex2html_mydb_mark>#5337#%   },

<tex2html_mydb_mark>#5338#%   'lines' =;SPMgt; 8,

<tex2html_mydb_mark>#5339#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#5340#%     bless( {

<tex2html_mydb_mark>#5341#%       'parameters' =;SPMgt; [ 'a', 'b' ],

<tex2html_mydb_mark>#5342#%       'symboltable' =;SPMgt; {

<tex2html_mydb_mark>#5343#%         'e' =;SPMgt; { 'type' =;SPMgt; 'A_9(CHAR)', 'line' =;SPMgt; 5 },

<tex2html_mydb_mark>#5344#%         'c' =;SPMgt; { 'type' =;SPMgt; 'A_1(A_2(INT))', 'line' =;SPMgt; 4 },

<tex2html_mydb_mark>#5345#%         'a' =;SPMgt; { 'type' =;SPMgt; 'INT', 'param' =;SPMgt; 1, 'line' =;SPMgt; 3 },

<tex2html_mydb_mark>#5346#%         'b' =;SPMgt; { 'type' =;SPMgt; 'A_10(CHAR)', 'param' =;SPMgt; 1, 'line' =;SPMgt; 3 },

<tex2html_mydb_mark>#5347#%         'd' =;SPMgt; { 'type' =;SPMgt; 'A_10(CHAR)', 'line' =;SPMgt; 5 }

<tex2html_mydb_mark>#5348#%       },

<tex2html_mydb_mark>#5349#%       'function_name' =;SPMgt; [ 'f', 3 ],

<tex2html_mydb_mark>#5350#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5351#%         bless( { # RETURN 

<tex2html_mydb_mark>#5352#%           'children' =;SPMgt; [

<tex2html_mydb_mark>#5353#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; [ 'RETURN', 7 ], 'token' =;SPMgt; 'RETURN' }, 'TERMINAL' ),

<tex2html_mydb_mark>#5354#%             bless( { # VARARRAY 

<tex2html_mydb_mark>#5355#%               'children' =;SPMgt; [

<tex2html_mydb_mark>#5356#%                 bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; [ 'b', 7 ], 'token' =;SPMgt; 'ID' }, 'TERMINAL' ),

<tex2html_mydb_mark>#5357#%                 bless( { # INDEXSPEC 

<tex2html_mydb_mark>#5358#%                   'children' =;SPMgt; [

<tex2html_mydb_mark>#5359#%                     bless( { # INUM

<tex2html_mydb_mark>#5360#%                       'children' =;SPMgt; [

<tex2html_mydb_mark>#5361#%                         bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; [ '0', 7 ], 'token' =;SPMgt; 'INUM' }, 'TERMINAL' )

<tex2html_mydb_mark>#5362#%                       ]

<tex2html_mydb_mark>#5363#%                     }, 'INUM' )

<tex2html_mydb_mark>#5364#%                   ]

<tex2html_mydb_mark>#5365#%                 }, 'INDEXSPEC' )

<tex2html_mydb_mark>#5366#%               ]

<tex2html_mydb_mark>#5367#%             }, 'VARARRAY' )

<tex2html_mydb_mark>#5368#%           ]

<tex2html_mydb_mark>#5369#%         }, 'RETURN' )

<tex2html_mydb_mark>#5370#%       ]

<tex2html_mydb_mark>#5371#%     }, 'FUNCTION' )

<tex2html_mydb_mark>#5372#%   ]

<tex2html_mydb_mark>#5373#% }, 'PROGRAM' );

<tex2html_mydb_mark>#5374#% \end{verbatim}

<tex2html_mydb_mark>#5375#% 

<tex2html_mydb_mark>#5376#% \paragraph{Ejemplo de Salida: Función sin Parámetros}

<tex2html_mydb_mark>#5377#% Un segundo ejemplo. Ante la entrada:

<tex2html_mydb_mark>#5378#% \begin{verbatim}

<tex2html_mydb_mark>#5379#% char d,e[1][2]; 

<tex2html_mydb_mark>#5380#% char f() {

<tex2html_mydb_mark>#5381#%   int c[2];

<tex2html_mydb_mark>#5382#%   char d;

<tex2html_mydb_mark>#5383#% 

<tex2html_mydb_mark>#5384#%   return d;

<tex2html_mydb_mark>#5385#% }

<tex2html_mydb_mark>#5386#% \end{verbatim}

<tex2html_mydb_mark>#5387#% Obtenemos la salida:

<tex2html_mydb_mark>#5388#% \begin{verbatim}

<tex2html_mydb_mark>#5389#% $VAR1 = bless( {

<tex2html_mydb_mark>#5390#%   'types' =;SPMgt; {

<tex2html_mydb_mark>#5391#%     'A_1(A_2(CHAR))' =;SPMgt; bless( {

<tex2html_mydb_mark>#5392#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5393#%         bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'CHAR' ) ] }, 'A_2' )

<tex2html_mydb_mark>#5394#%       ]

<tex2html_mydb_mark>#5395#%     }, 'A_1' ),

<tex2html_mydb_mark>#5396#%     'A_2(INT)' =;SPMgt; bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'INT' ) ] }, 'A_2' ),

<tex2html_mydb_mark>#5397#%     'CHAR' =;SPMgt; bless( { 'children' =;SPMgt; [] }, 'CHAR' ),

<tex2html_mydb_mark>#5398#%     'F_0(CHAR)' =;SPMgt; bless( { 'children' =;SPMgt; [ bless( { 'children' =;SPMgt; [] }, 'CHAR' ) ] }, 'F_0' ),

<tex2html_mydb_mark>#5399#%     'INT' =;SPMgt; bless( { 'children' =;SPMgt; [] }, 'INT' )

<tex2html_mydb_mark>#5400#%   },

<tex2html_mydb_mark>#5401#%   'symboltable' =;SPMgt; {

<tex2html_mydb_mark>#5402#%     'e' =;SPMgt; { 'type' =;SPMgt; 'A_1(A_2(CHAR))', 'line' =;SPMgt; 1 },

<tex2html_mydb_mark>#5403#%     'd' =;SPMgt; { 'type' =;SPMgt; 'CHAR', 'line' =;SPMgt; 1 },

<tex2html_mydb_mark>#5404#%     'f' =;SPMgt; { 'type' =;SPMgt; 'F_0(CHAR)', 'line' =;SPMgt; 2 }

<tex2html_mydb_mark>#5405#%   },

<tex2html_mydb_mark>#5406#%   'lines' =;SPMgt; 7,

<tex2html_mydb_mark>#5407#%   'children' =;SPMgt; [

<tex2html_mydb_mark>#5408#%     bless( {

<tex2html_mydb_mark>#5409#%       'parameters' =;SPMgt; [],

<tex2html_mydb_mark>#5410#%       'symboltable' =;SPMgt; {

<tex2html_mydb_mark>#5411#%         'c' =;SPMgt; { 'type' =;SPMgt; 'A_2(INT)', 'line' =;SPMgt; 3 },

<tex2html_mydb_mark>#5412#%         'd' =;SPMgt; { 'type' =;SPMgt; 'CHAR', 'line' =;SPMgt; 4 }

<tex2html_mydb_mark>#5413#%       },

<tex2html_mydb_mark>#5414#%       'function_name' =;SPMgt; [ 'f', 2 ],

<tex2html_mydb_mark>#5415#%       'children' =;SPMgt; [

<tex2html_mydb_mark>#5416#%         bless( {

<tex2html_mydb_mark>#5417#%           'children' =;SPMgt; [

<tex2html_mydb_mark>#5418#%             bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; [ 'RETURN', 6 ], 'token' =;SPMgt; 'RETURN' }, 'TERMINAL' ),

<tex2html_mydb_mark>#5419#%             bless( {

<tex2html_mydb_mark>#5420#%               'children' =;SPMgt; [

<tex2html_mydb_mark>#5421#%                 bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; [ 'd', 6 ], 'token' =;SPMgt; 'ID' }, 'TERMINAL' )

<tex2html_mydb_mark>#5422#%               ]

<tex2html_mydb_mark>#5423#%             }, 'VAR' )

<tex2html_mydb_mark>#5424#%           ]

<tex2html_mydb_mark>#5425#%         }, 'RETURN' )

<tex2html_mydb_mark>#5426#%       ]

<tex2html_mydb_mark>#5427#%     }, 'FUNCTION' )

<tex2html_mydb_mark>#5428#%   ]

<tex2html_mydb_mark>#5429#% }, 'PROGRAM' );

<tex2html_mydb_mark>#5430#% \end{verbatim}

<tex2html_mydb_mark>#5431#% 

<tex2html_mydb_mark>#5432#% \sectionpractica{Establecimiento de la relación uso-declaración}

<tex2html_mydb_mark>#5433#% \label{practica:identificaciondelosnombres}

<tex2html_mydb_mark>#5434#% En la segunda parte se resuelve el problema de la identificación de los

<tex2html_mydb_mark>#5435#% nombres estableciendo la relación entre el uso de un nombre y la declaración

<tex2html_mydb_mark>#5436#% que se le aplica (dada por los atributos \verb|scope| y \verb|type|):

<tex2html_mydb_mark>#5437#% ver directorio /home/lhp/projects/perl/src/topdown/Simple

<tex2html_mydb_mark>#5438#%Definimos el patrón $\tilde{s}$ asociado con la parte derecha $s$

<tex2html_mydb_mark>#5439#%como el  patrón en $B(\Sigma \cup \{x_1, \ldots x_k\})$ resultante

<tex2html_mydb_mark>#5440#%de reemplazar los noterminales $X_j$ de $N$ por las variables $x_j$.

<tex2html_mydb_mark>#5441#%El patrón asociado con su parte derecha $s = CONS(E,L)$ es $\tilde{s} = CONS(x_1, x_2)$. 

<tex2html_mydb_mark>#5442#%symbol_table = ();
  
<tex2html_mydb_mark>#5443#%args) = @_;
  
<tex2html_mydb_mark>#5444#%args) {
    
<tex2html_mydb_mark>#5445#%\subsectionpractica{Recursividad por la Izquierda}

<tex2html_mydb_mark>#5446#%Escriba un programa Perl que indique que reglas de producción de una gramática

<tex2html_mydb_mark>#5447#%independiente del contexto (administrada como en el ejemplo desarrollado 

<tex2html_mydb_mark>#5448#%en la sección \ref{subsection:dbmhashes}) son

<tex2html_mydb_mark>#5449#%recursivas por la izquierda. Se dice que una regla de producción es

<tex2html_mydb_mark>#5450#%recursiva por la izquierda si es de la forma $A-;SPMgt;A \beta$. Esto es, la variable

<tex2html_mydb_mark>#5451#%sintáctica $A$ es el primer símbolo de la parte derecha de la regla

<tex2html_mydb_mark>#5452#%de producción.

<tex2html_mydb_mark>#5453#%symbol_table|

<tex2html_mydb_mark>#5454#%Esta fase podría considerarse

<tex2html_mydb_mark>#5455#%una extensión de la fase de análisis semántico, especialmente 

<tex2html_mydb_mark>#5456#%si atendemos a la definición de la fase de análisis semántico como ``fase de determinación 

<tex2html_mydb_mark>#5457#%de aquellas propiedades que, siendo dependientes del contexto, pueden ser

<tex2html_mydb_mark>#5458#%computadas estáticamente en tiempo de compilación''

<tex2html_mydb_mark>#5459#%En realidad este formato con selección

<tex2html_mydb_mark>#5460#%en términos de los atributos puede reducirse al anterior si se

<tex2html_mydb_mark>#5461#%considera que la transformación sólo tiene lugar cuando la acción devuelve 

<tex2html_mydb_mark>#5462#%un valor cierto.

<tex2html_mydb_mark>#5463#%

<tex2html_mydb_mark>#5464#%\vspace{0.25cm}

<tex2html_mydb_mark>#5465#%$ASSIGN(LEFTVALUE, x) \Longrightarrow skip$ \verb|{ notlive($LEFTVALUE) }| 

<tex2html_mydb_mark>#5466#%\vspace{0.25cm}

<tex2html_mydb_mark>#5467#%

<tex2html_mydb_mark>#5468#%arg = @_;
  
<tex2html_mydb_mark>#5469#%children = $node-;SPMgt;children;

<tex2html_mydb_mark>#5470#%children) {
    
<tex2html_mydb_mark>#5471#
lhp@nereida:~/Lperl/src/topdown/PL0506$ perl -v

This is perl, v5.8.4 built for i386-linux-thread-multi

Copyright 1987-2004, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using `man perl' or `perldoc perl'.  If you have access to the
Internet, point your browser at http://www.perl.com/, the Perl Home Page.
<tex2html_mydb_mark>#5472#
lhp@nereida:~/Lperl/src/topdown/PL0506$ h2xs -XA -n PL::Tutu
Defaulting to backwards compatibility with perl 5.8.4
If you intend this module to be compatible with earlier perl versions, please
specify a minimum perl version with the -b option.

Writing PL-Tutu/lib/PL/Tutu.pm
Writing PL-Tutu/Makefile.PL
Writing PL-Tutu/README
Writing PL-Tutu/t/PL-Tutu.t
Writing PL-Tutu/Changes
Writing PL-Tutu/MANIFEST
<tex2html_mydb_mark>#5473#
lhp@nereida:~/Lperl/src/topdown/PL0506$ tree
.
`-- PL-Tutu
    |-- Changes
    |-- MANIFEST
    |-- Makefile.PL
    |-- README
    |-- lib
    |   `-- PL
    |       `-- Tutu.pm
    `-- t
        `-- PL-Tutu.t

4 directories, 6 files
<tex2html_mydb_mark>#5474#
lhp@nereida:~/Lperl/src/topdown/PL0506$ cd PL-Tutu/
lhp@nereida:~/Lperl/src/topdown/PL0506/PL-Tutu$ perl Makefile.PL
Checking if your kit is complete...
Looks good
Writing Makefile for PL::Tutu
<tex2html_mydb_mark>#5475#
lhp@nereida:~/Lperl/src/topdown/PL0506/PL-Tutu/lib/PL$ pwd
/home/lhp/Lperl/src/topdown/PL0506/PL-Tutu/lib/PL
lhp@nereida:~/Lperl/src/topdown/PL0506/PL-Tutu/lib/PL$ ls -l
total 4
-rw-r--r--  1 lhp lhp 2343 2005-09-28 11:16 Tutu.pm
<tex2html_mydb_mark>#5476#
1;
__END__

=head1 NOMBRE

PL::Tutu - Compilador para un lenguaje sencillo denominado
          ;SPMquot;Tutu;SPMquot; que usaremos en la asignatura PL

=head1 SINOPSIS

  use PL::Tutu;
  
  La subrutina PL::Tutu::compiler recibe dos argumentos: el 
  nombre del fichero de entrada (fuente.tutu) y el nombre del fichero de
  salida (código ensamblador para una especie de P-máquina).

=head1 DESCRIPCIÓN

Este módulo tiene dos objetivos: aprender a hacer un pequeño compilador
y aprender a programar modularmente en Perl, usando un buen número
de los recursos que este lenguaje ofrece.

El siguiente es un ejemplo de código fuente tutu:
 
  int a,b; 
  string c;
  a = 2+3;
  b = 3*4; 
  c = ;SPMquot;hola;SPMquot;; 
  p c; 
  c = ;SPMquot;mundo;SPMquot;; 
  p c; 
  p 9+2; 
  p a+1; 
  p b+1

supuesto que está guardado en el fichero ;SPMquot;test2.tutu;SPMquot;, podemos 
escribir un programa Perl ;SPMquot;main.pl;SPMquot; para compilarlo: 

    $ cat main.pl
    #!/usr/bin/perl -w -I..
    #use PL::Tutu;
    use Tutu;

    PL::Tutu::compiler(@ARGV);

al ejecutar ;SPMquot;main.pl;SPMquot;:

    $ ./main.pl test2.tutu test2.ok

obtenemos el fichero ;SPMquot;test2.ok;SPMquot; con el ensamblador: 
    $ cat test2.ok
    DATA holamundo
    PUSH 5
    PUSHADDR 0
    STORE_INT
    PUSH 12
    PUSHADDR 1
    STORE_INT
    PUSHSTR 0 4
    PUSHADDR 2
    STORE_STRING
    LOAD_STRING 2
    PRINT_STR
    PUSHSTR 4 5
    PUSHADDR 2
    STORE_STRING
    LOAD_STRING 2
    PRINT_STR
    PUSH 11
    PRINT_INT
    LOAD 0
    INC
    PRINT_INT
    LOAD 1
    INC
    PRINT_INT

Para mas información consulta la página de la asignatura.
¡Buena suerte!

=head2 EXPORT

No se exporta nada al espacio de nombres del cliente.


=head1 AUTOR

Casiano Rodríguez León, E;SPMlt;lt;SPMgt;casiano@ull.esE;SPMlt;gt;SPMgt;

=head1 VÉASE TAMBIÉN

L;SPMlt;perl;SPMgt;.

=cut
<tex2html_mydb_mark>#5477#
<center>
<img src="perldoc.jpg">
<p>
El resultado de usar <tt>perldoc Tutu</tt>
</center>
<hr>
<p>
<tex2html_mydb_mark>#5478#
make test
<tex2html_mydb_mark>#5479#
use Este::Modulo;
<tex2html_mydb_mark>#5480#
=head1 cabecera 
=head2 cabecera 
=item texto
=over N
=back
=cut
=pod
=for X
=begin X
=end X
<tex2html_mydb_mark>#5481#
 1 package PL::Tutu;
 2 use 5.008004;   # Versión mínima de Perl 5.84
 3 use strict;     # Variables deben ser declaradas, etc.
 4 use warnings;   # Enviar warnings
 5 use IO::File;
 6 use Carp;       # Provee alternativas a ;SPMquot;die;SPMquot; and ;SPMquot;warn;SPMquot; 
 7 
 8 require Exporter;
 9 
10 our @ISA = qw(Exporter);   # Heredamos los métodos de la clase Exporter
11 our @EXPORT = qw( compile compile_from_file); # Estas funciones serán exportadas
12 our $VERSION = '0.01';     # Variable que define la versión del módulo
13 
14 our %symbol_table;         # La tabla de símbolos $symbol_table{x} contiene
15 our $data;                 # la información asociada con el objeto 'x'
16 our $target;               # tipo, dirección, etc.
17 our @tokens;               # La lista de terminales
18 our $errorflag;
19 our ($lookahead, $value);  # Token actual y su atributo
20 our $tree;                 # referencia al objeto que contiene
21 our $global_address;       # el árbol sintáctico
22 
23 # Lexical analyzer 
24 package Lexical::Analysis;
25 sub scanner {
26 }
27 
28 package Syntax::Analysis;
29 sub parser {
30 }
31 
32 package Machine::Independent::Optimization;
33 sub Optimize {
34 }
35 
36 package Code::Generation;
37 sub code_generator {
38 }
39   
40 package Peephole::Optimization;
41 sub transform {
42 }
43 
44 package PL::Tutu;
45 sub compile {
46   my ($input) = @_; # Observe el contexto!
47   local %symbol_table = (); 
48   local $data = ;SPMquot;;SPMquot;; # Contiene todas las cadenas en el programa fuente
49   local $target = ;SPMquot;;SPMquot;; # target code
50   local @tokens =();    # ;SPMquot;local;SPMquot; salva el valor que serÃ¡ recuperado al finalizar
51   local $errorflag = 0; # el Ã¡mbito
52   local ($lookahead, $value) = ();
53   local $tree = undef; # Referencia al Ã¡rbol sintÃctico abstracto 
54   local $global_address = 0; # Usado para guardar la Ãltima direcciÃn ocupada
55   
56   ########lexical analysis
57   ;SPMamp;Lexical::Analysis::scanner($input);
58 
59   ########syntax (and semantic) analysis
60   $tree = ;SPMamp;Syntax::Analysis::parser;
61 
62   ########machine independent optimizations
63   ;SPMamp;Machine::Independent::Optimization::Optimize;
64 
65   ########code generation
66   ;SPMamp;Code::Generation::code_generator;
67 
68   ########peephole optimization
69   ;SPMamp;Peephole::Optimization::transform($target);
70 
71   return \$target; #retornamos una referencia a $target
72 }
73 
74 sub compile_from_file {
75   my ($input_name, $output_name) = @_; # Nombres de ficheros
76   my $fhi;                             # de entrada y de salida
77   my $targetref;
78   
79   if (defined($input_name) and (-r $input_name)) {
80     $fhi = IO::File-;SPMgt;new(;SPMquot;;SPMlt; $input_name;SPMquot;);
81   }
82   else { $fhi = 'STDIN'; }
83   my $input;
84   { # leer todo el fichero
85     local $/ = undef; # localizamos para evitar efectos laterales
86     $input = ;SPMlt;$fhi;SPMgt;;
87   }
88   $targetref = compile($input);
89 
90   ########code output
91   my $fh = defined($output_name)? IO::File-;SPMgt;new(;SPMquot;;SPMgt; $output_name;SPMquot;) : 'STDOUT';
92   $fh-;SPMgt;print($$targetref);
93   $fh-;SPMgt;close;
94   1; # El Ãºltimo valor evaluado es el valor retornado
95 }
96 
97 1;  # El 1 indica que la fase de carga termina con éxito
98 # Sigue la documentación ...
<tex2html_mydb_mark>#5482#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/$ mkdir scripts
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cd scripts/
<tex2html_mydb_mark>#5483#
... # despues de crear los ficheros
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ ls
test01.tutu  tutu  tutu.pl
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ cat tutu.pl
#!/usr/bin/perl -w -I../lib/
use PL::Tutu;

PL::Tutu::compile_from_file(@ARGV);
<tex2html_mydb_mark>#5484#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ cat tutu
#!/usr/bin/perl -w
use lib ('../lib');
use PL::Tutu;

;SPMamp;PL::Tutu::compile_from_file(@ARGV);
<tex2html_mydb_mark>#5485#
$ export PERL5LIB=~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/lib
$ perl -MPL::Tutu -e 'PL::Tutu::compile_from_file(;SPMquot;test01.tutu;SPMquot;)'
<tex2html_mydb_mark>#5486#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cat MANIFEST.SKIP
\.o$
^\.cvsignore$
/\.cvsignore$
\.cvsignore$
CVS/[^/]+$
\.svn\b
^Makefile$
/Makefile$
^blib/
\.swp$
\.bak$
\.pdf$
\.ps$
\.sal$
pm_to_blib
\.pdf$
\.tar.gz$
\.tgz$
^META.yml$
<tex2html_mydb_mark>#5487#
make manifest
<tex2html_mydb_mark>#5488#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cat Makefile.PL
use 5.008004;
use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    NAME              =;SPMgt; 'PL::Tutu',
    VERSION_FROM      =;SPMgt; 'lib/PL/Tutu.pm', # finds $VERSION
    PREREQ_PM         =;SPMgt; {}, # e.g., Module::Name =;SPMgt; 1.1
    EXE_FILES         =;SPMgt; [ 'scripts/tutu.pl', 'scripts/tutu' ],
    ($] ;SPMgt;= 5.005 ?     ## Add these new keywords supported since 5.005
      (ABSTRACT_FROM  =;SPMgt; 'lib/PL/Tutu.pm', # retrieve abstract from module
       AUTHOR         =;SPMgt; 'Lenguajes y Herramientas de Programacion ;SPMlt;lhp@;SPMgt;') : ()),
);
<tex2html_mydb_mark>#5489#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ perl Makefile.PL
Writing Makefile for PL::Tutu
<tex2html_mydb_mark>#5490#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make
cp scripts/tutu blib/script/tutu
/usr/bin/perl ;SPMquot;-MExtUtils::MY;SPMquot; -e ;SPMquot;MY-;SPMgt;fixin(shift);SPMquot; blib/script/tutu
cp scripts/tutu.pl blib/script/tutu.pl
/usr/bin/perl ;SPMquot;-MExtUtils::MY;SPMquot; -e ;SPMquot;MY-;SPMgt;fixin(shift);SPMquot; blib/script/tutu.pl
Manifying blib/man3/PL::Tutu.3pm
<tex2html_mydb_mark>#5491#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make manifest
/usr/bin/perl ;SPMquot;-MExtUtils::Manifest=mkmanifest;SPMquot; -e mkmanifest
Added to MANIFEST: scripts/tutu
<tex2html_mydb_mark>#5492#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make test
PERL_DL_NONLAZY=1 /usr/bin/perl ;SPMquot;-MExtUtils::Command::MM;SPMquot; ;SPMquot;-e;SPMquot; ;SPMquot;test_harness(0, 'blib/lib', 'blib/arch');SPMquot; t/*.t
t/PL-Tutu....ok
All tests successful.
Files=1, Tests=1,  0 wallclock secs ( 0.08 cusr +  0.00 csys =  0.08 CPU)
<tex2html_mydb_mark>#5493#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cd scripts/
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ ls -l
total 12
-rw-r--r--  1 lhp lhp 15 2005-09-29 12:56 test01.tutu
-rwxr-xr-x  1 lhp lhp 92 2005-09-29 13:29 tutu
-rwxr-xr-x  1 lhp lhp 80 2005-09-29 12:58 tutu.pl
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ tutu test01.tutu test01.sal
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ ls -l
total 12
-rw-r--r--  1 lhp lhp  0 2005-09-29 13:53 test01.sal
-rw-r--r--  1 lhp lhp 15 2005-09-29 12:56 test01.tutu
-rwxr-xr-x  1 lhp lhp 92 2005-09-29 13:29 tutu
-rwxr-xr-x  1 lhp lhp 80 2005-09-29 12:58 tutu.pl
<tex2html_mydb_mark>#5494#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ cat test01.tutu
int a,b;
a = 4
<tex2html_mydb_mark>#5495#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make dist
rm -rf PL-Tutu-0.01
/usr/bin/perl ;SPMquot;-MExtUtils::Manifest=manicopy,maniread;SPMquot; \
        -e ;SPMquot;manicopy(maniread(),'PL-Tutu-0.01', 'best');;SPMquot;
mkdir PL-Tutu-0.01
mkdir PL-Tutu-0.01/scripts
mkdir PL-Tutu-0.01/lib
mkdir PL-Tutu-0.01/lib/PL
mkdir PL-Tutu-0.01/t
tar cvf PL-Tutu-0.01.tar PL-Tutu-0.01
PL-Tutu-0.01/
PL-Tutu-0.01/scripts/
PL-Tutu-0.01/scripts/test01.tutu
PL-Tutu-0.01/scripts/tutu
PL-Tutu-0.01/scripts/tutu.pl
PL-Tutu-0.01/META.yml
PL-Tutu-0.01/Changes
PL-Tutu-0.01/MANIFEST
PL-Tutu-0.01/lib/
PL-Tutu-0.01/lib/PL/
PL-Tutu-0.01/lib/PL/Tutu.pm
PL-Tutu-0.01/MANIFEST.SKIP
PL-Tutu-0.01/t/
PL-Tutu-0.01/t/PL-Tutu.t
PL-Tutu-0.01/Makefile.PL
PL-Tutu-0.01/README
rm -rf PL-Tutu-0.01
gzip --best PL-Tutu-0.01.tar
<tex2html_mydb_mark>#5496#
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ ls -ltr
total 72
drwxr-xr-x  2 lhp lhp  4096 2005-09-29 12:01 t
-rw-r--r--  1 lhp lhp  1196 2005-09-29 12:01 README
drwxr-xr-x  3 lhp lhp  4096 2005-09-29 12:01 lib
-rw-r--r--  1 lhp lhp   152 2005-09-29 12:01 Changes
-rw-r--r--  1 lhp lhp   167 2005-09-29 13:23 MANIFEST.SKIP
-rw-r--r--  1 lhp lhp     0 2005-09-29 13:23 pm_to_blib
drwxr-xr-x  6 lhp lhp  4096 2005-09-29 13:23 blib
-rw-r--r--  1 lhp lhp   113 2005-09-29 13:23 MANIFEST.bak
drwxr-xr-x  2 lhp lhp  4096 2005-09-29 13:29 scripts
-rw-r--r--  1 lhp lhp   616 2005-09-29 13:49 Makefile.PL
-rw-r--r--  1 lhp lhp 20509 2005-09-29 13:51 Makefile
-rw-r--r--  1 lhp lhp  3654 2005-09-29 16:34 PL-Tutu-0.01.tar.gz
-rw-r--r--  1 lhp lhp   298 2005-09-29 16:34 META.yml
-rw-r--r--  1 lhp lhp   205 2005-09-29 16:34 MANIFEST
<tex2html_mydb_mark>#5497#
my ($input) = @_;
<tex2html_mydb_mark>#5498#
my $input = @_;
<tex2html_mydb_mark>#5499#
85   local $/ = undef;
86   my $input = ;SPMlt;$fhi;SPMgt;;
<tex2html_mydb_mark>#5500#
92   $fh-;SPMgt;print($$targetref);
<tex2html_mydb_mark>#5501#
nereida:~/LEyapp/examples;SPMgt; cat -n treereg
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Parse::Eyapp::YATW;
 4  use Parse::Eyapp::Node;
 5  use Parse::Eyapp::Treeregexp;
 6  use Carp;
 7  use Getopt::Long;
 8  use Pod::Usage;
 9
10  my $infile;
11  my $outfile;
12  my $packagename;
13  my $prefix = '';
14  my $syntax = 1;
15  my $numbers = 1;
16  my $severity = 0; # 0 = Don't  check arity. 1 = Check arity. 
17                    # 2 = Check arity and give a warning 3 = ... and croak
18  GetOptions(
19    'in=s'       =;SPMgt; \$infile,
20    'out=s'      =;SPMgt; \$outfile,
21    'mod=s'      =;SPMgt; \$packagename,
22    'prefix=s'   =;SPMgt; \$prefix,
23    'severity=i' =;SPMgt; \$severity,
24    'syntax!'    =;SPMgt; \$syntax,
25    'numbers!'   =;SPMgt; \$numbers,
26    'version'    =;SPMgt; \;SPMamp;version,
27    'usage'      =;SPMgt; \;SPMamp;usage,
28    'help'       =;SPMgt; \;SPMamp;man,
29  ) or croak usage();
30
31  # If an argument remains is the inputfile 
32  ($infile) = @ARGV unless defined($infile);
33  die usage() unless defined($infile);
34
35  my $treeparser = Parse::Eyapp::Treeregexp-;SPMgt;new(
36                      INFILE   =;SPMgt; $infile,
37                      OUTFILE  =;SPMgt; $outfile,
38                      PACKAGE  =;SPMgt; $packagename,
39                      PREFIX   =;SPMgt; $prefix,
40                      SYNTAX   =;SPMgt; $syntax,
41                      NUMBERS  =;SPMgt; $numbers,
42                      SEVERITY =;SPMgt; $severity
43                    );
44
45  $treeparser-;SPMgt;generate();
46
47  sub version {
48    print ;SPMquot;Version $Parse::Eyapp::Treeregexp::VERSION\n;SPMquot;;
49    exit;
50  }
51
52  sub usage {
53    print ;SPMlt;;SPMlt;;SPMquot;END_ERR;SPMquot;;
54  Supply the name of a file containing a tree grammar (.trg)
55  Usage is:
56  treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
57          [-p treeprefix] [-o outputfile] -i filename[.trg]
58  END_ERR
59    exit;
60  }
61
62  sub man {
63    pod2usage(
64      -exitval =;SPMgt; 1,
65      -verbose =;SPMgt; 2
66    );
67  }
68  __END__
69
70  =head1 SYNOPSIS
71
72    treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
73            [-p treeprefix] [-o outputfile] -i filename[.trg]
74    treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
75            [-p treeprefix] [-o outputfile] filename[.trg]
76 ... # Follows the documentation bla, bla, bla
<tex2html_mydb_mark>#5502#
nereida:~/LEyapp/examples;SPMgt; treereg -nos -nonu -se 3 -m Tutu Foldonly1.trg 
nereida:~/LEyapp/examples;SPMgt; treereg -nos -nonu -s 3 -m Tutu Foldonly1.trg  
Option s is ambiguous (severity, syntax)
nereida:~/LEyapp/examples;SPMgt; treereg -nos -bla -nonu -m Tutu Foldonly1.trg
Unknown option: bla
nereida:~/LEyapp/examples;SPMgt;
<tex2html_mydb_mark>#5503#
     ...
     if (m{\G\s*(\d+)}gc) {
       push @tokens, 'NUM', $1;
     } 
     elsif (m{\G\s*([a-z_]\w*)\b}igc) {
       push @tokens, 'ID', $1;
     } 
     ...
<tex2html_mydb_mark>#5504#
                            m{\G\s*(...)}gc
<tex2html_mydb_mark>#5505#
 1 package Lexical::Analysis;
 2 sub scanner {
 3   local $_ = shift;
 4   { # Con el redo del final hacemos un bucle ;SPMquot;infinito;SPMquot;
 5     if (m{\G\s*(\d+)}gc) {
 6       push @tokens, 'NUM', $1;
 7     } 
 8     elsif (m{\G\s*int\b}igc) {
 9       push @tokens, 'INT', 'INT';
10     } 
11     elsif (m{\G\s*string\b}igc) {
12       push @tokens, 'STRING', 'STRING';
13     } 
14     elsif (m{\G\s*p\b}igc) {
15       push @tokens, 'P', 'P'; # P para imprimir
16     } 
17     elsif (m{\G\s*([a-z_]\w*)\b}igc) {
18       push @tokens, 'ID', $1;
19     } 
20     elsif (m{\G\s*\"([^;SPMquot;]*)\"}igc) {
21       push @tokens, 'STR', $1;
22     } 
23     elsif (m{\G\s*([+*()=;,])}gc) {
24       push @tokens, 'PUN', $1;
25     }
26     elsif (m{\G\s*(\S)}gc) { # Hay un caracter ;SPMquot;no blanco;SPMquot;
27       Error::fatal ;SPMquot;Caracter invalido: $1\n;SPMquot;;
28     }
29     else {
30       last;
31     }
32     redo;
33   }
34 }
<tex2html_mydb_mark>#5506#
      return ('INT', 'INT') if (m{\G\s*int\b}igc);
<tex2html_mydb_mark>#5507#
######## global scope variables
our @tokens = ();
our $errorflag = 0;

package Error;

sub error($) {
  my $msg = shift;
  if (!$errorflag) {
    warn ;SPMquot;Error: $msg\n;SPMquot;;
    $errorflag = 1;
  }
}

sub fatal($) {
  my $msg = shift;
  die ;SPMquot;Error: $msg\n;SPMquot;;
}
<tex2html_mydb_mark>#5508#
$ perl -wde 0
main::(-e:1):   0
  DB;SPMlt;1;SPMgt; $x = ;SPMquot;ababab;SPMquot;
  DB;SPMlt;2;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 2
  DB;SPMlt;3;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 4
  DB;SPMlt;4;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 6
  DB;SPMlt;5;SPMgt; print ;SPMquot;falso;SPMquot; unless $x =~ m{b}g
falso
<tex2html_mydb_mark>#5509#
  DB;SPMlt;5;SPMgt; $x = ;SPMquot;bbabab;SPMquot;
  DB;SPMlt;6;SPMgt; $x =~ m{a}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= a pos = 3
  DB;SPMlt;7;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 4
  DB;SPMlt;8;SPMgt; $x =~ m{c}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
Use of uninitialized value in concatenation (.) 
  DB;SPMlt;18;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 1
<tex2html_mydb_mark>#5510#
  DB;SPMlt;23;SPMgt; $x = ;SPMquot;bbabab;SPMquot;
  DB;SPMlt;24;SPMgt; $x =~ m{a}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= a pos = 3
  DB;SPMlt;25;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 4
  DB;SPMlt;26;SPMgt; $x =~ m{c}gc
  DB;SPMlt;27;SPMgt; $x =~ m{b}g; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 6
<tex2html_mydb_mark>#5511#
  DB;SPMlt;3;SPMgt; $x = ;SPMquot;bcbabab;SPMquot;
  DB;SPMlt;4;SPMgt; $x =~ m{b}gc; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 1
  DB;SPMlt;5;SPMgt; $x =~ m{a}gc; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= a pos = 4

  DB;SPMlt;6;SPMgt; $x = ;SPMquot;bcbabab;SPMquot;
  DB;SPMlt;7;SPMgt; $x =~ m{b}gc; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
match= b pos = 1
  DB;SPMlt;8;SPMgt; $x =~ m{\Ga}gc; print ;SPMquot;match= ;SPMquot;.$;SPMamp;.;SPMquot; pos = ;SPMquot;.pos($x)
Use of uninitialized value in concatenation 
match=  pos = 1
<tex2html_mydb_mark>#5512#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL/Lexical$ perl -de 0
  DB;SPMlt;1;SPMgt; 'bb' =~ m{b|bb}; print $;SPMamp;
  b
  DB;SPMlt;2;SPMgt; 'bb' =~ m{bb|b}; print $;SPMamp;
  bb
<tex2html_mydb_mark>#5513#
 DB;SPMlt;1;SPMgt; $stringre = qr{;SPMquot;(\\.|[^\\;SPMquot;])*;SPMquot;}
 DB;SPMlt;2;SPMgt; print $;SPMamp; if ';SPMquot;esta \"palabra\" va entre comillas;SPMquot;' =~ $stringre
 ;SPMquot;esta \"palabra\" va entre comillas;SPMquot;
<tex2html_mydb_mark>#5514#
pl@nereida:~/src/perl/testing$ cat -n ccomments.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  sub showmatches {
 5   my ($x, $re) = @_;
 6
 7    for (my $i = 0; $x =~ /$re/gsx; $i++) {
 8      print ;SPMquot;matching $i: $1\n;SPMquot;;
 9      $i++;
10    }
11  }
12
13  my $x = ;SPMlt;;SPMlt;'EOC';
14  if (x) {
15    /* a comment */ return x + 1; /* another comment */
16  }
17  else {
18    return x + 2; /* a last comment */
19  }
20  EOC
21
22  print ;SPMquot;\n************************\n;SPMquot;;
23
24  my $greedy = q{ (
25           /\*  # Abrir comentario
26           .*   # Consumir caracteres (greedy)
27           \*/  # Cerrar comentario
28           )
29  };
30  print ;SPMquot;Greedy:\n;SPMquot;;
31  showmatches($x, $greedy);
32
33  print ;SPMquot;\n************************\n;SPMquot;;
34
35  my $lazy = q{ (
36           /\*  # Abrir comentario
37           .*?  # Consumir caracteres (lazy)
38           \*/  # Cerrar comentario
39           )
40  };
41  print ;SPMquot;Lazy:\n;SPMquot;;
42  showmatches($x, $lazy);
<tex2html_mydb_mark>#5515#
pl@nereida:~/src/perl/testing$ ccomments.pl

************************
Greedy:
matching 0: /* a comment */ return x + 1; /* another comment */
}
else {
  return x + 2; /* a last comment */

************************
Lazy:
matching 0: /* a comment */
matching 2: /* another comment */
matching 4: /* a last comment */
<tex2html_mydb_mark>#5516#
lhp@nereida:~$ perl -de 0
  DB;SPMlt;1;SPMgt; print ;SPMquot;Si;SPMquot; if  ('.5' =~ m{\d+})
Si
  DB;SPMlt;2;SPMgt; print ;SPMquot;Si;SPMquot; if  ('.5' =~ m{^\d+})

  DB;SPMlt;3;SPMgt; print ;SPMquot;Si;SPMquot; if  '0.7' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}
Si
  DB;SPMlt;4;SPMgt; print ;SPMquot;Si;SPMquot; if  '.7' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}

  DB;SPMlt;5;SPMgt; print ;SPMquot;Si;SPMquot; if  '1e2' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}
Si
  DB;SPMlt;6;SPMgt; print ;SPMquot;Si ;SPMquot; while  'ababa' =~ m{a}g
Si Si Si
  DB;SPMlt;7;SPMgt; print ;SPMquot;@a;SPMquot; if @a = 'ababa' =~ m{(a)}g
a a a
<tex2html_mydb_mark>#5517#
nereida:~/doc/casiano/PLBOOK/PLBOOK;SPMgt; perl -MRegexp::Common -e 'print ;SPMquot;$RE{num}{int}\n;SPMquot;'
(?:(?:[+-]?)(?:[0123456789]+))
<tex2html_mydb_mark>#5518#
nereida:/tmp;SPMgt; cat -n prueba.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Regexp::Common;
     4
     5  my $input = ;SPMlt;;SPMgt;;
     6
     7  print ;SPMquot;$;SPMamp;\n;SPMquot; if $input =~ /^$RE{num}{real}$/;
nereida:/tmp;SPMgt; ./prueba.pl
23.45
23.45
nereida:/tmp;SPMgt; ./prueba.pl
jshdf
nereida:/tmp;SPMgt;
<tex2html_mydb_mark>#5519#
sub _Lexer {

  return('', undef) unless defined($input);

  #Skip blanks
      $input=~m{\G((?:
              \s+       # any white space char
          |   \#[^\n]*  # Perl like comments
          )+)}xsgc
    and do {
        my($blanks)=$1;

        #Maybe At EOF
            pos($input) ;SPMgt;= length($input)
        and return('', undef);
        $tokenend += $blanks =~ tr/\n//;
    };
    
    $tokenbegin = $tokenend;

      $input=~/\G(and)/gc
    and return($1, [$1, $tokenbegin]);

      $input=~/\G(?:[A-Za-z_][A-Za-z0-9_]*::)*([A-Za-z_][A-Za-z0-9_]*)/gc
    and do {
      return('IDENT', [$1, $tokenbegin]);
    };

    ....................

        $input=~/\G{/gc
    and do {
        my($level,$from,$code);

        $from=pos($input);

        $level=1;
        while($input=~/([{}])/gc) {
                substr($input,pos($input)-1,1) eq '\\' #Quoted
            and next;
                $level += ($1 eq '{' ? 1 : -1)
            or last;
        }
            $level
        and  _SyntaxError(;SPMquot;Not closed open curly bracket { at $tokenbegin;SPMquot;);
        $code = substr($input,$from,pos($input)-$from-1);
        $tokenend+= $code=~tr/\n//;
        return('CODE', [$code, $tokenbegin]);
    };


    #Always return something
      $input=~/\G(.)/sg
    and do {
      $1 eq ;SPMquot;\n;SPMquot; and ++$tokenend;
      return ($1, [$1, $tokenbegin]);
    };
    #At EOF
    return('', undef);
}
<tex2html_mydb_mark>#5520#
$cuenta = $cielo =~ tr/*/*/; # cuenta el numero de estrellas en cielo
<tex2html_mydb_mark>#5521#
sub _SyntaxError {
  my($level,$message,$lineno)=@_;

  $message= ;SPMquot;*;SPMquot;.
      [ 'Warning', 'Error', 'Fatal' ]-;SPMgt;[$level].
      ;SPMquot;* $message, at ;SPMquot;.
      ($lineno ;SPMlt; 0 ? ;SPMquot;eof;SPMquot; : ;SPMquot;line $lineno;SPMquot;).;SPMquot; at file $filename\n;SPMquot;;

      $level ;SPMgt; 1
  and die $message;

  warn $message;

  $level ;SPMgt; 0 and ++$nberr;

      $nberr == $max_errors
  and die ;SPMquot;*Fatal* Too many errors detected.\n;SPMquot;
}
<tex2html_mydb_mark>#5522#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ pwd
/home/lhp/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ cat -n Error.pm
   1  package Error;
   2  use strict;
   3  use warnings;
   4  use Carp;
   5
   6  require Exporter;
   7
   8  our @ISA = qw(Exporter);
   9  our @EXPORT = qw( error fatal);
  10  our $VERSION = '0.01';
  11
  12  sub error {
  13    my $msg = join ;SPMquot; ;SPMquot;, @_;
  14    if (!$PL::Tutu::errorflag) {
  15      carp(;SPMquot;Error: $msg\n;SPMquot;);
  16      $PL::Tutu::errorflag = 1;
  17    }
  18  }
  19
  20  sub fatal {
  21    my $msg = join ;SPMquot; ;SPMquot;, @_;
  22    croak(;SPMquot;Error: $msg\n;SPMquot;);
  23  }
<tex2html_mydb_mark>#5523#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ cat -n Tutu.pm | head -8
     1  package PL::Tutu;
     2
     3  use 5.008004;
     4  use strict;
     5  use warnings;
     6  use IO::File;
     7  use Carp;
     8  use PL::Error;
<tex2html_mydb_mark>#5524#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ tree
.
|-- Error.pm
|-- Lexical
|   `-- Analysis.pm
`-- Tutu.pm
<tex2html_mydb_mark>#5525#
 1 package PL::Tutu;
 2 
 3 use 5.008004;
 4 use strict;
 5 use warnings;
 6 use IO::File;
 7 use Carp;
 8 use PL::Error;
 9 use PL::Lexical::Analysis;
10 ...
11 
12 sub compile {
13   my ($input) = @_;
14   local %symbol_table = ();
15   local $data = ;SPMquot;;SPMquot;; # Contiene todas las cadenas en el programa fuente
16   local $target = ;SPMquot;;SPMquot;; # target code
17   my @tokens = ();
18   local $errorflag = 0;
19   local ($lookahead, $value) = ();
20   local $tree = undef; # abstract syntax tree
21   local $global_address = 0;
22 
23   
24   ########lexical analysis
25   @tokens = ;SPMamp;PL::Lexical::Analysis::scanner($input);
26   print ;SPMquot;@tokens\n;SPMquot;;
27 
28   ...
29 
30   return \$target;
31 }
<tex2html_mydb_mark>#5526#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL/Lexical$ cat -n Analysis.pm
     1  # Lexical analyzer
     2  package PL::Lexical::Analysis;
     3  use strict;
     4  use warnings;
     5  use Carp;
     6  use PL::Error;
     7
     8  require Exporter;
     9
    10  our @ISA = qw(Exporter);
    11  our @EXPORT = qw( scanner );
    12  our $VERSION = '0.01';
    13
    14  sub scanner {
    15    local $_ = shift;
    16    my @tokens;
    17
    18    { # Con el redo del final hacemos un bucle ;SPMquot;infinito;SPMquot;
    19      if (m{\G\s*(\d+)}gc) {
    20        push @tokens, 'NUM', $1;
    21      }
    ..      ...
    37      elsif (m{\G\s*([+*()=;,])}gc) {
    38        push @tokens, 'PUN', $1;
    39      }
    40      elsif (m{\G\s*(\S)}gc) {
    41        Error::fatal ;SPMquot;Caracter invalido: $1\n;SPMquot;;
    42      }
    43      else {
    44        return @tokens;
    45      }
    46      redo;
    47    }
    48  }
<tex2html_mydb_mark>#5527#
########lexical analysis
@tokens = ;SPMamp;scanner($input);
print ;SPMquot;@tokens\n;SPMquot;;
<tex2html_mydb_mark>#5528#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/scripts$ cat tutu
#!/usr/bin/perl -w
use lib ('../lib');
use PL::Tutu;

;SPMamp;compile_from_file(@ARGV);
<tex2html_mydb_mark>#5529#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ make manifest
/usr/bin/perl ;SPMquot;-MExtUtils::Manifest=mkmanifest;SPMquot; -e mkmanifest
Added to MANIFEST: lib/PL/Lexical/Analysis.pm
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ cat -n MANIFEST
     1  Changes
     2  lib/PL/Error.pm
     3  lib/PL/Lexical/Analysis.pm
     4  lib/PL/Tutu.pm
     5  Makefile.PL
     6  MANIFEST
     7  MANIFEST.SKIP
     8  README
     9  scripts/test01.tutu
    10  scripts/tutu
    11  scripts/tutu.pl
    12  t/PL-Tutu.t
<tex2html_mydb_mark>#5530#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ make veryclean
rm -f blib/script/tutu blib/script/tutu.pl
rm -rf ./blib Makefile.aperl ...
mv Makefile Makefile.old ;SPMgt; /dev/null 2;SPMgt;;SPMamp;1
rm -rf blib/lib/auto/PL/Tutu blib/arch/auto/PL/Tutu
rm -rf PL-Tutu-0.01
rm -f  blib/lib/PL/.Tutu.pm.swp ...
rm -f *~ *.orig */*~ */*.orig
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ tree
.
|-- .svn                # use siempre un sistema de control de versiones
|-- Changes             # la historia de cambios
|-- MANIFEST            # lista de ficheros que componen la distribución
|-- MANIFEST.SKIP       # regexps para determinar que ficheros no pertenecen
|-- META.yml            # YML no es XML
|-- Makefile.PL         # generador del Makefle independiente de la plataforma
|-- PL-Tutu-0.01.tar.gz
|-- README              # instrucciones de instalacion
|-- lib
|   `-- PL
|       |-- Error.pm            # rutinas de manejo de errores
|       |-- Lexical
|       |   `-- Analysis.pm     # modulo con el analizador lexico
|       `-- Tutu.pm             # modulo principal
|-- scripts
|   |-- test01.sal   # salida del programa de prueba
|   |-- test01.tutu  # programa de prueba
|   |-- tutu         # compilador
|   `-- tutu.pl      # compilador
`-- t
    `-- 01Lexical.t  # prueba consolidada
<tex2html_mydb_mark>#5531#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ cd t
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ ls -l
total 4
-rw-r--r--  1 lhp lhp 767 2005-10-10 11:27 01Lexical.t
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ cat -n 01Lexical.t
 1  # Before `make install' is performed this script should be runnable with
 2  # `make test'. After `make install' it should work as `perl PL-Tutu.t'
 3
 4  #########################
 5
 6  # change 'tests =;SPMgt; 1' to 'tests =;SPMgt; last_test_to_print';
 7
 8  use Test::More tests =;SPMgt; 5;
 9  use Test::Exception;
10
11  BEGIN { use_ok('PL::Lexical::Analysis') };
12  BEGIN { use_ok('PL::Tutu') };
13
14  #########################
15
16  # Insert your test code below, the Test::More module is use()ed here so read
17  # its man page ( perldoc Test::More ) for help writing this test script.
18
19  can_ok('PL::Lexical::Analysis', 'scanner');
20
21  # Test result of call
22  my $a = 'int a,b; string c; c = ;SPMquot;hello;SPMquot;; a = 4; b = a +1; p b';
23  my @tokens = scanner($a);
24  my @expected_tokens = qw{
25  INT INT
26  ID a
27  PUN ,
28  ID b
29  PUN ;
30  STRING STRING
31  ID c
32  PUN ;
33  ID c
34  PUN =
35  STR ;SPMquot;hello;SPMquot;
36  PUN ;
37  ID a
38  PUN =
39  NUM 4
40  PUN ;
41  ID b
42  PUN =
43  ID a
44  PUN +
45  NUM 1
46  PUN ;
47  P P
48  ID b
49  };
50  is(@tokens, @expected_tokens, ;SPMquot;lexical analysis;SPMquot;);
51
52  # test a lexically  erroneous program
53  $a = 'int a,b; string c[2]; c = ;SPMquot;hello;SPMquot;; a = 4; b = a +1; p b';
54  throws_ok { scanner($a) } qr{Error: Caracter invalido:}, 'erroneous program';
<tex2html_mydb_mark>#5532#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ make test
PERL_DL_NONLAZY=1 /usr/bin/perl ;SPMquot;-MExtUtils::Command::MM;SPMquot; ;SPMquot;-e;SPMquot; ;SPMquot;test_harness(0, 'blib/lib', 'blib/arch');SPMquot; t/*.t
t/01Lexical....ok 1/5Possible attempt to separate words with commas at t/01Lexical.t line 49.
t/01Lexical....ok
All tests successful.
Files=1, Tests=5,  0 wallclock secs ( 0.08 cusr +  0.00 csys =  0.08 CPU)
<tex2html_mydb_mark>#5533#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ prove -I../lib 01Lexical.t
01Lexical....ok
All tests successful.
Files=1, Tests=2,  0 wallclock secs ( 0.03 cusr +  0.01 csys =  0.04 CPU)
<tex2html_mydb_mark>#5534#
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ prove -v 01Lexical.t
01Lexical....1..5
ok 1 - use PL::Lexical::Analysis;
ok 2 - use PL::Tutu;
ok 3 - PL::Lexical::Analysis-;SPMgt;can('scanner')
ok 4 - lexical analysis
ok 5 - erroneous program
ok
All tests successful.
Files=1, Tests=5,  0 wallclock secs ( 0.07 cusr +  0.01 csys =  0.08 CPU)
<tex2html_mydb_mark>#5535#
$ pwd
/home/lhp/projects/perl/src/tmp/PL/Tutu/tutu_src
$ cat pruebalex.pl
#!/usr/bin/perl -w -I..
#use PL::Tutu;
use Tutu;

my $a = 'int a,b; string c; c = ;SPMquot;hello;SPMquot;; a = 4; b = a +1; p b';
Lexical::Analysis::scanner($a);
print ;SPMquot;prog = $a\ntokens = @PL::Tutu::tokens\n;SPMquot;;
<tex2html_mydb_mark>#5536#
$ ./pruebalex.pl
prog = int a,b; string c; c = ;SPMquot;hello;SPMquot;; a = 4; b = a +1; p b
tokens = INT INT ID a PUN , ID b PUN ; STRING STRING ID c PUN ; 
ID c PUN = STR hello PUN ; ID a PUN = NUM 4 PUN ; ID b PUN = 
ID a PUN + NUM 1 PUN ; P P ID b
<tex2html_mydb_mark>#5537#
$ cat -n test.pl
 1  # Before `make install' is performed this script should be runnable with
 2  # `make test'. After `make install' it should work as `perl test.pl'
 3
 4  #########################
 5
 6  # change 'tests =;SPMgt; 1' to 'tests =;SPMgt; last_test_to_print';
 7
 8  use Test;
 9  BEGIN { plan tests =;SPMgt; 1 };
10  use PL::Tutu;
11  ok(1); # If we made it this far, we're ok.
12
13  #########################
14
15  # Insert your test code below, the Test module is use()ed here so read
16  # its man page ( perldoc Test ) for help writing this test script.
17
<tex2html_mydb_mark>#5538#
$ cat -n test.pl | tail -7
16  # its man page ( perldoc Test ) for help writing this test script.
17
18  my $a = 'int a,b; string c; c = ;SPMquot;hello;SPMquot;; a = 4; b = a +1; p b';
19  local @PL::Tutu::tokens = ();
20  Lexical::Analysis::scanner($a);
21  ok(;SPMquot;@PL::Tutu::tokens;SPMquot; eq
22  'INT INT ID a PUN , ID b PUN ; STRING STRING ID c PUN ; ID c 
     PUN = STR hello PUN ; ID a PUN = NUM 4 PUN ; ID b PUN = 
     ID a PUN + NUM 1 PUN ; P P ID b');
<tex2html_mydb_mark>#5539#
$ make test
PERL_DL_NONLAZY=1 /usr/bin/perl -Iblib/arch -Iblib/lib -I/usr/lib/perl/5.6.1 \
                                -I/usr/share/perl/5.6.1 test.pl
1..2
ok 1
ok 2
<tex2html_mydb_mark>#5540#
nereida:~/src/perl/YappWithDefaultAction/t;SPMgt; cat -n  15treeregswith2arrays.t
 1  #!/usr/bin/perl -w
 2  use strict;
 3  #use Test::More qw(no_plan);
 4  use Test::More tests =;SPMgt; 3;
 5  use_ok qw(Parse::Eyapp) or exit;

..  ..... etc., etc.

84  my $expected_tree = bless( {
85    'children' =;SPMgt; [
86      bless( { 'children' =;SPMgt; [
87          bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'a', 'token' =;SPMgt; 'a' }, 'TERMINAL' )
88        ]
89      }, 'A' ),
90      bless( { 'children' =;SPMgt; [
91          bless( { 'children' =;SPMgt; [], 'attr' =;SPMgt; 'c', 'token' =;SPMgt; 'c' }, 'TERMINAL' )
92        ]
93      }, 'C' )
94    ]
95  }, 'ABC' );
96  is_deeply($t, $expected_tree, ;SPMquot;deleting node between arrays;SPMquot;);
<tex2html_mydb_mark>#5541#
26     elsif (/\G\s*(.)/gc) {
27       Error::fatal ;SPMquot;Caracter invalido: $1\n;SPMquot;;
28     }
<tex2html_mydb_mark>#5542#
  sub fatal {
    my $msg = join ;SPMquot; ;SPMquot;, @_;
    croak(;SPMquot;Error: $msg\n;SPMquot;);
  }
<tex2html_mydb_mark>#5543#
sub tutu {
  my $refhash = shift;
  croak ;SPMquot;Error;SPMquot; unless UNIVERSAL::isa($refhash, 'HASH');
  ...
}
<tex2html_mydb_mark>#5544#
;SPMquot;;SPMquot; 
;SPMquot;h\"a\"h;SPMquot; 
;SPMquot;\;SPMquot;;SPMquot;
<tex2html_mydb_mark>#5545#
 1  SKIP: {
 2      eval { require HTML::Lint };
 3 
 4      skip ;SPMquot;HTML::Lint not installed;SPMquot;, 2 if $@;
 5 
 6      my $lint = new HTML::Lint;
 7      isa_ok( $lint, ;SPMquot;HTML::Lint;SPMquot; );
 8 
 9      $lint-;SPMgt;parse( $html );
10      is( $lint-;SPMgt;errors, 0, ;SPMquot;No errors found in HTML;SPMquot; );
11  }
<tex2html_mydb_mark>#5546#
nereida:~/src/perl/YappWithDefaultAction/t;SPMgt; cat 02Cparser.t | head -n 56 -
#!/usr/bin/perl -w
use strict;
#use Test::More qw(no_plan);
use Test::More tests =;SPMgt; 6;

use_ok qw(Parse::Eyapp) or exit;

SKIP: {
  skip ;SPMquot;You decided to skip C grammar test (env var TEST_FAST);SPMquot;, 5 if $ENV{TEST_FAST} ;
  my ($grammar, $parser);
  $grammar=join('',;SPMlt;DATA;SPMgt;);
  $parser=new Parse::Eyapp(input =;SPMgt; $grammar, inputfile =;SPMgt; 'DATA', firstline =;SPMgt; 52);

  #is($@, undef, ;SPMquot;Grammar module created;SPMquot;);

  # Does not work. May I have done s.t. wrong?
  #is(keys(%{$parser-;SPMgt;{GRAMMAR}{NULLABLE}}), 43, ;SPMquot;43 nullable productions;SPMquot;);

  is(keys(%{$parser-;SPMgt;{GRAMMAR}{NTERM}}), 233, ;SPMquot;233 syntactic variables;SPMquot;);

  is(scalar(@{$parser-;SPMgt;{GRAMMAR}{UUTERM}}), 3, ;SPMquot;3 UUTERM;SPMquot;);

  is(scalar(keys(%{$parser-;SPMgt;{GRAMMAR}{TERM}})), 108, ;SPMquot;108 terminals;SPMquot;);

  is(scalar(@{$parser-;SPMgt;{GRAMMAR}{RULES}}), 825, ;SPMquot;825 rules;SPMquot;);

  is(scalar(@{$parser-;SPMgt;{STATES}}), 1611, ;SPMquot;1611 states;SPMquot;);
}

__DATA__
/*
   This grammar is a stripped form of the original C++ grammar
   from the GNU CC compiler :

   YACC parser for C++ syntax.
   Copyright (C) 1988, 89, 93-98, 1999 Free Software Foundation, Inc.
   Hacked by Michael Tiemann (tiemann@cygnus.com)

   The full gcc compiler an the original grammar file are freely
   available under the GPL license at :

   ftp://ftp.gnu.org/gnu/gcc/
   ...................... etc. etc.
*/
nereida:~/src/perl/YappWithDefaultAction;SPMgt; echo $TEST_FAST
1
nereida:~/src/perl/YappWithDefaultAction;SPMgt; make test
PERL_DL_NONLAZY=1 /usr/bin/perl ;SPMquot;-MExtUtils::Command::MM;SPMquot; ;SPMquot;-e;SPMquot; ;SPMquot;test_harness(0, 'blib/lib', 'blib/arch');SPMquot; t/*.t
t/01calc....................................ok
t/02Cparser.................................ok
        5/6 skipped: various reasons
t/03newgrammar..............................ok
t/04foldandzero.............................ok
t/05treewithvars............................ok
t/06meta....................................ok
t/07translationschemetype...................ok
t/08tschemetypestar.........................ok
t/09ts_with_defaultaction...................ok
t/10ts_with_treereg.........................ok

etc., etc...................................ok

t/28unshifttwoitems.........................ok
t/29foldinglistsofexpressions...............ok
t/30complextreereg..........................ok
t/32deletenodewithwarn......................ok
t/33moveinvariantoutofloop..................ok
t/34moveinvariantoutofloopcomplexformula....ok
All tests successful, 5 subtests skipped.
Files=33, Tests=113,  5 wallclock secs ( 4.52 cusr +  0.30 csys =  4.82 CPU)
<tex2html_mydb_mark>#5547#
42 TODO: {
43   local $TODO = ;SPMquot;Randomly generated problem;SPMquot;;
44   can_ok('Algorithm::Knap01DP', 'GenKnap'); # sub GenKnap no ha sido escrita aún
45 }
<tex2html_mydb_mark>#5548#
pl@nereida:~/src/perl/YappWithDefaultAction$ cover -delete
Deleting database /home/pl/src/perl/YappWithDefaultAction/cover_db
pl@nereida:~/src/perl/YappWithDefaultAction$ HARNESS_PERL_SWITCHES=-MDevel::Cover make test
PERL_DL_NONLAZY=1 /usr/bin/perl ;SPMquot;-MExtUtils::Command::MM;SPMquot; ;SPMquot;-e;SPMquot; ;SPMquot;test_harness(0, 'blib/lib', 'blib/arch');SPMquot; t/*.t
t/01calc....................................ok 
t/01calc....................................ok
t/02Cparser.................................ok
        5/6 skipped: various reasons
t/03newgrammar..............................ok 
t/03newgrammar..............................ok
t/04foldandzero.............................ok
etc., etc. .................................ok
t/34moveinvariantoutofloopcomplexformula....ok
All tests successful, 5 subtests skipped.
Files=33, Tests=113, 181 wallclock secs (177.95 cusr +  2.94 csys = 180.89 CPU)
<tex2html_mydb_mark>#5549#
pl@nereida:~/src/perl/YappWithDefaultAction$ cover
Reading database from /home/pl/src/perl/YappWithDefaultAction/cover_db

---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
blib/lib/Parse/Eyapp.pm       100.0    n/a    n/a  100.0    n/a    0.2  100.0
...lib/Parse/Eyapp/Driver.pm   72.4   63.2   50.0   64.3    0.0   21.3   64.4
...ib/Parse/Eyapp/Grammar.pm   90.9   77.8   66.7  100.0    0.0   16.6   84.3
blib/lib/Parse/Eyapp/Lalr.pm   91.4   72.6   78.6  100.0    0.0   48.3   85.6
blib/lib/Parse/Eyapp/Node.pm   74.4   58.3   29.2   88.2    0.0    1.6   64.7
...ib/Parse/Eyapp/Options.pm   86.4   50.0    n/a  100.0    0.0    2.7   72.8
...lib/Parse/Eyapp/Output.pm   82.3   47.4   60.0   70.6    0.0    3.7   70.0
.../lib/Parse/Eyapp/Parse.pm  100.0    n/a    n/a  100.0    n/a    0.2  100.0
...Parse/Eyapp/Treeregexp.pm  100.0    n/a    n/a  100.0    n/a    0.1  100.0
blib/lib/Parse/Eyapp/YATW.pm   89.4   63.9   66.7   85.7    0.0    4.8   77.6
...app/_TreeregexpSupport.pm   73.1   33.3   50.0  100.0    0.0    0.4   60.8
main.pm                        52.2    0.0    n/a   80.0    0.0    0.0   45.7
Total                          83.8   64.7   60.0   84.5    0.0  100.0   75.5
---------------------------- ------ ------ ------ ------ ------ ------ ------

Writing HTML output to /home/pl/src/perl/YappWithDefaultAction/cover_db/coverage.html ...
pl@nereida:~/src/perl/YappWithDefaultAction$
<tex2html_mydb_mark>#5550#
nereida:~/src/perl/YappWithDefaultAction;SPMgt; setenv HARNESS_PERL_SWITCHES -MDevel::Cover
nereida:~/src/perl/YappWithDefaultAction;SPMgt; make test
PERL_DL_NONLAZY=1 /usr/bin/perl ;SPMquot;-MExtUtils::Command::MM;SPMquot; ;SPMquot;-e;SPMquot; ;SPMquot;test_harness(0, 'blib/lib', 'blib/arch');SPMquot; t/*.t
t/01calc....................................ok 
t/01calc....................................ok
t/02Cparser.................................ok
        5/6 skipped: various reasons
t/03newgrammar..............................ok 
t/03newgrammar..............................ok
t/04foldandzero.............................ok
t/05treewithvars............................ok
t/06meta....................................ok 
t/06meta....................................ok
t/07translationschemetype...................ok
............................................ok
t/38tspostfix_resultisarray.................ok
t/39tspostfix...............................ok 
All tests successful, 5 subtests skipped.
Files=38, Tests=135, 210 wallclock secs (206.28 cusr +  3.27 csys = 209.55 CPU)
nereida:~/src/perl/YappWithDefaultAction;SPMgt;
<tex2html_mydb_mark>#5551#
make HARNESS_PERL_SWITCHES=-MDevel::Cover test
<tex2html_mydb_mark>#5552#
nereida:~/src/perl/YappWithDefaultAction/t;SPMgt; perl -d:DProf 02Cparser.t
1..6
ok 1 - use Parse::Eyapp;
ok 2 - 233 syntactic variables
ok 3 - 3 UUTERM
ok 4 - 108 terminals
ok 5 - 825 rules
ok 6 - 1611 states
nereida:~/src/perl/YappWithDefaultAction/t;SPMgt; dprofpp tmon.out
Total Elapsed Time = 3.028396 Seconds
  User+System Time = 3.008396 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 31.4   0.945  1.473   1611   0.0006 0.0009  Parse::Eyapp::Lalr::_Transitions
 17.5   0.528  0.528   1611   0.0003 0.0003  Parse::Eyapp::Lalr::_Closures
 16.1   0.486  0.892      1   0.4861 0.8918  Parse::Eyapp::Lalr::_ComputeFollows
 8.04   0.242  0.391      1   0.2419 0.3906  Parse::Yapp::Driver::_Parse
 8.04   0.242  0.242  11111   0.0000 0.0000  Parse::Eyapp::Lalr::__ANON__
 4.59   0.138  0.138   8104   0.0000 0.0000  Parse::Eyapp::Lalr::_Preds
 2.66   0.080  0.080      1   0.0800 0.0800  Parse::Eyapp::Lalr::_SetDefaults
 2.66   0.080  0.972      1   0.0800 0.9718  Parse::Eyapp::Lalr::_ComputeLA
 2.46   0.074  0.074   3741   0.0000 0.0000  Parse::Eyapp::Parse::_Lexer
 1.89   0.057  0.074   8310   0.0000 0.0000  Parse::Eyapp::Parse::__ANON__
 0.96   0.029  0.028      1   0.0288 0.0276  Parse::Eyapp::Lalr::_SolveConflict
                                             s
 0.66   0.020  0.050      6   0.0033 0.0083  Parse::Eyapp::Output::BEGIN
 0.60   0.018  1.500      1   0.0176 1.4997  Parse::Eyapp::Lalr::_LR0
 0.53   0.016  0.259      3   0.0054 0.0863  Parse::Eyapp::Lalr::_Digraph
 0.33   0.010  0.010      1   0.0100 0.0100  Parse::Eyapp::Grammar::_SetNullable
<tex2html_mydb_mark>#5553#
nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; perl -MDevel::Profiler eyapp 02Cparser.yp
Unused terminals:

        END_OF_LINE, declared line 128
        ALL, declared line 119
        PRE_PARSED_CLASS_DECL, declared line 120

27 shift/reduce conflicts and 22 reduce/reduce conflicts
nereida:~/src/perl/YappWithDefaultAction/examples;SPMgt; dprofpp tmon.out
Total Elapsed Time = 3.914144 Seconds
  User+System Time = 3.917144 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 22.3   0.877  1.577   1611   0.0005 0.0010  Parse::Eyapp::Lalr::_Transitions
 17.8   0.700  0.700   1611   0.0004 0.0004  Parse::Eyapp::Lalr::_Closures
 15.6   0.614  1.185      1   0.6142 1.1854  Parse::Eyapp::Lalr::_ComputeFollow
                                             s
 9.60   0.376  0.545      1   0.3758 0.5453  Parse::Yapp::Driver::_Parse
 7.99   0.313  0.313   8104   0.0000 0.0000  Parse::Eyapp::Lalr::_Preds
 5.85   0.229  0.229      3   0.0763 0.0763  Parse::Eyapp::Lalr::_Digraph
 4.06   0.159  0.159   3741   0.0000 0.0000  Parse::Eyapp::Parse::_Lexer
 3.32   0.130  0.130      1   0.1300 0.1300  Parse::Eyapp::Lalr::DfaTable
 2.27   0.089  0.089      1   0.0890 0.0890  Parse::Eyapp::Lalr::_SetDefaults
 2.04   0.080  1.265      1   0.0800 1.2654  Parse::Eyapp::Lalr::_ComputeLA
 1.17   0.046  0.057      1   0.0464 0.0567  Parse::Eyapp::Grammar::Rules
 1.02   0.040  1.617      1   0.0397 1.6169  Parse::Eyapp::Lalr::_LR0
 0.77   0.030  0.030   1185   0.0000 0.0000  Parse::Eyapp::Lalr::_FirstSfx
 0.71   0.028  0.039      1   0.0284 0.0387  Parse::Eyapp::Grammar::RulesTable
 0.54   0.021  0.021   1650   0.0000 0.0000  Parse::Eyapp::Grammar::classname
<tex2html_mydb_mark>#5554#
 71 .................................... codigo omitido
 72
 73 use Devel::Size qw(size total_size);
 74 use Perl6::Form;
 75
 76 sub sizes {
 77   my $d = shift;
 78   my ($ps, $ts) = (size($d), total_size($d));
 79   my $ds = $ts-$ps;
 80   return ($ps, $ds, $ts);
 81 }
 82
 83 print form(
 84 ' ==============================================================',
 85 '| VARIABLE | SOLO ESTRUCTURA |     SOLO DATOS |          TOTAL |',
 86 '|----------+-----------------+----------------+----------------|',
 87 '| $parser  | {;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;} bytes  | {;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;} bytes | {;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;} bytes |', sizes($parser),
 88 '| $t       | {;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;} bytes  | {;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;} bytes | {;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;;SPMgt;} bytes |', sizes($t),
 89 ' ==============================================================',
 90 );
<tex2html_mydb_mark>#5555#
 ....... salida previa omitida

 ==============================================================
| VARIABLE | SOLO ESTRUCTURA |     SOLO DATOS |          TOTAL |
|----------+-----------------+----------------+----------------|
| $parser  |      748 bytes  |      991 bytes |     1739 bytes |
| $t       |       60 bytes  |     1237 bytes |     1297 bytes |
 ==============================================================
<tex2html_mydb_mark>#5556#
  DB;SPMlt;1;SPMgt; $a = ';SPMquot;Focho \"mucha\" chufa;SPMquot;'
  DB;SPMlt;2;SPMgt; print $a
;SPMquot;Focho \"mucha\" chufa;SPMquot;
  DB;SPMlt;3;SPMgt; print $;SPMamp; if $a =~ m{^;SPMquot;([^;SPMquot;]|\\;SPMquot;)*;SPMquot;}
;SPMquot;Focho \"
  DB;SPMlt;4;SPMgt; print $;SPMamp; if $a =~ m{^;SPMquot;(\\;SPMquot;||[^;SPMquot;])*;SPMquot;}
;SPMquot;Focho \"mucha\" chufa;SPMquot;
<tex2html_mydb_mark>#5557#
  DB;SPMlt;1;SPMgt; $a='4+5'
  DB;SPMlt;2;SPMgt; print ;SPMquot;($;SPMamp;) ;SPMquot; while ($a =~ m/(\G\d+)/gc) or ($a =~ m/(\G\+)/gc);
(4) (+) (5)
  DB;SPMlt;3;SPMgt; $a='4+5' # inicializamos la posición de búsqueda
  DB;SPMlt;4;SPMgt; print ;SPMquot;($;SPMamp;) ;SPMquot; while ($a =~ m/(\G\d+)/g) or ($a =~ m/(\G\+)/g);
(4)
  DB;SPMlt;5;SPMgt; $a='4+5'
  DB;SPMlt;6;SPMgt; print ;SPMquot;($;SPMamp;) ;SPMquot; while ($a =~ m/\G\d+|\G\+/g)
(4) (+) (5)
<tex2html_mydb_mark>#5558#
sub parse();
sub statements();
sub statement();
sub expression();
sub term();
sub factor();
sub idlist();
sub declaration();
sub declarations();
<tex2html_mydb_mark>#5559#
 1 sub match {
 2   my $t = shift;
 3 
 4   if ($lookahead eq $t) {
 5     ($lookahead, $value) = splice @tokens,0,2; 
 6     if (defined($lookahead)) { 
 7       $lookahead = $value if ($lookahead eq 'PUN');
 8     } else { $lookahead = 'EOI'; }
 9   }
10   else { error(;SPMquot;Se esperaba $t y se encontro $lookahead\n;SPMquot;); }
11 }
12 
13 sub statement {
14   if ($lookahead eq 'ID') { match('ID'); match('='); expression; }
15   elsif ($lookahead eq 'P') { match('P'); expression; }
16   else { error('Se esperaba un identificador'); }
17 }
18 
19 sub term() {
20   factor;
21   if ($lookahead eq '*') { match('*'); term; }
22 }
23 
24 sub expression() {
25   term;
26   if ($lookahead eq '+') { match('+'); expression; }
27 }
28 
29 sub factor() {
30   if ($lookahead eq 'NUM') { match('NUM'); }
31   elsif ($lookahead eq 'ID') { match('ID'); }
32   elsif ($lookahead eq '(') { match('('); expression; match(')'); }
33   else { error(;SPMquot;Se esperaba (, NUM o ID;SPMquot;); }
34 }
35 
36 sub statements {
37   statement;
38   if ($lookahead eq ';') { match(';'); statements; }
39 }
40 
41 sub parser {
42   ($lookahead, $value) = splice @tokens,0,2; 
43   statements; match('EOI');
44 }
<tex2html_mydb_mark>#5560#
sub A {
  if ($lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  elsif ($lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else ($lookahead in FIRST(gamma_n)) { imitar gamma_n }
}
<tex2html_mydb_mark>#5561#
sub A {
  if ($lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  elsif ($lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else ($lookahead in FIRST(gamma_n) or $lookahead in FOLLOW(A)) { imitar gamma_n }
}
<tex2html_mydb_mark>#5562#
Grammar/scripts$ cat -n grammar.pl
 1  #!/usr/bin/perl -w -I../lib
 2  use strict;
 3  use Grammar;
 4  use Data::Dumper;
 5
 6  sub usage {
 7    print ;SPMlt;;SPMlt;;SPMquot;EOI;SPMquot;;
 8  usage:
 9  $0 input_grammar
10  EOI
11    die ;SPMquot;\n;SPMquot;;
12  }
13
14  usage() unless @ARGV;
15  my $filename = shift;
16
17  local $/ = undef;
18  open my $FILE, ;SPMquot;$filename;SPMquot;;
19  my $grammar = ;SPMlt;$FILE;SPMgt;;
20  my $x = Grammar::Parse($grammar);
21
22  print Dumper($x);
<tex2html_mydb_mark>#5563#
Grammar/scripts$ cat -n aSb.yp
 1  %%
 2  S:
 3      |   'a' S 'b'
 4  ;
 5  %%

<tex2html_mydb_mark>#5564#
Grammar/scripts$ grammar.pl aSb.yp
$VAR1 = {
    'SYMS' =;SPMgt; { 'S' =;SPMgt; 2, ';SPMquot;b;SPMquot;' =;SPMgt; 3, ';SPMquot;a;SPMquot;' =;SPMgt; 3 }, # Símbolo =;SPMgt; línea
    'NULL' =;SPMgt; { 'S' =;SPMgt; 1 }, # símbolos que se anulan
    'RULES' =;SPMgt; [
                 [ 'S', [] ], # S produce vacío
                 [ 'S', [ ';SPMquot;a;SPMquot;', 'S', ';SPMquot;b;SPMquot;' ] ] # S -;SPMgt; aSb
               ],
    'START' =;SPMgt; 'S', # Símbolo de arranque
    'TERM' =;SPMgt; [ ';SPMquot;b;SPMquot;', ';SPMquot;a;SPMquot;' ], # terminales /tokens
    'NTERM' =;SPMgt; { 'S' =;SPMgt; [ 0, 1 ] }  # índices de las reglas de las variables sintácticas
  };
<tex2html_mydb_mark>#5565#
  Grammar/03/scripts$ cat -n aSb.yp
       1  %%
       2  S:
       3      |   'a' S 'b'
       4  ;
       5  %%
       6
       7  sub Lex {
       8    local $_ = shift; # input
       9    my @tokens;
      10
      11
      12    while ($_) {
      13      s/^\s*//; # fuera blancos
      14      push @tokens, $1, $1 if s/^(.)//s
      15    }
      16    @tokens;
      17  }
      18
      19  sub main {
      20    my $filename = shift;
      21    my $input;
      22
      23    if (defined($filename)) {
      24      local $/ = undef;
      25      open my $FILE, $filename or die ;SPMquot;No se pudo abrir $filename\n;SPMquot;;
      26      $input = ;SPMlt;$FILE;SPMgt;;
      27      close($FILE);
      28    }
      29    else { $input = ;SPMlt;STDIN;SPMgt; }
      30
      31    my @tokens = Lex($input);
      32    Parse(@tokens); # Llamada al analizador generado
      33    print ;SPMquot;Sintácticamente correcto\n;SPMquot;;
      34  }
<tex2html_mydb_mark>#5566#
{
  'SYMS' =;SPMgt; { 'S' =;SPMgt; 2, 'b' =;SPMgt; 3, 'a' =;SPMgt; 3 },  # Símbolo =;SPMgt; línea de aparición
  'NULL' =;SPMgt; { 'S' =;SPMgt; 1 }, # Símbolos que se anulan
  'RULES' =;SPMgt; [ # Reglas 
               [ 'S', [] ], # S produce vacío
               [ 'S', [ 'a', 'S', 'b' ] ] # S-;SPMgt; a S b
             ],
  'START' =;SPMgt; 'S', # Símbolo de arranque
  'TERM' =;SPMgt; [ 'b', 'a' ], # Terminales
  'NTERM' =;SPMgt; { 'S' =;SPMgt; [ 0, 1 ] } # Variables sintácticas e índices de las reglas de esa variable
  'TAIL' =;SPMgt; [ # [ 'Código de cola', línea en la que está el segundo %% ]
  '

  sub Lex {
    local $_ = shift; # input
    my @tokens;


    while ($_) {
      s/^\\s*//; # fuera blancos
      push @tokens, $1, $1 if s/^(.)//s
    }
    @tokens;
  }

  sub main {
    my $filename = shift;
    my $input;

    if (defined($filename)) {
      local $/ = undef;
      open my $FILE, $filename or die ;SPMquot;No se pudo abrir $filename\\n;SPMquot;;
      $input = ;SPMlt;$FILE;SPMgt;;
      close($FILE);
    }
    else { $input = ;SPMlt;STDIN;SPMgt; }

    my @tokens = Lex($input);
    my $ok = Parse(@tokens); # Llamada al analizador generado
    print ;SPMquot;Sintácticamente correcto\\n;SPMquot; if $ok;
  }

  ', 5 ], # línea en la que está el segundo %%
 };
<tex2html_mydb_mark>#5567#
$package_text = ;SPMamp;gap($grammar, 'Package_name');
<tex2html_mydb_mark>#5568#
use strict;
use Package_name;

;SPMamp;Package_name::main;
<tex2html_mydb_mark>#5569#
---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...ammar-0.03/lib/Grammar.pm  100.0    n/a    n/a  100.0    0.0   75.3   97.2
blib/lib/PL/FirstFollow.pm    100.0   92.9   50.0  100.0    0.0   24.7   95.1
Total                         100.0   92.9   50.0  100.0    0.0  100.0   95.5
---------------------------- ------ ------ ------ ------ ------ ------ ------
<tex2html_mydb_mark>#5570#
lhp@nereida:~/projects/Gift2LaTeX/Gift2LaTeX/lib$ cat -n Gift2LaTeX.pm
   1  package Gift2LaTeX;
   2
   3  use strict;
   4  use warnings;
   5  use Gift;
   6  use Text::Template;
   7  use HTML::Latex;
  ..    ......................................................
  49  package Gift::TRUEFALSE; # True-false questions belong to this class
  50
  51  { # closure
  52
  53    die ;SPMquot;Can't find $TEMPLATE_DIR/TRUEFALSE_question.tep\n;SPMquot;
  54          unless -e ;SPMquot;$TEMPLATE_DIR/TRUEFALSE_question.tep;SPMquot;;
  55    my $tfq_tmpl = Text::Template-;SPMgt;new( #tfq = true-false question
  56      DELIMITERS =;SPMgt; ['%;SPMlt;', '%;SPMgt;'];
  57      SOURCE =;SPMgt; ;SPMquot;$TEMPLATE_DIR/TRUEFALSE_question.tep;SPMquot;,
  58    );
  ..    ......................................................
  67    sub gen_latex {
  68      my $self = shift;
  69
  70      ########## Generate latex for question
  71      my $prefix  = $self-;SPMgt;PREFIX;
  72
  73      my $sufix = $self-;SPMgt;POSTSTATE;
  74
  75      $self-;SPMgt;Error(;SPMquot;Only HTML and PLAIN formats are supported\n;SPMquot;)
  76          unless (!$self-;SPMgt;FORMAT or ($self-;SPMgt;FORMAT =~ m{html|plain}i));
  77
  78      my ($prefix_tex, $sufix_tex);
  79      if (defined($self-;SPMgt;FORMAT) and $self-;SPMgt;FORMAT =~ m{plain}i) {
  80        $prefix_tex = $prefix;
  81        $sufix_tex  = $sufix;
  82      }
  83      else { # HTML by default
  ..    ......................................................
  86      }
  87      my $params = {
  88        prefix  =;SPMgt; $prefix_tex,
  89        sufix   =;SPMgt; $sufix_tex,
  90        separator =;SPMgt; $separator,
  91        label   =;SPMgt; $label_prefix.$question_number,
  92        question_number =;SPMgt; $question_number
  93      };
  94      my $question_tex = $tfq_tmpl-;SPMgt;fill_in(HASH =;SPMgt; $params);
  96      ########## Generate latex for answer
 ...      ....................................
 101    }
 102  }
<tex2html_mydb_mark>#5571#
lhp@nereida:~/projects/Gift2LaTeX/Gift2LaTeX/etc/en$ cat -n TRUEFALSE_question.tep
 1  \ begin{latexonly}
 2    %;SPMlt;$separator%;SPMgt;
 3    \ label{question:%;SPMlt;$label%;SPMgt;}
 4    %;SPMlt;$prefix%;SPMgt;
 5
 6    \ begin{center}
 7      \ begin{tabular}{llll}
 8          $\ bigcirc$ ;SPMamp; TRUE ;SPMamp; $\ bigcirc$ ;SPMamp; FALSE
 9      \ end{tabular}
10
11      \noindent %;SPMlt;$sufix%;SPMgt;
12    \ end{center}
13  \ end{latexonly}
14
15  \ begin{htmlonly}
16  %;SPMlt;$separator%;SPMgt;
17  \ label{question:%;SPMlt;$label%;SPMgt;}
18  %;SPMlt;$prefix%;SPMgt;
19
20  \ begin{center}
21    \ begin{tabular}{llll}
22        \ htmlref{$\bigcirc$}{answer:%;SPMlt;$label%;SPMgt;} ;SPMamp; TRUE ;SPMamp;
23        \ htmlref{$\bigcirc$}{answer:%;SPMlt;$label%;SPMgt;} ;SPMamp; FALSE
24    \ end{tabular}
25
26    \ noindent %;SPMlt;$sufix%;SPMgt;
27  \ end{center}
28  \ end{htmlonly}
<tex2html_mydb_mark>#5572#
my $usage = ;SPMquot;Usage: $0 ;SPMlt;file;SPMgt; [-full] [-o] [-beans]\n;SPMquot;
            . ;SPMquot;Options:\n;SPMquot;
            . ;SPMquot;    -full  : produce a full dump\n;SPMquot;
            . ;SPMquot;    -o     : dump in octal\n;SPMquot;
            . ;SPMquot;    -beans : source is Java\n;SPMquot;
            ;
<tex2html_mydb_mark>#5573#
print ;SPMlt;;SPMlt;;SPMquot;EOI;SPMquot;;
El programa se deberá ejecutar con:

$0 numfiles $opciones initialvalue
EOI
<tex2html_mydb_mark>#5574#
if ($usage_error) {
    warn ;SPMlt;;SPMlt;'END_USAGE';
Usage: qdump ;SPMlt;file;SPMgt; [-full] [-o] [-beans]
Options:
    -full  : produce a full dump
    -o     : dump in octal
    -beans : source is Java
END_USAGE
}
<tex2html_mydb_mark>#5575#
sub build_usage {
    my ($prog_name, $file_name) = @_;

    return ;SPMlt;;SPMlt;;SPMquot;END_USAGE;SPMquot;;
Usage: $prog_name $file_name [-full] [-o] [-beans]
Options:
    -full  : produce a full dump
    -o     : dump in octal
    -beans : source is Java
END_USAGE
}
<tex2html_mydb_mark>#5576#
if ($usage_error) {
    warn build_usage($PROGRAM_NAME, $requested_file);
}
<tex2html_mydb_mark>#5577#
sub expression() {
  my $r = $value.;SPMquot; ;SPMquot;; #accion intermedia
  match('NUM'); 
  return rest($r); # accion final $expr{T} = $r{T}
}

sub rest($) {
  my $v = shift;

  if ($lookahead eq '-') {
    match('-');
    my $r = ;SPMquot;$v $value -;SPMquot;; # accion intermedia
    match('NUM');
    return rest($r); # accion final $r{t} = $r_1{t}
  }
  elsif ($lookahead ne 'EOI') {
    error(;SPMquot;Se esperaba un operador;SPMquot;);
  }
  else { return $v; } # r -;SPMgt; epsilon { $r{t} = $r{h} }
}
<tex2html_mydb_mark>#5578#
int a,b;
string c, d;
a = 4;
p a
<tex2html_mydb_mark>#5579#
PROGRAM(
         DECLS[INT[ID, ID], STRING[ID, ID]], 
         STS[ASSIGN(LEFTVALUE, NUM), PRINT(ID)]
       )
<tex2html_mydb_mark>#5580#
package NUM;
<tex2html_mydb_mark>#5581#
package NUM;
sub incr { my $self = shift; $self-;SPMgt;{VAL}++ }
<tex2html_mydb_mark>#5582#
my $a = bless {VAL =;SPMgt; 4}, 'NUM';
<tex2html_mydb_mark>#5583#
$a-;SPMgt;incr;
<tex2html_mydb_mark>#5584#
sub new { my ($class, $value) = @_; return bless {VAL =;SPMgt; $value}, $class; }
<tex2html_mydb_mark>#5585#
 1 package PL::Syntax::Analysis;
 2
 3 use 5.006;
 4 use strict;
 5 use warnings;
 6 use Data::Dumper;
 7 use IO::File;
 8 use Class::MakeMethods::Emulator::MethodMaker '-sugar';
 9
10 require Exporter;
11 our @ISA = qw(Exporter);
12 our @EXPORT = qw( );
13 our $VERSION = '0.02';
14
15 #######################################################
16
17 # Grammar:
18 # P : DD L      | L
19 # DD: D ';' DD  | D ';'
20 # D : int I     | string I
21 # L : S         | S ; L
22 # S : ID '=' E  | p E  | epsilon
23 # E : T '+' E   | T
24 # T : F '*' T   | F
25 # F : '(' E ')' | id | num | str
26 # I : id ',' I  | id
<tex2html_mydb_mark>#5586#
PL0506/04sintactico/PL-Tutu$ cat -n Makefile.PL
  1  use 5.008004;
  2  use ExtUtils::MakeMaker;
  3  WriteMakefile(
  4      NAME              =;SPMgt; 'PL::Tutu',
  5      VERSION_FROM      =;SPMgt; 'lib/PL/Tutu.pm', # finds $VERSION
  6      PREREQ_PM         =;SPMgt; {Class::MakeMethods::Emulator::MethodMaker =;SPMgt; 0},1
  7      EXE_FILES         =;SPMgt; [ 'scripts/tutu.pl', 'scripts/tutu' ],
  8      ($] ;SPMgt;= 5.005 ?     ## Add these new keywords supported since 5.005
  9        (ABSTRACT_FROM  =;SPMgt; 'lib/PL/Tutu.pm', # retrieve abstract from module
 10         AUTHOR         =;SPMgt; 'Casiano Rodriguez Leon ;SPMlt;casiano@ull.es;SPMgt;') : ()),
 11  );
<tex2html_mydb_mark>#5587#
$ cat -n MANIFEST
 1  Changes
 2  lib/PL/Error.pm
 3  lib/PL/Lexical/Analysis.pm
 4  lib/PL/Syntax/Analysis.pm
 5  lib/PL/Tutu.pm
 6  Makefile.PL
 7  MANIFEST
 8  MANIFEST.SKIP
 9  README
10  scripts/test01.tutu
11  scripts/tutu
12  scripts/tutu.pl
13  t/01Lexical.t
<tex2html_mydb_mark>#5588#
04sintactico/PL-Tutu/lib/PL$ sed -ne '/sub compile\;SPMgt;/,/^}/p' Tutu.pm | cat -n
  1  sub compile {
  2    my ($input) = @_;
  3    #my %symbol_table = ();
  4    #my $data = ;SPMquot;;SPMquot;; # Contiene todas las cadenas en el programa fuente
  5    my $target = ;SPMquot;;SPMquot;; # target code
  6    my @tokens = ();
  7    my $tree = undef; # abstract syntax tree
  8    #my $global_address = 0;
  9
 10
 11    ########lexical analysis
 12    @tokens = scanner($input);
 13    #print ;SPMquot;@tokens\n;SPMquot;;
 14
 15    ########syntax (and semantic) analysis
 16    $tree = ;SPMamp;Syntax::Analysis::parser(@tokens);
 17    print Dumper($tree);
 18
 19    ########machine independent optimizations
 20    ;SPMamp;Machine::Independent::Optimization::Optimize;
 21
 22    ########code generation
 23    ;SPMamp;Code::Generation::code_generator;
 24
 25    ########peephole optimization
 26    ;SPMamp;Peephole::Optimization::transform($target);
 27
 28    return \$target;
 29  }
<tex2html_mydb_mark>#5589#
package TYPE;
make methods
  get_set       =;SPMgt; [ 'NAME', 'LENGTH' ],
  new_hash_init =;SPMgt; 'new';
<tex2html_mydb_mark>#5590#
sub TYPE::NAME {
  my ($self, $new) = @_;
  defined($new) and $self-;SPMgt;{NAME} = $new;
  return $self-;SPMgt;{NAME};
}
<tex2html_mydb_mark>#5591#
sub TYPE::new {
  my ($class, %args) = @_;
  my $self = {};

  bless $self, $class;
  foreach my $attribute (keys %args) {
    $self-;SPMgt;$attribute($args{$attribute});
  }
  return $self;
}
<tex2html_mydb_mark>#5592#
my $int_type = TYPE-;SPMgt;new(NAME =;SPMgt; 'INTEGER', LENGTH =;SPMgt; 1); 
my $string_type = TYPE-;SPMgt;new(NAME =;SPMgt; 'STRING', LENGTH =;SPMgt; 2);
my $err_type = TYPE-;SPMgt;new(NAME =;SPMgt; 'ERROR', LENGTH =;SPMgt; 0);
<tex2html_mydb_mark>#5593#
package PROGRAM; # raíz del AAA
make methods
  get_set       =;SPMgt; [ 'DECLS', 'STS' ],
  new_hash_init =;SPMgt; 'new';

package STRING; # tipo
make methods
  get_set       =;SPMgt; [ 'TYPE', 'IDLIST' ],
  new_hash_init =;SPMgt; 'new';

package INT; # tipo
make methods
  get_set       =;SPMgt; [ 'TYPE', 'IDLIST' ],
  new_hash_init =;SPMgt; 'new';

package ASSIGN; #sentencia
make methods
  get_set       =;SPMgt; [ 'LEFT', 'RIGHT' ],
  new_hash_init =;SPMgt; 'new';

package PRINT; #sentencia
make methods
  get_set       =;SPMgt; [ 'EXPRESSION' ],
  new_hash_init =;SPMgt; 'new';

package NUM; # para los números
make methods
  get_set       =;SPMgt; [ 'VAL', 'TYPE' ],
  new_hash_init =;SPMgt; 'new';

package ID; # Nodos identificador. Parte derecha
make methods
  get_set       =;SPMgt; [ 'VAL', 'TYPE' ],
  new_hash_init =;SPMgt; 'new';

package STR; # Clase para las constantes cadena
make methods
  get_set       =;SPMgt; [ 'OFFSET', 'LENGTH', 'TYPE' ],
  new_hash_init =;SPMgt; 'new';

package PLUS; # Nodo suma
make methods
  get_set       =;SPMgt; [ 'LEFT', 'RIGHT', 'TYPE' ],
  new_hash_init =;SPMgt; 'new';

package TIMES;
make methods
  get_set       =;SPMgt; [ 'LEFT', 'RIGHT', 'TYPE' ],
  new_hash_init =;SPMgt; 'new';

package LEFTVALUE; # Identificador en la parte izquierda
make methods       # de una asignación
  get_set       =;SPMgt; [ 'VAL', 'TYPE' ],
  new_hash_init =;SPMgt; 'new';
<tex2html_mydb_mark>#5594#
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') {
    $num = $value;
    match('NUM');
    return NUM-;SPMgt;new(VAL =;SPMgt; $num, TYPE =;SPMgt; $int_type);
  }
  elsif ($lookahead eq 'ID') {
    $id = $value;
    match('ID');
    return ID-;SPMgt;new( VAL =;SPMgt; $id, TYPE =;SPMgt; undef);
  }
  elsif ($lookahead eq 'STR') {
    $str = $value;
    match('STR');
    return STR-;SPMgt;new(OFFSET =;SPMgt; undef, LENGTH =;SPMgt; undef, TYPE =;SPMgt; $string_type);
  }
  elsif ($lookahead eq '(') {
    match('(');
    $e = expression;
    match(')');
    return $e;
  }
  else {
    Error::fatal(;SPMquot;Se esperaba (, NUM o ID;SPMquot;);
  }
}
<tex2html_mydb_mark>#5595#
sub statements() {
  my @s;

  @s = (statement());
  if ($lookahead eq ';') {
    match(';');
    push @s, statements();
  }
  return @s;
}

sub idlist() {
  my @id;

  if ($lookahead eq 'ID') {
    @id = ($value); # no es un objeto 
    match('ID');
    if ($lookahead eq ',') {
      match(',');
      push @id, idlist();
    }
  }
  else {
    Error::fatal('Se esperaba un identificador');
    @id = ('ERROR');
  }
  return @id;
}
<tex2html_mydb_mark>#5596#
sub declaration() {
  my ($t, $class, @il);

  if (($lookahead eq 'INT') or ($lookahead eq 'STRING')) {
    $class = $lookahead;
    $t = ;SPMamp;type();
    @il = ;SPMamp;idlist();
    return $class-;SPMgt;new(TYPE =;SPMgt; $t, IDLIST =;SPMgt; \@il);
  }
  else {
    Error::fatal('Se esperaba un tipo');
  }
}
<tex2html_mydb_mark>#5597#
 1 sub term() {
 2   my ($t, $t2);
 3 
 4   $t = factor;
 5   if ($lookahead eq '*') {
 6     match('*');
 7     $t2 = term;
 8     my $type = Semantic::Analysis::check_type_numeric_operator($t, $t2, '*');
 9     $t = TIMES-;SPMgt;new( LEFT =;SPMgt; $t, RIGHT =;SPMgt; $t2, TYPE =;SPMgt; $type);
10   }
11   return $t;
12 }
<tex2html_mydb_mark>#5598#
  sub check_type_numeric_operator {
    my ($op1, $op2, $operator) = @_;

    my $type = numeric_compatibility($op1, $op2, $operator);
    if ($type == $err_type) {
      Error::fatal(;SPMquot;Operandos incompatibles para el operador $operator;SPMquot;) 
    }
    else {
      return $type;
    }
  }
<tex2html_mydb_mark>#5599#
  sub numeric_compatibility {
    my ($op1, $op2, $operator) = @_;

    if (($op1-;SPMgt;TYPE == $op2-;SPMgt;TYPE) and is_numeric($op1-;SPMgt;TYPE)) {
      return $op1-;SPMgt;TYPE; # correct
    }
    ... # código de recuperación de errores de tipo
  }

  sub is_numeric {
    my $type = shift;

    return ($type == $int_type); # añadir long, float, double, etc.
  }
<tex2html_mydb_mark>#5600#
sub declaration() {
  my ($t, $class, @il);

  if (($lookahead eq 'INT') or ($lookahead eq 'STRING')) {
    $class = $lookahead;
    $t = ;SPMamp;type();
    @il = ;SPMamp;idlist();
    ;SPMamp;Semantic::Analysis::set_types($t, @il);
    ;SPMamp;Address::Assignment::compute_address($t, @il);
    return $class-;SPMgt;new(TYPE =;SPMgt; $t, IDLIST =;SPMgt; \@il);
  }
  else {
    Error::fatal('Se esperaba un tipo');
  }
}
<tex2html_mydb_mark>#5601#
sub set_types {
  my $type = shift;
  my @vars = @_;

  foreach my $var (@vars) {
    if (!exists($symbol_table{$id})) { $symbol_table{$var}-;SPMgt;{TYPE} = $type; }
    else { Error::error(;SPMquot;$id declarado dos veces en el mismo ámbito;SPMquot;); }
  }
}
<tex2html_mydb_mark>#5602#
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') { ... }
  elsif ($lookahead eq 'ID') {
    $id = $value;
    match('ID');
    my $type = Semantic::Analysis::check_declared($id);
    return ID-;SPMgt;new( VAL =;SPMgt; $id, TYPE =;SPMgt; $type);
  }
  elsif ($lookahead eq 'STR') { ... }
  elsif ($lookahead eq '(') { ... }
  else { Error::fatal(;SPMquot;Se esperaba (, NUM o ID;SPMquot;); }
}
<tex2html_mydb_mark>#5603#
sub check_declared {
  my $id = shift;

  if (!exists($symbol_table{$id})) {
    Error::error(;SPMquot;$id no ha sido declarado!;SPMquot;);
    # auto-declaración de la variable a err_type
    Semantic::Analysis::set_types($err_type, ($id));
  }
  return $symbol_table{$id}-;SPMgt;{TYPE};
}
<tex2html_mydb_mark>#5604#
int a;
a = 4;
{
  int a;
  a = 5;
  p a
}; /* el ; es necesario */
p a
<tex2html_mydb_mark>#5605#
;SPMamp;Machine::Independent::Optimization::fold
<tex2html_mydb_mark>#5606#
 1 sub operator_fold { # Obsérvese el uso del aliasing
 2 
 3   if ($_[0]-;SPMgt;LEFT-;SPMgt;is_operation) {
 4     $_[0]-;SPMgt;{LEFT}-;SPMgt;fold; 
 5   }
 6   if ($_[0]-;SPMgt;RIGHT-;SPMgt;is_operation) {
 7     $_[0]-;SPMgt;{RIGHT}-;SPMgt;fold;
 8   }
 9   if (ref($_[0]-;SPMgt;LEFT) eq ;SPMquot;NUM;SPMquot; and ref($_[0]-;SPMgt;RIGHT) eq ;SPMquot;NUM;SPMquot;) {
10     $_[0] = reduce_children($_[0]);
11   }
12 }
13 
14 sub PLUS::fold {
15  operator_fold(@_);
16 }
17 
18 sub TIMES::fold {
19  operator_fold(@_);
20 }
<tex2html_mydb_mark>#5607#
package Node;

sub is_operation {
  my $node = shift;

  return ref($node) =~ /^(TIMES)|(PLUS)$/;
}

package Leaf; # hoja del AAA
our @ISA = (;SPMquot;Node;SPMquot;);
sub children {
  return ();
}

package Binary;
our @ISA = (;SPMquot;Node;SPMquot;);
sub children {
  my $self = shift;

  return (LEFT =;SPMgt; $self-;SPMgt;{LEFT}, RIGHT =;SPMgt; $self-;SPMgt;{RIGHT});
}
<tex2html_mydb_mark>#5608#
package PLUS;
our @ISA = (;SPMquot;Binary;SPMquot;);

sub operator {
  my $self = shift;

  $_[0]+$_[1];
}

....

package TIMES;
our @ISA = (;SPMquot;Binary;SPMquot;);

sub operator {
  my $self = shift;

  $_[0]*$_[1];
}

....
<tex2html_mydb_mark>#5609#
1 sub reduce_children {
2   my ($node) = @_;
3 
4   my $value = $node-;SPMgt;operator($node-;SPMgt;LEFT-;SPMgt;VAL, $node-;SPMgt;RIGHT-;SPMgt;VAL);
5   NUM-;SPMgt;new(VAL =;SPMgt; $value, TYPE =;SPMgt; $PL::Tutu::int_type);
6 }
<tex2html_mydb_mark>#5610#
sub PRINT::fold {
  $_[0]-;SPMgt;{EXPRESSION}-;SPMgt;fold;
}
<tex2html_mydb_mark>#5611#
sub ASSIGN::fold {
  $_[0]-;SPMgt;{RIGHT}-;SPMgt;fold;
}
<tex2html_mydb_mark>#5612#
sub ID::fold { }

sub NUM::fold { }

sub STR::fold { }
<tex2html_mydb_mark>#5613#
sub fold {
  my @statements = @{$tree-;SPMgt;{STS}};
  for my $s (@statements) {
    $s-;SPMgt;fold;
  }
}
<tex2html_mydb_mark>#5614#
  Tree::Transform::match_and_transform_list(
    NODES =;SPMgt; $tree-;SPMgt;{STS}, # lista de sentencias
    PATTERN =;SPMgt; sub {
       $_[0]-;SPMgt;is_operation and $_[0]-;SPMgt;LEFT-;SPMgt;isa(;SPMquot;NUM;SPMquot;) 
       and $_[0]-;SPMgt;RIGHT-;SPMgt;isa(;SPMquot;NUM;SPMquot;) 
    },
    ACTION =;SPMgt; sub { 
      $_[0] = Machine::Independent::Optimization::reduce_children($_[0]) 
    }
  );
<tex2html_mydb_mark>#5615#
sub match_and_transform_list {
  my %arg = @_;
  my @statements = @{$arg{NODES}} or 
   Error::fatal(;SPMquot;Internal error. match_and_transform_list ;SPMquot;.
   ;SPMquot;espera una lista anónima de nodos;SPMquot;);
  local $pattern = ($arg{PATTERN} or sub { 1 });
  local @pattern_args = @{$arg{PATTERN_ARGS}} if defined $arg{PATTERN_ARGS};
  local $action = ($arg{ACTION} or sub { print ref($_[0]),;SPMquot;\n;SPMquot; }); 
  local @action_args = @{$arg{ACTION_ARGS}} if defined $arg{ACTION_ARGS};

  for (@statements) {
    match_and_transform($_);
  }
}
<tex2html_mydb_mark>#5616#
package Tree::Transform;

our $pattern;
our @pattern_args;
our $action;
our @action_args;
our @statements;

sub match_and_transform {
  my $node = $_[0] or Error::fatal(;SPMquot;Error interno. match_and_transform necesita un nodo;SPMquot;);
  Error::fatal(;SPMquot;Error interno. El nodo de la clase;SPMquot;,ref($node),
               ;SPMquot; no dispone de método 'children';SPMquot;) unless $node-;SPMgt;can(;SPMquot;children;SPMquot;);
  
  my %children = $node-;SPMgt;children;

  for my $k (keys %children) {
    $node-;SPMgt;{$k} = match_and_transform($children{$k});
  }

  if ($pattern-;SPMgt;($node, @pattern_args)) {
    $action-;SPMgt;( $node, @action_args); 
  }
  return $node;
}
<tex2html_mydb_mark>#5617#
package Node;

sub is_operation {
  my $node = shift;

  return ref($node) =~ /^(TIMES)|(PLUS)$/;
}

package Leaf; # hoja del AAA
our @ISA = (;SPMquot;Node;SPMquot;);
sub children {
  return ();
}

package Binary;
our @ISA = (;SPMquot;Node;SPMquot;);
sub children {
  my $self = shift;

  return (LEFT =;SPMgt; $self-;SPMgt;{LEFT}, RIGHT =;SPMgt; $self-;SPMgt;{RIGHT});
}
<tex2html_mydb_mark>#5618#
package PLUS;
our @ISA = (;SPMquot;Binary;SPMquot;);

sub operator {
  my $self = shift;

  $_[0]+$_[1];
}

....

package TIMES;
our @ISA = (;SPMquot;Binary;SPMquot;);

sub operator {
  my $self = shift;

  $_[0]*$_[1];
}

....
<tex2html_mydb_mark>#5619#
1 sub reduce_children {
2   my ($node) = @_;
3 
4   my $value = $node-;SPMgt;operator($node-;SPMgt;LEFT-;SPMgt;VAL, $node-;SPMgt;RIGHT-;SPMgt;VAL);
5   NUM-;SPMgt;new(VAL =;SPMgt; $value, TYPE =;SPMgt; $PL::Tutu::int_type);
6 }
<tex2html_mydb_mark>#5620#
int a; a = a * 4 * 5;
<tex2html_mydb_mark>#5621#
int a; a = a * (4 * 5);
<tex2html_mydb_mark>#5622#
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') { ... }
  elsif ($lookahead eq 'ID') { ... }
  elsif ($lookahead eq 'STR') {
    $str = $value;
    my ($offset, $length) = Address::Assignment::str($str);
    match('STR');
    return STR-;SPMgt;new(OFFSET =;SPMgt; $offset, LENGTH =;SPMgt; $length, TYPE =;SPMgt; $string_type);
  }
  elsif ($lookahead eq '(') { ... }
  else { Error::fatal(;SPMquot;Se esperaba (, NUM o ID;SPMquot;); }
}
<tex2html_mydb_mark>#5623#
  sub str {
    my $str = shift;
    my $len = length($str);
    my $offset = length($data);
    $data .= $str;
    return ($offset, $len);
  }
<tex2html_mydb_mark>#5624#
# declaration -;SPMgt; type idlist
# type        -;SPMgt; INT | STRING
sub declaration() {
  my ($t, $decl, @il);

  if (($lookahead eq 'INT') or ($lookahead eq 'STRING')) {
    $t = ;SPMamp;type(); @il = ;SPMamp;idlist();
    ;SPMamp;Semantic::Analysis::set_types($t, @il);
    ;SPMamp;Address::Assignment::compute_address($t, @il);
    $decl = [$t, \@il];
    return bless $decl, 'DECL';
  }
  else { Error::fatal('Se esperaba un tipo'); }
}
<tex2html_mydb_mark>#5625#
  sub compute_address {
    my $type = shift;
    my @id_list = @_;

    for my $i (@id_list) {
      $symbol_table{$i}-;SPMgt;{ADDRESS} = $global_address;
      $global_address += $type-;SPMgt;LENGTH;
    }
  }
<tex2html_mydb_mark>#5626#
  ... 
  ##### En compile, despues de haber calculado las direcciones
  Tree::Transform::match_and_transform_list(
    NODES =;SPMgt; $tree-;SPMgt;{STS},
    PATTERN =;SPMgt; sub { 
      $_[0]-;SPMgt;isa('STR')
    },
    ACTION =;SPMgt; sub { $_[0]-;SPMgt;{OFFSET} += $global_address; }
  );
<tex2html_mydb_mark>#5627#
  sub str {
    my $str = shift;
    my $len = length($str);
    my $offset = length($data);
    $data .= $str;
    return ($offset, $len);
  }
<tex2html_mydb_mark>#5628#
DB;SPMlt;1;SPMgt; $str = ;SPMquot;world;SPMquot;
#              012345678901234567890123456789012
DB;SPMlt;2;SPMgt; $data = ;SPMquot;hello worldjust another statement;SPMquot;
DB;SPMlt;3;SPMgt; $res = $data =~ m{$str}g
DB;SPMlt;4;SPMgt; x pos($data) # la siguiente busqueda comienza en la 11
0  11
DB;SPMlt;5;SPMgt; $s = ;SPMquot;hello;SPMquot;
DB;SPMlt;6;SPMgt; $res = $data =~ m{$s}g
DB;SPMlt;7;SPMgt; x pos($data) # No hay ;SPMquot;hello;SPMquot; despues de world en $data
0  undef
DB;SPMlt;8;SPMgt; $res = $data =~ m{$str}g # Repetimos ...
DB;SPMlt;9;SPMgt; x pos($data)
0  11
DB;SPMlt;10;SPMgt; pos($data) = 0  # Podemos reiniciar pos!
DB;SPMlt;11;SPMgt; $res = $data =~ m{$s}g
DB;SPMlt;12;SPMgt; x pos($data) # Ahora si se encuentra ;SPMquot;hello;SPMquot;
0  5
<tex2html_mydb_mark>#5629#
   0    |    1    |    2      
0 1 2 3 | 4 5 6 7 | 8 9 10  11
p r o c | e s a d | o r \0  \0
<tex2html_mydb_mark>#5630#
   0    |     1      |    2      |    3
0 1 2 3 | 4  5  6  7 | 8 9 10 11 | 12 13 14 15
l u c a | s \0 \0 \0 | p e  d  r |  o \0 \0 \0
<tex2html_mydb_mark>#5631#
   0    |    1    |    2     
0 1 2 3 | 4 5 6 7 | 8 9 10 11
l u c a | s p e d | r o \0 \0
<tex2html_mydb_mark>#5632#
DB;SPMlt;1;SPMgt; $x = ;SPMquot;hola;SPMquot;x4
DB;SPMlt;2;SPMgt; p $x
holaholaholahola
<tex2html_mydb_mark>#5633#
  $tree = Syntax::Analysis::parser;
  ... # otras fases
  ########code generation
  local $target = ;SPMquot;;SPMquot;; # target code
  $tree-;SPMgt;translate;
  ...
<tex2html_mydb_mark>#5634#
sub PROGRAM::translate {
  my $tree = shift;

  $target .= ;SPMquot;DATA ;SPMquot;. $data.;SPMquot;\n;SPMquot; if $data;
  $tree-;SPMgt;STS-;SPMgt;translate;
}
<tex2html_mydb_mark>#5635#
sub STATEMENTS::translate {
  my $statements = shift;
  my @statements = @{$statements};

  for my $s (@statements) {
    $s-;SPMgt;translate;
  }
}
<tex2html_mydb_mark>#5636#
sub PRINT::translate {
  my $self = shift;

  $self-;SPMgt;EXPRESSION-;SPMgt;translate;
  if ($self-;SPMgt;EXPRESSION-;SPMgt;TYPE == $int_type) { emit ;SPMquot;PRINT_INT\n;SPMquot;; }
  else {emit ;SPMquot;PRINT_STR\n;SPMquot;; }
}
<tex2html_mydb_mark>#5637#
sub ID::translate {
  my $self = shift;

  my $id = $self-;SPMgt;VAL;
  my $type =  Semantic::Analysis::get_type($id);
  if ($type == $int_type) {
    emit ;SPMquot;LOAD ;SPMquot;.$symbol_table{$id}-;SPMgt;{ADDRESS}.;SPMquot;\n;SPMquot;;
  }
  else {
    emit ;SPMquot;LOAD_STRING ;SPMquot;.$symbol_table{$id}-;SPMgt;{ADDRESS}.;SPMquot;\n;SPMquot;;
  }
}
<tex2html_mydb_mark>#5638#
sub emit { $target .= shift; }
<tex2html_mydb_mark>#5639#
sub ASSIGN::translate {
  my $self = shift;

  $self-;SPMgt;RIGHT-;SPMgt;translate;
  my $id = $self-;SPMgt;LEFT;
  $id-;SPMgt;translate;
  my $type =  Semantic::Analysis::get_type($id-;SPMgt;VAL);

  if ($type == $int_type) {
    emit ;SPMquot;STORE_INT\n;SPMquot;;
  }
  else {
    emit ;SPMquot;STORE_STRING\n;SPMquot;;
  }
}
<tex2html_mydb_mark>#5640#
sub STR::translate {
  my $self = shift;

  emit ;SPMquot;PUSHSTR ;SPMquot;.$self-;SPMgt;OFFSET.;SPMquot; ;SPMquot;.$self-;SPMgt;LENGTH.;SPMquot;\n;SPMquot;;
}
<tex2html_mydb_mark>#5641#
$ cat test06.tutu
string a;
a = ;SPMquot;hola;SPMquot;;
p a
<tex2html_mydb_mark>#5642#
$ ./main.pl test06.tutu test06.ok
$ cat test06.ok
DATA 2, hola
PUSHSTR 2 4
PUSHADDR 0
STORE_STRING
LOAD_STRING 0
PRINT_STR
<tex2html_mydb_mark>#5643#
sub LEFTVALUE::translate {
  my $id = shift -;SPMgt;VAL;

  emit ;SPMquot;PUSHADDR ;SPMquot;.$symbol_table{$id}-;SPMgt;{ADDRESS}.;SPMquot;\n;SPMquot;;
}

sub NUM::translate {
  my $self = shift;

  emit ;SPMquot;PUSH ;SPMquot;.$self-;SPMgt;VAL.;SPMquot;\n;SPMquot;;
}

sub PLUS::translate {
  my $self = shift;

  $self-;SPMgt;LEFT-;SPMgt;translate;
  $self-;SPMgt;RIGHT-;SPMgt;translate;
  emit ;SPMquot;PLUS\n;SPMquot;;
}

sub TIMES::translate {
  my $self = shift;

  $self-;SPMgt;LEFT-;SPMgt;translate;
  $self-;SPMgt;RIGHT-;SPMgt;translate;
  emit ;SPMquot;MULT\n;SPMquot;;
}
<tex2html_mydb_mark>#5644#
$ cat test02.tutu
int a,b; string c; 
a = 2+3; b = 3*4; c = ;SPMquot;hola;SPMquot;; p c; 
c = ;SPMquot;mundo;SPMquot;; p c; p 9+2; p a+1; p b+1
<tex2html_mydb_mark>#5645#
$ ./main.pl test02.tutu test02.ok
$ cat test02.ok
DATA 4, holamundo
PUSH 5
PUSHADDR 0
STORE_INT
PUSH 12
PUSHADDR 1
STORE_INT
PUSHSTR 4 4
PUSHADDR 2
STORE_STRING
LOAD_STRING 2
PRINT_STR
PUSHSTR 8 5
PUSHADDR 2
STORE_STRING
LOAD_STRING 2
PRINT_STR
PUSH 11
PRINT_INT
LOAD 0
INC
PRINT_INT
LOAD 1
INC
PRINT_INT
<tex2html_mydb_mark>#5646#
LOADM R0, a
PLUSM R0, b
<tex2html_mydb_mark>#5647#
package Operation;
our @ISA = (;SPMquot;Binary;SPMquot;);

sub required_registers {
  my $self = shift;

  my $rl = $self-;SPMgt;LEFT-;SPMgt;required_registers('LEFT');
  my $rr = $self-;SPMgt;RIGHT-;SPMgt;required_registers('RIGHT');
  $self-;SPMgt;{REQ_REG} = ($rl == $rr)? $rl+1: Aux::max($rl, $rr);
  return $self-;SPMgt;REQ_REG;
}
<tex2html_mydb_mark>#5648#
package Value;
our @ISA = (;SPMquot;Leaf;SPMquot;);

sub required_registers {
  my $self = shift;
  my $position = shift;

  $self-;SPMgt;{REQ_REG} = ($position eq 'LEFT') ? 1 : 0;
  return $self-;SPMgt;REQ_REG;
}
<tex2html_mydb_mark>#5649#
package STATEMENTS;

sub required_registers {
  my $self = shift;
  my @sts = @{$self};

  for (@sts) {
    $_-;SPMgt;required_registers;
  }
}
<tex2html_mydb_mark>#5650#
package Operation;
our @ISA = (;SPMquot;Binary;SPMquot;);
...

sub gen_code {
  my $self = shift;

  if ($self-;SPMgt;RIGHT-;SPMgt;isa('Leaf')) {
    my $right = $self-;SPMgt;RIGHT;
    my $a = $right-;SPMgt;VAL;
    my $rightoperand = $right-;SPMgt;gen_operand; # valor o dirección 
    my $key = $right-;SPMgt;key;                  # M, C, etc.
    $self-;SPMgt;LEFT-;SPMgt;gen_code;
    Aux::emit($self-;SPMgt;nemonic.;SPMquot;$key $RSTACK[0], $rightoperand # $a\n;SPMquot;);
  }
  ...
}
<tex2html_mydb_mark>#5651#
sub  nemonic {
  return ;SPMquot;MULT;SPMquot;;
}
<tex2html_mydb_mark>#5652#
package NUM;
...
sub gen_operand {
  my $self = shift;

  return $self-;SPMgt;VAL;
}
<tex2html_mydb_mark>#5653#
package ID;
...
sub gen_operand {
  my $self = shift;

  return $symbol_table{$self-;SPMgt;VAL}-;SPMgt;{ADDRESS},
}
<tex2html_mydb_mark>#5654#
 1   ...
 2   if ($self-;SPMgt;RIGHT-;SPMgt;isa('Leaf')) { ...  }
 3   else { # Hijo derecho no es una hoja
 4     my ($t1, $t2) = ($self-;SPMgt;LEFT, $self-;SPMgt;RIGHT);
 5     my ($r1, $r2) = ($t1-;SPMgt;REQ_REG, $t2-;SPMgt;REQ_REG);
 6 
 7     if ($r1 ;SPMlt; Aux::min($r2, $NUM_REG)) {
 8       $t2-;SPMgt;gen_code;
 9       my $R = shift @RSTACK;
10       $t1-;SPMgt;gen_code;
11       Aux::emit($self-;SPMgt;nemonic.;SPMquot;R $RSTACK[0], $R\n;SPMquot;);
12       push @RSTACK, $R;
13     }
14     ...
15   }
<tex2html_mydb_mark>#5655#
  if ($self-;SPMgt;RIGHT-;SPMgt;isa('Leaf')) { ...  }
  else { ...
    if ($r1 ;SPMlt; Aux::min($r2, $NUM_REG)) { ... }
    elsif (($r1 ;SPMgt;= $r2) and ($r2 ;SPMlt; $NUM_REG)) {
      $t1-;SPMgt;gen_code;
      my $R = shift @RSTACK;
      $t2-;SPMgt;gen_code;
      Aux::emit($self-;SPMgt;nemonic.;SPMquot;R $R, $RSTACK[0]\n;SPMquot;);
      unshift @RSTACK, $R;
    }
    elsif (($r1 ;SPMgt;= $NUM_REG) and ($r2 ;SPMgt;= $NUM_REG)) {
      $t2-;SPMgt;gen_code;
      Aux::emit(;SPMquot;STORE $T, $RSTACK[0]\n;SPMquot;);
      $T++;
      $t1-;SPMgt;gen_code;
      $T--;
      Aux::emit($self-;SPMgt;nemonic.;SPMquot;M $RSTACK[0], $T\n;SPMquot;);
    }
  }
}
<tex2html_mydb_mark>#5656#
local $T =  $final_global_address+length($data);
<tex2html_mydb_mark>#5657#
package Value;
our @ISA = (;SPMquot;Leaf;SPMquot;);
...

sub gen_code {
  my $self = shift;
  my $a = $self-;SPMgt;VAL;

  if ($self-;SPMgt;REQ_REG == 1) {
    if (ref($self) eq ;SPMquot;NUM;SPMquot;) { Aux::emit(;SPMquot;LOADC $RSTACK[0], $a\n;SPMquot;); }
    else { 
      my $address = $symbol_table{$a}-;SPMgt;{ADDRESS};
      Aux::emit(;SPMquot;LOADM $RSTACK[0], $address # $a\n;SPMquot;);
    }
  }
  else {
    croak(;SPMquot;gen_code visita hoja izquierda con REQ_REG = ;SPMquot;.$self-;SPMgt;REQ_REG);
  }
}
<tex2html_mydb_mark>#5658#
use constant LAST_REG =;SPMgt; 1;
our @RSTACK = map ;SPMquot;R$_;SPMquot;, 0..LAST_REG; # Registros disponibles
<tex2html_mydb_mark>#5659#
string a,b;
a = ;SPMquot;hola;SPMquot;;
b = a;
p b
<tex2html_mydb_mark>#5660#
1 LSTRG  R0, 4, 4 
2 STORES  0, R0 # a
3 LOADS  R0, 0 # a
4 STORES  2, R0 # b
5 LOADS  R0, 2 # b
6 PRNTS  R0
<tex2html_mydb_mark>#5661#
$ cat test18.tutu
int a,b,c;

a = a + (b + c)
<tex2html_mydb_mark>#5662#
LOADM R0, 0 # a
LOADM R1, 1 # b
PLUSM R1, 2 # c
PLUSR R0, R1
STORE  0, R0 # a
<tex2html_mydb_mark>#5663#
traduce(t)
ADDM $RSTACK[0], dirección de ID
<tex2html_mydb_mark>#5664#
LOADM R0, 1 # b
PLUSM R0, 2 # c
PLUSM R0, 0 # a
STORE  0, R0 # a
<tex2html_mydb_mark>#5665#
package Peephole::Optimization;

sub transform {
  $target = shift;
  $target =~ s/PUSH 1\nPLUS/INC/g;
}
<tex2html_mydb_mark>#5666#
$ perl -de 0
DB;SPMlt;1;SPMgt; $a = ;SPMquot;MUL R2, 16;SPMquot;
DB;SPMlt;2;SPMgt; $a =~ s/MUL R(\d), (\d+)/($2 == 16)?;SPMquot;SHL R$1, 4;SPMquot;:$;SPMamp;/e
DB;SPMlt;3;SPMgt; p $a
SHL R2, 4
DB;SPMlt;5;SPMgt; $a = ;SPMquot;MUL R2, 7;SPMquot;
DB;SPMlt;6;SPMgt; $a =~ s/MUL R(\d), (\d+)/($2 == 16)?;SPMquot;SHL R$1, 4;SPMquot;:$;SPMamp;/e
DB;SPMlt;7;SPMgt; p $a
MUL R2, 7
DB;SPMlt;8;SPMgt;
<tex2html_mydb_mark>#5667#
$ cat test14.tutu
int a,b; a = 2; b = a*a+1
<tex2html_mydb_mark>#5668#
1 LOADC R0, 2
2 STORE  0, R0 # a
3 LOADM R0, 0 # a
4 MULTM R0, 0 # a
5 PLUSC R0, 1 # 1
6 STORE  1, R0 # b
<tex2html_mydb_mark>#5669#%%

<tex2html_mydb_mark>#5670#%lex

<tex2html_mydb_mark>#5671#%%

<tex2html_mydb_mark>#5672#%%

<tex2html_mydb_mark>#5673#%w{basic2_lex_ugly.js} do
  
<tex2html_mydb_mark>#5674#%w{basic2_lex.jison} do
  
<tex2html_mydb_mark>#5675#%lex

<tex2html_mydb_mark>#5676#%%

<tex2html_mydb_mark>#5677#%;SPMquot;                   return '%'

<tex2html_mydb_mark>#5678#%left '+' '-'

<tex2html_mydb_mark>#5679#%left '*' '/'

<tex2html_mydb_mark>#5680#%left '^'

<tex2html_mydb_mark>#5681#%right '!'

<tex2html_mydb_mark>#5682#%right '%'

<tex2html_mydb_mark>#5683#%left UMINUS

<tex2html_mydb_mark>#5684#%start expressions

<tex2html_mydb_mark>#5685#%% /* language grammar */

<tex2html_mydb_mark>#5686#%'
        
<tex2html_mydb_mark>#5687#%prec UMINUS
        
<tex2html_mydb_mark>#5688#%w{calcugly.js} do
  
<tex2html_mydb_mark>#5689#%w{calculator.jison} do
  
<tex2html_mydb_mark>#5690#%\begin{center}

<tex2html_mydb_mark>#5691#%\begin{figure}[htb]

<tex2html_mydb_mark>#5692#%\centerline{\includegraphics[scale=1.2]{chapter_bottomup/nfa.png}}

<tex2html_mydb_mark>#5693#%\caption{NFA que reconoce los prefijos viables}

<tex2html_mydb_mark>#5694#%\label{fig:nfa}

<tex2html_mydb_mark>#5695#%\end{figure}

<tex2html_mydb_mark>#5696#%\end{makeimage}

<tex2html_mydb_mark>#5697#%\end{center}

<tex2html_mydb_mark>#5698#%\centerline{\includegraphics[scale=1.2]{chapter_bottomup/dfa.png}}

<tex2html_mydb_mark>#5699#%lex
     
<tex2html_mydb_mark>#5700#%
     
<tex2html_mydb_mark>#5701#%
     
<tex2html_mydb_mark>#5702#%

<tex2html_mydb_mark>#5703#%lex'

<tex2html_mydb_mark>#5704#% (véase la figura \ref{fig:lrparser}). 

<tex2html_mydb_mark>#5705#%\begin{figure}

<tex2html_mydb_mark>#5706#%\input{parser_fig.tex}

<tex2html_mydb_mark>#5707#%\caption{Estructura de un Análizador LR}

<tex2html_mydb_mark>#5708#%\label{fig:lrparser}       

<tex2html_mydb_mark>#5709#%\end{figure}

<tex2html_mydb_mark>#5710#
%%

S   : A
    ;
A   : /* empty */  
    | A x 
    ;
<tex2html_mydb_mark>#5711#
[~/jison/examples/basic2_lex(develop)]$ cat basic2_lex.jison 
/* description: Basic grammar that contains a nullable A nonterminal. */

%lex
%%

\s+               {/* skip whitespace */}
[a-zA-Z_]\w*      {return 'x';}

/lex

%%

S   : A
           { return $1+;SPMquot; identifiers;SPMquot;; }
    ;
A   : /* empty */  
           { 
              console.log(;SPMquot;starting;SPMquot;); 
              $$ = 0; 
           }
    | A x  { 
              $$ = $1 + 1;  
              console.log($$)
           }
    ;
<tex2html_mydb_mark>#5712#
$ cat basic2_lex.html
;SPMlt;!DOCTYPE HTML;SPMgt;
;SPMlt;html lang=;SPMquot;en;SPMquot;;SPMgt;
  ;SPMlt;head;SPMgt;
    ;SPMlt;meta charset=;SPMquot;utf-8;SPMquot;;SPMgt;
    ;SPMlt;title;SPMgt;Jison;SPMlt;/title;SPMgt;
    ;SPMlt;link rel=;SPMquot;stylesheet;SPMquot; href=;SPMquot;global.css;SPMquot; type=;SPMquot;text/css;SPMquot; media=;SPMquot;screen;SPMquot; charset=;SPMquot;utf-8;SPMquot; /;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;basic2_lex demo;SPMlt;/h1;SPMgt;
    ;SPMlt;div id=;SPMquot;content;SPMquot;;SPMgt;
      ;SPMlt;script src=;SPMquot;jquery/jquery.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt; 
      ;SPMlt;script src=;SPMquot;basic2_lex.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
      ;SPMlt;script src=;SPMquot;main.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
      ;SPMlt;p;SPMgt;
        ;SPMlt;input type=;SPMquot;text;SPMquot; value=;SPMquot;x x x x;SPMquot; /;SPMgt; ;SPMlt;button;SPMgt;parse;SPMlt;/button;SPMgt; 
        ;SPMlt;span id=;SPMquot;output;SPMquot;;SPMgt;;SPMlt;/span;SPMgt; ;SPMlt;!-- Output goes here! --;SPMgt;
      ;SPMlt;/p;SPMgt;
    ;SPMlt;/div;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#5713#
$ cat Rakefile 
# install package:
#     sudo npm install beautifier
# 
#   more about beautifier:
#       https://github.com/rickeyski/node-beautifier

dec ;SPMquot;compile the grammar basic2_lex_ugly.jison;SPMquot;
task :default =;SPMgt; %w{basic2_lex_ugly.js} do
  sh ;SPMquot;mv basic2_lex.js basic2_lex_ugly.js;SPMquot;
  sh ;SPMquot;jsbeautify basic2_lex_ugly.js ;SPMgt; basic2_lex.js;SPMquot;
  sh ;SPMquot;rm -f basic2_lex_ugly.js;SPMquot;
end

file ;SPMquot;basic2_lex_ugly.js;SPMquot; =;SPMgt; %w{basic2_lex.jison} do
  sh ;SPMquot;jison basic2_lex.jison -o basic2_lex.js;SPMquot;
end
<tex2html_mydb_mark>#5714#
[~/jison/examples/basic2_lex(develop)]$ cat global.css 
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: left; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: none; }
.unhidden    { display: block; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }
span.header { background-color: blue }
span.comments { background-color: orange }
span.blanks { background-color: green }
span.nameEqualValue { background-color: cyan }
span.error { background-color: red }

body
{
 background-color:#b0c4de;  /* blue */
}
<tex2html_mydb_mark>#5715#
[~/jison/examples/html_calc_example(develop)]$ cat calculator.jison 

/* description: Parses end executes mathematical expressions. */

/* lexical grammar */
%lex
%%

\s+                   /* skip whitespace */
[0-9]+(;SPMquot;.;SPMquot;[0-9]+)?\b  return 'NUMBER'
;SPMquot;*;SPMquot;                   return '*'
;SPMquot;/;SPMquot;                   return '/'
;SPMquot;-;SPMquot;                   return '-'
;SPMquot;+;SPMquot;                   return '+'
;SPMquot;^;SPMquot;                   return '^'
;SPMquot;!;SPMquot;                   return '!'
;SPMquot;%;SPMquot;                   return '%'
;SPMquot;(;SPMquot;                   return '('
;SPMquot;);SPMquot;                   return ')'
;SPMquot;PI;SPMquot;                  return 'PI'
;SPMquot;E;SPMquot;                   return 'E'
;SPMlt;;SPMlt;EOF;SPMgt;;SPMgt;               return 'EOF'
.                     return 'INVALID'

/lex

/* operator associations and precedence */

%left '+' '-'
%left '*' '/'
%left '^'
%right '!'
%right '%'
%left UMINUS

%start expressions

%% /* language grammar */

expressions
    : e EOF
        { typeof console !== 'undefined' ? console.log($1) : print($1);
          return $1; }
    ;

e
    : e '+' e
        {$$ = $1+$3;}
    | e '-' e
        {$$ = $1-$3;}
    | e '*' e
        {$$ = $1*$3;}
    | e '/' e
        {$$ = $1/$3;}
    | e '^' e
        {$$ = Math.pow($1, $3);}
    | e '!'
        {{
          $$ = (function fact (n) { return n==0 ? 1 : fact(n-1) * n })($1);
        }}
    | e '%'
        {$$ = $1/100;}
    | '-' e %prec UMINUS
        {$$ = -$2;}
    | '(' e ')'
        {$$ = $2;}
    | NUMBER
        {$$ = Number(yytext);}
    | E
        {$$ = Math.E;}
    | PI
        {$$ = Math.PI;}
    ;
<tex2html_mydb_mark>#5716#
[~/jison/examples/html_calc_example(develop)]$ cat main.js
$(document).ready(function () {
  $(;SPMquot;button;SPMquot;).click(function () {
    try {
      var result = calculator.parse($(;SPMquot;input;SPMquot;).val())
      $(;SPMquot;span;SPMquot;).html(result);
    } catch (e) {
      $(;SPMquot;span;SPMquot;).html(String(e));
    }
  });
});
<tex2html_mydb_mark>#5717#
[~/jison/examples/html_calc_example(develop)]$ cat calculator.html 
;SPMlt;!DOCTYPE HTML;SPMgt;
;SPMlt;html lang=;SPMquot;en;SPMquot;;SPMgt;
  ;SPMlt;head;SPMgt;
    ;SPMlt;meta charset=;SPMquot;utf-8;SPMquot;;SPMgt;
    ;SPMlt;title;SPMgt;Calc;SPMlt;/title;SPMgt;
    ;SPMlt;link rel=;SPMquot;stylesheet;SPMquot; href=;SPMquot;global.css;SPMquot; type=;SPMquot;text/css;SPMquot; media=;SPMquot;screen;SPMquot; charset=;SPMquot;utf-8;SPMquot; /;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;Calculator demo;SPMlt;/h1;SPMgt;
    ;SPMlt;div id=;SPMquot;content;SPMquot;;SPMgt;
      ;SPMlt;script src=;SPMquot;jquery/jquery.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt; 
      ;SPMlt;script src=;SPMquot;calculator.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
      ;SPMlt;script src=;SPMquot;main.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
      ;SPMlt;p;SPMgt;
        ;SPMlt;input type=;SPMquot;text;SPMquot; value=;SPMquot;PI*4^2 + 5;SPMquot; /;SPMgt; ;SPMlt;button;SPMgt;equals;SPMlt;/button;SPMgt; 
        ;SPMlt;span;SPMgt;;SPMlt;/span;SPMgt; ;SPMlt;!-- Output goes here! --;SPMgt;
      ;SPMlt;/p;SPMgt;
    ;SPMlt;/div;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#5718#
[~/jisoncalc(clase)]$ cat Rakefile 
task :default =;SPMgt; %w{calcugly.js} do
  sh ;SPMquot;jsbeautify calcugly.js ;SPMgt; calculator.js;SPMquot;
  sh ;SPMquot;rm -f calcugly.js;SPMquot;
end

file ;SPMquot;calcugly.js;SPMquot; =;SPMgt; %w{calculator.jison} do
  sh ;SPMquot;jison calculator.jison calculator.l -o calculator.js; mv calculator.js calcugly.js;SPMquot;
end

task :testf do
  sh ;SPMquot;open -a firefox test/test.html;SPMquot;
end

task :tests do
  sh ;SPMquot;open -a safari test/test.html;SPMquot;
end
<tex2html_mydb_mark>#5719#
[~/jison/examples/html_calc_example(develop)]$ cat global.css
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: left; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: none; }
.unhidden    { display: block; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }
span.header { background-color: blue }
span.comments { background-color: orange }
span.blanks { background-color: green }
span.nameEqualValue { background-color: cyan }
span.error { background-color: red }

body
{
 background-color:#b0c4de;  /* blue */
}
<tex2html_mydb_mark>#5720#
$ cat test/assert.js 
var output = document.getElementById('output');

function assert( outcome, description) {
  var li = document.createElement('li');
  li.className = outcome ? 'pass' : 'fail';
  li.appendChild(document.createTextNode(description));
  
  output.appendChild(li);
};
<tex2html_mydb_mark>#5721#
~/jisoncalc(clase)]$ cat test/test.css 
.pass:before {
  content: 'PASS: ';
  color:  blue;
  font-weight: bold;
}

.fail:before {
  content: 'FAIL: ';
  color: red;
  font-weight: bold;
  
}
<tex2html_mydb_mark>#5722#
[~/jisoncalc(clase)]$ cat test/test.html
;SPMlt;!DOCTYPE HTML;SPMgt;
;SPMlt;html lang=;SPMquot;en;SPMquot;;SPMgt;
  ;SPMlt;head;SPMgt;
    ;SPMlt;meta charset=;SPMquot;UTF-8;SPMquot;;SPMgt;
    ;SPMlt;title;SPMgt;Testing Our Simple Calculator;SPMlt;/title;SPMgt;
    ;SPMlt;link rel=;SPMquot;stylesheet;SPMquot; href=;SPMquot;test.css;SPMquot; /;SPMgt;
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../calculator.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;

  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;Testing Our Simple Calculator
    ;SPMlt;/h1;SPMgt;
    
    ;SPMlt;ul id=;SPMquot;output;SPMquot;;SPMgt;;SPMlt;/ul;SPMgt;
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;______.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
    
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot;;SPMgt;
      var r = __________.parse(;SPMquot;a = 4*8;SPMquot;);
      assert(_______________, ;SPMquot;a is 4*8;SPMquot;);
      assert(_____________, ;SPMquot;32 == 4*8;SPMquot;);
      r = calculator.parse(;SPMquot;a = 4;\nb=a+1;\nc=b*2;SPMquot;);
      assert(____________, ;SPMquot;4 is the first computed result ;SPMquot;);
      assert(______________, ;SPMquot;a is 4;SPMquot;);
      assert(______________, ;SPMquot;b is 5;SPMquot;);
      assert(______________, ;SPMquot;c is 10;SPMquot;);
    ;SPMlt;/script;SPMgt;
      See the NetTuts+ tutorial at ;SPMlt;a href=;SPMquot;http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/;SPMquot;;SPMgt;Quick and Easy JavaScript Testing;SPMlt;/a;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#5723#
[~/srcPLgrado/aSb(develop)]$ cat -n aSb.jison 
     1  %lex
     2  %%
     3  .               { return yytext; }
     4  /lex
     5  %%
     6  P: S            { return $1; }
     7  ;
     8  S: /* empty */  { console.log(;SPMquot;empty;SPMquot;);    $$ = ''; }
     9     | 'a' S 'b'  { console.log(;SPMquot;S -;SPMgt; aSb;SPMquot;); $$ = $1+$2+$3; }
    10  ;
    11  %%

<tex2html_mydb_mark>#5724#
nereida:[~/PLgradoBOOK(eps)]$ jison --help

Usage: jison [file] [lexfile] [options]

file        file containing a grammar
lexfile     file containing a lexical grammar

Options:
   -o FILE, --outfile FILE       Filename and base module name of the generated parser
   -t, --debug                   Debug mode
   -t TYPE, --module-type TYPE   The type of module to generate (commonjs, amd, js)
   -V, --version                 print version and exit
<tex2html_mydb_mark>#5725#
[~/srcPLgrado/aSb(develop)]$ bison -v aSb.jison 
aSb.jison:1.1-4: invalid directive: `%lex'
aSb.jison:3.1: syntax error, unexpected identifier
aSb.jison:4.1: invalid character: `/'
<tex2html_mydb_mark>#5726#
[~/srcPLgrado/aSb(develop)]$ bison -v aSb.jison 
[~/srcPLgrado/aSb(develop)]$ ls -ltr | tail -1
-rw-rw-r--  1 casiano  staff    926 19 mar 13:29 aSb.output
<tex2html_mydb_mark>#5727#
[~/srcPLgrado/aSb(develop)]$ cat -n aSb.output 
     1  Grammar
     2  
     3      0 $accept: P $end
     4  
     5      1 P: S
     6  
     7      2 S: /* empty */
     8      3  | 'a' S 'b'
     9  
    10  
    11  Terminals, with rules where they appear
    12  
    13  $end (0) 0
    14  'a' (97) 3
    15  'b' (98) 3
    16  error (256)
    17  
    18  
    19  Nonterminals, with rules where they appear
    20  
    21  $accept (5)
    22      on left: 0
    23  P (6)
    24      on left: 1, on right: 0
    25  S (7)
    26      on left: 2 3, on right: 1 3
    27  
    28  
    29  state 0
    30  
    31      0 $accept: . P $end
    32  
    33      'a'  shift, and go to state 1
    34  
    35      $default  reduce using rule 2 (S)
    36  
    37      P  go to state 2
    38      S  go to state 3
    39  
    40  
    41  state 1
    42  
    43      3 S: 'a' . S 'b'
    44  
    45      'a'  shift, and go to state 1
    46  
    47      $default  reduce using rule 2 (S)
    48  
    49      S  go to state 4
    50  
    51  
    52  state 2
    53  
    54      0 $accept: P . $end
    55  
    56      $end  shift, and go to state 5
    57  
    58  
    59  state 3
    60  
    61      1 P: S .
    62  
    63      $default  reduce using rule 1 (P)
    64  
    65  
    66  state 4
    67  
    68      3 S: 'a' S . 'b'
    69  
    70      'b'  shift, and go to state 6
    71  
    72  
    73  state 5
    74  
    75      0 $accept: P $end .
    76  
    77      $default  accept
    78  
    79  
    80  state 6
    81  
    82      3 S: 'a' S 'b' .
    83  
    84      $default  reduce using rule 3 (S)
<tex2html_mydb_mark>#5728#
                      0:	$start -;SPMgt; S $end
                      1:	S -;SPMgt; /* empty */
                      2:	S -;SPMgt; 'a' S 'b'
<tex2html_mydb_mark>#5729#
	$start -;SPMgt; . S $end	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 1
<tex2html_mydb_mark>#5730#
	$start -;SPMgt; S . $end	
	$end	shift 3
<tex2html_mydb_mark>#5731#
	S -;SPMgt; 'a' . S 'b'	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 4
<tex2html_mydb_mark>#5732#
	$start -;SPMgt; S $end .	
	$default	accept
<tex2html_mydb_mark>#5733#
	S -;SPMgt; 'a' S . 'b'	
	'b'	shift 5
<tex2html_mydb_mark>#5734#
	S -;SPMgt; 'a' S 'b' .	
	$default	reduce 2 (S)
<tex2html_mydb_mark>#5735#
push(s0);
 b = yylex();
 for( ; ; ;) {
   s = top(0); a = b;
   switch (action[s][a]) {
     case ;SPMquot;shift t;SPMquot; : 
       push(t); 
       b = yylex();
       break;
     case ;SPMquot;reduce A -;SPMgt;alpha;SPMquot; : 
       eval(Sub{A -;SPMgt; alpha}-;SPMgt;(top(|alpha|-1).attr, ... , top(0).attr)); 
       pop(|alpha|); 
       push(goto[top(0)][A]); 
       break;
     case ;SPMquot;accept;SPMquot; : return (1); 
     default : yyerror(;SPMquot;syntax error;SPMquot;);
   }
 }
<tex2html_mydb_mark>#5736#
a = (2+5)*3;
if a == 0 then b = 5 else b = 3;
c = b + 1;
<tex2html_mydb_mark>#5737#
        2
        5
        +
        3
        *
        ;SPMamp;a
        =
        a
        0
        ==
        jmpz else1
        5
        ;SPMamp;b
        =
        jmp endif0
:else1
        3
        ;SPMamp;b
        =
:endif0
        b
        1
        +
        ;SPMamp;c
        =
<tex2html_mydb_mark>#5738#
[~/srcPLgrado/jisoninfix2postfix(master)]$ cat test/test.html 
;SPMlt;!DOCTYPE HTML;SPMgt;
;SPMlt;html lang=;SPMquot;en;SPMquot;;SPMgt;
  ;SPMlt;head;SPMgt;
    ;SPMlt;meta charset=;SPMquot;UTF-8;SPMquot;;SPMgt;
    ;SPMlt;title;SPMgt;Testing Our Simple Translator;SPMlt;/title;SPMgt;
    ;SPMlt;link rel=;SPMquot;stylesheet;SPMquot; href=;SPMquot;test.css;SPMquot; /;SPMgt;
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;../calculator.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;

  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;Testing Our Simple Translator
    ;SPMlt;/h1;SPMgt;
    
    ;SPMlt;ul id=;SPMquot;output;SPMquot;;SPMgt;;SPMlt;/ul;SPMgt;
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot; src=;SPMquot;assert.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
    
    ;SPMlt;script type=;SPMquot;text/javascript;SPMquot;;SPMgt;

      var r = calculator.parse(;SPMquot;a = 4*8;SPMquot;);
      assert( /4\s*8\s*[*]\s*a\s*=\s*/.exec(r), ;SPMquot;a is 4*8;SPMquot;);
      
      r = calculator.parse(;SPMquot;a=4;b=a+1;SPMquot;);
      r = r.replace(/\s+/g,'');
      var expected = ;SPMquot;4a=a1+b=;SPMquot;;
      assert( r == expected, ;SPMquot;a = 4;\nb=a+1 translated;SPMquot;);


      var r = calculator.parse(;SPMquot;if a ;SPMgt; 0 then b = 1 else b = 2;SPMquot;);
      r = r.replace(/\s+/g,'');
      expected = ;SPMquot;a 0 ;SPMgt; jmpz else1 1 b = jmp endif0 :else1 2 b = :endif0;SPMquot;.
                 replace(/\s+/g,'');
      assert( r == expected, ;SPMquot;'if a ;SPMgt; 0 then b = 1 else b = 2' translated;SPMquot;);
    ;SPMlt;/script;SPMgt;
      See the NetTuts+ tutorial at ;SPMlt;a href=;SPMquot;http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/;SPMquot;;SPMgt;Quick and Easy JavaScript Testing;SPMlt;/a;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#5739#%lex

<tex2html_mydb_mark>#5740#%%

<tex2html_mydb_mark>#5741#%%

<tex2html_mydb_mark>#5742#%%

<tex2html_mydb_mark>#5743#% edit chapter_bottomup/aSb.tex

<tex2html_mydb_mark>#5744#%\centerline{\includegraphics[scale=1.2]{chapter_bottomup/dfa.png}}

<tex2html_mydb_mark>#5745#%;SPMquot;/;SPMgt;

<tex2html_mydb_mark>#5746#%token NUMBER
     
<tex2html_mydb_mark>#5747#%left '@'
     
<tex2html_mydb_mark>#5748#%right ';SPMamp;'  dummy
     
<tex2html_mydb_mark>#5749#%
     
<tex2html_mydb_mark>#5750#%prec dummy
    
<tex2html_mydb_mark>#5751#%

<tex2html_mydb_mark>#5752#%prec dummy

<tex2html_mydb_mark>#5753#%left '@'
     
<tex2html_mydb_mark>#5754#%right ';SPMamp;'  dummy

<tex2html_mydb_mark>#5755#%token|. De esta manera

<tex2html_mydb_mark>#5756#%{| y \verb|%}|. Estos delimitadores

<tex2html_mydb_mark>#5757#%{

<tex2html_mydb_mark>#5758#%}

<tex2html_mydb_mark>#5759#%token NUM

<tex2html_mydb_mark>#5760#%%

<tex2html_mydb_mark>#5761#%%% TEXEXPAND: END FILE ./chapter_bottomup/jison.tex

<tex2html_mydb_mark>#5762#
[~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ jison --version
0.4.2
<tex2html_mydb_mark>#5763#
[~/srcPLgrado/aSb(develop)]$ cat aSb.jison 
%lex
%%
.               { return yytext; }
/lex
%%
S: /* empty */  { console.log(;SPMquot;empty;SPMquot;); }
   | 'a' S 'b'  { console.log(;SPMquot;S -;SPMgt; aSb;SPMquot;); }
;
%%

<tex2html_mydb_mark>#5764#
/* parser generated by jison 0.4.2 */
var aSb = (function() {
    var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
            ;SPMquot;$accept;SPMquot;: 0, /* super-arranque $accept -;SPMgt; S */
            ;SPMquot;$end;SPMquot;: 1     /* end of input */
            ;SPMquot;error;SPMquot;: 2, /* numero para el símbolo 'error' */
            ;SPMquot;S;SPMquot;: 3,     /* numero para el símbolo 'S' */
            ;SPMquot;a;SPMquot;: 4,
            ;SPMquot;b;SPMquot;: 5,
        },
        /* array inverso de terminales */
        terminals_: {   /* numero -;SPMgt; terminal */
            2: ;SPMquot;error;SPMquot;, 
            4: ;SPMquot;a;SPMquot;,
            5: ;SPMquot;b;SPMquot;
        },
        productions_: 
        [0, 
/* 1 */     [3, 0], /* S : vacio        simbolo,longitud de la parte derecha */
/* 2 */     [3, 3]  /* S : a S b        simbolo,longitud */
        ],
<tex2html_mydb_mark>#5765#
<img src="aSb.png" width="50%"/>
<p>

DFA construido por Jison
<tex2html_mydb_mark>#5766#
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

    var $0 = $$.length - 1;
    switch (yystate) { /* yystate: numero de regla de producción */
        case 1:
            console.log(;SPMquot;empty;SPMquot;);
            break;
        case 2:
            console.log(;SPMquot;S -;SPMgt; aSb;SPMquot;);
            break;
    }
},
<tex2html_mydb_mark>#5767#
r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
<tex2html_mydb_mark>#5768#
$$ = $1 + $2 + $3;
<tex2html_mydb_mark>#5769#
this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
<tex2html_mydb_mark>#5770#
        table: [{
/* 0 */     1: [2, 1],    /* En estado 0 viendo $end(1) reducir por S : vacio */
            3: 1,         /* En el estado 0 viendo S(3) ir al estado 1 */
            4: [1, 2]     /* Estado 0 viendo a(4) shift(1) al estado 2 */
        }, {
/* 1 */     1: [3]        /* En 1 viendo $end(1) aceptar */
        }, {
/* 2 */     3: 3,         /* En 2 viendo S ir a 3 */
            4: [1, 2],    /* En 2 viendo a(4) shift a 2 */
            5: [2, 1]     /* En 2 viendo b(5) reducir por regla 1: S -;SPMgt; vacio */
        }, {
/* 3 */     5: [1, 4]     /* En 3 viendo b(5) shift a 4 */
        }, {
/* 4 */     1: [2, 2],    /* En 4  viendo $end(1) reducir(2) por la 2: S -;SPMgt; aSb */
            5: [2, 2]     /* En 4 viendo b(5) reducir por la 2: S-;SPMgt; aSb */
        }],
<tex2html_mydb_mark>#5771#
        {
            1: [2, 1],    /* En estado 0 viendo $end(1) reducir(2) por S : vacio */
            3: 1,         /* En el estado 0 viendo S(3) ir (goto) al estado 1 */
            4: [1, 2]     /* Estado 0 viendo a(4) shift(1) al estado 2 */
        }
<tex2html_mydb_mark>#5772#
        defaultActions: {},
<tex2html_mydb_mark>#5773#
    while (true) {
          state = stack[stack.length - 1]; 
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == ;SPMquot;undefined;SPMquot;) {
                  symbol = lex();
              }   
              action = table[state] ;SPMamp;;SPMamp; table[state][symbol];
          }   
          ...
    }
<tex2html_mydb_mark>#5774#
parse: function parse(input) {
    ...
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == ;SPMquot;undefined;SPMquot;) {
                symbol = lex(); /* obtener siguiente token */
            }
            action = table[state] ;SPMamp;;SPMamp; table[state][symbol];
        }
        if (typeof action === ;SPMquot;undefined;SPMquot; || !action.length || !action[0]) {
          ... // error
        }
        if (action[0] instanceof Array ;SPMamp;;SPMamp; action.length ;SPMgt; 1) {
            throw new Error(;SPMquot;Parse Error: multiple actions possible at state: ...;SPMquot; 
        }
        switch (action[0]) {
            case 1:                                    // shift
                ...
                break;
            case 2:                                    // reduce
                len = this.productions_[action[1]][1]; // longitud de la producción
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {                           // datos de la posición
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                };
                ...
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                if (typeof r !== ;SPMquot;undefined;SPMquot;) {
                    return r; /* un return de algo distinto de undefined nos saca del parser */
                }
                if (len) {                                  /* retirar de las pilas */
                    stack = stack.slice(0, - 1 * len * 2);  /* simbolo, estado, simbolo, estado ... */
                    vstack = vstack.slice(0, - 1 * len);    /* retirar atributos */
                    lstack = lstack.slice(0, - 1 * len);    /* retirar localizaciones */
                }
                stack.push(this.productions_[action[1]][0]); /* empujemos el símbolo */
                vstack.push(yyval.$);                        /* empujemos valor semantico */
                lstack.push(yyval._$);                       /* empujemos localización */
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);                        /* empujemos goto[top][A]*/
                break;
            case 3: // accept
                return true;
        }
    }
    return true;
}
<tex2html_mydb_mark>#5775#
parse: function parse(input) {
    ...
    while (true) {
        state = stack[stack.length - 1];     /* estado en el top de la pila */
        if (this.defaultActions[state]) {    /* definida la acción por defecto? */
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == ;SPMquot;undefined;SPMquot;) {
                symbol = lex();              /* obtener token */
            }
            action = table[state] ;SPMamp;;SPMamp; table[state][symbol]; /* obtener la acción para el estado actual */
        }
        if (typeof action === ;SPMquot;undefined;SPMquot; || !action.length || !action[0]) { 
            ... /* error */
        }
        if (action[0] instanceof Array ;SPMamp;;SPMamp; action.length ;SPMgt; 1) {
            throw new Error(;SPMquot;Parse Error: multiple actions possible at state: ;SPMquot; + state + ;SPMquot;, token: ;SPMquot; + symbol);
        }
        switch (action[0]) {
            case 1:
                stack.push(symbol);                /* empujamos token */
                vstack.push(this.lexer.yytext);    /* empujamos el atributo del token */
                lstack.push(this.lexer.yylloc);    /* salvamos la localización del token */
                stack.push(action[1]);             /* salvamos el estado */
                symbol = null;
                if (!preErrorSymbol) {             /* si no hay errores ... */
                    yyleng = this.lexer.yyleng;    /* actualizamos los atributos */
                    yytext = this.lexer.yytext;    /* del objeto */
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering ;SPMgt; 0) recovering--; /* las cosas van mejor si hubieron errores */
                } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;
            case 2:
                ...
                break;
            case 3:
                return true;
        }
    }
    return true;
}
<tex2html_mydb_mark>#5776#
while (true) {
    state = stack[stack.length - 1];
    if (this.defaultActions[state]) { action = this.defaultActions[state]; } 
    else {
        if (symbol === null || typeof symbol == ;SPMquot;undefined;SPMquot;) { symbol = lex(); }
        action = table[state] ;SPMamp;;SPMamp; table[state][symbol];
    }
    if (typeof action === ;SPMquot;undefined;SPMquot; || !action.length || !action[0]) {
        var errStr = ;SPMquot;;SPMquot;;
        if (!recovering) { /* recovering = en estado de recuperación de un error */
            expected = [];                       /* computemos los tokens esperados */
            for (p in table[state])              /* si el estado ;SPMquot;state;SPMquot; transita con p */
              if (this.terminals_[p] ;SPMamp;;SPMamp; p ;SPMgt; 2) { /* y ;SPMquot;p;SPMquot; es un terminal no especial */
                  expected.push(;SPMquot;';SPMquot; + this.terminals_[p] + ;SPMquot;';SPMquot;); /* entonces es esperado */
              }
            if (this.lexer.showPosition) { /* si esta definida la función showPosition */
                errStr = ;SPMquot;Parse error on line ;SPMquot; + (yylineno + 1) + 
                         ;SPMquot;:\n;SPMquot; + this.lexer.showPosition() + 
                         ;SPMquot;\nExpecting ;SPMquot; + expected.join(;SPMquot;, ;SPMquot;) + 
                         ;SPMquot;, got ';SPMquot; + 
                         (this.terminals_[symbol] || symbol) + /* terminals_ es el array inverso */
                         ;SPMquot;';SPMquot;;                                  /* numero -;SPMgt; terminal             */
            } else { /* ¡monta la cadena como puedas! */
                errStr = ;SPMquot;Parse error on line ;SPMquot; + (yylineno + 1) + 
                         ;SPMquot;: Unexpected ;SPMquot; + 
                         (symbol == 1 ? ;SPMquot;end of input;SPMquot; : ;SPMquot;';SPMquot; + 
                         (this.terminals_[symbol] || symbol) + ;SPMquot;';SPMquot;);
            }
            this.parseError(errStr, {    /* genera la excepción */
                text: this.lexer.match,  /* hash/objeto conteniendo los detalles del */
                token: this.terminals_[symbol] || symbol,                   /* error */
                line: this.lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
    }
    if (action[0] instanceof Array ;SPMamp;;SPMamp; action.length ;SPMgt; 1) {
        throw new Error(;SPMquot;Parse Error: multiple actions possible at state: ;SPMquot; + state + ;SPMquot;, token: ;SPMquot; + symbol);
    }
    ...
}
<tex2html_mydb_mark>#5777#
        parseError: function parseError(str, hash) {
            throw new Error(str); /* El hash contiene info sobre el error: token, linea, etc. */
        },
<tex2html_mydb_mark>#5778#
/* generated by jison-lex 0.1.0 */
var lexer = (function() {
    var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) { /* manejo de errores léxicos */ },
        setInput: function(input) { /* inicializar la entrada para el analizadorléxico */},
        input: function() { /* ... */ },
        unput: function(ch) { /* devolver al flujo de entrada */ },
        more: function() { /* ... */ },
        less: function(n) { /* ... */ },
        pastInput: function() { /* ... */ },
        upcomingInput: function() { /* ... */ },
        showPosition: function() { /* ... */ },
        next: function() {
                if (this.done) { return this.EOF; }
                if (!this._input) this.done = true;

                var token, match, tempMatch, index, col, lines;
                if (!this._more) { this.yytext = ''; this.match = ''; }
                var rules = this._currentRules();
                for (var i = 0; i ;SPMlt; rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch ;SPMamp;;SPMamp; (!match || tempMatch[0].length ;SPMgt; match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: 
                          lines ? lines[lines.length - 1].length - 
                                  lines[lines.length - 1].match(/\r?\n?/)[0].length 
                                  : 
                                  this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(
                                 this, 
                                 this.yy, 
                                 this, 
                                 rules[index], 
                                 this.conditionStack[this.conditionStack.length - 1]
                            );
                    if (this.done ;SPMamp;;SPMamp; this._input) this.done = false;
                    if (token) return token;
                    else return;
                }
                if (this._input === ;SPMquot;;SPMquot;) { return this.EOF; } 
                else {
                    return this.parseError(
                             'Lexical error on line ' + (this.yylineno + 1) + 
                              '. Unrecognized text.\n' + this.showPosition(), 
                              { text: ;SPMquot;;SPMquot;, token: null, line: this.yylineno }
                           );
                }
            },
        lex: function lex() {
            var r = this.next();
            if (typeof r !== 'undefined') {
                return r;
            } else {
                return this.lex();
            }
        },
        begin: function begin(condition) { },
        popState: function popState() { },
        _currentRules: function _currentRules() { },
        topState: function() { },
        pushState: function begin(condition) { },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START)
        {
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
                case 0:
                    return yy_.yytext;
                    break;
            }
        },
        rules: [/^(?:.)/], /* lista de expresiones regulares */
        conditions: { /* ... */ }
  }
};
<tex2html_mydb_mark>#5779#
if (typeof require !== 'undefined' ;SPMamp;;SPMamp; typeof exports !== 'undefined') {
    exports.parser = aSb;         /* hacemos accesible el objeto aSb  */
    exports.Parser = aSb.Parser;
<tex2html_mydb_mark>#5780#
      function Parser() {
          this.yy = {}; 
      }   
      Parser.prototype = parser;
      parser.Parser = Parser;
      return new Parser;
  })();
<tex2html_mydb_mark>#5781#
    exports.parse = function() {
        return aSb.parse.apply(aSb, arguments);
    };
<tex2html_mydb_mark>#5782#
    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log('Usage: ' + args[0] + ' FILE');
            process.exit(1);
        }
        var source = require('fs').readFileSync(require('path').normalize(args[1]), ;SPMquot;utf8;SPMquot;);
        return exports.parser.parse(source);
    };
    if (typeof module !== 'undefined' ;SPMamp;;SPMamp; require.main === module) {
        exports.main(process.argv.slice(1));
    }
}
<tex2html_mydb_mark>#5783#
[~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ node aSb.js input.ab 
empty
S -;SPMgt; aSb
S -;SPMgt; aSb
[~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ cat input.ab 
aabb
<tex2html_mydb_mark>#5784#
~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ node debug aSb.js input.ab 
;SPMlt; debugger listening on port 5858
connecting... ok
break in aSb.js:2
  1 /* parser generated by jison 0.4.2 */
  2 var aSb = (function() {
  3     var parser = {
  4         trace: function trace() {},
debug;SPMgt; n
break in aSb.js:390
 388     return new Parser;
 389 })();
 390 if (typeof require !== 'undefined' ;SPMamp;;SPMamp; typeof exports !== 'undefined') {
 391     exports.parser = aSb;
 392     exports.Parser = aSb.Parser;
<tex2html_mydb_mark>#5785#
debug;SPMgt; repl
Press Ctrl + C to leave debug repl
;SPMgt; 
;SPMgt; typeof require
'function'
;SPMgt; typeof exports
'object'
;SPMgt; aSb
{ yy: {} }
;SPMgt; aSb.Parser
[Function]
^C
debug;SPMgt; sb(396)
 395     };
debug;SPMgt; c
break in aSb.js:396
 394         return aSb.parse.apply(aSb, arguments);
 395     };
*396     exports.main = function commonjsMain(args) {
 397         if (!args[1]) {
 398             console.log('Usage: ' + args[0] + ' FILE');
debug;SPMgt; n
break in aSb.js:404
 402         return exports.parser.parse(source);
 403     };
 404     if (typeof module !== 'undefined' ;SPMamp;;SPMamp; require.main === module) {
 405         exports.main(process.argv.slice(1));
 406     }
debug;SPMgt; repl
Press Ctrl + C to leave debug repl
;SPMgt; process.argv.slice(1)
[ '/Users/casiano/Dropbox/src/javascript/PLgrado/jison-aSb/aSb.js',
  'input.ab' ]
;SPMgt; typeof module
'object'
;SPMgt; require.main
{ id: '.',
  exports: 
   { parser: { yy: {} },
     Parser: [Function],
     parse: [Function],
     main: [Function] },
  parent: null,
  filename: '/Users/casiano/Dropbox/src/javascript/PLgrado/jison-aSb/aSb.js',
  loaded: false,
  children: [],
  paths: 
   [ '/Users/casiano/Dropbox/src/javascript/PLgrado/jison-aSb/node_modules',
     '/Users/casiano/Dropbox/src/javascript/PLgrado/node_modules',
     '/Users/casiano/Dropbox/src/javascript/node_modules',
     '/Users/casiano/Dropbox/src/node_modules',
     '/Users/casiano/Dropbox/node_modules',
     '/Users/casiano/node_modules',
     '/Users/node_modules',
     '/node_modules' ] }
^C
debug;SPMgt; n
break in aSb.js:405
 403     };
 404     if (typeof module !== 'undefined' ;SPMamp;;SPMamp; require.main === module) {
 405         exports.main(process.argv.slice(1));
 406     }
 407 }
debug;SPMgt; n
;SPMlt; empty
;SPMlt; S -;SPMgt; aSb
;SPMlt; S -;SPMgt; aSb
break in aSb.js:409
 407 }
 408 
 409 });
debug;SPMgt; c
program terminated
debug;SPMgt;
<tex2html_mydb_mark>#5786#
$ cat -n Precedencia.yp
     1  %token NUMBER
     2  %left '@'
     3  %right ';SPMamp;'  dummy
     4  %%
     5  list
     6      :
     7      | list '\n'
     8      | list e
     9      ;
    10
    11  e : NUMBER
    12    | e ';SPMamp;' e
    13    | e '@' e %prec dummy
    14    ;
    15
    16  %%

<tex2html_mydb_mark>#5787#
$ cat -n useprecedencia.pl
cat -n useprecedencia.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Precedencia;
     4
     5  sub Error {
     6    exists $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
     7    and do {
     8      print $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
     9      delete $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
    10      return;
    11    };
    12    print ;SPMquot;Syntax error.\n;SPMquot;;
    13  }
    14
    15  sub Lexer {
    16    my($parser)=shift;
    17
    18    defined($parser-;SPMgt;YYData-;SPMgt;{INPUT})
    19    or  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;STDIN;SPMgt;
    20    or  return('',undef);
    21
    22    $parser-;SPMgt;YYData-;SPMgt;{INPUT}=~s/^[ \t]//;
    23
    24    for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {
    25        s/^([0-9]+(?:\.[0-9]+)?)//
    26                and return('NUMBER',$1);
    27        s/^(.)//s
    28                and return($1,$1);
    29    }
    30  }
    31
    32  my $debug_level = (@ARGV)? oct(shift @ARGV): 0x1F;
    33  my $parser = Precedencia-;SPMgt;new();
    34  $parser-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;Lexer, yyerror =;SPMgt; \;SPMamp;Error, yydebug =;SPMgt; $debug_level );
<tex2html_mydb_mark>#5788#
yapp -v -m Precedencia Precedencia.yp
$ ls -ltr |tail -2
-rw-r--r--  1 lhp lhp   1628 2004-12-07 13:21 Precedencia.pm
-rw-r--r--  1 lhp lhp   1785 2004-12-07 13:21 Precedencia.output
<tex2html_mydb_mark>#5789#
$ cat -n Precedencia.output
     1  Conflicts:
     2  ----------
     3  Conflict in state 8 between rule 6 and token '@' resolved as reduce.
     4  Conflict in state 8 between rule 6 and token ';SPMamp;' resolved as shift.
     5  Conflict in state 9 between rule 5 and token '@' resolved as reduce.
     6  Conflict in state 9 between rule 5 and token ';SPMamp;' resolved as shift.
     7
     8  Rules:
     9  ------
    10  0:      $start -;SPMgt; list $end
    11  1:      list -;SPMgt; /* empty */
    12  2:      list -;SPMgt; list '\n'
    13  3:      list -;SPMgt; list e
    14  4:      e -;SPMgt; NUMBER
    15  5:      e -;SPMgt; e ';SPMamp;' e
    16  6:      e -;SPMgt; e '@' e
    17  ...
<tex2html_mydb_mark>#5790#
85  State 8:
86
87          e -;SPMgt; e . ';SPMamp;' e  (Rule 5)
88          e -;SPMgt; e . '@' e  (Rule 6)
89          e -;SPMgt; e '@' e .  (Rule 6)
90
91          ';SPMamp;'     shift, and go to state 7
92
93          $default        reduce using rule 6 (e)
<tex2html_mydb_mark>#5791#
    13    | e '@' e %prec dummy

<tex2html_mydb_mark>#5792#
     2  %left '@'
     3  %right ';SPMamp;'  dummy

<tex2html_mydb_mark>#5793#
State 9:

	e -;SPMgt; e . ';SPMamp;' e	(Rule 5)
	e -;SPMgt; e ';SPMamp;' e .	(Rule 5)
	e -;SPMgt; e . '@' e	(Rule 6)
	';SPMamp;'	shift, and go to state 7
	$default	reduce using rule 5 (e)
<tex2html_mydb_mark>#5794#
$ ./useprecedencia.pl
----------------------------------------
In state 0:
Stack:[0]
Don't need token.
Reduce using rule 1 (list,0): Back to state 0, then go to state 1.
<tex2html_mydb_mark>#5795#
20 State 0:
21
22   $start -;SPMgt; . list $end (Rule 0)
23
24   $default  reduce using rule 1 (list)
25
26   list  go to state 1
<tex2html_mydb_mark>#5796#
----------------------------------------
In state 1:
Stack:[0,1]
2@3@4
Need token. Got ;SPMgt;NUMBER;SPMlt;
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 1, then go to state 2.
----------------------------------------
<tex2html_mydb_mark>#5797#
In state 2:
Stack:[0,1,2]
Need token. Got ;SPMgt;@;SPMlt;
Shift and go to state 6.
----------------------------------------
In state 6:
Stack:[0,1,2,6]
Need token. Got ;SPMgt;NUMBER;SPMlt;
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,2,6,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 6, then go to state 8.
----------------------------------------
In state 8:
Stack:[0,1,2,6,8]
Need token. Got ;SPMgt;@;SPMlt;
Reduce using rule 6 (e,3): Back to state 1, then go to state 2.
----------------------------------------
...
Accept.
<tex2html_mydb_mark>#5798#
%{
our contador = 0;
%}

%token NUM
...
%%

<tex2html_mydb_mark>#5799#%right  '='

<tex2html_mydb_mark>#5800#%left   '-' '+'

<tex2html_mydb_mark>#5801#%left   '*' '/'

<tex2html_mydb_mark>#5802#%left   NEG

<tex2html_mydb_mark>#5803#%right  '^'

<tex2html_mydb_mark>#5804#%

<tex2html_mydb_mark>#5805#%%| en una línea aparte. Así, el \verb|%%| de la línea 15

<tex2html_mydb_mark>#5806#%prec| la cual le da una prioridad explícita.  

<tex2html_mydb_mark>#5807#%prec NEG   { -$_[2] }

<tex2html_mydb_mark>#5808#%prec NEG| de la línea

<tex2html_mydb_mark>#5809#%%|, sigue la parte en la que se 

<tex2html_mydb_mark>#5810#%

<tex2html_mydb_mark>#5811#%\begin{makeimage}

<tex2html_mydb_mark>#5812#%\begin{VCPicture}{(0, 0)(6,6)}

<tex2html_mydb_mark>#5813#%% states

<tex2html_mydb_mark>#5814#%\StateVar[S' \rightarrow _\uparrow S]{(2,0)}{0} 

<tex2html_mydb_mark>#5815#%\StateVar[S' \rightarrow S_\uparrow]{(3,4)}{1} 

<tex2html_mydb_mark>#5816#%\StateVar[S \rightarrow _\uparrow a S b ]{(8,4)}{2}

<tex2html_mydb_mark>#5817#%\StateVar[S \rightarrow _\uparrow ]{(6,0)}{3}

<tex2html_mydb_mark>#5818#%\StateVar[S \rightarrow a _\uparrow S b]{(6,2)}{4}

<tex2html_mydb_mark>#5819#%\StateVar[S \rightarrow a S _\uparrow b]{(11,1)}{5}

<tex2html_mydb_mark>#5820#%\StateVar[S \rightarrow a S b _\uparrow]{(13,3)}{6}

<tex2html_mydb_mark>#5821#%% initial--final

<tex2html_mydb_mark>#5822#%\Initial{0} %\Final{2}

<tex2html_mydb_mark>#5823#%% transitions 

<tex2html_mydb_mark>#5824#%\EdgeL{0}{1}{S} 

<tex2html_mydb_mark>#5825#%\ArcL{0}{2}{\epsilon} 

<tex2html_mydb_mark>#5826#%\ArcL{0}{3}{\epsilon} 

<tex2html_mydb_mark>#5827#%\ArcL{2}{4}{a} 

<tex2html_mydb_mark>#5828#%\ArcL{4}{2}{\epsilon} 

<tex2html_mydb_mark>#5829#%\ArcL{4}{3}{\epsilon} 

<tex2html_mydb_mark>#5830#%\ArcL{4}{5}{S} 

<tex2html_mydb_mark>#5831#%\ArcL{5}{6}{b} 

<tex2html_mydb_mark>#5832#%%\LoopN{0}{a} \LoopS{C}{d}

<tex2html_mydb_mark>#5833#%%

<tex2html_mydb_mark>#5834#%\end{VCPicture}

<tex2html_mydb_mark>#5835#%\centerline{\epsfig{file=figures/nfa.eps, width=17cm}}

<tex2html_mydb_mark>#5836#%\end{makeimage}

<tex2html_mydb_mark>#5837#%\centerline{\epsfig{file=figures/dfa.eps, width=12cm}}

<tex2html_mydb_mark>#5838#%
     
<tex2html_mydb_mark>#5839#%
     
<tex2html_mydb_mark>#5840#% (véase la figura \ref{fig:lrparser}). 

<tex2html_mydb_mark>#5841#%\begin{figure}

<tex2html_mydb_mark>#5842#%\input{parser_fig.tex}

<tex2html_mydb_mark>#5843#%\caption{Estructura de un Análizador LR}

<tex2html_mydb_mark>#5844#%\label{fig:lrparser}       

<tex2html_mydb_mark>#5845#%\end{figure}

<tex2html_mydb_mark>#5846#%token NUMBER
     
<tex2html_mydb_mark>#5847#%left '@'
     
<tex2html_mydb_mark>#5848#%right ';SPMamp;'  dummy
     
<tex2html_mydb_mark>#5849#%
     
<tex2html_mydb_mark>#5850#%prec dummy
    
<tex2html_mydb_mark>#5851#%

<tex2html_mydb_mark>#5852#%prec dummy

<tex2html_mydb_mark>#5853#%left '@'
     
<tex2html_mydb_mark>#5854#%right ';SPMamp;'  dummy

<tex2html_mydb_mark>#5855#%left '*'

<tex2html_mydb_mark>#5856#%%

<tex2html_mydb_mark>#5857#%%

<tex2html_mydb_mark>#5858#%{
 
<tex2html_mydb_mark>#5859#%}
 
<tex2html_mydb_mark>#5860#%right  '='
 
<tex2html_mydb_mark>#5861#%left   '-' '+'

<tex2html_mydb_mark>#5862#%left   '*' '/'

<tex2html_mydb_mark>#5863#%left   NEG

<tex2html_mydb_mark>#5864#%

<tex2html_mydb_mark>#5865#%prec NEG   { bless [$_[2]], 'NEG' }

<tex2html_mydb_mark>#5866#%

<tex2html_mydb_mark>#5867#%token FLOAT INTEGER
 
<tex2html_mydb_mark>#5868#%token GLOBAL
 
<tex2html_mydb_mark>#5869#%token LOCAL
 
<tex2html_mydb_mark>#5870#%token NAME
 
<tex2html_mydb_mark>#5871#%
 
<tex2html_mydb_mark>#5872#%s de clase %s, tipo %s\n;SPMquot;,

<tex2html_mydb_mark>#5873#%s de clase %s, tipo %s\n;SPMquot;,

<tex2html_mydb_mark>#5874#%

<tex2html_mydb_mark>#5875#%token FLOAT INTEGER 

<tex2html_mydb_mark>#5876#%token GLOBAL 

<tex2html_mydb_mark>#5877#%token LOCAL 

<tex2html_mydb_mark>#5878#%token NAME

<tex2html_mydb_mark>#5879#%%

<tex2html_mydb_mark>#5880#%%

<tex2html_mydb_mark>#5881#%
     
<tex2html_mydb_mark>#5882#%

<tex2html_mydb_mark>#5883#%right  '='

<tex2html_mydb_mark>#5884#%left   '-' '+'

<tex2html_mydb_mark>#5885#%left   '*' '/'

<tex2html_mydb_mark>#5886#%left   NEG

<tex2html_mydb_mark>#5887#%right  '^'

<tex2html_mydb_mark>#5888#%

<tex2html_mydb_mark>#5889#%prec NEG   { -$_[2] }

<tex2html_mydb_mark>#5890#%token NUMBER

<tex2html_mydb_mark>#5891#%%

<tex2html_mydb_mark>#5892#%%    

<tex2html_mydb_mark>#5893#%2.1lf\n;SPMquot;,$x); }

<tex2html_mydb_mark>#5894#%d\n;SPMquot;,$code); }
 
<tex2html_mydb_mark>#5895#%token|. De esta manera

<tex2html_mydb_mark>#5896#%{| y \verb|%}|. Estos delimitadores

<tex2html_mydb_mark>#5897#%{

<tex2html_mydb_mark>#5898#%}

<tex2html_mydb_mark>#5899#%token NUM

<tex2html_mydb_mark>#5900#%%

<tex2html_mydb_mark>#5901#%{
 
<tex2html_mydb_mark>#5902#%}
 
<tex2html_mydb_mark>#5903#%left   '-' '+'
 
<tex2html_mydb_mark>#5904#%left   '*' '/'

<tex2html_mydb_mark>#5905#%left   NEG

<tex2html_mydb_mark>#5906#%

<tex2html_mydb_mark>#5907#%token declarator basictype functionheader functionbody

<tex2html_mydb_mark>#5908#%

<tex2html_mydb_mark>#5909#%

<tex2html_mydb_mark>#5910#%| 

<tex2html_mydb_mark>#5911#%

<tex2html_mydb_mark>#5912#%

<tex2html_mydb_mark>#5913#%token| como en el código que aparece encima. De esta manera

<tex2html_mydb_mark>#5914#%Recicle

<tex2html_mydb_mark>#5915#%y extienda de manera apropiada el código que 

<tex2html_mydb_mark>#5916#%ha escrito para la versión previa de Tutu en las restantes fases: análisis léxico,

<tex2html_mydb_mark>#5917#%semántico, optimización de código, cálculo de direcciones, generación de código

<tex2html_mydb_mark>#5918#%y optimización peephole. Extienda el plegado de constantes 

<tex2html_mydb_mark>#5919#%y las transformaciones algebraicas a las operaciones

<tex2html_mydb_mark>#5920#%lógicas y de comparación.

<tex2html_mydb_mark>#5921#%Genere código para la máquina basada en registros.

<tex2html_mydb_mark>#5922#%Para ello, extienda el juego de instrucciones de manera apropiada.

<tex2html_mydb_mark>#5923#%Modifique y amplíe los programas de prueba para comprobar que los

<tex2html_mydb_mark>#5924#%cambios introducidos funcionan correctamente.

<tex2html_mydb_mark>#5925#%%| en una

<tex2html_mydb_mark>#5926#%%' 

<tex2html_mydb_mark>#5927#%%' 

<tex2html_mydb_mark>#5928#%start| indicando cual es el símbolo de arranque de la gramática.

<tex2html_mydb_mark>#5929#%(left|right|nonassoc)/gc
        
<tex2html_mydb_mark>#5930#%(start)/gc
        
<tex2html_mydb_mark>#5931#%(expect)/gc
        
<tex2html_mydb_mark>#5932#%{/gc
    
<tex2html_mydb_mark>#5933#%expect| en el fuente,

<tex2html_mydb_mark>#5934#%union| y a las especificaciones de 

<tex2html_mydb_mark>#5935#%type| no son usadas por \verb|yapp|. Estas declaraciones son

<tex2html_mydb_mark>#5936#%union|

<tex2html_mydb_mark>#5937#%{
 
<tex2html_mydb_mark>#5938#%}
 
<tex2html_mydb_mark>#5939#%union {
 
<tex2html_mydb_mark>#5940#%token ;SPMlt;n;SPMgt; FLOAT INTEGER 

<tex2html_mydb_mark>#5941#%token ;SPMlt;n;SPMgt; GLOBAL 

<tex2html_mydb_mark>#5942#%token ;SPMlt;n;SPMgt; LOCAL 

<tex2html_mydb_mark>#5943#%token ;SPMlt;s;SPMgt; NAME

<tex2html_mydb_mark>#5944#%type ;SPMlt;n;SPMgt; class type

<tex2html_mydb_mark>#5945#%

<tex2html_mydb_mark>#5946#%union| de la línea 8 indica que los atributos

<tex2html_mydb_mark>#5947#%s de clase %s, tipo %s\n;SPMquot;,$1,CLASE($;SPMlt;n;SPMgt;-1),TIPO($;SPMlt;n;SPMgt;0)); }

<tex2html_mydb_mark>#5948#%s de clase %s, tipo %s\n;SPMquot;,$3,CLASE($;SPMlt;n;SPMgt;-1),TIPO($;SPMlt;n;SPMgt;0)); }

<tex2html_mydb_mark>#5949#%

<tex2html_mydb_mark>#5950#%
 
<tex2html_mydb_mark>#5951#%s\n;SPMquot;,s);

<tex2html_mydb_mark>#5952#%%|. Veamos como ejemplo de manejo de

<tex2html_mydb_mark>#5953#%{
 
<tex2html_mydb_mark>#5954#%}
 
<tex2html_mydb_mark>#5955#%
 
<tex2html_mydb_mark>#5956#%

<tex2html_mydb_mark>#5957#%union|) y la enumeración de los terminales.

<tex2html_mydb_mark>#5958#%s;SPMquot;,yytext); }@

<tex2html_mydb_mark>#5959#%\centerline{\epsfig{file=figures/yapp_inheritance.eps, height=7cm}}

<tex2html_mydb_mark>#5960#%Repase los fuentes de Yapp. Puede obtenerlos en

<tex2html_mydb_mark>#5961#%

<tex2html_mydb_mark>#5962#%\begin{latexonly}

<tex2html_mydb_mark>#5963#%\begin{verbatim}

<tex2html_mydb_mark>#5964#%http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm

<tex2html_mydb_mark>#5965#%\end{verbatim}

<tex2html_mydb_mark>#5966#%\end{latexonly}

<tex2html_mydb_mark>#5967#%

<tex2html_mydb_mark>#5968#%\begin{rawhtml}

<tex2html_mydb_mark>#5969#%;SPMlt;a href=;SPMquot;http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm;SPMquot;;SPMgt;http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm;SPMlt;/a;SPMgt; 

<tex2html_mydb_mark>#5970#%\end{rawhtml}

<tex2html_mydb_mark>#5971#%

<tex2html_mydb_mark>#5972#%o bien en nuestros servidores locales, por ejemplo en 

<tex2html_mydb_mark>#5973#%el mismo directorio en que se guarda la

<tex2html_mydb_mark>#5974#%versión HTML de estos apuntes encontrará una copia de 

<tex2html_mydb_mark>#5975#%right '+'
 
<tex2html_mydb_mark>#5976#%left 'a'
 
<tex2html_mydb_mark>#5977#%nonassoc 'b'
 
<tex2html_mydb_mark>#5978#%
 
<tex2html_mydb_mark>#5979#%prec 'a'                    { print ;SPMquot;S -;SPMgt; + S + prec a\n;SPMquot; }
 
<tex2html_mydb_mark>#5980#%

<tex2html_mydb_mark>#5981#%prec
  
<tex2html_mydb_mark>#5982#%{

<tex2html_mydb_mark>#5983#%}

<tex2html_mydb_mark>#5984#%Responda a las siguientes preguntas:

<tex2html_mydb_mark>#5985#%

<tex2html_mydb_mark>#5986#%\begin{itemize}

<tex2html_mydb_mark>#5987#%\item

<tex2html_mydb_mark>#5988#%¿Que se guarda en \verb|SYMS|?

<tex2html_mydb_mark>#5989#%\item

<tex2html_mydb_mark>#5990#%En este ejemplo los valores del hash \verb|TERM| esta indefinidos. En general

<tex2html_mydb_mark>#5991#%contienen un array anónimo con información sobre el terminal. ¿Que información

<tex2html_mydb_mark>#5992#%exactamente? 

<tex2html_mydb_mark>#5993#%\item

<tex2html_mydb_mark>#5994#%¿Que contiene el hash \verb|PREC|? ¿tiene algo que ver con la directiva

<tex2html_mydb_mark>#5995#%\verb|%prec|?

<tex2html_mydb_mark>#5996#%\item

<tex2html_mydb_mark>#5997#%¿Cuál es el significado del 5 en la tercera componente de \verb|TAIL|?

<tex2html_mydb_mark>#5998#%¿Qué contiene el array anónimo de clave \verb|HEAD|?

<tex2html_mydb_mark>#5999#%\item

<tex2html_mydb_mark>#6000#%¿Cómo es la estructura de la lista representando una regla? ¿Qué

<tex2html_mydb_mark>#6001#%significan los diferentes elementos de la lista?

<tex2html_mydb_mark>#6002#%\item

<tex2html_mydb_mark>#6003#%¿Cuál es el significado del hash con clave \verb|NULL|? ¿En que forma es

<tex2html_mydb_mark>#6004#%usado durante el análisis para controlar posibles errores?

<tex2html_mydb_mark>#6005#%\item

<tex2html_mydb_mark>#6006#%¿Cómo se denotan las variables sintácticas asociadas con acciones

<tex2html_mydb_mark>#6007#%intermedias? ¿Sabría señalar el lugar en  \verb|YappParse.yp|

<tex2html_mydb_mark>#6008#%en que se trata con esta situación?

<tex2html_mydb_mark>#6009#%\item

<tex2html_mydb_mark>#6010#%¿Cuál es el significado de la clave \verb|EXPECT|?

<tex2html_mydb_mark>#6011#%\item

<tex2html_mydb_mark>#6012#%¿Qué referencian los índices en el array anónimo

<tex2html_mydb_mark>#6013#%asociado con clave \verb|S| en \verb|NTERM|?

<tex2html_mydb_mark>#6014#%\item

<tex2html_mydb_mark>#6015#%¿Que limitaciones observa en  \verb|YappParse.yp|?

<tex2html_mydb_mark>#6016#%\end{itemize}

<tex2html_mydb_mark>#6017#%autoaction CODE| la

<tex2html_mydb_mark>#6018#%, \verb|{ $_[1] }|,

<tex2html_mydb_mark>#6019#%{

<tex2html_mydb_mark>#6020#%tree_name = ('=' =;SPMgt; 'eq', '+' =;SPMgt; 'plus', '-' =;SPMgt; 'minus', 
                 
<tex2html_mydb_mark>#6021#%}

<tex2html_mydb_mark>#6022#%right  '='

<tex2html_mydb_mark>#6023#%left   '-' '+'

<tex2html_mydb_mark>#6024#%left   '*' '/'

<tex2html_mydb_mark>#6025#%left   NEG

<tex2html_mydb_mark>#6026#%autoaction { [$tree_name{$_[2]}, $_[1], $_[3]] }

<tex2html_mydb_mark>#6027#%%

<tex2html_mydb_mark>#6028#%prec NEG   { ['neg', $_[2]] }
        
<tex2html_mydb_mark>#6029#%%

<tex2html_mydb_mark>#6030#%right  '='

<tex2html_mydb_mark>#6031#%left   '-' '+'

<tex2html_mydb_mark>#6032#%left   '*' '/'

<tex2html_mydb_mark>#6033#%left   NEG

<tex2html_mydb_mark>#6034#%autoaction { my $n = $#_;  bless [@_[1..$n]], $_[0]-;SPMgt;YYLhs }

<tex2html_mydb_mark>#6035#%%

<tex2html_mydb_mark>#6036#%prec NEG 
        
<tex2html_mydb_mark>#6037#%%

<tex2html_mydb_mark>#6038#%autotree| que de lugar a la construcción del árbol de análisis

<tex2html_mydb_mark>#6039#%\vspace{0.5cm}

<tex2html_mydb_mark>#6040#%\begin{tabular}{lll}

<tex2html_mydb_mark>#6041#%program      ;SPMamp;$\rightarrow$;SPMamp; definitions \{ definitions \}\\ 

<tex2html_mydb_mark>#6042#%definitions  ;SPMamp;$\rightarrow$;SPMamp; datadefinition $|$ functiondefinition\\ 

<tex2html_mydb_mark>#6043#%datadefinition   ;SPMamp;$\rightarrow$;SPMamp; basictype declarator \{ ',' declarator \} ';'\\ 

<tex2html_mydb_mark>#6044#%declarator  ;SPMamp;$\rightarrow$;SPMamp; ID \{ '$[$' constantexp '$]$' \}\\ 

<tex2html_mydb_mark>#6045#%functiondefinition ;SPMamp;$\rightarrow$;SPMamp; $[$ basictype $]$ functionheader functionbody\\ 

<tex2html_mydb_mark>#6046#%basictype    ;SPMamp;$\rightarrow$;SPMamp; INT  $|$ CHAR\\ 

<tex2html_mydb_mark>#6047#%functionheader ;SPMamp;$\rightarrow$;SPMamp; ID '(' $[$ parameters $]$ ')'\\ 

<tex2html_mydb_mark>#6048#%parameters ;SPMamp;$\rightarrow$;SPMamp; basictype declarator \{ ',' basictype declarator \} \\ 

<tex2html_mydb_mark>#6049#%functionbody ;SPMamp;$\rightarrow$;SPMamp; '\{' \{ datadefinition \} \{ statement \} '\}'\\ 

<tex2html_mydb_mark>#6050#%statement ;SPMamp;$\rightarrow$;SPMamp; $[$ exp $]$ ';'\\ 

<tex2html_mydb_mark>#6051#%          ;SPMamp;;SPMamp;$|$ '\{' \{ datadefinition \} \{ statement \} '\}'\\ 

<tex2html_mydb_mark>#6052#%          ;SPMamp;;SPMamp;$|$  IF '(' exp ')' statement $[$ ELSE statement $]$\\ 

<tex2html_mydb_mark>#6053#%          ;SPMamp;;SPMamp;$|$  WHILE '(' exp ')' statement\\ 

<tex2html_mydb_mark>#6054#%          ;SPMamp;;SPMamp;$|$  RETURN $[$ exp $]$ ';'\\ 

<tex2html_mydb_mark>#6055#%constantexp  ;SPMamp;$\rightarrow$;SPMamp; exp \\ 

<tex2html_mydb_mark>#6056#%exp       ;SPMamp;$\rightarrow$;SPMamp; lvalue '=' exp $|$ lvalue '+=' exp \\ 

<tex2html_mydb_mark>#6057#%          ;SPMamp;;SPMamp;$|$ exp '\&\&' exp $|$ exp '$||$' exp  $|$\\ 

<tex2html_mydb_mark>#6058#%          ;SPMamp;;SPMamp;$|$ exp '==' exp $|$ exp '!=' exp  $|$\\ 

<tex2html_mydb_mark>#6059#%          ;SPMamp;;SPMamp;$|$ exp '$;SPMlt;$' exp $|$ exp '$;SPMgt;$' exp  $|$ exp '$;SPMlt;=$' exp $|$ exp '$;SPMgt;=$' exp  $|$\\ 

<tex2html_mydb_mark>#6060#%          ;SPMamp;;SPMamp;$|$ exp '+' exp $|$ exp '-' exp  $|$\\ 

<tex2html_mydb_mark>#6061#%          ;SPMamp;;SPMamp;$|$ exp '*' exp $|$ exp '/' exp $|$\\ 

<tex2html_mydb_mark>#6062#%          ;SPMamp;;SPMamp;$|$ unary\\ 

<tex2html_mydb_mark>#6063#%unary     ;SPMamp;$\rightarrow$;SPMamp; '$++$' lvalue  $|$ '$--$' lvalue $|$ primary\\ 

<tex2html_mydb_mark>#6064#%primary   ;SPMamp;$\rightarrow$;SPMamp; '(' exp ')' $|$ ID '(' $[$ argumentlist $]$ ')' $|$ lvalue\\ 

<tex2html_mydb_mark>#6065#%          ;SPMamp;             ;SPMamp; $|$ NUM $|$ CHARACTER $|$ STRING\\ 

<tex2html_mydb_mark>#6066#%lvalue   ;SPMamp;$\rightarrow$;SPMamp; ID  \{ '$[$' exp '$]$' \}\\ 

<tex2html_mydb_mark>#6067#%argumentlist ;SPMamp;$\rightarrow$;SPMamp; exp \{ ',' exp \}

<tex2html_mydb_mark>#6068#%\end{tabular}

<tex2html_mydb_mark>#6069#%\vspace{0.25cm}

<tex2html_mydb_mark>#6070#%

<tex2html_mydb_mark>#6071#%La descripción utiliza una notación tipo BNF: las llaves indican 

<tex2html_mydb_mark>#6072#%0 o mas repeticiones y los corchetes opcionalidad.

<tex2html_mydb_mark>#6073#%prec '+'
  
<tex2html_mydb_mark>#6074#%' binary
  
<tex2html_mydb_mark>#6075#%=' binary
  
<tex2html_mydb_mark>#6076#%| 

<tex2html_mydb_mark>#6077#%

<tex2html_mydb_mark>#6078#%

<tex2html_mydb_mark>#6079#%token|. De esta manera

<tex2html_mydb_mark>#6080#%left|, \verb|%right|,

<tex2html_mydb_mark>#6081#%nonassoc| y \verb|%prec|.

<tex2html_mydb_mark>#6082#%tree| y añadiendo las correspondientes acciones de \verb|bypass|.

<tex2html_mydb_mark>#6083#%name TYPEDFUNC
 
<tex2html_mydb_mark>#6084#%http://home.debitel.net/user/boesswetter/xml_yylex/XML-YYLex.html

<tex2html_mydb_mark>#6085#%{

<tex2html_mydb_mark>#6086#%}

<tex2html_mydb_mark>#6087#%token INT EOL

<tex2html_mydb_mark>#6088#%token LEFT_PAR RIGHT_PAR

<tex2html_mydb_mark>#6089#%left PLUS MINUS

<tex2html_mydb_mark>#6090#%left MULT DIV

<tex2html_mydb_mark>#6091#%%

<tex2html_mydb_mark>#6092#%%

<tex2html_mydb_mark>#6093#
<a href="http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm">http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm</a>
<tex2html_mydb_mark>#6094#
 1  #
 2  # Calc.yp
 3  # 
 4  # Parse::Yapp input grammar example.
 5  #
 6  # This file is PUBLIC DOMAIN 
 7  #
 8  #
<tex2html_mydb_mark>#6095#
 9  %right  '='
10  %left   '-' '+'
11  %left   '*' '/'
12  %left   NEG
13  %right  '^'
14  
15  %%
16  input:  #empty
17       |   input line  { push(@{$_[1]},$_[2]); $_[1] }
18  ;
<tex2html_mydb_mark>#6096#
19  
20  line:  '\n'       { 0 }
21      |  exp '\n'   { print ;SPMquot;$_[1]\n;SPMquot;; $_[1] }
22      |  error '\n' { $_[0]-;SPMgt;YYErrok; 0 }
23  ;
<tex2html_mydb_mark>#6097#
24  
25  exp:        NUM
<tex2html_mydb_mark>#6098#
26          |   VAR           { $_[0]-;SPMgt;YYData-;SPMgt;{VARS}{$_[1]} }
<tex2html_mydb_mark>#6099#
27          |   VAR '=' exp   { $_[0]-;SPMgt;YYData-;SPMgt;{VARS}{$_[1]}=$_[3] }
28          |   exp '+' exp   { $_[1] + $_[3] }
29          |   exp '-' exp   { $_[1] - $_[3] }
30          |   exp '*' exp   { $_[1] * $_[3] }
<tex2html_mydb_mark>#6100#
31          |   exp '/' exp   {
32                              $_[3]
33                              and return($_[1] / $_[3]);
34                              $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
35                                =   ;SPMquot;Illegal division by zero.\n;SPMquot;;
36                              $_[0]-;SPMgt;YYError;
37                              undef
38                            }
<tex2html_mydb_mark>#6101#
my $result = $self-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;_Lexer, 
                             yyerror =;SPMgt; \;SPMamp;_Error,
                             yydebug =;SPMgt; 0x0 );
<tex2html_mydb_mark>#6102#
39          |   '-' exp %prec NEG   { -$_[2] }

<tex2html_mydb_mark>#6103#
40          |   exp '^' exp         { $_[1] ** $_[3] }
41          |   '(' exp ')'         { $_[2] }
42  ;
<tex2html_mydb_mark>#6104#
...

sub Run {
    my($self)=shift;
    my $result = $self-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;_Lexer, 
                                 yyerror =;SPMgt; \;SPMamp;_Error,
                                 yydebug =;SPMgt; 0x0 );
    my @result = @$result;
    print ;SPMquot;@result\n;SPMquot;;
}
<tex2html_mydb_mark>#6105#
43  # rutinas de apoyo 
44  %%
45  
46  sub _Error {
47    exists $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
48      and do {
49          print $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
50          delete $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
51          return;
52      };
53    print ;SPMquot;Syntax error.\n;SPMquot;;
54  }
55
<tex2html_mydb_mark>#6106#
56  sub _Lexer {
57    my($parser)=shift;
58  
59    defined($parser-;SPMgt;YYData-;SPMgt;{INPUT})
60    or  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;STDIN;SPMgt;
61    or  return('',undef);
62
<tex2html_mydb_mark>#6107#
63    $parser-;SPMgt;YYData-;SPMgt;{INPUT}=~s/^[ \t]//;
64
<tex2html_mydb_mark>#6108#
65    for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {
66      s/^([0-9]+(?:\.[0-9]+)?)//
67        and return('NUM',$1);
68      s/^([A-Za-z][A-Za-z0-9_]*)//
69        and return('VAR',$1);
70      s/^(.)//s
71        and return($1,$1);
72    }
73  }
<tex2html_mydb_mark>#6109#
;SPMgt; cat Makefile
Calc.pm: Calc.yp
        yapp -m Calc Calc.yp
;SPMgt; make
yapp -m Calc Calc.yp
<tex2html_mydb_mark>#6110#
;SPMgt; ls -ltr
total 96
-rw-r-----    1 pl       users        1959 Oct 20  1999 Calc.yp
-rw-r-----    1 pl       users          39 Nov 16 12:26 Makefile
-rwxrwx--x    1 pl       users          78 Nov 16 12:30 usecalc.pl
-rw-rw----    1 pl       users        5254 Nov 16 12:35 Calc.pm
<tex2html_mydb_mark>#6111#
$ yapp -V
This is Parse::Yapp version 1.05.
<tex2html_mydb_mark>#6112#
$ yapp -h

Usage:  yapp [options] grammar[.yp]
  or    yapp -V
  or    yapp -h

    -m module   Give your parser module the name ;SPMlt;module;SPMgt;
                default is ;SPMlt;grammar;SPMgt;
    -v          Create a file ;SPMlt;grammar;SPMgt;.output describing your parser
    -s          Create a standalone module in which the driver is included
    -n          Disable source file line numbering embedded in your parser
    -o outfile  Create the file ;SPMlt;outfile;SPMgt; for your parser module
                Default is ;SPMlt;grammar;SPMgt;.pm or, if -m A::Module::Name is
                specified, Name.pm
    -t filename Uses the file ;SPMlt;filename;SPMgt; as a template for creating the parser
                module file.  Default is to use internal template defined
                in Parse::Yapp::Output
    -b shebang  Adds '#!;SPMlt;shebang;SPMgt;' as the very first line of the output file

    grammar     The grammar file. If no suffix is given, and the file
                does not exists, .yp is added

    -V          Display current version of Parse::Yapp and gracefully exits
    -h          Display this help screen
<tex2html_mydb_mark>#6113#
;SPMgt; cat usecalc.pl
#!/usr/local/bin/perl5.8.0 -w

use Calc;

$parser = new Calc();
$parser-;SPMgt;Run;
<tex2html_mydb_mark>#6114#
$ ./usecalc3.pl
2+3
5
4*8
32
^D
5 32
<tex2html_mydb_mark>#6115#
25  exp:        NUM { $_[1]; } # acción por defecto
<tex2html_mydb_mark>#6116#
25  exp:        NUM { $_[1]; } # acción por defecto
<tex2html_mydb_mark>#6117#
28          |   exp '+' exp   { $_[1] + $_[3] }
<tex2html_mydb_mark>#6118#
                         E(3)
                       / | \
                    (1)E + E(2)
                      /     \ 
                    NUM     NUM
<tex2html_mydb_mark>#6119#
$ cat -n aSb.yp
     1  %%
     2  S:  # empty
     3      |   'a' S 'b'  
     4  ;
     5  %%
     ......
<tex2html_mydb_mark>#6120#
$ ls -l aSb.*
-rw-r--r--  1 lhp lhp  738 2004-12-19 09:52 aSb.output
-rw-r--r--  1 lhp lhp 1841 2004-12-19 09:52 aSb.pm
-rw-r--r--  1 lhp lhp  677 2004-12-19 09:46 aSb.yp
<tex2html_mydb_mark>#6121#
                      0:	$start -;SPMgt; S $end
                      1:	S -;SPMgt; /* empty */
                      2:	S -;SPMgt; 'a' S 'b'
<tex2html_mydb_mark>#6122#
	$start -;SPMgt; . S $end	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 1
<tex2html_mydb_mark>#6123#
	$start -;SPMgt; S . $end	
	$end	shift 3
<tex2html_mydb_mark>#6124#
	S -;SPMgt; 'a' . S 'b'	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 4
<tex2html_mydb_mark>#6125#
	$start -;SPMgt; S $end .	
	$default	accept
<tex2html_mydb_mark>#6126#
	S -;SPMgt; 'a' S . 'b'	
	'b'	shift 5
<tex2html_mydb_mark>#6127#
	S -;SPMgt; 'a' S 'b' .	
	$default	reduce 2 (S)
<tex2html_mydb_mark>#6128#
 1 package Calc;
 2 use vars qw ( @ISA );
 3 use strict;
 4 @ISA= qw ( Parse::Yapp::Driver );
 5 use Parse::Yapp::Driver;
 6 
 7 sub new {
 8    my($class)=shift;
 9    ref($class) and $class=ref($class);
10 
11     my($self)=$class-;SPMgt;SUPER::new( 
12        yyversion =;SPMgt; '1.05',
13        yystates =;SPMgt; [ 
..          ...
32        ], # estados
33        yyrules  =;SPMgt; [
..       	# ... mas reglas
70        ], # final de las reglas
71        @_); # argumentos pasados
72   bless($self,$class);
73 }
<tex2html_mydb_mark>#6129#
10 
11     my($self)=$class-;SPMgt;SUPER::new( 
12        yyversion =;SPMgt; '1.05',
13        yystates =;SPMgt; [
14         {#State 0
15           DEFAULT =;SPMgt; -1, GOTOS =;SPMgt; { 'input' =;SPMgt; 1 }
16         },
17         {#State 1
18           ACTIONS =;SPMgt; {
19             'NUM' =;SPMgt; 6, '' =;SPMgt; 4, ;SPMquot;-;SPMquot; =;SPMgt; 2, ;SPMquot;(;SPMquot; =;SPMgt; 7,
20             'VAR' =;SPMgt; 8, ;SPMquot;\n;SPMquot; =;SPMgt; 5, 'error' =;SPMgt; 9
21           },
22           GOTOS =;SPMgt; { 'exp' =;SPMgt; 3, 'line' =;SPMgt; 10 }
23         },
24         # ...  mas estados
25         {#State 27
26           ACTIONS =;SPMgt; {
27             ;SPMquot;-;SPMquot; =;SPMgt; 12, ;SPMquot;+;SPMquot; =;SPMgt; 13, ;SPMquot;/;SPMquot; =;SPMgt; 15, ;SPMquot;^;SPMquot; =;SPMgt; 16,
28             ;SPMquot;*;SPMquot; =;SPMgt; 17
29           },
30           DEFAULT =;SPMgt; -8
31         }
32        ], # estados
<tex2html_mydb_mark>#6130#
33        yyrules  =;SPMgt; [
34        [#Rule 0
35              '$start', 2, undef ],
36        [#Rule 1
37              'input', 0, undef ],
38        [#Rule 2
39              'input', 2, sub
40 #line 17 ;SPMquot;Calc.yp;SPMquot;
41              { push(@{$_[1]},$_[2]); $_[1] }
42        ],
43        [#Rule 3
44              'line', 1, sub
45 #line 20 ;SPMquot;Calc.yp;SPMquot;
46              { $_[1] }
47        ],
48        [#Rule 4
49              'line', 2, sub
50 #line 21 ;SPMquot;Calc.yp;SPMquot;
51              { print ;SPMquot;$_[1]\n;SPMquot; }
52        ],
53   # ... mas reglas
54     [#Rule 11
55             'exp', 3, sub
56 #line 30 ;SPMquot;Calc.yp;SPMquot;
57 { $_[1] * $_[3] }
58    ],
59   [#Rule 12
60             'exp', 3, sub
61 #line 31 ;SPMquot;Calc.yp;SPMquot;
62   {
63     $_[3] and return($_[1] / $_[3]);
64     $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG} =   ;SPMquot;Illegal division by zero.\n;SPMquot;;
65     $_[0]-;SPMgt;YYError;
66     undef
67   }
68     ],
69   # ... mas reglas
70   ], # final de las reglas
<tex2html_mydb_mark>#6131#
71   @_);
72   bless($self,$class);
73 }
74
<tex2html_mydb_mark>#6132#
75 #line 44 ;SPMquot;Calc.yp;SPMquot; 
76 
77 
78 sub _Error {
79   # ...
80 }
81 
82 sub _Lexer {
83   my($parser)=shift;
84   # ...
85 }
86 
87 sub Run {
88     my($self)=shift;
89     $self-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;_Lexer, yyerror =;SPMgt; \;SPMamp;_Error );
90 }
91 
92 my($calc)=new Calc;
93 $calc-;SPMgt;Run;
94 
95 1;
<tex2html_mydb_mark>#6133#
push(s0);
 b = yylex();
 for( ; ; ;) {
   s = top(0); a = b;
   switch (action[s][a]) {
     case ;SPMquot;shift t;SPMquot; : 
       push(t); 
       b = yylex();
       break;
     case ;SPMquot;reduce A -;SPMgt;alpha;SPMquot; : 
       eval(Sub{A -;SPMgt; alpha}-;SPMgt;(top(|alpha|-1).attr, ... , top(0).attr)); 
       pop(|alpha|); 
       push(goto[top(0)][A]); 
       break;
     case ;SPMquot;accept;SPMquot; : return (1); 
     default : yyerror(;SPMquot;syntax error;SPMquot;);
   }
 }
<tex2html_mydb_mark>#6134#
 1  $ ./use_aSb.pl
 2  ----------------------------------------
 3  In state 0:
 4  Stack:[0]
 5  ab  # el usuario ha escrito esto
 6  Need token. Got ;SPMgt;a;SPMlt;
 7  Shift and go to state 2.
 8  ----------------------------------------
 9  In state 2:
10  Stack:[0,2]
11  Need token. Got ;SPMgt;b;SPMlt;
12  Reduce using rule 1 (S,0): S -;SPMgt; epsilon
13  Back to state 2, then go to state 4.
14  ----------------------------------------
15  In state 4:
16  Stack:[0,2,4]
17  Shift and go to state 5.
18  ----------------------------------------
19  In state 5:
20  Stack:[0,2,4,5]
21  Don't need token.
22  Reduce using rule 2 (S,3): S -;SPMgt; a S b
23  Back to state 0, then go to state 1.
24  ----------------------------------------
25  In state 1:
26  Stack:[0,1]
27  Need token. Got ;SPMgt;;SPMlt;
28  Shift and go to state 3.
29  ----------------------------------------
30  In state 3:
31  Stack:[0,1,3]
32  Don't need token.
33  Accept.
<tex2html_mydb_mark>#6135#
$ cat -n Precedencia.yp
     1  %token NUMBER
     2  %left '@'
     3  %right ';SPMamp;'  dummy
     4  %%
     5  list
     6      :
     7      | list '\n'
     8      | list e
     9      ;
    10
    11  e : NUMBER
    12    | e ';SPMamp;' e
    13    | e '@' e %prec dummy
    14    ;
    15
    16  %%

<tex2html_mydb_mark>#6136#
$ cat -n useprecedencia.pl
cat -n useprecedencia.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Precedencia;
     4
     5  sub Error {
     6    exists $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
     7    and do {
     8      print $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
     9      delete $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
    10      return;
    11    };
    12    print ;SPMquot;Syntax error.\n;SPMquot;;
    13  }
    14
    15  sub Lexer {
    16    my($parser)=shift;
    17
    18    defined($parser-;SPMgt;YYData-;SPMgt;{INPUT})
    19    or  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;STDIN;SPMgt;
    20    or  return('',undef);
    21
    22    $parser-;SPMgt;YYData-;SPMgt;{INPUT}=~s/^[ \t]//;
    23
    24    for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {
    25        s/^([0-9]+(?:\.[0-9]+)?)//
    26                and return('NUMBER',$1);
    27        s/^(.)//s
    28                and return($1,$1);
    29    }
    30  }
    31
    32  my $debug_level = (@ARGV)? oct(shift @ARGV): 0x1F;
    33  my $parser = Precedencia-;SPMgt;new();
    34  $parser-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;Lexer, yyerror =;SPMgt; \;SPMamp;Error, yydebug =;SPMgt; $debug_level );
<tex2html_mydb_mark>#6137#
yapp -v -m Precedencia Precedencia.yp
$ ls -ltr |tail -2
-rw-r--r--  1 lhp lhp   1628 2004-12-07 13:21 Precedencia.pm
-rw-r--r--  1 lhp lhp   1785 2004-12-07 13:21 Precedencia.output
<tex2html_mydb_mark>#6138#
$ cat -n Precedencia.output
     1  Conflicts:
     2  ----------
     3  Conflict in state 8 between rule 6 and token '@' resolved as reduce.
     4  Conflict in state 8 between rule 6 and token ';SPMamp;' resolved as shift.
     5  Conflict in state 9 between rule 5 and token '@' resolved as reduce.
     6  Conflict in state 9 between rule 5 and token ';SPMamp;' resolved as shift.
     7
     8  Rules:
     9  ------
    10  0:      $start -;SPMgt; list $end
    11  1:      list -;SPMgt; /* empty */
    12  2:      list -;SPMgt; list '\n'
    13  3:      list -;SPMgt; list e
    14  4:      e -;SPMgt; NUMBER
    15  5:      e -;SPMgt; e ';SPMamp;' e
    16  6:      e -;SPMgt; e '@' e
    17  ...
<tex2html_mydb_mark>#6139#
85  State 8:
86
87          e -;SPMgt; e . ';SPMamp;' e  (Rule 5)
88          e -;SPMgt; e . '@' e  (Rule 6)
89          e -;SPMgt; e '@' e .  (Rule 6)
90
91          ';SPMamp;'     shift, and go to state 7
92
93          $default        reduce using rule 6 (e)
<tex2html_mydb_mark>#6140#
    13    | e '@' e %prec dummy

<tex2html_mydb_mark>#6141#
     2  %left '@'
     3  %right ';SPMamp;'  dummy

<tex2html_mydb_mark>#6142#
State 9:

	e -;SPMgt; e . ';SPMamp;' e	(Rule 5)
	e -;SPMgt; e ';SPMamp;' e .	(Rule 5)
	e -;SPMgt; e . '@' e	(Rule 6)
	';SPMamp;'	shift, and go to state 7
	$default	reduce using rule 5 (e)
<tex2html_mydb_mark>#6143#
$ ./useprecedencia.pl
----------------------------------------
In state 0:
Stack:[0]
Don't need token.
Reduce using rule 1 (list,0): Back to state 0, then go to state 1.
<tex2html_mydb_mark>#6144#
20 State 0:
21
22   $start -;SPMgt; . list $end (Rule 0)
23
24   $default  reduce using rule 1 (list)
25
26   list  go to state 1
<tex2html_mydb_mark>#6145#
----------------------------------------
In state 1:
Stack:[0,1]
2@3@4
Need token. Got ;SPMgt;NUMBER;SPMlt;
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 1, then go to state 2.
----------------------------------------
<tex2html_mydb_mark>#6146#
In state 2:
Stack:[0,1,2]
Need token. Got ;SPMgt;@;SPMlt;
Shift and go to state 6.
----------------------------------------
In state 6:
Stack:[0,1,2,6]
Need token. Got ;SPMgt;NUMBER;SPMlt;
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,2,6,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 6, then go to state 8.
----------------------------------------
In state 8:
Stack:[0,1,2,6,8]
Need token. Got ;SPMgt;@;SPMlt;
Reduce using rule 6 (e,3): Back to state 1, then go to state 2.
----------------------------------------
...
Accept.
<tex2html_mydb_mark>#6147#
  my $p = new Parse::Yapp(input =;SPMgt; $grammar);
  $p = $p-;SPMgt;Output(classname =;SPMgt; $name);
<tex2html_mydb_mark>#6148#
  eval $p;
<tex2html_mydb_mark>#6149#
$ cat left.pl
#!/usr/local/bin/perl5.8.0 -w
#use strict;
use Parse::Yapp;

sub lex{
    my($parser)=shift;

    return('',undef) unless $parser-;SPMgt;YYData-;SPMgt;{INPUT};
    for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {
        s/^\s*//;
        s/^(.)//;
        my $ret = $1;
        return($ret, $ret);
    }
}

sub yapp {
  my $grammar = shift
     or die ;SPMquot;Must specify a grammar as first argument;SPMquot;;
  my $name = shift
     or die ;SPMquot;Must specify the name of the class as second argument;SPMquot;;

  my $p = new Parse::Yapp(input =;SPMgt; $grammar) or die ;SPMquot;Bad grammar.;SPMquot;;
  $p = $p-;SPMgt;Output(classname =;SPMgt; $name) or die ;SPMquot;Can't generate parser.;SPMquot;;

  eval $p;
  $@ and die ;SPMquot;Error while compiling your parser: $@\n;SPMquot;;
}

######## main #########
my $grammar = q {
%left '*'
%%
S:  A
;

A:  A '*' A  { ;SPMquot;($_[1] $_[2] $_[3]);SPMquot; }
 |  B
;

B:  'a' | 'b' | 'c' | 'd'
;

%%
};

;SPMamp;yapp($grammar, ;SPMquot;Example;SPMquot;);
my $p = new Example(yylex =;SPMgt; \;SPMamp;lex, yyerror =;SPMgt; sub {});

print ;SPMquot;Expresion: ;SPMquot;;
$p-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;;SPMgt;;
$p-;SPMgt;YYData-;SPMgt;{INPUT} =~ s/\s*$//;

my $out=$p-;SPMgt;YYParse;
print ;SPMquot;out = $out\n;SPMquot;;
<tex2html_mydb_mark>#6150#
$ ./left.pl
Expresion: a*b*c*d
out = (((a * b) * c) * d)
<tex2html_mydb_mark>#6151#
$ cat -n Infixtree_bless.yp
 1  #
 2  # Infixtree.yp
 3  #
 4
 5  %{
 6  use Data::Dumper;
 7  %}
 8  %right  '='
 9  %left   '-' '+'
10  %left   '*' '/'
11  %left   NEG
12
13  %%
14  input:  #empty
15          |   input line
16  ;
17
18  line:     '\n'         { $_[1] }
19          | exp '\n'     { print Dumper($_[1]); }
20          | error '\n'   { $_[0]-;SPMgt;YYErrok }
21  ;
22
23  exp:        NUM
24          |   VAR                 { $_[1] }
25          |   VAR '=' exp         { bless [$_[1], $_[3]], 'ASSIGN' }
26          |   exp '+' exp         { bless [$_[1], $_[3] ], 'PLUS'}
27          |   exp '-' exp         { bless [$_[1], $_[3] ], 'MINUS'}
28          |   exp '*' exp         { bless [$_[1], $_[3]], 'TIMES' }
29          |   exp '/' exp         { bless [$_[1], $_[3]], 'DIVIDE' }
30          |   '-' exp %prec NEG   { bless [$_[2]], 'NEG' }
31          |   '(' exp ')'         { $_[2] }
32  ;
33
34  %%
35
36  sub _Error {
37          exists $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
38      and do {
39          print $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
40          delete $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
41          return;
42      };
43      print ;SPMquot;Syntax error.\n;SPMquot;;
44  }
45
46  sub _Lexer {
47      my($parser)=shift;
48
49          defined($parser-;SPMgt;YYData-;SPMgt;{INPUT})
50      or  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;STDIN;SPMgt;
51      or  return('',undef);
52
53      $parser-;SPMgt;YYData-;SPMgt;{INPUT}=~s/^[ \t]//;
54
55      for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {
56          s/^([0-9]+(?:\.[0-9]+)?)//
57                  and return('NUM',$1);
58          s/^([A-Za-z][A-Za-z0-9_]*)//
59                  and return('VAR',$1);
60          s/^(.)//s
61                  and return($1,$1);
62      }
63  }
64
65  sub Run {
66      my($self)=shift;
67      $self-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;_Lexer, yyerror =;SPMgt; \;SPMamp;_Error );
68  }
<tex2html_mydb_mark>#6152#
$ yapp -m Infixtree Infixtree_bless.yp
<tex2html_mydb_mark>#6153#
$ cat -n ./useinfixtree.pl
     1  #!/usr/bin/perl -w
     2
     3  use Infixtree;
     4
     5  $parser = new Infixtree();
     6  $parser-;SPMgt;Run;
<tex2html_mydb_mark>#6154#
$ ./useinfixtree.pl
a = 2+3
$VAR1 = bless( [
                 'a',
                 bless( [
                          '2',
                          '3'
                        ], 'PLUS' )
               ], 'ASSIGN' );
b = a*4+a
$VAR1 = bless( [
                 'b',
                 bless( [
                          bless( [
                                   'a',
                                   '4'
                                 ], 'TIMES' ),
                          'a'
                        ], 'PLUS' )
               ], 'ASSIGN' );
<tex2html_mydb_mark>#6155#
 1     sub esquema_de_traduccion {
 2       my $node = shift;
 3 
 4       for my $child ($node-;SPMgt;children) { # de izquierda a derecha
 5         if ($child-;SPMgt;isa('ACTION') {
 6           $child-;SPMgt;execute;
 7         }
 8         else { esquema_de_traduccion($child) }
 9       }
10     }
<tex2html_mydb_mark>#6156#
$ cat -n Inherited.yp
 1  %token FLOAT INTEGER
 2  %token GLOBAL
 3  %token LOCAL
 4  %token NAME
 5
 6  %%
 7  declarationlist
 8    : # vacio
 9    | declaration ';' declarationlist
10    ;
11
12  declaration
13    : class type namelist { ; }
14    ;
15
16  class
17    : GLOBAL
18    | LOCAL
19    ;
20
21  type
22    : FLOAT
23    | INTEGER
24    ;
25
26  namelist
27    : NAME
28       { printf(;SPMquot;%s de clase %s, tipo %s\n;SPMquot;,
29               $_[1], $_[0]-;SPMgt;YYSemval(-1),$_[0]-;SPMgt;YYSemval(0)); }
30    | namelist ',' NAME
31        { printf(;SPMquot;%s de clase %s, tipo %s\n;SPMquot;,
32                 $_[3], $_[0]-;SPMgt;YYSemval(-1),$_[0]-;SPMgt;YYSemval(0)); }
33    ;
34  %%

<tex2html_mydb_mark>#6157#
$ cat -n useinherited.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Inherited;
 4
 5  sub Error {
 6    exists $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
 7    and do {
 8      print $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
 9      delete $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
10      return;
11    };
12    print ;SPMquot;Error sintáctico\n;SPMquot;;
13  }
14
15  { # hagamos una clausura con la entrada
16    my $input;
17    local $/ = undef;
18    print ;SPMquot;Entrada (En Unix, presione CTRL-D para terminar):\n;SPMquot;;
19    $input = ;SPMlt;stdin;SPMgt;;
20
21    sub scanner {
22
23      { # Con el redo del final hacemos un bucle ;SPMquot;infinito;SPMquot;
24        if ($input =~ m|\G\s*INTEGER\b|igc) {
25          return ('INTEGER', 'INTEGER');
26        }
27        elsif ($input =~ m|\G\s*FLOAT\b|igc) {
28          return ('FLOAT', 'FLOAT');
29        }
30        elsif ($input =~ m|\G\s*LOCAL\b|igc) {
31          return ('LOCAL', 'LOCAL');
32        }
33        elsif ($input =~ m|\G\s*GLOBAL\b|igc) {
34          return ('GLOBAL', 'GLOBAL');
35        }
36        elsif ($input =~ m|\G\s*([a-z_]\w*)\b|igc) {
37          return ('NAME', $1);
38        }
39        elsif ($input =~ m/\G\s*([,;])/gc) {
40          return ($1, $1);
41        }
42        elsif ($input =~ m/\G\s*(.)/gc) {
43          die ;SPMquot;Caracter invalido: $1\n;SPMquot;;
44        }
45        else {
46          return ('', undef); # end of file
47        }
48        redo;
49      }
50    }
51  }
52
53  my $debug_level = (@ARGV)? oct(shift @ARGV): 0x1F;
54  my $parser = Inherited-;SPMgt;new();
55  $parser-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;scanner, yyerror =;SPMgt; \;SPMamp;Error, yydebug =;SPMgt; $debug_level );
<tex2html_mydb_mark>#6158#
$ ./useinherited.pl 0
Entrada (En Unix, presione CTRL-D para terminar):
global integer x, y, z;
local float a,b;
x de clase GLOBAL, tipo INTEGER
y de clase GLOBAL, tipo INTEGER
z de clase GLOBAL, tipo INTEGER
a de clase LOCAL, tipo FLOAT
b de clase LOCAL, tipo FLOAT
<tex2html_mydb_mark>#6159#
%token FLOAT INTEGER 
%token GLOBAL 
%token LOCAL 
%token NAME

%%
declarationlist 
  : /* vacio */                     { bless [], 'declarationlist' } 
  | declaration ';' declarationlist { push @{$_[3]}, $_[1]; $_[3] }
  ;

declaration
  : class type namelist 
      { 
        bless {class =;SPMgt; $_[1], type =;SPMgt; $_[2], namelist =;SPMgt; $_[3]}, 'declaration'; 
      }
  ;

class
  : GLOBAL  { bless { GLOBAL =;SPMgt; 0}, 'class' } 
  | LOCAL   { bless { LOCAL =;SPMgt; 1}, 'class' }
  ;

type
  : FLOAT   { bless { FLOAT =;SPMgt; 2}, 'type' } 
  | INTEGER { bless { INTEGER =;SPMgt; 3}, 'type' }
  ;

namelist
  : NAME  
     { bless [ $_[1]], 'namelist' }
  | namelist ',' NAME 
      { push @{$_[1]}, $_[3]; $_[1] }
  ;
%%

<tex2html_mydb_mark>#6160#
$ ./useinherited3.pl
Entrada (En Unix, presione CTRL-D para terminar):
global float x,y;
$VAR1 = bless( [
  bless( {
    'namelist' =;SPMgt; bless( [ 'x', 'y' ], 'namelist' ),
    'type' =;SPMgt; bless( { 'FLOAT' =;SPMgt; 2 }, 'type' ),
    'class' =;SPMgt; bless( { 'GLOBAL' =;SPMgt; 0 }, 'class' )
  }, 'declaration' )
], 'declarationlist' );
<tex2html_mydb_mark>#6161#
$ cat -n Inherited2.yp
     1  %%
     2  S : 'a' A C
     3    | 'b' A B  { $_[2]; } C
     4    ;
     5
     6  C : 'c' { print ;SPMquot;Valor: ;SPMquot;,$_[0]-;SPMgt;YYSemval(0),;SPMquot;\n;SPMquot;; $_[0]-;SPMgt;YYSemval(0) }
     7    ;
     8
     9  A : 'a' { 'a' }
    10    ;
    11
    12  B : 'b' { 'b' }
    13    ;
    14
    15  %%

<tex2html_mydb_mark>#6162#
$ ./useinherited2.pl '0x04'
Entrada (En Unix, presione CTRL-D para terminar):
b a b c
Shift 2.  Shift 6.
Reduce using rule 5 (A,1): Back to state 2, then state 5.
Shift 8.
Reduce 6 (B,1): Back to state 5, then state 9.
Reduce 2 (@1-3,0): Back to state 9, then state 12.
<tex2html_mydb_mark>#6163#
$ cat -n Inherited2.output
     1  Rules:
     2  ------
     3  0:      $start -;SPMgt; S $end
     4  1:      S -;SPMgt; 'a' A C
     5  2:      @1-3 -;SPMgt; /* empty */
     6  3:      S -;SPMgt; 'b' A B @1-3 C
     7  4:      C -;SPMgt; 'c'
     8  5:      A -;SPMgt; 'a'
     9  6:      B -;SPMgt; 'b'
        ...
<tex2html_mydb_mark>#6164#
Shift 10.
Reduce 4 (C,1): 
Valor: a
Back to state 12, then 13.
Reduce using rule 3 (S,5): Back to state 0, then state 1.
Shift 4.
Accept.
<tex2html_mydb_mark>#6165#
 9  %right  '='
10  %left   '-' '+'
11  %left   '*' '/'
12  %left   NEG
13  %right  '^'
14
15  %%
16  input:  # empty
17          |   input line  { push(@{$_[1]},$_[2]); $_[1] }
18  ;
19
20  line:       '\n'       { $_[1] }
21          |   exp '\n'   { print ;SPMquot;$_[1]\n;SPMquot; }
22          |   error '\n' { $_[0]-;SPMgt;YYErrok }
23  ;
<tex2html_mydb_mark>#6166#
24
25  exp:        NUM
26          |   VAR                 { $_[0]-;SPMgt;YYData-;SPMgt;{VARS}{$_[1]} }
27          |   VAR '=' exp         { $_[0]-;SPMgt;YYData-;SPMgt;{VARS}{$_[1]}=$_[3] }
28          |   exp '+' exp         { $_[1] + $_[3] }
29          |   exp '-' exp         { $_[1] - $_[3] }
30          |   exp '*' exp         { $_[1] * $_[3] }
31          |   exp '/' exp         {
32                                    $_[3]
33                                    and return($_[1] / $_[3]);
34                                    $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
35                                      =   ;SPMquot;Illegal division by zero.\n;SPMquot;;
36                                    $_[0]-;SPMgt;YYError;
37                                    undef
38                                  }
39          |   '-' exp %prec NEG   { -$_[2] }
40          |   exp '^' exp         { $_[1] ** $_[3] }
41          |   '(' exp ')'         { $_[2] }
42  ;
<tex2html_mydb_mark>#6167#
$self-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;_Lexer, yyerror =;SPMgt; \;SPMamp;_Error, yydebug =;SPMgt; 0x10 );
<tex2html_mydb_mark>#6168#
$ ./usecalc.pl
3-+2
Syntax error.
**Entering Error recovery.
**Pop state 12.
**Pop state 3.
**Shift $error token and go to state 9.
**Dicard invalid token ;SPMgt;+;SPMlt;.
**Pop state 9.
**Shift $error token and go to state 9.
**Dicard invalid token ;SPMgt;NUM;SPMlt;.
**Pop state 9.
**Shift $error token and go to state 9.
**End of Error recovery.
<tex2html_mydb_mark>#6169#
	exp -;SPMgt; exp '-' . exp	(Rule 10)
	'('	shift 7 '-'	shift 2 NUM	shift 6 VAR	shift 8
	exp	go to state 21
<tex2html_mydb_mark>#6170#
	line -;SPMgt; exp . '\n'	(Rule 4)
	exp -;SPMgt; exp . '+' exp	(Rule 9)
	exp -;SPMgt; exp . '-' exp	(Rule 10)
	exp -;SPMgt; exp . '*' exp	(Rule 11)
	exp -;SPMgt; exp . '/' exp	(Rule 12)
	exp -;SPMgt; exp . '^' exp	(Rule 14)

	'*'	shift 17 '+'	shift 13 '-'	shift 12 '/'	shift 15
	'\n'	shift 14 '^'	shift 16
<tex2html_mydb_mark>#6171#
	$start -;SPMgt; input . $end	(Rule 0)
	input -;SPMgt; input . line	(Rule 2)

	$end	shift 4 '('	shift 7 '-'	shift 2 '\n'	shift 5
	NUM	shift 6 VAR	shift 8
	error	shift 9

	exp	go to state 3
	line	go to state 10
<tex2html_mydb_mark>#6172#
	line -;SPMgt; error . '\n'	(Rule 5)
	'\n'	shift, and go to state 20
<tex2html_mydb_mark>#6173#
**Dicard invalid token ;SPMgt;+;SPMlt;.
**Pop state 9.
**Shift $error token and go to state 9.
**Dicard invalid token ;SPMgt;NUM;SPMlt;.
**Pop state 9.
**Shift $error token and go to state 9.
**End of Error recovery.
<tex2html_mydb_mark>#6174#
%token NUMBER
%%
command 
  : 
  | command list '\n' { $_[0]-;SPMgt;YYErrok; } 
  ;

list 
    : NUMBER            { put($1); }
    | list ',' NUMBER   { put($3); $_[0]-;SPMgt;YYErrok; }
    | error             { err(1); }
    | list error        { err(2); }
    | list error NUMBER { err(3); put($3); $_[0]-;SPMgt;YYErrok; }
    | list ',' error    { err(4); }
    ;
    
%%    
sub put { my $x = shift; printf(;SPMquot;%2.1lf\n;SPMquot;,$x); }
sub err { my $code = shift; printf(;SPMquot;err %d\n;SPMquot;,$code); }
 ...
<tex2html_mydb_mark>#6175#
%{
our contador = 0;
%}

%token NUM
...
%%

<tex2html_mydb_mark>#6176#
$ cat -n Infixtree_conflict.yp
 1  #
 2  # Infixtree.yp
 3  #
 4
 5  %{
 6  use Data::Dumper;
 7  %}
 8  %left   '-' '+'
 9  %left   '*' '/'
10  %left   NEG
11
12  %%
13  input:  #empty
14          |   input line
15  ;
16
17  line:     '\n'         { $_[1] }
18          | exp '\n'     { print Dumper($_[1]); }
19          | error '\n'   { $_[0]-;SPMgt;YYErrok }
20  ;
21
22  exp:        NUM
23          |   VAR                 { $_[1] }
24          |   VAR '=' exp         { bless [$_[1], $_[3]], 'ASSIGN' }
25          |   exp '+' exp         { bless [$_[1], $_[3] ], 'PLUS'}
26          |   exp '-' exp         { bless [$_[1], $_[3] ], 'MINUS'}
27          |   exp '*' exp         { bless [$_[1], $_[3]], 'TIMES' }
28          |   exp '/' exp         { bless [$_[1], $_[3]], 'DIVIDE' }
   ....
<tex2html_mydb_mark>#6177#
$ yapp -v -m Infixtree Infixtree_conflict.yp
4 shift/reduce conflicts
<tex2html_mydb_mark>#6178#
$ cat -n Infixtree_conflict.output
1  Warnings:
2  ---------
3  4 shift/reduce conflicts
4
5  Conflicts:
6  ----------
7  Conflict in state 11 between rule 13 and token '-' resolved as reduce.
8  Conflict in state 11 between rule 13 and token '*' resolved as reduce.
  ...
<tex2html_mydb_mark>#6179#
    ...
26  Conflict in state 23 between rule 11 and token '/' resolved as reduce.
27  State 25 contains 4 shift/reduce conflicts
<tex2html_mydb_mark>#6180#
291 State 25:
292
293   exp -;SPMgt; VAR '=' exp .  (Rule 8)
294   exp -;SPMgt; exp . '+' exp  (Rule 9)
295   exp -;SPMgt; exp . '-' exp  (Rule 10)
296   exp -;SPMgt; exp . '*' exp  (Rule 11)
297   exp -;SPMgt; exp . '/' exp  (Rule 12)
298
299   '*' shift, and go to state 16
300   '+' shift, and go to state 13
301   '-' shift, and go to state 12
302   '/' shift, and go to state 15
303
304   '*' [reduce using rule 8 (exp)]
305   '+' [reduce using rule 8 (exp)]
306   '-' [reduce using rule 8 (exp)]
307   '/' [reduce using rule 8 (exp)]
308   $default  reduce using rule 8 (exp)
<tex2html_mydb_mark>#6181#
29 Rules:
30 ------
31 0:  $start -;SPMgt; input $end
32 1:  input -;SPMgt; /* empty */
33 2:  input -;SPMgt; input line
34 3:  line -;SPMgt; '\n'
35 4:  line -;SPMgt; exp '\n'
36 5:  line -;SPMgt; error '\n'
37 6:  exp -;SPMgt; NUM
38 7:  exp -;SPMgt; VAR
39 8:  exp -;SPMgt; VAR '=' exp
40 9:  exp -;SPMgt; exp '+' exp
41 10: exp -;SPMgt; exp '-' exp
42 11: exp -;SPMgt; exp '*' exp
43 12: exp -;SPMgt; exp '/' exp
44 13: exp -;SPMgt; '-' exp
45 14: exp -;SPMgt; '(' exp ')'
<tex2html_mydb_mark>#6182#
294   exp -;SPMgt; exp . '+' exp  (Rule 9)
295   exp -;SPMgt; exp . '-' exp  (Rule 10)
296   exp -;SPMgt; exp . '*' exp  (Rule 11)
297   exp -;SPMgt; exp . '/' exp  (Rule 12)
<tex2html_mydb_mark>#6183#
1 %token declarator basictype functionheader functionbody
2 %%
3 program: definitionslist
4        ;
5
6 definitionslist: definitions definitionslist
7                | definitions
8                ;
9
10 definitions: datadefinition
11            | functiondefinition
12            ;
13 datadefinition: basictype declaratorlist ';'
14               ;
15
16 declaratorlist: declarator ',' declaratorlist
17               | declarator
18               ;
19 functiondefinition: basictype functionheader functionbody
20                   | functionheader functionbody
21                   ;
22
23 %%

<tex2html_mydb_mark>#6184#
19 functiondefinition: basictype functionheader functionbody
20                   | functionheader functionbody
21                   ;
<tex2html_mydb_mark>#6185#
     15
     16 declaratorlist: declarator declaratorlist
     17               | declarator
     18               ;
     19 functiondefinition: basictype functionheader functionbody
     20                   | functionheader functionbody
     21                   ;
     22
     23 %%
~
~
~
~
~
~
~
~
~
~
:!yapp %

<tex2html_mydb_mark>#6186#
yapp:   head body tail 
head:   headsec '%%' 
headsec: #empty  
    |   decls  
decls:  decls decl  | decl       
body:   rulesec '%%' 
rulesec:  rulesec rules | rules 
rules:  IDENT ':' rhss ';'  
tail:   /*empty*/
    |   TAILCODE
<tex2html_mydb_mark>#6187#
decl:  '\n'                 
    |   TOKEN typedecl symlist '\n'
    |   ASSOC typedecl symlist '\n'  
    |   START ident '\n'       
    |   HEADCODE '\n'         
    |   UNION CODE '\n'      
    |   TYPE typedecl identlist '\n'
    |   EXPECT NUMBER '\n'  

typedecl: # empty
    |   ';SPMlt;' IDENT ';SPMgt;'
<tex2html_mydb_mark>#6188#
    ...
    if($lexlevel == 0) {# In head section
            $$input=~/\G%(left|right|nonassoc)/gc
        and return('ASSOC',[ uc($1), $lineno[0] ]);
            $$input=~/\G%(start)/gc
        and return('START',[ undef, $lineno[0] ]);
            $$input=~/\G%(expect)/gc
        and return('EXPECT',[ undef, $lineno[0] ]);
            $$input=~/\G%{/gc
    ...
<tex2html_mydb_mark>#6189#
 1 %{
 2 #include ;SPMlt;stdio.h;SPMgt;
 3 
 4 #define CLASE(x) ((x == 1)?;SPMquot;global;SPMquot;:;SPMquot;local;SPMquot;)
 5 #define TIPO(x) ((x == 1)?;SPMquot;float;SPMquot;:;SPMquot;integer;SPMquot;)
 6 %}
 7 
 8 %union {
 9   int n;   /* enumerado */
10   char *s; /* cadena */
11 }
12 
13 %token ;SPMlt;n;SPMgt; FLOAT INTEGER 
14 %token ;SPMlt;n;SPMgt; GLOBAL 
15 %token ;SPMlt;n;SPMgt; LOCAL 
16 %token ;SPMlt;s;SPMgt; NAME
17 %type ;SPMlt;n;SPMgt; class type
18 
19 %%

<tex2html_mydb_mark>#6190#
29 class
30   : GLOBAL { $$ = 1; }
31   | LOCAL  { $$ = 2; }
32   ;
33 
34 type
35   : FLOAT   { $$ = 1; }
36   | INTEGER { $$ = 2; }
37   ;
<tex2html_mydb_mark>#6191#
39 namelist
40   : NAME   { printf(;SPMquot;%s de clase %s, tipo %s\n;SPMquot;,$1,CLASE($;SPMlt;n;SPMgt;-1),TIPO($;SPMlt;n;SPMgt;0)); }
41   | namelist ',' NAME 
42       { printf(;SPMquot;%s de clase %s, tipo %s\n;SPMquot;,$3,CLASE($;SPMlt;n;SPMgt;-1),TIPO($;SPMlt;n;SPMgt;0)); }
43   ;
44 %%

<tex2html_mydb_mark>#6192#
rhss:   rhss '|' rule | rule 
rule:   rhs prec epscode | rhs 
rhs:    #empty     
    |   rhselts   
rhselts: rhselts rhselt | rhselt  
rhselt: symbol | code 
prec: PREC symbol
epscode: # vacio 
    |   code  
code:   CODE
<tex2html_mydb_mark>#6193#
    ....
    $lineno[0]=$lineno[1];
    ....
    $$input=~/\G{/gc
    and do {
        my($level,$from,$code);

        $from=pos($$input);
        $level=1;
        while($$input=~/([{}])/gc) {
            substr($$input,pos($$input)-1,1) eq '\\' #Quoted 
            and next;
            $level += ($1 eq '{' ? 1 : -1) or last;
        }
        $level and  _SyntaxError(2,;SPMquot;Unmatched { opened line $lineno[0];SPMquot;,-1);
        $code = substr($$input,$from,pos($$input)-$from-1);
        $lineno[1]+= $code=~tr/\n//;
        return('CODE',[ $code, $lineno[0] ]);
    };
<tex2html_mydb_mark>#6194#
;SPMquot;{ My string block };SPMquot;
;SPMquot;\{ My other string block \};SPMquot;
qq/ My unmatched brace \} /

# Casamos con el siguiente: {
q/ for my closing brace } / # 

q/ My opening brace { /
# debe cerrarse: }
<tex2html_mydb_mark>#6195#
tail:   /*empty*/
    |   TAILCODE
<tex2html_mydb_mark>#6196#
 1 %%
 2 
 3 extern FILE * yyin;
 4 
 5 main(int argc, char **argv) {
 6   if (argc ;SPMgt; 1) yyin = fopen(argv[1],;SPMquot;r;SPMquot;);
 7   /* yydebug = 1;
 8   */
 9   yyparse();
10 }
11 
12 yyerror(char *s) {
13   printf(;SPMquot;%s\n;SPMquot;,s);
14 }
<tex2html_mydb_mark>#6197#
 1   inherited: y.tab.c lex.yy.c
 2      gcc -DYYDEBUG=1 -g -o inherited1 y.tab.c lex.yy.c
 3   y.tab.c y.tab.h: inherited1.y 
 4      yacc -d -v inherited1.y 
 5   lex.yy.c: inherited1.l y.tab.h
 6      flex -l inherited1.l
 7   clean:
 8      - rm -f y.tab.c lex.yy.c *.o core inherited1
<tex2html_mydb_mark>#6198#
pl@nereida:~/src/inherited$ make
yacc -d -v inherited1.y
flex -l inherited1.l
gcc -DYYDEBUG=1 -g -o inherited1 y.tab.c lex.yy.c
pl@nereida:~/src/inherited$ ls -ltr
total 232
-rw-r-----  1 pl users   242 Dec 10  2003 Makefile
-rw-r-----  1 pl users   404 Dec 10  2003 inherited1.l
-rw-r-----  1 pl users   878 Dec 10  2003 inherited1.y
-rw-rw----  1 pl users  1891 Jan 26 15:41 y.tab.h
-rw-rw----  1 pl users 30930 Jan 26 15:41 y.tab.c
-rw-rw----  1 pl users  2365 Jan 26 15:41 y.output
-rw-rw----  1 pl users 44909 Jan 26 15:41 lex.yy.c
-rwxrwx--x  1 pl users 56336 Jan 26 15:41 inherited1
<tex2html_mydb_mark>#6199#
 1   %{
 2   #include ;SPMlt;string.h;SPMgt;
 3   #include ;SPMquot;y.tab.h;SPMquot;
 4   %}
 5   id [A-Za-z_][A-Za-z_0-9]*
 6   white [ \t\n]+
 7   %%
 8   global    {  return GLOBAL; }
 9   local     {  return LOCAL; }
10   float     {  return FLOAT; }
11   int       {  return INTEGER; }
12   {id}      {  yylval.s = strdup(yytext); return NAME; }
13   {white}   { ; }
14   ,         { return yytext[0]; }
15   .         { fprintf(stderr,;SPMquot;Error. carácter inesperado.\n;SPMquot;); }
16   %%
17   int yywrap() { return 1; }
<tex2html_mydb_mark>#6200#
<a href="http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm">http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm</a>
<tex2html_mydb_mark>#6201#
 1 sub _Parse {
 2   my($self)=shift;
 3 
 4   my($rules,$states,$lex,$error)
 5      = @$self{ 'RULES', 'STATES', 'LEX', 'ERROR' };
 6   my($errstatus,$nberror,$token,$value,$stack,$check,$dotpos)
 7      = @$self{ 'ERRST', 'NBERR', 'TOKEN', 'VALUE', 'STACK', 'CHECK', 'DOTPOS' };
 8 
 9   $$errstatus=0;
10   $$nberror=0;
11   ($$token,$$value)=(undef,undef);
12   @$stack=( [ 0, undef ] ); # push estado 0
13   $$check='';
<tex2html_mydb_mark>#6202#
14 
15   while(1) { 
16     my($actions,$act,$stateno);
17 
18     $stateno=$$stack[-1][0];     # sacar el estado en el top de 
19     $actions=$$states[$stateno]; # la pila
<tex2html_mydb_mark>#6203#
20 
21     if  (exists($$actions{ACTIONS})) {
22       defined($$token) or do {
23         ($$token,$$value)=;SPMamp;$lex($self); # leer siguiente token
24       };
25 
26       # guardar en $act la acción asociada con el estado y el token
27       $act = exists($$actions{ACTIONS}{$$token})?   
28          $$actions{ACTIONS}{$$token} : 
29          exists($$actions{DEFAULT})? $$actions{DEFAULT} : undef;
30     }
31     else { $act=$$actions{DEFAULT}; }
<tex2html_mydb_mark>#6204#
32 
33     defined($act) and do {
34       $act ;SPMgt; 0 and do { # $act ;SPMgt;0 indica shift
35          $$errstatus and do { --$$errstatus; };
<tex2html_mydb_mark>#6205#
36          # Transitar: guardar (estado, valor)
37          push(@$stack,[ $act, $$value ]);
38          $$token ne ''   #Don't eat the eof
39          and $$token=$$value=undef;
40          next; # siguiente iteración
41       };
<tex2html_mydb_mark>#6206#
43       # $act ;SPMlt; 0, indica reduce
44       my($lhs,$len,$code,@sempar,$semval);
45 
46       #obtenemos una referencia a la variable,
47       #longitud de la parte derecha, referencia
48       #a la acción
49       ($lhs,$len,$code)=@{$$rules[-$act]};
50       $act or $self-;SPMgt;YYAccept();
<tex2html_mydb_mark>#6207#
              sub YYAccept {
                my($self)=shift;

                ${$$self{CHECK}}='ACCEPT';
                  undef;
              }
<tex2html_mydb_mark>#6208#
51       $$dotpos=$len; # dotpos es la longitud de la regla
52       unpack('A1',$lhs) eq '@'    #In line rule
53       and do {
54         $lhs =~ /^\@[0-9]+\-([0-9]+)$/
55           or  die ;SPMquot;In line rule name '$lhs' ill formed: ;SPMquot;.
56                   ;SPMquot;report it as a BUG.\n;SPMquot;;
57         $$dotpos = $1;
58       };
<tex2html_mydb_mark>#6209#
60       @sempar = $$dotpos ?   
61          map { $$_[1] } @$stack[ -$$dotpos .. -1 ] : ();
<tex2html_mydb_mark>#6210#
62       $semval = $code ? ;SPMamp;$code( $self, @sempar ) : 
63                         @sempar ? $sempar[0] : undef;
<tex2html_mydb_mark>#6211#
65       splice(@$stack,-$len,$len);
<tex2html_mydb_mark>#6212#
      $$check eq 'ACCEPT' and do { return($semval); };
      $$check eq 'ABORT' and  do { return(undef); };
<tex2html_mydb_mark>#6213#
      $$check eq 'ERROR' or  do { 
          push(@$stack, [ $$states[$$stack[-1][0]]{GOTOS}{$lhs}, $semval ]);
          $$check='';
          next;
      };
<tex2html_mydb_mark>#6214#
      $$check='';

    }; # fin de defined($act)

    # Manejo de errores: código suprimido
    ... 

  }
}#_Parse
<tex2html_mydb_mark>#6215#
pl@nereida:~/src/perl/Parse-AutoTree/trunk/scripts$ cat -n int.yp
 1  %right '+'
 2  %left 'a'
 3  %nonassoc 'b'
 4  %%
 5  S:   /* empty rule */                       { print ;SPMquot;S -;SPMgt; epsilon\n;SPMquot; }
 6   |   'a' { print ;SPMquot;Intermediate\n;SPMquot;; } S 'b'  { print ;SPMquot;S -;SPMgt; a S b\n;SPMquot; }
 7   |   '+' S '+' %prec 'a'                    { print ;SPMquot;S -;SPMgt; + S + prec a\n;SPMquot; }
 8  ;
 9  %%
10
11  sub _Error {
12          exists $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG}
13      and do {
14          print $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
15          delete $_[0]-;SPMgt;YYData-;SPMgt;{ERRMSG};
16          return;
17      };
18      print ;SPMquot;Syntax error.\n;SPMquot;;
19  }
20
21  sub _Lexer {
22      my($parser)=shift;
23
24          defined($parser-;SPMgt;YYData-;SPMgt;{INPUT})
25      or  $parser-;SPMgt;YYData-;SPMgt;{INPUT} = ;SPMlt;STDIN;SPMgt;
26      or  return('',undef);
27
28      $parser-;SPMgt;YYData-;SPMgt;{INPUT}=~s/^[ \t\n]//;
29
30      for ($parser-;SPMgt;YYData-;SPMgt;{INPUT}) {
31          s/^(.)//s and return($1,$1);
32      }
33  }
34
35  sub Run {
36      my($self)=shift;
37      $self-;SPMgt;YYParse( yylex =;SPMgt; \;SPMamp;_Lexer, yyerror =;SPMgt; \;SPMamp;_Error, yydebug =;SPMgt; 0x1F );
38  }
<tex2html_mydb_mark>#6216#
sub Parse {
  my $grammar = shift;

  my $x = new Parse::Yapp::Parse;
  my $r = $x-;SPMgt;Parse($grammar);

  return $r;
}
<tex2html_mydb_mark>#6217#
nereida:~/src/perl/Parse-AutoTree/trunk/scripts;SPMgt; grammar.pl int.yp
$VAR1 = {
  'START' =;SPMgt; 'S', # Símbolo de arranque
  'SYMS' =;SPMgt; { 'S' =;SPMgt; 5, 'b' =;SPMgt; 3, 'a' =;SPMgt; 2, '+' =;SPMgt; 1 }, # Símbolo =;SPMgt; línea
  'TERM' =;SPMgt; { 
    'b' =;SPMgt; [ 'NONASSOC', 2 ],  # terminal =;SPMgt; [ Asociatividad, precedencia ]
    'a' =;SPMgt; [ 'LEFT', 1 ],      # terminal =;SPMgt; [ Asociatividad, precedencia ]
    '+' =;SPMgt; [ 'RIGHT', 0 ] },   # terminal =;SPMgt; [ Asociatividad, precedencia ]
    # Si el terminal no tiene precedencia toma la forma  terminal =;SPMgt; []
  'NTERM' =;SPMgt; { 'S' =;SPMgt; [ '1', '3', '4' ] }, # variable =;SPMgt; [ indice en RULES de las reglas de S ]
  'PREC' =;SPMgt; { 'a' =;SPMgt; 1 }, # Terminales que son usandos en una directiva %prec
  'NULL' =;SPMgt; { 'S' =;SPMgt; 1 }, # Variables que producen vacío
  'EXPECT' =;SPMgt; 0, # Número de conflictos esperados
  'RULES' =;SPMgt; [
     [ '$start', [ 'S', '' ], undef, undef ], # Regla de superarranque
     [
       'S', [], # producción
       undef,   # precedencia explícita de la regla
       [ ' print ;SPMquot;S -;SPMgt; epsilon\n;SPMquot; ', 5 ] # [ acción asociada, línea ]
     ],
     [
       '@1-1', [], # Regla intermedia: Variable temporal
       undef,
       [ ' print ;SPMquot;Intermediate\n;SPMquot;; ', 6 ]
     ],
     [
       'S', [ 'a', '@1-1', 'S', 'b' ],
       undef,
       [ ' print ;SPMquot;S -;SPMgt; a S b\n;SPMquot; ', 6 ]
     ],
     [
       'S', [ '+', 'S', '+' ],
       1, # precedencia explícita de la regla
       [ ' print ;SPMquot;S -;SPMgt; + S + prec a\n;SPMquot; ', 7 ]
     ]
   ],
  'HEAD' =;SPMgt; undef, # Código de cabecera 
  'TAIL' =;SPMgt; [ '... código de cola ...', 9 ], # Línea en la que comienza la sección de cola
};
<tex2html_mydb_mark>#6218#
   @$parsed{ 'HEAD', 'TAIL', 'RULES', 'NTERM', 'TERM',
              'NULL', 'PREC', 'SYMS',  'START', 'EXPECT' }
    =       (  $head,  $tail,  $rules,  $nterm,  $term,
               $nullable, $precterm, $syms, $start, $expect);
<tex2html_mydb_mark>#6219#
%{
require 5.004;

use Carp;

my($input,$lexlevel,@lineno,$nberr,$prec,$labelno);
my($syms,$head,$tail,$token,$term,$nterm,$rules,$precterm,$start,$nullable);
my($expect);

%}

<tex2html_mydb_mark>#6220#
%{
use Data::Dumper;
my %tree_name = ('=' =;SPMgt; 'eq', '+' =;SPMgt; 'plus', '-' =;SPMgt; 'minus', 
                 '*' =;SPMgt; 'times', '/' =;SPMgt; 'divide');
%}
%right  '='
%left   '-' '+'
%left   '*' '/'
%left   NEG
%autoaction { [$tree_name{$_[2]}, $_[1], $_[3]] }

%%
input:               { undef }
        | input line { undef } 
;

line:     '\n'         { undef }
        | exp '\n'     { print Dumper($_[1]); }
        | error '\n'   { $_[0]-;SPMgt;YYErrok }
;

exp:        NUM                 { $_[1] }
        |   VAR                 { $_[1] }
        |   VAR '=' exp | exp '+' exp | exp '-' exp | exp '*' exp | exp '/' exp      
        |   '-' exp %prec NEG   { ['neg', $_[2]] }
        |   '(' exp ')'         { $_[2] }
;

%%

<tex2html_mydb_mark>#6221#
$ ./useautoaction1.pl
2+3*4
^D
$VAR1 = [
          'plus',
          '2',
          [ 'times', '3', '4' ]
        ];
<tex2html_mydb_mark>#6222#
BEGIN { unshift @INC, '/home/lhp/Lperl/src/yapp/Parse-Yapp-Auto/lib/' }
<tex2html_mydb_mark>#6223#
my($code)= $autoaction? $autoaction:undef;
<tex2html_mydb_mark>#6224#
%right  '='
%left   '-' '+'
%left   '*' '/'
%left   NEG
%autoaction { my $n = $#_;  bless [@_[1..$n]], $_[0]-;SPMgt;YYLhs }
%%
input:                 
        |   input line 
;
line:     '\n'       { } 
        | exp '\n'   { [ $_[1] ] } 
        | error '\n' { }
;
exp:        NUM         |   VAR         |   VAR '=' exp         
        |   exp '+' exp |   exp '-' exp |   exp '*' exp |   exp '/' exp      
        |   '-' exp %prec NEG 
        |   '(' exp ')' { [ $_[2] ] }     
;
%%
...
<tex2html_mydb_mark>#6225#
$ ./uselhs2.pl
2+3*4
$VAR1 = bless( 
[
  bless( [], 'input' ),
  [
    bless( [
      bless( [ '2' ], 'exp' ),
      '+',
      bless( [
        bless( [ '3' ], 'exp' ), '*', bless( [ '4' ], 'exp' ) ], 'exp' )
    ], 'exp' )
  ]
], 'input' );
<tex2html_mydb_mark>#6226#
{ my $n = $#_;  bless [@_[1..$n]], $_[0]-;SPMgt;YYLhs }
<tex2html_mydb_mark>#6227#
 1 sub _Parse {
 2   my($self)=shift;
 3   ... 
 4   $$errstatus=0; $$nberror=0;
<tex2html_mydb_mark>#6228#
 5   ($$token,$$value)=(undef,undef);
 6   @$stack=( [ 0, undef ] ); $$check='';
 7   while(1) {
 8     my($actions,$act,$stateno);
 9     $stateno=$$stack[-1][0];
10     $actions=$$states[$stateno];
11 
12     if  (exists($$actions{ACTIONS})) { 
13       defined($$token) or  do { ($$token,$$value)=;SPMamp;$lex($self); };
14       ...
15     }
16     else { $act=$$actions{DEFAULT}; }
<tex2html_mydb_mark>#6229#
17     defined($act) and do { 
18       $act ;SPMgt; 0 and do { #shift
19           $$errstatus and  do { --$$errstatus; };
20           ...
21           next;
22       };
23       #reduce
24       ....
25       $$check eq 'ERROR' or  do {
26         push(@$stack, [ $$states[$$stack[-1][0]]{GOTOS}{$lhs}, $semval ]);
27         $$check='';
28         next;
29       };
30       $$check='';
31     };
<tex2html_mydb_mark>#6230#
32     #Error
33     $$errstatus or   do {
34       $$errstatus = 1;
35       ;SPMamp;$error($self);
36       $$errstatus # if 0, then YYErrok has been called
37       or  next;   # so continue parsing
38       ++$$nberror;
39     };
<tex2html_mydb_mark>#6231#
47     $$errstatus=3;
<tex2html_mydb_mark>#6232#
48     while(@$stack
49         and (not exists($$states[$$stack[-1][0]]{ACTIONS})
50         or  not exists($$states[$$stack[-1][0]]{ACTIONS}{error})
51         or  $$states[$$stack[-1][0]]{ACTIONS}{error} ;SPMlt;= 0)) {
52       pop(@$stack);
53     }
54     @$stack or do {
55       return(undef);
56     };
<tex2html_mydb_mark>#6233#
57     #shift the error token
58     push(@$stack, [ $$states[$$stack[-1][0]]{ACTIONS}{error}, undef ]);
59   }
60   #never reached
61   croak(;SPMquot;Error in driver logic. Please, report it as a BUG;SPMquot;);
62 }#_Parse
<tex2html_mydb_mark>#6234#
41     $$errstatus == 3  #The next token is not valid: discard it
42     and  do {
43       $$token eq ''  # End of input: no hope
44       and  do { return(undef); }; 
45       $$token=$$value=undef;
46     };
<tex2html_mydb_mark>#6235#
sub YYErrok {
  my($self)=shift;

  ${$$self{ERRST}}=0;
    undef;
}
<tex2html_mydb_mark>#6236#
sub YYNberr {
  my($self)=shift;

  ${$$self{NBERR}};
}

sub YYRecovering {
  my($self)=shift;

  ${$$self{ERRST}} != 0;
}
<tex2html_mydb_mark>#6237#
program: definition+

definition: funcDef | basictype funcDef | declaration

basictype: INT | CHAR

funcDef: ID '('  params  ')' block

params: ( basictype ID arraySpec);SPMlt;* ',';SPMgt;

block: '{' declaration* statement* '}'

declaration: basictype declList ';'

declList: (ID arraySpec) ;SPMlt;+ ',';SPMgt;

arraySpec: ( '[' INUM ']')*

statement:
    expression ';'
  | ';'
  | BREAK ';'
  | CONTINUE ';'
  | RETURN ';'
  | RETURN expression ';'
  | block
  | ifPrefix statement %prec '+'
  | ifPrefix statement 'ELSE' statement
  | loopPrefix statement

ifPrefix: IF '(' expression ')'

loopPrefix: WHILE '(' expression ')'

expression: binary ;SPMlt;+ ',';SPMgt;

Variable: ID ('[' binary ']') *

Primary:
    INUM
  | CHARCONSTANT
  | Variable
  | '(' expression ')'
  | function_call

function_call:  ID  '(' binary ;SPMlt;* ',';SPMgt; ')'

Unary: '++' Variable | '--' Variable | Primary

binary:
    Unary
  | binary '+' binary
  | binary '-' binary
  | binary '*' binary
  | binary '/' binary
  | binary '%' binary
  | binary ';SPMlt;' binary
  | binary ';SPMgt;' binary
  | binary ';SPMgt;=' binary
  | binary ';SPMlt;=' binary
  | binary '==' binary
  | binary '!=' binary
  | binary ';SPMamp;' binary
  | binary '**' binary
  | binary '|' binary
  | Variable '=' binary
  | Variable '+=' binary
  | Variable '-=' binary
  | Variable '*=' binary
  | Variable '/=' binary
  | Variable '%=' binary
  | etc. etc.
<tex2html_mydb_mark>#6238#
     15
     16 declaratorlist: declarator +
     17 ;
     18 functiondefinition: 
     19    basictype functionheader functionbody
     20  | functionheader functionbody
     21 ;
     22
     23 %%
~
~
~
~
~
~
~
~
~
~
:!eyapp %

<tex2html_mydb_mark>#6239#
nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; cat -n prueba5.c
     1  int f(int a)
     2  {
     3    if (a;SPMgt;0)
     4      a = f(a-1);
     5  }
<tex2html_mydb_mark>#6240#
nereida:~/doc/casiano/PLBOOK/PLBOOK/code;SPMgt; eyapp Simple2 ;\
                                  usesimple2.pl prueba5.c
PROGRAM(
  TYPEDFUNC(
    INT(TERMINAL[INT:1]),
    FUNCTION(
      TERMINAL[f:1],
      PARAMS(
        PARAM(
          INT(TERMINAL[INT:1]),
          TERMINAL[a:1],
          ARRAYSPEC
        )
      ),
      BLOCK(
        DECLARATIONS,
        STATEMENTS(
          IF(
            GT(
              VAR(TERMINAL[a:3]),
              INUM(TERMINAL[0:3])
            ),
            ASSIGN(
              VAR(TERMINAL[a:4]),
              FUNCTIONCALL(
                TERMINAL[f:4],
                ARGLIST(
                  MINUS(
                    VAR(TERMINAL[a:4]),
                    INUM(TERMINAL[1:4])
                  )
                ) # ARGLIST
              ) # FUNCTIONCALL
            ) # ASSIGN
          ) # IF
        ) # STATEMENTS
      ) # BLOCK
    ) # FUNCTION
  ) # TYPEDFUNC
) # PROGRAM
<tex2html_mydb_mark>#6241#
 1  definition:
 2      funcDef { $_[1]-;SPMgt;type(;SPMquot;INTFUNC;SPMquot;); $_[1] }
 3    | %name TYPEDFUNC
 4      basictype funcDef
 5    | declaration { $_[1] }
 6  ;
<tex2html_mydb_mark>#6242#
;SPMgt; byacc -V
byacc: Berkeley yacc version 1.8.2 (C or perl)
<tex2html_mydb_mark>#6243#
byacc  [ -CPcdlrtv ] [ -b file_prefix ] [ -p symbol_prefix ] filename
<tex2html_mydb_mark>#6244#
%{
%}

%token INT EOL
%token LEFT_PAR RIGHT_PAR
%left PLUS MINUS
%left MULT DIV

%%
start:	|
		start input
	;

input:		expr EOL	{ print $1 . ;SPMquot;\n;SPMquot;; }
	|	EOL
	;

expr:		INT		{ $p-;SPMgt;mydebug(;SPMquot;INT -;SPMgt; Expr!;SPMquot;); $$ = $1; }
	|	expr PLUS expr	{ $p-;SPMgt;mydebug(;SPMquot;PLUS -;SPMgt; Expr!;SPMquot;); $$ = $1 + $3; }
	|	expr MINUS expr	{ $p-;SPMgt;mydebug(;SPMquot;MINUS -;SPMgt; Expr!;SPMquot;); $$ = $1 - $3; }
	|	expr MULT expr	{ $p-;SPMgt;mydebug(;SPMquot;MULT -;SPMgt; Expr!;SPMquot;); $$ = $1 * $3; }
	|	expr DIV expr	{ $p-;SPMgt;mydebug(;SPMquot;DIV -;SPMgt; Expr!;SPMquot;); $$ = $1 / $3; }
	|	LEFT_PAR expr RIGHT_PAR { $p-;SPMgt;mydebug(;SPMquot;PARENS -;SPMgt; Expr!;SPMquot;); $$ = $2; }
	;
%%

sub yyerror {
    my ($msg, $s) = @_;
    my ($package, $filename, $line) = caller;
    
    die ;SPMquot;$msg at ;SPMlt;DATA;SPMgt; \n$package\n$filename\n$line\n;SPMquot;;
}

sub mydebug {
    my $p = shift;
    my $msg = shift;
    if ($p-;SPMgt;{'yydebug'})
    {
        print ;SPMquot;$msg\n;SPMquot;;
    }
}
<tex2html_mydb_mark>#6245#
;SPMgt; ls -l
total 12
-rw-r-----    1 pl       casiano        47 Dec 29  2002 Makefile
-rw-r-----    1 pl       casiano       823 Dec 29  2002 calc.y
-rwxr-x--x    1 pl       casiano       627 Nov 10 15:37 tokenizer.pl
;SPMgt; cat Makefile
MyParser.pm: calc.y
        byacc -d -P MyParser $;SPMlt;

;SPMgt; make
byacc -d -P MyParser calc.y
;SPMgt; ls -ltr
total 28
-rw-r-----    1 pl       casiano       823 Dec 29  2002 calc.y
-rw-r-----    1 pl       casiano        47 Dec 29  2002 Makefile
-rwxr-x--x    1 pl       casiano       627 Nov 10 15:37 tokenizer.pl
-rw-rw----    1 pl       users          95 Nov 16 12:49 y.tab.ph
-rw-rw----    1 pl       users        9790 Nov 16 12:49 MyParser.pm
<tex2html_mydb_mark>#6246#
 cat y.tab.ph
$INT=257;
$EOL=258;
$LEFT_PAR=259;
$RIGHT_PAR=260;
$PLUS=261;
$MINUS=262;
$MULT=263;
$DIV=264;
<tex2html_mydb_mark>#6247#
;SPMgt; cat tokenizer.pl
#!/usr/local/bin/perl5.8.0

require 5.004;
use strict;
use Parse::YYLex;
use MyParser;

print STDERR ;SPMquot;Version $Parse::ALex::VERSION\n;SPMquot;;

my (@tokens) = ((LEFT_PAR =;SPMgt; '\(',
                 RIGHT_PAR =;SPMgt; '\)',
                 MINUS =;SPMgt; '-',
                 PLUS =;SPMgt; '\+',
                 MULT =;SPMgt; '\*',
                 DIV =;SPMgt; '/',
                 INT =;SPMgt; '[1-9][0-9]*',
                 EOL =;SPMgt; '\n',
                 ERROR =;SPMgt; '.*'),
                sub { die ;SPMquot;!can\'t analyze: \"$_[1]\"\n!;SPMquot;; });

my $lexer = Parse::YYLex-;SPMgt;new(@tokens);

sub yyerror
{
    die ;SPMquot;There was an error:;SPMquot; . join(;SPMquot;\n;SPMquot;, @_). ;SPMquot;\n;SPMquot;;
}

my $debug = 0;
my $parser = new MyParser($lexer-;SPMgt;getyylex(), \;SPMamp;MyParser::yyerror , $debug);
$lexer-;SPMgt;from(\*STDIN);
$parser-;SPMgt;yyparse(\*STDIN);
<tex2html_mydb_mark>#6248#
;SPMgt; tokenizer.pl
Version 2.15
yydebug: state 0, reducing by rule 1 (start :)
yydebug: after reduction, shifting from state 0 to state 1
3*(5-9)
yydebug: state 1, reading 257 (INT)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 5 (expr : INT)
INT -;SPMgt; Expr!
yydebug: after reduction, shifting from state 1 to state 6
yydebug: state 6, reading 263 (MULT)
yydebug: state 6, shifting to state 11
yydebug: state 11, reading 259 (LEFT_PAR)
yydebug: state 11, shifting to state 4
yydebug: state 4, reading 257 (INT)
yydebug: state 4, shifting to state 2
yydebug: state 2, reducing by rule 5 (expr : INT)
INT -;SPMgt; Expr!
yydebug: after reduction, shifting from state 4 to state 7
yydebug: state 7, reading 262 (MINUS)
yydebug: state 7, shifting to state 10
yydebug: state 10, reading 257 (INT)
yydebug: state 10, shifting to state 2
yydebug: state 2, reducing by rule 5 (expr : INT)
INT -;SPMgt; Expr!
yydebug: after reduction, shifting from state 10 to state 15
yydebug: state 15, reading 260 (RIGHT_PAR)
yydebug: state 15, reducing by rule 7 (expr : expr MINUS expr)
MINUS -;SPMgt; Expr!
yydebug: after reduction, shifting from state 4 to state 7
yydebug: state 7, shifting to state 13
yydebug: state 13, reducing by rule 10 (expr : LEFT_PAR expr RIGHT_PAR)
PARENS -;SPMgt; Expr!
yydebug: after reduction, shifting from state 11 to state 16
yydebug: state 16, reducing by rule 8 (expr : expr MULT expr)
MULT -;SPMgt; Expr!
yydebug: after reduction, shifting from state 1 to state 6
yydebug: state 6, reading 258 (EOL)
yydebug: state 6, shifting to state 8
yydebug: state 8, reducing by rule 3 (input : expr EOL)
-12
yydebug: after reduction, shifting from state 1 to state 5
yydebug: state 5, reducing by rule 2 (start : start input)
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, reading 0 (end-of-file)
<tex2html_mydb_mark>#6249#%%|. 

<tex2html_mydb_mark>#6250#%start|:

<tex2html_mydb_mark>#6251#%{
 
<tex2html_mydb_mark>#6252#%}
 
<tex2html_mydb_mark>#6253#%token NUMBER
 
<tex2html_mydb_mark>#6254#%left '+' '-'
 
<tex2html_mydb_mark>#6255#%left '*' '/'
 
<tex2html_mydb_mark>#6256#%

<tex2html_mydb_mark>#6257#%.8g\n;SPMquot;,$2);}

<tex2html_mydb_mark>#6258#%

<tex2html_mydb_mark>#6259#%s\n;SPMquot;,s);

<tex2html_mydb_mark>#6260#%{
 
<tex2html_mydb_mark>#6261#%}
 
<tex2html_mydb_mark>#6262#%
 
<tex2html_mydb_mark>#6263#%

<tex2html_mydb_mark>#6264#%left '+'| se traduce en la reducción por la regla 5.

<tex2html_mydb_mark>#6265#%.8g\n;SPMquot;,$2);| asociado con la regla y la salida

<tex2html_mydb_mark>#6266#%{

<tex2html_mydb_mark>#6267#%}

<tex2html_mydb_mark>#6268#%token NUMBER

<tex2html_mydb_mark>#6269#%left '@' 

<tex2html_mydb_mark>#6270#%right ';SPMamp;'  dummy

<tex2html_mydb_mark>#6271#%%

<tex2html_mydb_mark>#6272#%prec dummy
    
<tex2html_mydb_mark>#6273#%%

<tex2html_mydb_mark>#6274#%s\n;SPMquot;,s);

<tex2html_mydb_mark>#6275#%left '@'|?.  ¿O quizá es porque la precedencia de \verb|@|

<tex2html_mydb_mark>#6276#%prec dummy|

<tex2html_mydb_mark>#6277#%union|.

<tex2html_mydb_mark>#6278#%union| especifica la colección de posibles tipos de datos de \verb|yylval| y de los atributos \verb|$1|, \verb|$2|, \ldots 

<tex2html_mydb_mark>#6279#%union {
  
<tex2html_mydb_mark>#6280#%token ;SPMlt;val;SPMgt;   NUMBER

<tex2html_mydb_mark>#6281#%token ;SPMlt;index;SPMgt; VAR

<tex2html_mydb_mark>#6282#%type  ;SPMlt;val;SPMgt;   expr

<tex2html_mydb_mark>#6283#%right '='

<tex2html_mydb_mark>#6284#%left '+' '-'

<tex2html_mydb_mark>#6285#%left '*' '/'

<tex2html_mydb_mark>#6286#%token1 y \verb1%type1 para definir el tipo del correspondiente atributo asociado.

<tex2html_mydb_mark>#6287#%union| es utilizada por  \verb|yacc|

<tex2html_mydb_mark>#6288#%union|, \verb|%token| y \verb|%type|.
 
<tex2html_mydb_mark>#6289#%union| y de las

<tex2html_mydb_mark>#6290#%{

<tex2html_mydb_mark>#6291#%}

<tex2html_mydb_mark>#6292#%union {
  
<tex2html_mydb_mark>#6293#%token ;SPMlt;tA;SPMgt; A

<tex2html_mydb_mark>#6294#%type ;SPMlt;tx;SPMgt; x

<tex2html_mydb_mark>#6295#%%

<tex2html_mydb_mark>#6296#%s\n;SPMquot;,buffer); } '\n' s 
  
<tex2html_mydb_mark>#6297#%c;SPMquot;,$1); }
  
<tex2html_mydb_mark>#6298#%s%c;SPMquot;,$;SPMlt;tx;SPMgt;2,$1); free($2); }
  
<tex2html_mydb_mark>#6299#%%

<tex2html_mydb_mark>#6300#%s\n;SPMquot;,s);

<tex2html_mydb_mark>#6301#%{

<tex2html_mydb_mark>#6302#%}

<tex2html_mydb_mark>#6303#%%

<tex2html_mydb_mark>#6304#%%

<tex2html_mydb_mark>#6305#%s\n;SPMquot;,buffer); } '\n' s@ 

<tex2html_mydb_mark>#6306#%{

<tex2html_mydb_mark>#6307#%}

<tex2html_mydb_mark>#6308#%token NUMBER

<tex2html_mydb_mark>#6309#%left '-'

<tex2html_mydb_mark>#6310#%%

<tex2html_mydb_mark>#6311#%.8g\n;SPMquot;,$2);}
    
<tex2html_mydb_mark>#6312#%%

<tex2html_mydb_mark>#6313#%{

<tex2html_mydb_mark>#6314#%}

<tex2html_mydb_mark>#6315#%union { 
  
<tex2html_mydb_mark>#6316#%token ;SPMlt;val;SPMgt;NUMBER

<tex2html_mydb_mark>#6317#%%

<tex2html_mydb_mark>#6318#%%    

<tex2html_mydb_mark>#6319#%2.1lf\n;SPMquot;,x);

<tex2html_mydb_mark>#6320#%d\n;SPMquot;,code);

<tex2html_mydb_mark>#6321#%s\n;SPMquot;,s);

<tex2html_mydb_mark>#6322#
nereida:~/src/precedencia/hoc1;SPMgt; cat -n hoc1.y
 1  %{
 2  /* File: /home/pl/src/precedencia/hoc1/hoc1.y */
 3  #define YYSTYPE double
 4  #include ;SPMlt;stdio.h;SPMgt;
 5  %}
 6  %token NUMBER
 7  %left '+' '-'
 8  %left '*' '/'
 9  %%
10  list
11      :
12      | list '\n'
13      | list expr   { printf(;SPMquot;%.8g\n;SPMquot;,$2);}
14      ;
15
16  expr
17      : NUMBER { $$ = $1;}
18      | expr '+' expr {$$ = $1 + $3;}
19      | expr '-' expr {$$ = $1 - $3;}
20      | expr '*' expr {$$ = $1 * $3;}
21      | expr '/' expr {$$ = $1 / $3;}
22      ;
23
24  %%
25
26  extern FILE * yyin;
27
28  main(int argc, char **argv) {
29    if (argc ;SPMgt; 1) yyin = fopen(argv[1],;SPMquot;r;SPMquot;);
30    yydebug = 1;
31    yyparse();
32  }
33
34  yyerror(char *s) {
35    printf(;SPMquot;%s\n;SPMquot;,s);
36  }
<tex2html_mydb_mark>#6323#
nereida:~/src/precedencia/hoc1;SPMgt; cat -n hoc1.l
 1  %{
 2  #include ;SPMquot;y.tab.h;SPMquot;
 3  extern YYSTYPE yylval;
 4  %}
 5  number [0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?
 6  %%
 7  {number} { yylval = atof(yytext); return NUMBER; }
 8  .|\n     { return yytext[0];}
 9  %%
10  int yywrap() { return 1; }
<tex2html_mydb_mark>#6324#
nereida:~/src/precedencia/hoc1;SPMgt; yacc -d -v hoc1.y
nereida:~/src/precedencia/hoc1;SPMgt; ls -lt | head -4
total 200
-rw-rw----  1 pl users    2857 2007-01-18 10:26 y.output
-rw-rw----  1 pl users   35936 2007-01-18 10:26 y.tab.c
-rw-rw----  1 pl users    1638 2007-01-18 10:26 y.tab.h
nereida:~/src/precedencia/hoc1;SPMgt; sed -ne '27,48p' y.tab.h | cat -n
 1  #ifndef YYTOKENTYPE
 2  # define YYTOKENTYPE
 3     /* Put the tokens into the symbol table, so that GDB and other debuggers
 4        know about them.  */
 5     enum yytokentype {
 6       NUMBER = 258
 7     };
 8  #endif
 9  /* Tokens.  */
10  #define NUMBER 258
..  .........................................................
15  #if ! defined (YYSTYPE) ;SPMamp;;SPMamp; ! defined (YYSTYPE_IS_DECLARED)
16  typedef int YYSTYPE;
17  # define yystype YYSTYPE /* obsolescent; will be withdrawn */
18  # define YYSTYPE_IS_DECLARED 1
19  # define YYSTYPE_IS_TRIVIAL 1
20  #endif
21
22  extern YYSTYPE yylval;
<tex2html_mydb_mark>#6325#
;SPMgt; cat Makefile
hoc1: y.tab.c lex.yy.c
        gcc -DYYDEBUG=1 -g -o hoc1 y.tab.c lex.yy.c
y.tab.c y.tab.h: hoc1.y
        yacc -d -v hoc1.y
lex.yy.c: hoc1.l y.tab.h
        flex -l hoc1.l
clean:
        - rm -f y.tab.c lex.yy.c *.o core hoc1
<tex2html_mydb_mark>#6326#
$ hoc1
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
2.5+3.5+1
<tex2html_mydb_mark>#6327#
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 43 ('+')
yydebug: state 4, shifting to state 5
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 5 to state 6
yydebug: state 6, reducing by rule 5 (expr : expr '+' expr)
<tex2html_mydb_mark>#6328#
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 43 ('+')
yydebug: state 4, shifting to state 5
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 5 to state 6
yydebug: state 6, reducing by rule 5 (expr : expr '+' expr)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, reducing by rule 3 (list : list expr)
7
<tex2html_mydb_mark>#6329#    
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 2 (list : list '\n')
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, reading 0 (end-of-file)
$
<tex2html_mydb_mark>#6330#
%{
#define YYSTYPE double
#include ;SPMlt;stdio.h;SPMgt;
%}
%token NUMBER
%left '@' 
%right ';SPMamp;'  dummy
%%
list 
    :
    | list '\n'  
    | list e 
    ;

e : NUMBER  
  | e ';SPMamp;' e 
  | e '@' e %prec dummy
    ;

%%
extern FILE * yyin;
 
main(int argc, char **argv) {
  if (argc ;SPMgt; 1) yyin = fopen(argv[1],;SPMquot;r;SPMquot;);
  yydebug = 1;
  yyparse();
}
 
yyerror(char *s) {
  printf(;SPMquot;%s\n;SPMquot;,s);
}
<tex2html_mydb_mark>#6331#
   0  $accept : list $end

   1  list :
   2       | list '\n'
   3       | list e

   4  e : NUMBER
   5    | e ';SPMamp;' e
   6    | e '@' e
<tex2html_mydb_mark>#6332#
state 0
	$accept : . list $end  (0)
	list : .  (1)

	.  reduce 1

	list  goto 1


state 1
	$accept : list . $end  (0)
	list : list . '\n'  (2)
	list : list . e  (3)

	$end  accept
	NUMBER  shift 2
	'\n'  shift 3
	.  error

	e  goto 4


state 2
	e : NUMBER .  (4)

	.  reduce 4


state 3
	list : list '\n' .  (2)

	.  reduce 2


state 4
	list : list e .  (3)
	e : e . ';SPMamp;' e  (5)
	e : e . '@' e  (6)

	'@'  shift 5
	';SPMamp;'  shift 6
	$end  reduce 3
	NUMBER  reduce 3
	'\n'  reduce 3
<tex2html_mydb_mark>#6333#
state 5
	e : e '@' . e  (6)

	NUMBER  shift 2
	.  error

	e  goto 7


state 6
	e : e ';SPMamp;' . e  (5)

	NUMBER  shift 2
	.  error

	e  goto 8


state 7
	e : e . ';SPMamp;' e  (5)
	e : e . '@' e  (6)
	e : e '@' e .  (6)

	';SPMamp;'  shift 6
	$end  reduce 6
	NUMBER  reduce 6
	'@'  reduce 6
	'\n'  reduce 6

state 8
	e : e . ';SPMamp;' e  (5)
	e : e ';SPMamp;' e .  (5)
	e : e . '@' e  (6)

	';SPMamp;'  shift 6
	$end  reduce 5
	NUMBER  reduce 5
	'@'  reduce 5
	'\n'  reduce 5
<tex2html_mydb_mark>#6334#
7 terminals, 3 nonterminals
7 grammar rules, 9 states
<tex2html_mydb_mark>#6335#
$ hocprec
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
1@2;SPMamp;3
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 64 ('@')
yydebug: state 4, shifting to state 5
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 5 to state 7
yydebug: state 7, reading 38 (';SPMamp;')
yydebug: state 7, shifting to state 6
<tex2html_mydb_mark>#6336#
$ hocprec
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
1;SPMamp;2@3
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 38 (';SPMamp;')
yydebug: state 4, shifting to state 6
yydebug: state 6, reading 257 (NUMBER)
yydebug: state 6, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 6 to state 8
yydebug: state 8, reading 64 ('@')
yydebug: state 8, reducing by rule 5 (e : e ';SPMamp;' e)
<tex2html_mydb_mark>#6337#
%union {
  double val;
  int index;
}
<tex2html_mydb_mark>#6338#
%token ;SPMlt;val;SPMgt;   NUMBER
%token ;SPMlt;index;SPMgt; VAR
%type  ;SPMlt;val;SPMgt;   expr
%right '='
%left '+' '-'
%left '*' '/'

<tex2html_mydb_mark>#6339#
%{
#include ;SPMlt;string.h;SPMgt;
char buffer[256];
#define YYDEBUG 1
%}
%union {
  char tA;
  char *tx;
}
%token ;SPMlt;tA;SPMgt; A
%type ;SPMlt;tx;SPMgt; x
%%
s : x { *$1 = '\0'; printf(;SPMquot;%s\n;SPMquot;,buffer); } '\n' s 
  |
  ;

x : A { $$ = buffer + sprintf(buffer,;SPMquot;%c;SPMquot;,$1); }
  | A { $;SPMlt;tx;SPMgt;$ = strdup(;SPMquot;**;SPMquot;); } x 
    { $$ = $3 + sprintf($3,;SPMquot;%s%c;SPMquot;,$;SPMlt;tx;SPMgt;2,$1); free($2); }
  ;

%%

main() {
  yydebug=1;
  yyparse();
}

yyerror(char *s) {
  printf(;SPMquot;%s\n;SPMquot;,s);
}
<tex2html_mydb_mark>#6340#
%{
#include ;SPMquot;y.tab.h;SPMquot;
%}
%%
[\t ]+
[a-zA-Z0-9]   { yylval.tA = yytext[0]; return A; }
(.|\n)        { return yytext[0]; }
%%
yywrap() { return 1; }
<tex2html_mydb_mark>#6341#
$ yacc -d -v media4.y ; flex -l medial.l ; gcc -g y.tab.c lex.yy.c
$ a.out
ABC
yydebug: state 0, reading 257 (A)
yydebug: state 0, shifting to state 1
yydebug: state 1, reading 257 (A)
yydebug: state 1, reducing by rule 5 ($$2 :)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, shifting to state 1
yydebug: state 1, reading 257 (A)
yydebug: state 1, reducing by rule 5 ($$2 :)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, shifting to state 1
yydebug: state 1, reading 10 ('\n')
yydebug: state 1, reducing by rule 4 (x : A)
yydebug: after reduction, shifting from state 4 to state 6
yydebug: state 6, reducing by rule 6 (x : A $$2 x)
yydebug: after reduction, shifting from state 4 to state 6
yydebug: state 6, reducing by rule 6 (x : A $$2 x)
yydebug: after reduction, shifting from state 0 to state 3
yydebug: state 3, reducing by rule 1 ($$1 :)
C**B**A
yydebug: after reduction, shifting from state 3 to state 5
yydebug: state 5, shifting to state 7
yydebug: state 7, reading 0 (end-of-file)
yydebug: state 7, reducing by rule 3 (s :)
yydebug: after reduction, shifting from state 7 to state 8
yydebug: state 8, reducing by rule 2 (s : x $$1 '\n' s)
yydebug: after reduction, shifting from state 0 to state 2
<tex2html_mydb_mark>#6342#
$ yacc -d -v media3.y
yacc: 1 rule never reduced
yacc: 3 shift/reduce conflicts.
<tex2html_mydb_mark>#6343#
 1    0  $accept : s $end
 2
 3    1  $$1 :
 4
 5    2  s : x $$1 '\n' s
 6    3    |
 7
 8    4  x : A
 9
10    5  $$2 :
11
12    6  x : $$2 A x
13 ^L
<tex2html_mydb_mark>#6344#
14 0: shift/reduce conflict (shift 1, reduce 5) on A
15 state 0
16         $accept : . s $end  (0)
17         s : .  (3)
18         $$2 : .  (5)
19
20         A  shift 1
21         $end  reduce 3
22
23         s  goto 2
24         x  goto 3
25         $$2  goto 4
<tex2html_mydb_mark>#6345#
$ hoc1
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
3--2
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 45 (illegal-symbol)
syntax error
yydebug: error recovery discarding state 4
yydebug: error recovery discarding state 1
yydebug: error recovery discarding state 0
<tex2html_mydb_mark>#6346#
%{
#define YYSTYPE double
#define YYDEBUG 1
#include ;SPMlt;stdio.h;SPMgt;
%}
%token NUMBER
%left '-'
%%
list 
    :
    | list '\n'  
    | list error '\n'  { yyerrok; }
    | list expr   { printf(;SPMquot;%.8g\n;SPMquot;,$2);}
    ;

expr 
    : NUMBER { $$ = $1;} 
    | expr '-' expr {$$ = $1 - $3;}
    ;

%%

<tex2html_mydb_mark>#6347#
goodtoken = 3; b = yylex();
for( ; ; ;) {
  s = top(); a = b;
  switch (action[s][a])) {
    case ;SPMquot;shift t;SPMquot; : push(t); b = yylex(); goodtoken++; break;
    case ;SPMquot;reduce A -;SPMgt; alpha;SPMquot; : 
            pop(strlen(alpha));
            push(goto[top()][A]; 
          break; 
    case ;SPMquot;accept;SPMquot; : return (1); 
    default : if (errorrecovery(;SPMquot;syntax error;SPMquot;)) return (ERROR);
  }
}
<tex2html_mydb_mark>#6348#
errorrecovery(char * s) {
 if (goodtoken ;SPMgt; 2) { 
   yyerror(s); goodtoken = 0; 
 }
 while (action[s][error] != shift)
   popstate(s);
 push(goto[s][error]);
 s = top();
 while (action[s][a] == reduce A -;SPMgt; alpha) {
   pop(strlen(|alpha|)); 
   push(goto[top()][A]; 
   s = top(); 
 }
 switch (action[s][a])) {
   case ;SPMquot;shift t;SPMquot; : 
     push(t); 
     b = yylex(); 
     goodtoken++; 
     RETURN RECOVERING;
   case ;SPMquot;accept;SPMquot; : return (ERROR); 
   default : 
     do b = yylex(); 
     while ((b != EOF);SPMamp;;SPMamp;(action[s][b] == error); 
     if (b == EOF) 
       return (ERROR); 
     else 
       RETURN RECOVERING
}
<tex2html_mydb_mark>#6349#
$ yacc -d hoc1.y; flex -l hoc1.l; gcc y.tab.c lex.yy.c; a.out
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
2--3-1
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 5 (expr : NUMBER)
yydebug: after reduction, shifting from state 1 to state 5
yydebug: state 5, reading 45 ('-')
yydebug: state 5, shifting to state 7
yydebug: state 7, reading 45 ('-')
syntax error
<tex2html_mydb_mark>#6350#
yydebug: error recovery discarding state 7
yydebug: error recovery discarding state 5
yydebug: state 1, error recovery shifting to state 2
<tex2html_mydb_mark>#6351#
yydebug: state 2, error recovery discards token 45 ('-')
yydebug: state 2, reading 257 (NUMBER)
yydebug: state 2, error recovery discards token 257 (NUMBER)
yydebug: state 2, reading 45 ('-')
yydebug: state 2, error recovery discards token 45 ('-')
yydebug: state 2, reading 257 (NUMBER)
yydebug: state 2, error recovery discards token 257 (NUMBER)
<tex2html_mydb_mark>#6352#
yydebug: state 2, reading 10 ('\n')
yydebug: state 2, shifting to state 6
yydebug: state 6, reducing by rule 3 (list : list error '\n')
yydebug: after reduction, shifting from state 0 to state 1
<tex2html_mydb_mark>#6353#
%{
#include ;SPMlt;stdio.h;SPMgt;
void put(double x);
void err(int code); 
%}

%union { 
  double val; 
}
%token ;SPMlt;val;SPMgt;NUMBER
%%
command 
  : 
  | command list '\n' { yyerrok; } 
  ;

list 
    : NUMBER            { put($1); }
    | list ',' NUMBER   { put($3); yyerrok; }
    | error             { err(1); }
    | list error        { err(2); }
    | list error NUMBER { err(3); put($3); yyerrok; }
    | list ',' error    { err(4); }
    ;
    
%%    
void put(double x) {   
  printf(;SPMquot;%2.1lf\n;SPMquot;,x);
}

void err(int code) {
  printf(;SPMquot;err %d\n;SPMquot;,code);
}

main() {
  yydebug = 1;
  yyparse();
}

yyerror(char *s) {
  printf(;SPMquot;%s\n;SPMquot;,s);
}
<tex2html_mydb_mark>#6354#
   0  $accept : command $end

   1  command :
   2          | command list '\n'

   3  list : NUMBER
   4       | list ',' NUMBER
   5       | error
   6       | list error
   7       | list error NUMBER
   8       | list ',' error

state 0
	$accept : . command $end  (0)
	command : .  (1)

	.  reduce 1

	command  goto 1


state 1
	$accept : command . $end  (0)
	command : command . list '\n'  (2)

	$end  accept
	error  shift 2
	NUMBER  shift 3
	.  error

	list  goto 4


state 2
	list : error .  (5)

	.  reduce 5


state 3
	list : NUMBER .  (3)

	.  reduce 3


state 4
	command : command list . '\n'  (2)
	list : list . ',' NUMBER  (4)
	list : list . error  (6)
	list : list . error NUMBER  (7)
	list : list . ',' error  (8)

	error  shift 5
	'\n'  shift 6
	','  shift 7
	.  error


state 5
	list : list error .  (6)
	list : list error . NUMBER  (7)

	NUMBER  shift 8
	error  reduce 6
	'\n'  reduce 6
	','  reduce 6


state 6
	command : command list '\n' .  (2)

	.  reduce 2


state 7
	list : list ',' . NUMBER  (4)
	list : list ',' . error  (8)

	error  shift 9
	NUMBER  shift 10
	.  error


state 8
	list : list error NUMBER .  (7)

	.  reduce 7


state 9
	list : list ',' error .  (8)

	.  reduce 8


state 10
	list : list ',' NUMBER .  (4)

	.  reduce 4


5 terminals, 3 nonterminals
9 grammar rules, 11 states
<tex2html_mydb_mark>#6355#
;SPMgt; error
yydebug: state 0, reducing by rule 1 (command :)
yydebug: after reduction, shifting from state 0 to state 1
10 20
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 3 (list : NUMBER)
10.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 257 (NUMBER)
syntax error
yydebug: state 4, error recovery shifting to state 5
yydebug: state 5, shifting to state 8
yydebug: state 8, reducing by rule 7 (list : list error NUMBER)
err 3
20.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
10;20 30
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 3 (list : NUMBER)
10.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 59 (illegal-symbol)
syntax error
yydebug: state 4, error recovery shifting to state 5
yydebug: state 5, error recovery discards token 59 (illegal-symbol)
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 8
yydebug: state 8, reducing by rule 7 (list : list error NUMBER)
err 3
20.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 257 (NUMBER)
syntax error
yydebug: state 4, error recovery shifting to state 5
yydebug: state 5, shifting to state 8
yydebug: state 8, reducing by rule 7 (list : list error NUMBER)
err 3
30.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
3,
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 3 (list : NUMBER)
3.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 44 (',')
yydebug: state 4, shifting to state 7
yydebug: state 7, reading 10 ('\n')
syntax error
yydebug: state 7, error recovery shifting to state 9
yydebug: state 9, reducing by rule 8 (list : list ',' error)
err 4
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
#
yydebug: state 1, reading 35 (illegal-symbol)
syntax error
yydebug: state 1, error recovery shifting to state 2
yydebug: state 2, reducing by rule 5 (list : error)
err 1
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, error recovery discards token 35 (illegal-symbol)
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, reading 0 (end-of-file)
<tex2html_mydb_mark>#6356#%= ______ %;SPMgt;;SPMquot;;SPMgt; ;SPMlt;%= _ %;SPMgt; ;SPMlt;/span;SPMgt;\n';

<tex2html_mydb_mark>#6357#%%% TEXEXPAND: END FILE ./chapter99/bitacora.tex

<tex2html_mydb_mark>#6358#%\bibliographystyle{plain}

<tex2html_mydb_mark>#6359#%\bibliography{perlbib/perl}

<tex2html_mydb_mark>#6360#
;SPMquot;hello small world and blue sky;SPMquot;.match(/(\S+)\s+(\S+)/);
<tex2html_mydb_mark>#6361#
;SPMgt; x = ;SPMquot;I have 2 numbers: 53147;SPMquot;
;SPMgt; pats = [ /(.*)(\d*)/, 
           /(.*)(\d+)/, 
           /(.*?)(\d*)/, 
           /(.*?)(\d+)/, 
           /(.*)(\d+)$/, 
           /(.*?)(\d+)$/, 
           /(.*)\b(\d+)$/, 
           /(.*\D)(\d+)$/ ]
<tex2html_mydb_mark>#6362#
   pats.map( function(r) { return r.exec(x).slice(1); })
<tex2html_mydb_mark>#6363#
;SPMgt;  a = ;SPMquot;hola juan;SPMquot;
 =;SPMgt; ;SPMquot;hola juan;SPMquot; 
;SPMgt; a.match(/(?:hola )*(juan)/)
<tex2html_mydb_mark>#6364#
m = 'main() /* 1c */ { /* 2c */ return; /* 3c */ }'.match(new RegExp('/\\*.*\\*/'))
<tex2html_mydb_mark>#6365#
;SPMgt; 'ab,cd,4,3,   de,   fg'.replace(/,/, ', ')
=;SPMgt; ;SPMquot;ab, cd, 4, 3,    de,    fg;SPMquot;
<tex2html_mydb_mark>#6366#
;SPMgt; re = __________
;SPMgt; str = ;SPMquot;John Smith;SPMquot;
'John Smith'
;SPMgt; newstr = str.replace(re, ;SPMquot;______;SPMquot;)
'Smith, John'
<tex2html_mydb_mark>#6367#
;SPMgt; re = /d(b+)(d)/ig
/d(b+)(d)/gi
;SPMgt; z = ;SPMquot;dBdxdbbdzdbd;SPMquot;
'dBdxdbbdzdbd'
;SPMgt; result = re.exec(z)
[ ______, _____, ______, index: __, input: 'dBdxdbbdzdbd' ]
;SPMgt; re.lastIndex
______
;SPMgt; result = re.exec(z)
[ ______, _____, ______, index: __, input: 'dBdxdbbdzdbd' ]
;SPMgt; re.lastIndex
______
;SPMgt; result = re.exec(z)
[ ______, _____, ______, index: __, input: 'dBdxdbbdzdbd' ]
;SPMgt; re.lastIndex
______
;SPMgt; result = re.exec(z)
_____
<tex2html_mydb_mark>#6368#
;SPMgt; x = ;SPMquot;hello;SPMquot;
;SPMgt; r = /l(___)/
;SPMgt; z = r.exec(x)
[ 'l', index: 3, input: 'hello' ]
<tex2html_mydb_mark>#6369#
;SPMgt; z = ;SPMquot;dBdDBBD;SPMquot;
;SPMgt; re = /d(b+)(d)/ig
;SPMgt; re.lastIndex = ________
;SPMgt; result = re.exec(z)
[ 'DBBD',
  'BB',
  'D',
  index: 3,
  input: 'dBdDBBD' ]
<tex2html_mydb_mark>#6370#
;SPMgt; RegExp.prototype.bexec = function(str) {
...   var i = this.lastIndex;
...   var m = this.exec(str);
...   if (m ;SPMamp;;SPMamp; m.index == i) return m;
...   return null;
... }
[Function]
<tex2html_mydb_mark>#6371#
;SPMgt; re = /d(b+)(d)/ig
/d(b+)(d)/gi
;SPMgt; z = ;SPMquot;dBdXXXXDBBD;SPMquot;
'dBdXXXXDBBD'
;SPMgt; re.lastIndex = 3
;SPMgt; re.bexec(z)
_____________________________________________________
;SPMgt; re.lastIndex = 7
;SPMgt; re.bexec(z)
_____________________________________________________
<tex2html_mydb_mark>#6372#
;SPMlt;html;SPMgt;
  ;SPMlt;head;SPMgt;
      ;SPMlt;meta http-equiv=;SPMquot;Content-Type;SPMquot; content=;SPMquot;text/html; charset=_____;SPMquot;;SPMgt;
      ;SPMlt;title;SPMgt;JavaScript Temperature Converter;SPMlt;/title;SPMgt;
      ;SPMlt;link ____=;SPMquot;global.css;SPMquot; ___=;SPMquot;stylesheet;SPMquot; ____=;SPMquot;text/css;SPMquot;;SPMgt;

     ;SPMlt;script type=;SPMquot;_______________;SPMquot; src=;SPMquot;temperature.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;____;SPMgt;
    ;SPMlt;h1;SPMgt;Temperature Converter;SPMlt;/h1;SPMgt;
    ;SPMlt;table;SPMgt;
      ;SPMlt;tr;SPMgt;
        ;SPMlt;th;SPMgt;Enter  Temperature (examples: 32F, 45C, -2.5f):;SPMlt;/th;SPMgt;
        ;SPMlt;td;SPMgt;;SPMlt;input id=;SPMquot;________;SPMquot; ________=;SPMquot;calculate();;SPMquot;;SPMgt;;SPMlt;/td;SPMgt;
      ;SPMlt;/tr;SPMgt;
      ;SPMlt;tr;SPMgt;
        ;SPMlt;th;SPMgt;Converted Temperature:;SPMlt;/th;SPMgt;
        ;SPMlt;td;SPMgt;;SPMlt;span class=;SPMquot;output;SPMquot; id=;SPMquot;_________;SPMquot;;SPMgt;;SPMlt;/span;SPMgt;;SPMlt;/td;SPMgt;
      ;SPMlt;/tr;SPMgt;
    ;SPMlt;/table;SPMgt;
  ;SPMlt;/____;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#6373#
;SPMquot;use strict;SPMquot;; // Use ECMAScript 5 strict mode in browsers that support it
function calculate() {
  var result;
  var original       = document.getElementById(;SPMquot;________;SPMquot;);
  var temp = original.value;
  var regexp = /_______________________________/;
  
  var m = temp.match(______);
  
  if (m) {
    var num = ____;  // paréntesis correspondiente
    var type = ____;
    num = parseFloat(num);
    if (type == 'c' || type == 'C') {
      result = (num * 9/5)+32;
      result = ______________________________ // 1 sólo decimal y el tipo
    }
    else {
      result = (num - 32)*5/9;
      result = ____________________________ // 1 sólo decimal y el tipo
    }
    converted._________ = result; // Insertar ;SPMquot;result;SPMquot; en la página
  }
  else {
    converted._________ = ;SPMquot;ERROR! Try something like '-4.2C' instead;SPMquot;;
  }
}
<tex2html_mydb_mark>#6374#
;SPMlt;td;SPMgt;;SPMlt;textarea autofocus cols = ;SPMquot;80;SPMquot; rows = ;SPMquot;5;SPMquot; id=;SPMquot;original;SPMquot;;SPMgt;;SPMlt;/textarea;SPMgt;;SPMlt;/td;SPMgt;
<tex2html_mydb_mark>#6375#
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
<tex2html_mydb_mark>#6376#
  if (window.localStorage) localStorage.original  = temp;
<tex2html_mydb_mark>#6377#
window.onload = function() {
  // If the browser supports localStorage and we have some stored data
  if (window.localStorage ;SPMamp;;SPMamp; localStorage.original) {
    document.getElementById(;SPMquot;original;SPMquot;).value = localStorage.original;
  }
};
<tex2html_mydb_mark>#6378#
.hidden      { display: ____; }
.unhidden    { display: _____; }
<tex2html_mydb_mark>#6379#
var entityMap = {
    ;SPMquot;;SPMamp;;SPMquot;: ;SPMquot;;SPMamp;___;;SPMquot;,
    ;SPMquot;;SPMlt;;SPMquot;: ;SPMquot;;SPMamp;__;;SPMquot;,
    ;SPMquot;;SPMgt;;SPMquot;: ;SPMquot;;SPMamp;__;;SPMquot;,
    ';SPMquot;': ';SPMamp;quot;',
    ;SPMquot;';SPMquot;: ';SPMamp;#39;',
    ;SPMquot;/;SPMquot;: ';SPMamp;#x2F;'
  };

function escapeHtml(string) {
  return String(string).replace(/_________/g, function (s) {
    return ____________;
  });
<tex2html_mydb_mark>#6380#
;SPMgt; ;SPMquot;bb;SPMquot;.match(/b|bb/)

;SPMgt; ;SPMquot;bb;SPMquot;.match(/bb|b/)
<tex2html_mydb_mark>#6381#
;SPMlt;html;SPMgt;
  ;SPMlt;head;SPMgt;
     ;SPMlt;meta http-equiv=;SPMquot;Content-Type;SPMquot; content=;SPMquot;text/html; charset=UTF-8;SPMquot;;SPMgt;
     ;SPMlt;title;SPMgt;INI files;SPMlt;/title;SPMgt;
     ;SPMlt;link href=;SPMquot;global.css;SPMquot; rel=;SPMquot;__________;SPMquot; type=;SPMquot;text/css;SPMquot;;SPMgt;

     ;SPMlt;script type=;SPMquot;_______________;SPMquot; src=;SPMquot;underscore.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;_______________;SPMquot; src=;SPMquot;jquery.js;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
     ;SPMlt;script type=;SPMquot;_______________;SPMquot; src=;SPMquot;______;SPMquot;;SPMgt;;SPMlt;/script;SPMgt;
  ;SPMlt;/head;SPMgt;
  ;SPMlt;body;SPMgt;
    ;SPMlt;h1;SPMgt;INI files;SPMlt;/h1;SPMgt;
    ;SPMlt;input type=;SPMquot;file;SPMquot; id=;SPMquot;_________;SPMquot; /;SPMgt;
    ;SPMlt;div id=;SPMquot;out;SPMquot; class=;SPMquot;hidden;SPMquot;;SPMgt;
    ;SPMlt;table;SPMgt;
      ;SPMlt;tr;SPMgt;;SPMlt;th;SPMgt;Original;SPMlt;/th;SPMgt;;SPMlt;th;SPMgt;Tokens;SPMlt;/th;SPMgt;;SPMlt;/tr;SPMgt;
      ;SPMlt;tr;SPMgt;
        ;SPMlt;td;SPMgt;
          ;SPMlt;pre class=;SPMquot;input;SPMquot; id=;SPMquot;____________;SPMquot;;SPMgt;;SPMlt;/pre;SPMgt;
        ;SPMlt;/td;SPMgt;
        ;SPMlt;td;SPMgt;
          ;SPMlt;pre class=;SPMquot;output;SPMquot; id=;SPMquot;___________;SPMquot;;SPMgt;;SPMlt;/pre;SPMgt;
        ;SPMlt;/td;SPMgt;
      ;SPMlt;/tr;SPMgt;
    ;SPMlt;/table;SPMgt;
    ;SPMlt;/div;SPMgt;
  ;SPMlt;/body;SPMgt;
;SPMlt;/html;SPMgt;
<tex2html_mydb_mark>#6382#
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.
<tex2html_mydb_mark>#6383#
;SPMquot;use ______;SPMquot;; // Use ECMAScript 5 strict mode in browsers that support it

$(document)._____(function() {
   $(;SPMquot;#fileinput;SPMquot;).______(calculate);
});

function calculate(evt) {
  var f = evt.target.files[0]; 

  if (f) {
    var r = new __________();
    r.onload = function(e) { 
      var contents = e.target.______;
      
      var tokens = lexer(contents);
      var pretty = tokensToString(tokens);
      
      out.className = 'unhidden';
      initialinput._________ = contents;
      finaloutput._________ = pretty;
    }
    r.__________(f); // Leer como texto
  } else { 
    alert(;SPMquot;Failed to load file;SPMquot;);
  }
}

var temp = ';SPMlt;li;SPMgt; ;SPMlt;span class = ;SPMquot;;SPMlt;%= ______ %;SPMgt;;SPMquot;;SPMgt; ;SPMlt;%= _ %;SPMgt; ;SPMlt;/span;SPMgt;\n';

function tokensToString(tokens) {
   var r = '';
   for(var i in tokens) {
     var t = tokens[i];
     var s = JSON.stringify(t, undefined, 2); //______________________________
     s = _.template(temp, {t: t, s: s});
     r += s;
   }
   return ';SPMlt;ol;SPMgt;\n'+r+';SPMlt;/ol;SPMgt;';
}

function lexer(input) {
  var blanks         = /^___/;
  var iniheader      = /^________________/;
  var comments       = /^________/;
  var nameEqualValue = /^________________________/;
  var any            = /^_______/;

  var out = [];
  var m = null;

  while (input != '') {
    if (m = blanks.____(input)) {
      input = input.substr(m.index+___________);
      out.push({ type : ________, match: _ });
    }
    else if (m = iniheader.exec(input)) {
      input = input.substr(___________________);
      _______________________________________ // avanzemos en input
    }
    else if (m = comments.exec(input)) {
      input = input.substr(___________________);
      _________________________________________
    }
    else if (m = nameEqualValue.exec(input)) {
      input = input.substr(___________________);
      _______________________________________________
    }
    else if (m = any.exec(input)) {
      _______________________________________
      input = '';
    }
    else {
      alert(;SPMquot;Fatal Error!;SPMquot;+substr(input,0,20));
      input = '';
    }
  }
  return out;
}