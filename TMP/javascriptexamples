




\documentclass[11pt,a4paper,oneside,onecolumn]{book}
\usepackage{epsfig} 
\usepackage{latexsym,amsfonts,amssymb,amstext,amsthm,float,amsmath,dsfont}
\usepackage[spanish]{babel}    
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{alltt}
\usepackage{html}
\usepackage{makeidx}
\usepackage{hyperref}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{listings}
\lstloadlanguages{Ruby}
\lstset{%
backgroundcolor=\color{GreenYellow},
basicstyle=\ttfamily\color{black},
commentstyle = \ttfamily\color{red},
keywordstyle=\ttfamily\color{blue},
stringstyle=\color{orange}}

%\topmargin -4 mm
\voffset -10 mm
\topmargin 0 mm
%\headheight 10 mm
\headheight 0 mm
%\headsep 10 mm
\headsep 0 mm

%\textheight 229 mm
\textheight 256 mm

\oddsidemargin -5.4 mm
\evensidemargin -5.4 mm

\textwidth 17 cm
\columnsep 10 mm

%%% TEXEXPAND: INCLUDED FILE MARKER ./booktt/commontex/commands.tex
\newcommand{\datetofill}{\rule{5mm}{.1pt}/\rule{5mm}{.1pt}/\rule{10mm}{.1pt}}

% Comandos para el índice de referencias cruzadas
\newcommand{\infinity}{\infty}

\newcommand{\ici}[1]
  {\index{#1}}

\newcommand{\perlcookbook}[2]
  {\htmladdnormallink{#1}{http://docstore.mik.ua/orelly/perl/cookbook/#2}}
 
\newcommand{\pci}[1]
  {\index{Práctica!#1}}
 
\newcommand{\ci}[1]
  {\index{#1}#1}
 
\newcommand{\cei}[1]
  {\index{#1}\emph{#1}}

\newcommand{\ceis}[2]
  {\index{#2}\emph{#1}}

\newcommand{\tei}[1]
  { {\tt #1} } %{\index{#1}{{\tt #1}}}

\newcommand{\htei}[1]
  { #1 } %{\index{#1}}


\newcommand{\teis}[2]
  {\index{#2}{{\tt #1}}}

\newcommand{\xsub}[1]
  {\index{XSUB!{\tt #1}}
   {\tt #1}
  }

\newcommand{\typemap}[1]
  {\index{typemap!{\tt #1}}
   {\tt #1}
  }

\newcommand{\api}[1]
  {\index{Perl API!{\tt #1}}
   {\tt #1}
  }

%%%%%%%%%%%%%% 
\newcommand{\hueco}[1]
  {\underline{\hspace{#1cm}}}

\newcommand{\parrafo}[1]
{ 
  \paragraph{#1}
  \begin{tabular}{c}
  \end{tabular}
}

\newcommand{\sectionpractica}[1]
  {\section{Práctica: #1}
   \index{Práctica!#1}
  }

\newcommand{\subsectionpractica}[1]
  {\subsection{Práctica: #1}
   \index{Práctica!#1}
  }

\newcommand{\subsubsectionpractica}[1]
  {\subsubsection{Práctica: #1}
   \index{Práctica!#1}
  }

\newcommand{\sectionejercicio}[1]
  {\section{Ejercicio: #1}
   \index{Ejercicio!#1}
  }

\newcommand{\parrafopractica}[1]
  {\parrafo{Práctica: #1}
   \index{Práctica!#1}
  }

\newcommand{\subsectionejercicio}[1]
  {\subsection{Ejercicio: #1}
   \index{Ejercicio!#1}
  }

\newcommand{\subsubsectionejercicio}[1]
  {\subsubsection{Ejercicio: #1}
   \index{Ejercicio!#1}
  }


\newcommand{\subsectionrepaso}[1]
  {\subsection{Repaso: #1}
   \index{Repaso!#1}
  }

\newcommand{\eref}[1]
  {\externalref{#1} \cite{CasianoIntroAPerl}}

\newcommand{\regexpg}{\cpan{Regexp::Grammars}}

\newcommand{\rgsec}[2]
 {\htmladdnormallink{#1}
 {http://search.cpan.org/~dconway/Regexp-Grammars/lib/Regexp/Grammars.pm\##2}}

\newtheorem{definition}{Definición}[section] 
\newtheorem{theorem}{Teorema}[section] 
\newtheorem{algorithm}{Algoritmo}[section] 
\newtheorem{program}{Programa}[section] 
\newtheorem{exercise}{Ejercicio}[section] 
%\newtheorem{lab}{Práctica \addcontentsline{toc}{section}{hola}}[section] 

\newtheorem{example}{Ejemplo}[section] 
\newtheorem{execution}{Ejecución}[section] 
\newtheorem{listing}{Listado}[section] 
\newtheorem{advice}{Consejo}[section] 
\newtheorem{scheme}{Esquema}[section] 

\newenvironment{unicodeverb}
{\begin{htmlonly}\begin{verbatim}}
{\end{verbatim}\end{htmlonly}}

%\newcommand{bcita}[0]
%{\begin{it}\begin{quote}}
%
%\newcommand{ecita}{[0]
%{\end{quote}\end{it}}}

\newcommand{\modern}{{\it Modern Perl}}

\newcommand{\lhp}[2]
{\htmladdnormallink{#1}
{http://nereida.deioc.ull.es/~lhp/perlexamples/node#2.html}}

\newcommand{\man}[1]
{\htmladdnormallink{{\tt #1}}
{http://manpages.debian.net/cgi-bin/man.cgi?query=#1}}

\newcommand{\manuk}[1]
{\htmladdnormallink{{\tt #1}}
{http://unixhelp.ed.ac.uk/CGI/man-cgi?#1}}

\newcommand{\mandragonfly}[1]
{\htmladdnormallink{{\tt #1}}
{http://leaf.dragonflybsd.org/cgi/web-man?command=#1&section=ANY}}

\newcommand{\manopenbsd}[1]
{\htmladdnormallink{{\tt #1}}
{http://www.openbsd.org/cgi-bin/man.cgi?query=#1}}

\newcommand{\link}[2]
{\htmladdnormallink{#1}
{#2}}


\newcommand{\cpan}[1]
 {\htmladdnormallink{{\tt #1}}
 {http://search.cpan.org/perldoc?#1}}

%%%%%%%%%%%%%%%%%% git
\newcommand{\githelp}[2]
 {\htmladdnormallink{#1}
 {http://help.github.com/#2/}}

\newcommand{\github}
 {\htmladdnormallink{GitHub}
 {http://help.github.com}}
%%%%%%%%%%%%%%%%%% javascript
\newcommand{\npm}
 {\htmladdnormallink{{\tt npm}}
 {https://npmjs.org/}}

\newcommand{\npmdoc}[1]
 {\htmladdnormallink{{\tt #1}}
 {https://npmjs.org/doc/#1.html}}

\newcommand{\ebnfparser}
 {\htmladdnormallink{{\tt ebnf-parser}}
 {https://github.com/zaach/ebnf-parser}}


\newcommand{\markdown}
 {\htmladdnormallink{{\tt markdown}}
 {http://daringfireball.net/projects/markdown/syntax}}

%%%%%%%%%%%%%%%%% ruby
\newcommand{\rake}
 {\htmladdnormallink{{\tt Rake}}
 {http://rake.rubyforge.org/}}

\newcommand{\rbp}
 {\htmladdnormallink{{\tt Ruby Best Practices}}
 {http://www.humbug.in/docs/ruby-best-practices/index.html} \cite{RBP}}

\newcommand{\rspec}
 {\htmladdnormallink{{\tt RSpec}}
 {http://rspec.info/}}

\newcommand{\rubyforge}[2]
 {\htmladdnormallink{#1}
 {http://rake.rubyforge.org/classes/#2}}

\newcommand{\rubygems}
 {\htmladdnormallink{{\tt RubyGems.org}}
 {https://rubygems.org/}}

\newcommand{\gem}
 {\htmladdnormallink{{\tt gems}}
 {http://docs.rubygems.org/read/book/2}}

\newcommand{\webrick}{\htmladdnormallink{{\tt Webrick}}{http://naupacto.com/rubydoc/guiaWEBrick/index.html}}
\newcommand{\shotgun}{\htmladdnormallink{{\tt Shotgun}}{http://ruby.about.com/od/sinatra/a/sinatra5.htm}}

\newcommand{\rubymod}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/#1.html}}

\newcommand{\String}
 {\htmladdnormallink{{\tt String}}
 {http://www.ruby-doc.org/core-1.9.3/String.html}}

\newcommand{\Symbol}
 {\htmladdnormallink{{\tt Symbol}}
 {http://www.ruby-doc.org/core-1.9.3/Symbol.html}}

\newcommand{\Proc}
 {\htmladdnormallink{{\tt Proc}}
 {http://www.ruby-doc.org/core-1.9.3/Proc.html}}

\newcommand{\Method}
 {\htmladdnormallink{{\tt Method}}
 {http://www.ruby-doc.org/core-1.9.3/Method.html}}

\newcommand{\UnboundMethod}
 {\htmladdnormallink{{\tt UnboundMethod}}
 {http://www.ruby-doc.org/core-1.9.3/UnboundMethod.html}}

\newcommand{\Binding}
 {\htmladdnormallink{{\tt Binding}}
 {http://www.ruby-doc.org/core-1.9.3/Binding.html}}

\newcommand{\Kernel}
 {\htmladdnormallink{{\tt Kernel}}
 {http://www.ruby-doc.org/core-1.9.3/Kernel.html}}

\newcommand{\BasicObject}
 {\htmladdnormallink{{\tt BasicObject}}
 {http://www.ruby-doc.org/core-1.9.3/BasicObject.html}}

\newcommand{\Object}
 {\htmladdnormallink{{\tt Object}}
 {http://www.ruby-doc.org/core-1.9.3/Object.html}}

\newcommand{\Enumerable}
 {\htmladdnormallink{{\tt Enumerable}}
 {http://www.ruby-doc.org/core-1.9.3/Enumerable.html}}

\newcommand{\Class}
 {\htmladdnormallink{{\tt Class}}
 {http://www.ruby-doc.org/core-1.9.3/Class.html}}

\newcommand{\Module}
 {\htmladdnormallink{{\tt Module}}
 {http://www.ruby-doc.org/core-1.9.3/Module.html}}

\newcommand{\rubycoreclassmethod}[2]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/#2.html\#method-c-#1}}

\newcommand{\rubycoreinstancemethod}[2]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/#2.html\#method-i-#1}}

\newcommand{\modulec}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Module.html\#method-c-#1}}

\newcommand{\classi}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Class.html\#method-i-#1}}

\newcommand{\modulei}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Module.html\#method-i-#1}}

\newcommand{\modulep}[1]
 {\index{#1?}\htmladdnormallink{{\tt #1?}}
 {http://www.ruby-doc.org/core-1.9.3/Module.html\#method-i-#1-3F}}

\newcommand{\symboli}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Symbol.html\#method-i-#1}}

\newcommand{\kerneli}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Kernel.html\#method-i-#1}}

\newcommand{\objecti}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Object.html\#method-i-#1}}

\newcommand{\methodi}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Method.html\#method-i-#1}}

\newcommand{\proci}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Proc.html\#method-i-#1}}

\newcommand{\unboundmethodi}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/UnboundMethod.html\#method-i-#1}}

\newcommand{\bindingi}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/Binding.html\#method-i-#1}}

\newcommand{\basicobjecti}[1]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/core-1.9.3/BasicObject.html\#method-i-#1}}

\newcommand{\rubyclass}[2]
 {\index{#1}\htmladdnormallink{{\tt #1}}
 {http://ruby-doc.org/core-1.9.3/#2.html}}

\newcommand{\rubystdlibclass}[2]
 {\htmladdnormallink{{\tt #1}}
 {http://ruby-doc.org/stdlib-1.9.3/libdoc/#2.html}}

\newcommand{\rubypackage}[1]
 {\htmladdnormallink{{\tt #1}}
 {http://www.ruby-doc.org/stdlib-1.9.3/libdoc/#1/rdoc/}}

\newcommand{\rdoc}
 {\htmladdnormallink{{\tt RDoc}}
 {http://rdoc.sourceforge.net/doc/index.html}}

\newcommand{\ERB}
 {\htmladdnormallink{{\tt ERB}}
 {http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html}}

%%%%%%%%%%%%%%%%% end ruby

\newcommand{\cpanf}[2]
 {\htmladdnormallink{#2}
 {http://search.cpan.org/perldoc?#1\##2}}

\newcommand{\gnereida}[1]
 {\htmladdnormallink{#1}
 {http://www.google.es/search?q=site:nereida.deioc.ull.es+#1&ie=UTF-8&hl=es}}

\newcommand{\gdefine}[1]
 {\htmladdnormallink{#1}
 {http://www.google.com/search?q=define:#1}}

\newcommand{\googlecode}[1]
 {\htmladdnormallink{#1}
 {http://code.google.com/p/#1/}}

\newcommand{\perldocf}[1]
{\htmladdnormallink{{\tt #1}}
{http://www.ayni.com/perldoc/functions/#1.html}}

\newcommand{\perldoc}[1]
{\htmladdnormallink{{\tt #1}}
{http://search.cpan.org/perldoc/?#1}}

\newcommand{\vim}{\htmladdnormallink{{\tt vim}}{http://www.vim.org/}}

\newcommand{\vimdoc}[2]
{\htmladdnormallink{{\tt #1}}
{http://vimdoc.sourceforge.net/htmldoc/#2}}

\newcommand{\pd}[2]
{la sección '#2' en \htmladdnormallink{{\tt #1}}
{http://perldoc.perl.org/#1.html\##2}}

\newcommand{\wikipedia}[2]
{\htmladdnormallink{#1}
{http://en.wikipedia.org/wiki/#1}}

\newcommand{\wikip}[2]
{\htmladdnormallink{#1}
{http://en.wikipedia.org/wiki/#2}}


\newcommand{\perlmonk}[1]
{\htmladdnormallink{PerlMonks}
{http://www.perlmonks.org/?node_id=#1}}

\newcommand{\pmm}[2]
{\htmladdnormallink{#2}
{http://www.perlmonks.org/?node_id=#1}}


\newcommand{\code}[1]
  {{\tt #1}}

\newcommand{\perlmarkmail}[1]
{\htmladdnormallink{#1}
{http://perl.markmail.org/search/?q=#1}}

\newcommand{\cpandist}[1]
{\htmladdnormallink{{\tt #1}}
{http://search.cpan.org/dist/#1}}

\newcommand{\I}[1]
  {{\it #1}}

%http://svnbook.red-bean.com/nightly/en/svn.branchmerge.basicmerging.html
\newcommand{\svnbook}[2]{\htmladdnormallink{#1}{http://svnbook.red-bean.com/nightly/en/#2.html}}
%\newcommand{\svnbook}[2]{\htmladdnormallink{#1}{http://svnbook.red-bean.com/en/1.5/#2.html}}
\newcommand{\svnb}[2]{\htmladdnormallink{#1}{http://svnbook.red-bean.com/en/1.5/#2}}

%%% TEXEXPAND: END FILE ./booktt/commontex/commands.tex

%\pagestyle{empty}
\pagestyle{plain} %each page number

%\input{amssym.def}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Apuntes de la Asignatura Procesadores de Lenguajes\
  }
\author{Casiano R. León \thanks{DEIOC Universidad de La Laguna}}
%%%%5   \date{\normalsize\today}

\makeindex

%%%%%%%%%%%%%%%%012345678012345678

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=35 
                 alt="PL"
                ]
     {logoLPP.png}}
     {http://nereida.deioc.ull.es/~plgrado/index.html}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=50 
                 alt="PL moodle"
                ]
     {moodleLHPlogo.jpeg}}
     {http://campusvirtual.ull.es/1213m2/course/view.php?id=271}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=30 
                 alt="ps"
                ]
     {gv.jpeg}}
     {javascriptexamples.pdf}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=60 
                 alt="ruby gems"
                ]
     {lupa.gif}}
     {https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=30 
                 alt="perldoc"
                ]
     {perlonion.jpeg}}
     {https://developer.mozilla.org/es/docs/JavaScript}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=27 
                 alt="google code project hosting"
                ]
     {google-code-project-hosting.jpeg}}
     {http://github.com}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=27 
                 alt="blogs"
                ]
     {perl6.jpg}}
     {http://jquery.com/}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=35 
                 alt="google"
                ]
     {ggoogle.gif}}
     {http://www.google.es/}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=35 
                 alt="etsii"
                ]
     {etsii.png}}
     {http://www.ull.es/view/centros/etsii/Grado/es}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=35 
                 alt="ull"
                ]
     {ull.gif}}
     {http://www.ull.es/}} 

  \htmladdtonavigation{\htmladdnormallink{
     \htmladdimg[
                 width=32 
                 alt="pcgull"
                ]
     {logopcgull.gif}}
     {http://crondinosaur.blogspot.com/}} 





\begin{document}

\topmargin=5pt
\maketitle


\tableofcontents 
\listoffigures
\listoftables


\chapter*{A Juana}
\vspace{8cm}
{\it
\begin{Large}
\begin{verse}
\flushright 
For it is in teaching that we learn\\
And it is in understanding that we are understood
\end{verse}
\end{Large}
}

\chapter*{Agradecimientos/Acknowledgments}
\begin{verse}
\flushright \it
I'd like to thank 
%\vspace{2cm}
%\vspace{2cm}

A mis alumnos de 
Procesadores de Lenguajes del Grado de Informática
de la Escuela Superior de Informática en la Universidad de La Laguna
\end{verse}




\part{PRIMERA PARTE: APUNTES DE JAVASCRIPT}

%1 edit chapter1/chapter1.erb
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter1/chapter1.tex
% Never edit chapter1.tex!!. Edit chapter1.erb or changes may
% dissapear
\chapter{Introducción}


\chapter{Estructura Léxica}


\chapter{Tipos, Valores y Variables}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter1/tipos_valores_y_variables.tex
%%% TEXEXPAND: END FILE ./chapter1/tipos_valores_y_variables.tex

\chapter{Expresiones y Operadores}

\chapter{Sentencias}

\chapter{Objetos}

\section{Tutoriales de OOP en JavaScript en la Web}

\begin{enumerate}
\item
\htmladdnormallink{The Basics of Object-Oriented JavaScript
Leigh Kaszick on Nov 11th 2009}{http://net.tutsplus.com/tutorials/javascript-ajax/the-basics-of-object-oriented-javascript/} en NetTuts+
\item 
\htmladdnormallink{Understanding JavaScript OOP}{http://killdream.github.com/blog/2011/10/understanding-javascript-oop/} por Quildreen Motta.
\item 
\htmladdnormallink{Object.defineProperty(obj, prop, descriptor)}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty}
\item 
\htmladdnormallink{What is the 'new' keyword in JavaScript?}{http://stackoverflow.com/questions/1646698/what-is-the-new-keyword-in-javascript}
\item 
\htmladdnormallink{Constructors considered mildly confusing}{http://joost.zeekat.nl/constructors-considered-mildly-confusing.html}
\item
\htmladdnormallink{Google I/O 2011: Learning to Love JavaScript}{http://youtu.be/seX7jYI96GE}
por Alex Russell, Mayo 2011. ¡Excelente!
\end{enumerate}

\section{Ejercicios}

\begin{enumerate}
\item  ¿Cual es la salida?
\begin{verbatim}
> z
{ x: 3, y: 1 }
> Object.keys(z)
?????
> Object.keys(z).forEach(function(i) { console.log(i+" -> "+z[i]); })
?????
\end{verbatim}

\item  ¿Que queda finalmente en \verb|z|?
\begin{verbatim}
> z
{ x: 2, y: 1 }
> Object.defineProperty(z, 'y', {writable : false})
{ x: 2, y: 1 }
> z.x = 3
??????
> z.y = 2
??????
> z

\end{verbatim}

\item  ¿Cuales son las salidas?
\begin{verbatim}
> obj = { x : 1, y : 2}
{ x: 1, y: 2 }
> bValue = 5
5
> Object.defineProperty(obj, "b", {get: function(){ return bValue; }, 
                                   set: function(y){ bValue = y; }}) 
{ x: 1, y: 2 }
> obj.b = "hello"

> bValue

> obj.b

> bValue = "world"

> obj.b

> 

\end{verbatim}
\item 
¿Cuales son las salidas?
\begin{verbatim}
> var o = {};
undefined
> Object.defineProperty(o, "a", { value : 1, enumerable:true });
{ a: 1 }
> Object.defineProperty(o, "b", { value : 2, enumerable:false });
{ a: 1 }
> Object.defineProperty(o, "c", { value : 3 }); // enumerable defaults to false
{ a: 1 }
> o.d = 4; // enumerable defaults to true when creating a property by setting it
4
>  
undefined
> for (var i in o) {    
...   console.log(i);  
... }
???????
> Object.keys(o); 
???????
> o.propertyIsEnumerable('a'); 
????
> o.propertyIsEnumerable('b');
????
> o.propertyIsEnumerable('c');
????
> o.b
????
> o["b"]
????
\end{verbatim}
\item 
\begin{verbatim}
> function foo(a, b){return a * b;}
undefined
> f = function foo(a, b){return a * b;}
[Function: foo]
> foo.length
2
> foo.constructor
[Function: Function]
> foo.prototype
{}
> typeof foo.prototype
'object'
> [1, 2].constructor
[Function: Array]
\end{verbatim}
\item  ¿Cuales son las salidas? 
\begin{verbatim}
> Object.getPrototypeOf({ a: 1})

> Object.getPrototypeOf([1,2,3])

> Object.getPrototypeOf([1,2,3]) == Array.prototype

> Object.getPrototypeOf({ a:1 }) === Object.prototype

> Object.getPrototypeOf(Array.prototype)

> Object.getPrototypeOf(Object.prototype)

> Object.getPrototypeOf(function() {})

> Object.getPrototypeOf(Object.getPrototypeOf(function() {}))

> [1,2,3].__proto__

> [1,2,3].__proto__ == Array.prototype


\end{verbatim}
\end{enumerate}

\begin{figure}[htb]
\begin{center}
% \includegraphics[scale=1.2]{chapter1/javascript_natives.png}
\centerline{\epsfig{file=chapter1/javascript_natives.eps, width=12cm}}
\end{center}
\label{figure:javascriptnatives}
\caption{Jerarquía de Prototipos Nativos}
\end{figure}

% \begin{figure}[htb]
% \centerline{\epsfig{file=chapter1/javascript_natives.eps, height=14cm}}
% \caption{Jerarquía de Prototipos Nativos}
% \label{figure:javascriptnatives}
% \end{figure}

\begin{verbatim}
var b = new Foo(20);
var c = new Foo(30);
\end{verbatim}
\begin{figure}[htb]
\begin{center}
% \includegraphics[scale=1]{chapter1/proto_and_prototypes.png}
\centerline{\epsfig{file=chapter1/proto_and_prototypes.eps, width=12cm}}
\end{center}
\label{figure:javascriptnatives}
\caption{\_\_proto\_\_ and prototypes}
\end{figure}

\section{Comprobando Propiedades}

\begin{verbatim}
> o = { x: 1}
{ x: 1 }
> "x" in o
true
> "y" in o
false
> "toString" in o
true
> o.hasOwnProperty('x')
true
> o.hasOwnProperty('toString')
false
\end{verbatim}

\section{Enumeración de Propiedades}

\begin{verbatim}
> o = { x: 1 }
{ x: 1 }
> b = Object.create(o)
{}
> b.y = 2
2
> b.propertyIsEnumerable('x')
false
> b.propertyIsEnumerable('y')
true
> Object.prototype.propertyIsEnumerable('toString')
false
> a = {x:1, y:2 }
{ x: 1, y: 2 }
> b = Object.create(a)
{}
> b.z = 3
3
> for(i in b) console.log(b[i])
3
1
2
undefined
> for(i in b) console.log(i)
z
x
y
undefined
> b.propertyIsEnumerable("toString")
false
\end{verbatim}

\chapter{Arrays}

\chapter{Funciones}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_funciones/funciones.tex
\section{Definiendo Funciones}

\section{Invocando Funciones}

\section{Argumentos y Parámetros}

\section{Funciones como Valores}

\section{Funciones como Espacios de Nombres}

\section{Clausuras}

\section{Propiedades, Métodos y Constructor}

\subsection{La propiedad {\tt length}}

\subsection{La Propiedad {\tt property}}

\subsection{Los Métodos {\tt call} y {\tt apply}}
\label{subsection:callyapply}
Los métodos \tei{call} y \tei{apply} nos permiten
invocar una función como si fuera un método de algún otro 
objeto.

\begin{verbatim}
[~/Dropbox/src/javascript/learning]$ cat call.js 
var Bob = {
  name: "Bob",
  greet: function() {
    console.log("Hi, I'm " + this.name);
  }
}
 
var Alice = {
  name: "Alice",
};

Bob.greet.call(Alice);
\end{verbatim}

\begin{verbatim}
[~/Dropbox/src/javascript/learning]$ node call.js
Hi, I'm Alice
\end{verbatim}

\section{Programación Funcional}

%%% TEXEXPAND: END FILE ./chapter_funciones/funciones.tex

\chapter{Clases y Módulos}
Véase el libro {\it Learning JavaScript Design Pattern}
\cite{osmani2012learning}

\section{Herencia}

\begin{verbatim}
[~/Dropbox/src/javascript/inheritance]$ cat inh1.js 
//Shape - superclass
function Shape() {
  this.x = 0;
  this.y = 0;
}
 
Shape.prototype.toString = function() {
  return "("+this.x+", "+this.y+")";
}

Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info("Shape moved to "+this);
};
 
// Rectangle - subclass
function Rectangle() {
  Shape.call(this); //call super constructor.
}
 
// Rectangle inherits from Shape
Rectangle.prototype = Object.create(Shape.prototype);
 
var rect = new Rectangle();
 
console.log("x = "+rect);
console.log("rect is an instance of Rectangle? "+(rect instanceof Rectangle)) //true.
console.log("rect is an instance of Shape? "+(rect instanceof Shape))         //true.
 
rect.move(1, 2); //Outputs, "Shape moved."
\end{verbatim}

\begin{verbatim}
[~/Dropbox/src/javascript/inheritance]$ node inh1.js 
x = (0, 0)
rect is an instance of Rectangle? true
rect is an instance of Shape? true
Shape moved to (1, 2)

\end{verbatim}

\subsection{call y apply}

\begin{enumerate}
\item 
\htmladdnormallink{Function.apply and Function.call in JavaScript}{http://odetocode.com/blogs/scott/archive/2007/07/05/function-apply-and-function-call-in-javascript.aspx}
\begin{verbatim}
> function f() { console.log(this.x); }
undefined
> f.toString()
'function f() { console.log(this.x); }'
> z = { x : 99 }
{ x: 99 }
> f.call(z)
99
undefined
> 
\end{verbatim}
\item 
\begin{verbatim}
> o  = { x : 15 }
{ x: 15 }
> function f(m) { console.log(m+" "+this.x); }
undefined
> f("invoking f")
invoking f 10
undefined
> f.call(o, "invoking f via call");
invoking f via call 15
undefined
\end{verbatim}
\end{enumerate}

\section{Ejercicios}
\begin{enumerate}
\item ¿Cual es la salida?
\begin{verbatim}
> String.prototype.repeat = function(times) {
...   return new Array(times+1).join(this)
... }
[Function]
>  
undefined
> "hello".repeat(3)

> 
\end{verbatim}

\item  ¿Cuales son los resultados?
\begin{verbatim}
> z = Object.create({x:1, y:2})
{}
> z.x

> z.y

> z.__proto__

> z.__proto__.__proto__

> z.__proto__.__proto__.__proto__

\end{verbatim}
\item 
Describa las salidas:
\begin{verbatim}
> obj = {x : 'something' }
{ x: 'something' }
> w = Object.create(obj)
{}
> w.x
'something'
> w.x = "another thing"
'another thing'
> w.__proto__

> obj == w.__proto__

\end{verbatim}
\item 
Explique la salida:
\begin{verbatim}
> obj = {x : { y : 1} }
{ x: { y: 1 } }
> w = Object.create(obj)
{}
> w.x == obj.x
true
> w.x.y = 2
2
> obj
{ x: { y: 2 } }
> 
\end{verbatim}
\item 
Explique las salidas:
\begin{verbatim}
> inherit = Object.create
[Function: create]
> o = {}
{}
> o.x = 1
1
> p = inherit(o)
{}
> p.x
1
> p.y = 2
2
> p
{ y: 2 }
> o
{ x: 1 }
> o.y
undefined
> q = inherit(p)
{}
> q.z = 3
3
> q
{ z: 3 }
> s = q.toString()
'[object Object]'
> q.x+q.y+q.z
6
> o.x
1
> o.x = 4
4
> p.x
4
> q.x
4
> q.x = 5
5
> p.x
4
> o.x
4
\end{verbatim}
\end{enumerate}


\chapter{Subconjuntos y Extensiones de JavaScript}

\chapter{JavaScript en el Lado del Servidor}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_node/node.tex
Node es un intérprete JavScript escrito en C++ y con una API ligada a
Unix para trabajar con procesos, fichero, sockets, etc.  Los programas
Node por defecto nunca se bloquean. Node utiliza manejadores de eventos
que a menudo se implementan haciendo uso de funciones anidadas  y
clausuras.


\section{Instalar Node.js}
\begin{enumerate}
\item \htmladdnormallink{http://nodejs.org/download/}{http://nodejs.org/download/}
\item 
\htmladdnormallink{Should I install node.js on Ubuntu using package manager or from source?}{http://stackoverflow.com/questions/13845321/should-i-install-node-js-on-ubuntu-using-package-manager-or-from-source}
\item 
\htmladdnormallink{The Node Beginner Book}{http://www.nodebeginner.org/}
\end{enumerate}


\section{Primeros Pasos. Un Ejemplo Simple}
\begin{verbatim}
[~/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ cat -n hello_world.js 
     1  console.log("Hello world!");
     2  a = [ 'batman', 'robin'];
     3  a.push("superman");
     4  console.log(a);
     5  h = { name: 'jane rodriguez-leon', department: 'IT' };
     6  console.log(h);
     7  console.log(h['name']);
\end{verbatim}

\begin{verbatim}
[~/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ node hello_world.js 
Hello world!
[ 'batman', 'robin', 'superman' ]
{ name: 'jane rodriguez-leon', department: 'IT' }
jane rodriguez-leon
\end{verbatim}

\begin{verbatim}
[~/Dropbox/academica/ETSII/grado/LPP/LPPbook]$ node
> .help
.break  Sometimes you get stuck, this gets you out
.clear  Alias for .break
.exit Exit the repl
.help Show repl options
.load Load JS from a file into the REPL session
.save Save all evaluated commands in this REPL session to a file

> console.log("Hello world!")
Hello world!
undefined
> a = [ 'batman', 'robin']
[ 'batman', 'robin' ]
> a.push("superman")
3
> a
[ 'batman', 'robin', 'superman' ]
> h = { name: 'jane rodriguez-leon', department: 'IT' }
{ name: 'jane rodriguez-leon',
  department: 'IT' }
> h['name']
'jane rodriguez-leon'
> 4+2
6
> _    # ultimo valor evaluado
6
> _+1
7
> 
> a = [1,2,3]
[ 1, 2, 3 ]
> a.forEach(function(e) { console.log(e); })
1
2
3
> a.forEach(function(v) {
... console.log(v
..... .break
> a
[ 1, 2, 3 ]
> .exit # también CTRL-D en Unix
[~/Dropbox/academica/ETSII/grado/LPP/LPPbook]$ 
\end{verbatim}

\section{Usando REPL desde un programa}

Es posible crear un bucle REPL en cualquier punto de nuestro programa - quizá para depurarlo.
Para ello usamos la función 
\tei{repl.start}.
Esta función retorna una instancia REPLServer. Acepta como argumento un objeto
\verb"options" que toma los siguientes valores:

\begin{enumerate}
\item \verb|prompt| - the prompt and stream for all I/O. Defaults to > .
\item \verb|input| - the readable stream to listen to. Defaults to process.stdin.
\item \verb|output| - the writable stream to write readline data to. Defaults to process.stdout.
\item \verb|terminal| - pass true if the stream should be treated
like a TTY, and have ANSI/VT100 escape codes written to it. Defaults
to checking isTTY on the output stream upon instantiation.
\item \verb|eval| - function that will be used to eval each given
line. Defaults to an async wrapper for eval(). 
\item \verb|useColors| - a boolean which specifies whether or not
the writer function should output colors. If a different writer
function is set then this does nothing. Defaults to the repl's
terminal value.
\item \verb|useGlobal| - if set to true, then the repl will use the
global object, instead of running scripts in a separate context.
Defaults to false.
\item \verb|ignoreUndefined| - if set to true, then the repl will
not output the return value of command if it's undefined. Defaults
to false.
\item \verb|writer| - the function to invoke for each command that
gets evaluated which returns the formatting (including coloring)
to display. Defaults to util.inspect.
\end{enumerate}

\begin{verbatim}
[~/Dropbox/src/javascript/node.js/repl(master)]$ cat repl.js 
var repl = require("repl");

connections = 0;

repl.start({
  prompt: "node via stdin> ",
  input: process.stdin,
  output: process.stdout
});
\end{verbatim}

\begin{verbatim}
[~/Dropbox/src/javascript/node.js/repl(master)]$ node repl.js 
node via stdin> 2+3
5
node via stdin> .exit
\end{verbatim}

el bucle REPL proporciona acceso a las variables de ámbito global. Es posible
hacer explícitamente visible una variable al REPL asignándosela al
\verb|context| asociado con el
REPLServer. Por ejemplo:

\begin{verbatim}
[~/Dropbox/src/javascript/node.js/repl(master)]$ cat repl2.js 
var repl = require("repl");

z = 4
repl.start({
  prompt: "node via stdin> ",
  input: process.stdin,
  output: process.stdout
}).context.m = "message";
\end{verbatim}
Las variables en el objeto \verb|context| se ven como locales 
al  REPL:

\begin{verbatim}
[~/Dropbox/src/javascript/node.js/repl(master)]$ node repl2.js 
node via stdin> z
4
node via stdin> m
'message'

\end{verbatim}

\section{Usando REPL via un socket TCP}
\begin{verbatim}
[~/Dropbox/src/javascript/node.js/repl(master)]$ cat repl_server.js 
var net = require("net"),
    repl = require("repl");

connections = 0;

net.createServer(function (socket) {
  connections += 1;
  repl.start({
    prompt: "node via TCP socket> ",
    input: socket,
    output: socket
  }).on('exit', function() {
    socket.end();
  });
}).listen(5001);

[~/Dropbox/src/javascript/node.js/repl(master)]$ node repl_server.js 

\end{verbatim}

Podemos ahora usar \cei{netcat} para comunicar con el servidor:
\begin{verbatim}
[~/Dropbox/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ nc -v localhost 5001
nc: connect to localhost port 5001 (tcp) failed: Connection refused
Connection to localhost 5001 port [tcp/commplex-link] succeeded!
node via TCP socket> a = 2+3
5
node via TCP socket> a
5
node via TCP socket> .exit
[~/Dropbox/src/javascript/node.js/hector_correa_introduction_to_node(master)]$ 
\end{verbatim}

\section{Referencias sobre REPL}

\begin{enumerate}
\item 
Véase \htmladdnormallink{Node.js v0.8.18 Manual \& Documentation}{http://nodejs.org/api/repl.html}
\item 
Véase \htmladdnormallink{How do I use node's REPL?}{http://docs.nodejitsu.com/articles/REPL/how-to-use-nodejs-repl} en \htmladdnormallink{http://docs.nodejitsu.com/}{http://docs.nodejitsu.com/}.
\end{enumerate}

\section{Entrada Salida en Node.js}

\begin{enumerate}
\item 
\htmladdnormallink{How To Read User Input With NodeJS}{http://st-on-it.blogspot.com.es/2011/05/how-to-read-user-input-with-nodejs.html} por Nikolay V. Nemshilov
\end{enumerate}

\section{Debugger}

\begin{enumerate}
\item 
\htmladdnormallink{Node.js debugger}{http://nodejs.org/api/debugger.html}
\end{enumerate}

\section{Modulos}
%http://nodejs.org/api/modules.html#loading_from_node_modules_Folders
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter1/modulos.tex
\subsection{Introducción}

\begin{verbatim}
[~/javascript/node.js/creating_modules(master)]$ cat foo.js 
var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));
\end{verbatim}

\begin{verbatim}
[~/javascript/node.js/creating_modules(master)]$ cat circle.js 
var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
\end{verbatim}

\begin{verbatim}
[~/javascript/node.js/creating_modules(master)]$ node foo.js The area of a circle of radius 4 is 50.26548245743669
\end{verbatim}

El módulo \verb|circle.js| exporta las funciones \verb|area()| 
y \verb|circumference()|. Para exportar un objeto lo añadimos 
al objeto expecial \verb|exports|.

Las variables locales al módulo serán privadas.
En este ejemplo la variable \verb|PI| es privada a \verb|circle.js|.

\begin{verbatim}
[~/javascript/node.js/creating_modules(master)]$ node debug foo.js 
< debugger listening on port 5858
connecting... ok
break in foo.js:1
  1 var circle = require('./circle.js');
  2 console.log( 'The area of a circle of radius 4 is '
  3            + circle.area(4));
debug> n
break in foo.js:2
  1 var circle = require('./circle.js');
  2 console.log( 'The area of a circle of radius 4 is '
  3            + circle.area(4));
  4 
debug> repl
Press Ctrl + C to leave debug repl
> circle
{ circumference: [Function],
  area: [Function] }
> circle.area(2)
12.566370614359172
> PI
ReferenceError: PI is not defined
> 
\end{verbatim}

\subsection{Ciclos}

\begin{verbatim}
[~/javascript/node.js/creating_modules/cycles(master)]$ cat a.js
console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');
\end{verbatim}

\begin{verbatim}
[~/javascript/node.js/creating_modules/cycles(master)]$ cat b.js
console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');
\end{verbatim}

\begin{verbatim}
[~/javascript/node.js/creating_modules/cycles(master)]$ cat main.js
console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);
\end{verbatim}
When \verb|main.js| loads \verb|a.js|, then \verb|a.js| in turn loads
\verb|b.js|. At that point, \verb|b.js| tries to load \verb|a.js|. In
order to prevent an infinite loop an unfinished copy of the \verb|a.js|
exports object is returned to the \verb|b.js| module. \verb|b.js| then
finishes loading, and its exports object is provided to the \verb|a.js|
module.

By the time \verb|main.js| has loaded both modules, they're both finished. The
output of this program would thus be:

\begin{verbatim}
[~/javascript/node.js/creating_modules/cycles(master)]$ node main.js 
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
\end{verbatim}

\subsection{Especificación de Ficheros Conteniendo Módulos}

\begin{enumerate}
\item If the exact filename is not found, then node will attempt to
load the required filename with the added extension of \verb|.js|,
\verb|.json|, and then \verb|.node|.

\item
\verb|.js| files are interpreted as JavaScript text files, and \verb|.json| files are parsed as JSON text files. \verb|.node| files are interpreted as compiled addon modules 

\item
A module prefixed with \verb|'/'| is an absolute path to the file. For example,
\verb|require('/home/marco/foo.js')| will load the file at \verb|/home/marco/foo.js|.

\item
A module prefixed with \verb|'./'| is relative to the file calling require(). 

\item
Without a leading verb|'/'| or \verb|'./'| to indicate a file, the module is either a 
\cei{core module} or is loaded from a \verb|node_modules| folder.

\item
If the given path does not exist, \verb|require()| 
will throw an Error with its code property set to \verb'MODULE_NOT_FOUND'.
\end{enumerate}

\subsection{Carga desde Carpetas {\tt node\_modules}}

\begin{enumerate}
\item
If the module identifier passed to \verb|require()| is not a native module,
and does not begin with \verb|'/'|, \verb|'../'|, or \verb|'./'|, then node starts at the
parent directory of the current module, and adds \verb|/node_mo1dules|, and
attempts to load the module from that location.

\item
If it is not found there, then it moves to the parent directory, and so
on, until the root of the tree is reached.
\end{enumerate}

For example, if the file at \verb|'/home/ry/projects/foo.js'| called
require(\verb|'bar.js'|), then node would look in the following locations,
in this order:

\begin{verbatim}
/home/ry/projects/node_modules/bar.js
/home/ry/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
\end{verbatim}

This allows programs to localize their dependencies, so that they do not clash.

\subsection{Las Carpetas Usadas Como Módulos}
It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library. 

There
are a few ways in which a folder may be passed to \verb|require()| as an
argument.

\begin{enumerate}
\item
The first is to create a \verb|package.json| file in the root of the
folder, which specifies a \verb|main| module. 
An example \verb|package.json| file
might look like this:

\begin{verbatim}
{ "name" : "some-library",
  "main" : "./lib/some-library.js" }
\end{verbatim}

If this was in a folder at 
\verb|./some-library|, then \verb|require('./some-library')| would attempt
to load \verb|./some-library/lib/some-library.js|.

This is the extent of Node's awareness of \verb|package.json| files.

\item
If there is no \verb|package.json| 
file present in the directory, then node will
attempt to load an 
\verb|index.js| or
\verb|index.node| 
file out of that directory. 

For
example, if there was no 
\verb|package.json| file in the above example, then
\verb|require('./some-library')| would attempt to load:

\begin{verbatim}
./some-library/index.js
./some-library/index.node
\end{verbatim}

\end{enumerate}

\subsection{Caching}

\begin{enumerate}
\item
Modules are cached after the first time they are loaded. This means
(among other things) that every call to \verb|require('foo')| will get exactly
the same object returned, if it would resolve to the same file.

\item
Multiple calls to \verb|require('foo')| may not cause the module code
to be executed multiple times. This is an important feature. With it,
\cei{partially done} objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

\item
If you want to have a module execute code multiple times, then export
a function, and call that function.

\item
Modules are cached based on their {\bf resolved filename}. Since modules may
resolve to a different filename based on the location of the calling
module (loading from \verb|node_modules folders|), it is not a guarantee that
\verb|require('foo')| will always return the exact same object, if it would
resolve to different files.

\end{enumerate}

\subsection{El Objeto {\tt module} y {\tt module.exports}}

\begin{enumerate}
\item
In each module, the \verb|module| free variable is a reference to the object
representing the current module. 

\item
In particular \verb|module.exports| is the
same as the exports object. 

\item
\verb|module| isn't actually a global but rather
local to each module.

\item
The exports object is created by the \verb|Module| system. 
Sometimes this is not acceptable, 
many want their module to be an instance of some class. 
To do this assign the desired export object to \verb|module.exports|. 

\begin{itemize}
\item
\begin{verbatim}
[~/javascript/node.js/creating_modules/module_exports(master)]$ cat a.js
var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);
\end{verbatim}

\item
\begin{verbatim}
$ cat main.js 
var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});
\end{verbatim}
\item
\begin{verbatim}
$ node main.js 
module a is ready
\end{verbatim}
\end{itemize}
La asignación a \verb|module.exports| debe hacerse inmediatamente. 
No puede hacerse en un callback.

\end{enumerate}

\subsection{Algoritmo de Búsqueda Ejecutado por {\tt require}}

\parrafo{require(X) from module at path Y}
\begin{enumerate}
\item If X is a core module,
\begin{enumerate}
  \item return the core module
  \item STOP
\end{enumerate}
\item If X begins with './' or '/' or '../'
\begin{enumerate}
  \item \verb|LOAD_AS_FILE(Y + X)|
  \item \verb|LOAD_AS_DIRECTORY(Y + X)|
\end{enumerate}
\item \verb|LOAD_NODE_MODULES(X, dirname(Y))|
\item THROW "not found"
\end{enumerate}

\parrafo{LOAD\_AS\_FILE(X)}
\begin{enumerate}
\item If X is a file, load X as JavaScript text.  STOP
\item If X.js is a file, load X.js as JavaScript text.  STOP
\item If X.node is a file, load X.node as binary addon.  STOP
\end{enumerate}

\parrafo{LOAD\_AS\_DIRECTORY(X)}
\begin{enumerate}
\item If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. \verb|LOAD_AS_FILE(M)|
\item If X/index.js is a file, load X/index.js as JavaScript text.  STOP
\item If X/index.node is a file, load X/index.node as binary addon.  STOP
\end{enumerate}

\parrafo{LOAD\_NODE\_MODULES(X, START)}
\begin{enumerate}
\item let \verb|DIRS=NODE_MODULES_PATHS(START)|
\item for each DIR in DIRS:
   a. \verb|LOAD_AS_FILE(DIR/X)|
   b. \verb|LOAD_AS_DIRECTORY(DIR/X)|
\end{enumerate}

\parrafo{NODE\_MODULES\_PATHS(START)}
\begin{enumerate}
\item let PARTS = path split(START)
\item let ROOT = index of first instance of "node\_modules" in PARTS, or 0
\item let I = count of PARTS - 1
\item let DIRS = []
\item while I > ROOT,
   a. if PARTS[I] = "node\_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node\_modules")
   b. DIRS = DIRS + DIR
   c. let I = I - 1
\item return DIRS
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter1/modulos.tex

\section{Como Crear tu Propio Módulo en Node.js}
% http://howtonode.org/how-to-module está desactualizado
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter1/create_module.tex

\subsection{Introducción}

Cuando Node carga nuestro fichero JavaScript
crea un nuevo ámbito. Cuando estamos en nuestro módulo, no podemos
ver el ámbito externo lo que evita las colisiones de nombres.

\subsection{Un Fichero {\tt package.json}}

Creamos un fichero en la raíz de nuestro proyecto con nombre 
\verb|package.json|. Este fichero describe nuestro proyecto.
Es esencial si vamos a publicar nuestro proyecto con 
\npm{}.

Podemos especificar en este fichero:

\begin{enumerate}
\item
Name, version, description, and keywords to describe your program.
\item
A homepage where users can learn more about it.
\item
Other packages that yours depends on.
\end{enumerate}

Si hemos instalado \npm{} podemos usar el comando 
\verb|npm| \npmdoc{init} para empezar.
Véase  \verb|npm help|
\npmdoc{json} 
para obtener información sobre este fichero:

La cosa mas importante a especificar 
cuando estamos escribiendo un programa para su uso por otros,
es el módulo \verb|main|. Este consituirá el punto de entrada 
a nuestro programa.

Es esencial documentar las dependencias.

El siguiente es un ejemplo de fichero \verb|package.json| tomado
del proyecto \ebnfparser{}:
\begin{verbatim}
[~/javascript/PLgrado/ebnf-parser(master)]$ cat -n package.json 
   1  {
   2    "name": "ebnf-parser",
   3    "version": "0.1.1",
   4    "description": "A parser for BNF and EBNF grammars used by jison",
   5    "main": "ebnf-parser.js",
   6    "scripts": {
   7      "test": "make test"
   8    },
   9    "repository": "",
  10    "keywords": [
  11      "bnf",
  12      "ebnf",
  13      "grammar",
  14      "parser",
  15      "jison"
  16    ],
  17    "author": "Zach Carter",
  18    "license": "MIT",
  19    "devDependencies": {
  20      "jison": "0.4.x",
  21      "lex-parser": "0.1.0",
  22      "test": "*"
  23    }
  24  }
\end{verbatim}

\subsection{README y otros documentos}

Pon la información basica acerca del módulo 
en la raíz del proyecto.
Como ejemplo veamos el \verb|README.md| (observa que 
está en formato \markdown{}) 
del proyecto \ebnfparser{}:

\begin{verbatim}
$ cat README.md 

# ebnf-parser

A parser for BNF and EBNF grammars used by jison.

## install

    npm install ebnf-parser


## build

To build the parser yourself, clone the git repo then run:

    make

This will generate `parser.js`, which is required by `ebnf-parser.js`.

## usage

The parser translates a string grammar or JSON grammar into a JSON grammar that jison can use (ENBF is transformed into BNF).

    var ebnfParser = require('ebnf-parser');

    // parse a bnf or ebnf string grammar
    ebnfParser.parse("%start ... %");

    // transform an ebnf JSON gramamr
    ebnfParser.transform({"ebnf": ...});


## example grammar

The parser can parse its own BNF grammar, shown below:

    %start spec

    /* grammar for parsing jison grammar files */

    %{
    var transform = require('./ebnf-transform').transform;
    var ebnf = false;
    %}

    %%

    spec
        : declaration_list '%%' grammar optional_end_block EOF
            {$$ = $1; return extend($$, $3);}
        | declaration_list '%%' grammar '%%' CODE EOF
            {$$ = $1; yy.addDeclaration($$,{include:$5}); return extend($$, $3);}
        ;

    optional_end_block
        :
        | '%%'
        ;

    declaration_list
        : declaration_list declaration
            {$$ = $1; yy.addDeclaration($$, $2);}
        |
            {$$ = {};}
        ;

    declaration
        : START id
            {$$ = {start: $2};}
        | LEX_BLOCK
            {$$ = {lex: $1};}
        | operator
            {$$ = {operator: $1};}
        | ACTION
            {$$ = {include: $1};}
        ;

    operator
        : associativity token_list
            {$$ = [$1]; $$.push.apply($$, $2);}
        ;

    associativity
        : LEFT
            {$$ = 'left';}
        | RIGHT
            {$$ = 'right';}
        | NONASSOC
            {$$ = 'nonassoc';}
        ;

    token_list
        : token_list symbol
            {$$ = $1; $$.push($2);}
        | symbol
            {$$ = [$1];}
        ;

    grammar
        : production_list
            {$$ = $1;}
        ;

    production_list
        : production_list production
            {$$ = $1;
              if($2[0] in $$) $$[$2[0]] = $$[$2[0]].concat($2[1]);
              else  $$[$2[0]] = $2[1];}
        | production
            {$$ = {}; $$[$1[0]] = $1[1];}
        ;

    production
        : id ':' handle_list ';'
            {$$ = [$1, $3];}
        ;

    handle_list
        : handle_list '|' handle_action
            {$$ = $1; $$.push($3);}
        | handle_action
            {$$ = [$1];}
        ;

    handle_action
        : handle prec action
            {$$ = [($1.length ? $1.join(' ') : '')];
                if($3) $$.push($3);
                if($2) $$.push($2);
                if ($$.length === 1) $$ = $$[0];
            }
        ;

    handle
        : handle expression_suffix
            {$$ = $1; $$.push($2)}
        |
            {$$ = [];}
        ;

    handle_sublist
        : handle_sublist '|' handle
            {$$ = $1; $$.push($3.join(' '));}
        | handle
            {$$ = [$1.join(' ')];}
        ;

    expression_suffix
        : expression suffix
            {$$ = $expression + $suffix; }
        ;

    expression
        : ID
            {$$ = $1; }
        | STRING
            {$$ = ebnf ? "'"+$1+"'" : $1; }
        | '(' handle_sublist ')'
            {$$ = '(' + $handle_sublist.join(' | ') + ')'; }
        ;

    suffix
        : {$$ = ''}
        | '*'
        | '?'
        | '+'
        ;

    prec
        : PREC symbol
            {$$ = {prec: $2};}
        |
            {$$ = null;}
        ;

    symbol
        : id
            {$$ = $1;}
        | STRING
            {$$ = yytext;}
        ;

    id
        : ID
            {$$ = yytext;}
        ;

    action
        : '{' action_body '}'
            {$$ = $2;}
        | ACTION
            {$$ = $1;}
        | ARROW_ACTION
            {$$ = '$$ ='+$1+';';}
        |
            {$$ = '';}
        ;

    action_body
        :
            {$$ = '';}
        | ACTION_BODY
            {$$ = yytext;}
        | action_body '{' action_body '}' ACTION_BODY
            {$$ = $1+$2+$3+$4+$5;}
        | action_body '{' action_body '}'
            {$$ = $1+$2+$3+$4;}
        ;

    %%

    // transform ebnf to bnf if necessary
    function extend (json, grammar) {
        json.bnf = ebnf ? transform(grammar) : grammar;
        return json;
    }

## license

MIT
\end{verbatim}

En general se anima  a que uses el formato markdown. Salva el fichero como
\verb|README.md|.

La documentación adicional se pone en un directorio \verb|./docs|. 
Los ficheros markdown teminan en \verb|.md| y los html en \verb|.html|.

\subsection{Véase También}
\begin{itemize}
\item
\htmladdnormallink{How To: Create Your Own Node.js Module}{http://howtonode.org/how-to-module} por Isaac Z. Schlueter autor de 
\htmladdnormallink{npm}{http://npmjs.org/}.
Véase también este
\htmladdnormallink{gist en GitHub}{https://gist.github.com/isaacs/4150d972e0aa2a4060c1}
\item
\htmladdnormallink{Creating Custom Modules}{http://howtonode.org/creating-custom-modules}
\item
\htmladdnormallink{How to Build a Nodejs Npm Package From Scratch.}{http://decodize.com/javascript/build-nodejs-npm-installation-package-scratch/} May 2012 Decodize

\end{itemize}
%%% TEXEXPAND: END FILE ./chapter1/create_module.tex


\section{Mas sobre Node}
\begin{enumerate}
\item
Véase el libro 'Learning Node' de S. Powers \cite{learningnode}.
\item \htmladdnormallink{Node.js}{http://nodejs.org/}
\item \htmladdnormallink{docs.nodejitsu.com}{http://docs.nodejitsu.com}: collection of node.js how-to articles. These articles range from basic to advanced. They provide relevant code samples and insights into the design and philosophy of node itself

\item \htmladdnormallink{http://howtonode.org/}{http://howtonode.org/}
contiene un número creciente de tutoriales
\item El manual de node.js puede encontrarse en formato pdf en el proyecto 
\htmladdnormallink{https://github.com/zeMirco/nodejs-pdf-docs}{https://github.com/zeMirco/nodejs-pdf-docsoen}
en GitHub. En concreto en este \htmladdnormallink{enlace}{https://github.com/zeMirco/nodejs-pdf-docs/blob/master/pdf/all.pdf?raw=true}
\item \htmladdnormallink{Guías de node.js}{http://nodeguide.com/} de
\htmladdnormallink{Felix Geisendörfer}{https://twitter.com/felixge}
\item \htmladdnormallink{Introduction to Node.js}{http://hectorcorrea.jit.su/blog/introduction-to-node-js} por Hector Correa
\item \htmladdnormallink{El Libro para Principiantes en Node.js}{http://www.nodebeginner.org/index-es.html} por Manuel Kiessling  y Herman A. Junge
\end{enumerate}
Para aprender JavaScript podemos usar el libro
\htmladdnormallink{eloquent JavaScript}{http://eloquentjavascript.net/} de Marijn Haverbeke \cite{eloquentjavascript}.


%%% TEXEXPAND: END FILE ./chapter_node/node.tex

\chapter{JavaScript en los Navegadores}

\chapter{El Objeto Window}

\chapter{Manejo de Documentos en JavaScript}

\chapter{Manejo de CSS}

\chapter{Manejo de Eventos}

\chapter{HTTP}

\chapter{La Librería JQuery}

\chapter{Almacenamiento en el Cliente}

\chapter{Multimedia y Gráficos}

\chapter{HTML5}

\chapter{XML}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapterxml/xml.tex
Véase el libro \htmladdnormallink{Sams Teach Yourself XML in 21 Days}{http://books.google.es/books?id=q8XqByA2dXYC} en Google o en 
\htmladdnormallink{informit}{http://www.informit.com/library/library.aspx?b=STY_XML_21days}
\cite{holzner2003sams}
%%% TEXEXPAND: END FILE ./chapterxml/xml.tex

\chapter{Backbone}
\begin{enumerate}
\item 
\htmladdnormallink{Developing Backbone.js Applications}{http://addyosmani.github.com/backbone-fundamentals/}
\end{enumerate}

\chapter{Closure Tools}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_closure_tools/closure_tools.tex

\section{Véase También}
\begin{enumerate}
\item
\htmladdnormallink{Google I/O 2011: JavaScript Programming in the Large with Closure Tools}{http://youtu.be/M3uWx-fhjUc}  (YouTube)
\item
\htmladdnormallink{The Closure Tools project is an effort by Google to open source the tools used in many of Google's sites and web applications}{https://developers.google.com/closure/?hl=es}
\item Herramientas:
\begin{enumerate}
\item
\htmladdnormallink{Closure Compiler}{https://code.google.com/p/closure-compiler/} en Google-Code
\item
\htmladdnormallink{Closure Library}{https://code.google.com/p/closure-library/} en Google-Code
\item
\htmladdnormallink{Closure Template}{https://code.google.com/p/closure-templates/} en Google-Code
\item
\htmladdnormallink{Closure Linter}{https://code.google.com/p/closure-linter/} en Google-Code
\end{enumerate}
\item
\htmladdnormallink{Getting Started with the Closure Library}{https://developers.google.com/closure/library/docs/gettingstarted?hl=es} (Hello World!)
\end{enumerate}

%%% TEXEXPAND: END FILE ./chapter_closure_tools/closure_tools.tex


\chapter{Pruebas}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_pruebas/pruebas.tex
\section{Testing en JavaScript: Fácil y Rápido}
\label{section:tstingfacil}
\begin{enumerate}
\item 
\htmladdnormallink{Quick Tip: Quick and Easy JavaScript Testing with “Assert”}{http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/}
por
\htmladdnormallink{Jeffrey Way}{http://net.tutsplus.com/author/jeffreyway/}

\end{enumerate}

\section{Unit Testing, TDD y BDD con Jasmine}
\begin{enumerate}
\item
\htmladdnormallink{Jasmine: BDD Style JavaScript Testing Hello World}{http://youtu.be/nH1Amt_JHLg} por Chris McNabb (YouTube Sep. 2012)
\item
\htmladdnormallink{Download Jasmine}{https://github.com/pivotal/jasmine/downloads}
\item
\htmladdnormallink{Testing Your JavaScript with Jasmine
Andrew Burgess on Aug 4th 2011}{http://net.tutsplus.com/tutorials/javascript-ajax/testing-your-javascript-with-jasmine/?search_index=3}
\item 
\htmladdnormallink{Unit Testing in JavaScript via Jasmine}{http://youtu.be/eVpXkyN0zOE} (Youtube)
\item 
\htmladdnormallink{Jasmine}{http://pivotal.github.com/jasmine/} en GitHub
\item
\htmladdnormallink{Behavior Driven Testing with Jasmine}{http://youtu.be/KdCQFFHUpi4} (YouTube, Davis Frank de Pivotal Labs, Contiene una introducción a BDD)
\item
\htmladdnormallink{Jasmine Wiki}{https://github.com/pivotal/jasmine/wiki}
\item
\htmladdnormallink{Testem}{http://net.tutsplus.com/tutorials/javascript-ajax/make-javascript-testing-fun-with-testem} tutorial en net.tutplus (trabaja sobre Jasmine y sobre Coffee)
\item
Jasmine Matchers: \htmladdnormallink{Class jasmine.Matchers}{http://pivotal.github.com/jasmine/jsdoc/symbols/jasmine.Matchers.html}
\end{enumerate}

%%% TEXEXPAND: END FILE ./chapter_pruebas/pruebas.tex

\chapter{Buenas Prácticas y Patrones}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_buenas_practicas/buenas_practicas.tex

\section{Véase También}
\begin{enumerate}
\item
\htmladdnormallink{Google I/O 2011: Learning to Love JavaScript}{http://youtu.be/seX7jYI96GE}
por Alex Russell, Mayo 2011. ¡Excelente!
\item
\htmladdnormallink{traceur compiler}{https://code.google.com/p/traceur-compiler/}
\item
\htmladdnormallink{Google I/O 2011: JavaScript Programming in the Large with Closure Tools}{http://youtu.be/M3uWx-fhjUc} 
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter_buenas_practicas/buenas_practicas.tex

\chapter{Herramientas}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter11/herramientas.tex
\section{n}

\tei{n} es una herramienta parecida a \tei{rvm} para Node.js:
\begin{verbatim}
$sudo npm install n -g
\end{verbatim}
y

\begin{verbatim}
[~/Dropbox/src/javascript/node.js/creating_modules(master)]$ n help

  Usage: n [options] [COMMAND] [config]

  Commands:

    n                            Output versions installed
    n latest [config ...]        Install or activate the latest node release
    n stable [config ...]        Install or activate the latest stable node release
    n <version> [config ...]     Install and/or use node <version>
    n use <version> [args ...]   Execute node <version> with [args ...]
    n bin <version>              Output bin path for <version>
    n rm <version ...>           Remove the given version(s)
    n prev                       Revert to the previously activated version
    n --latest                   Output the latest node version available
    n --stable                   Output the latest stable node version available
    n ls                         Output the versions of node available

  Options:

    -V, --version   Output current version of n
    -h, --help      Display help information

  Aliases:

    which   bin
    use     as
    list    ls
    -       rm
\end{verbatim}

\begin{verbatim}
$ sudo n latest
\end{verbatim}

\section{Google Chrome y Javascript}
\label{section:chromedeveloper}

\begin{enumerate}
\item 
\htmladdnormallink{Building Browser Apps with Google Chrome}{http://www.buildbrowserapps.com/chromeappbook/index.html}
\end{enumerate}


\parrafo{Enlaces Relacionados}

\begin{enumerate}
\item 
\htmladdnormallink{Chrome Developer Tools Tutorial: Elements (Part 1/2)}{http://youtu.be/dNsM2PUkZ1g} 
\end{enumerate}

\section{Plugins, Editores, IDEs}
\begin{itemize}
\item
\htmladdnormallink{jslint}{https://github.com/hallettj/jslint.vim} lint plugin para vim
\item
\htmladdnormallink{vim plugins for HTML and CSS hi-speed coding.}{http://mattn.github.com/zencoding-vim/} disponible en 
\htmladdnormallink{http://www.vim.org}{http://www.vim.org/scripts/script.php?script_id=2981} y en github 
\htmladdnormallink{https://github.com/mattn/zencoding-vim/}{https://github.com/mattn/zencoding-vim/}
\item
\htmladdnormallink{Vim Essential Plugin: Sparkup}{http://net.tutsplus.com/tutorials/other/vim-essential-plugin-sparkup/?search_index=1} parecido a zenconding. El tutorial es de 2011.
\end{itemize}

\section{Grunt}

\begin{enumerate}
\item
\htmladdnormallink{Grunt - The Basics}{http://youtu.be/q3Sqljpr-Vc} Youtube
\item
\htmladdnormallink{Grunt home page}{http://gruntjs.com/}
\end{enumerate}

\section{Beautifiers, Pretty-Printers}
\begin{enumerate}
\item 
\htmladdnormallink{beautifier}{https://github.com/rickeyski/node-beautifier}
de Rickeyski
\end{enumerate}

\section{Modulos}
\begin{enumerate}
\item 
\htmladdnormallink{NODE.JS Modules}{https://nodejsmodules.org/}
\end{enumerate}


%%% TEXEXPAND: END FILE ./chapter11/herramientas.tex

%%% TEXEXPAND: END FILE ./chapter1/chapter1.tex

\part{SEGUNDA PARTE: APUNTES DE PROCESADORES DE LENGUAJES}

%2
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter2/regexp.tex
\chapter{Expresiones Regulares y Análisis Léxico en JavaScript}

%  Power Sh. JavaScript Cookbook. Chapter 1. Working with JavaScript Strings
%  David Flanagan. JavaScript, the Definitive Guide. O'Reilly.  Chapter 10.
%  JavaScript. The Missing Manual. Chapter 4. working with words, numbers and dates. A quick object lesson

\section{Mozilla Developer Network: Documentación}

\begin{enumerate}
\item \htmladdnormallink{RegExp Objects}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Regexp}
\item 
\htmladdnormallink{exec}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec}
\item 
\htmladdnormallink{search}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search}
\item 
\htmladdnormallink{match}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match}
\item 
\htmladdnormallink{replace}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace}
\end{enumerate}

\sectionpractica{Conversor de Temperaturas}

\parrafo{index.html}

  \begin{latexonly}
    \begin{verbatim}

<html>
  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>JavaScript Temperature Converter</title>
      <link href="global.css" rel="stylesheet" type="text/css">

     <script type="text/javascript" src="temperature.js"></script>
  </head>
  <body>
    <h1>Temperature Converter</h1>
    <table>
      <tr>
        <th>Enter  Temperature (examples: 32F, 45C, -2.5f):</th>
        <td><input id="original" onchange="calculate();"></td>
      </tr>
      <tr>
        <th>Converted Temperature:</th>
        <td><span class="output" id="converted"></span></td>
      </tr>
    </table>
  </body>
</html>

    \end{verbatim}
  \end{latexonly}
    \begin{rawhtml}
    <pre>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
      <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">&quot;Content-Type&quot;</span> <span class="na">content=</span><span class="s">&quot;text/html; charset=UTF-8&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;title&gt;</span>JavaScript Temperature Converter<span class="nt">&lt;/title&gt;</span>
      <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;global.css&quot;</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">type=</span><span class="s">&quot;text/css&quot;</span><span class="nt">&gt;</span>

     <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;temperature.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Temperature Converter<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;table&gt;</span>
      <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;th&gt;</span>Enter  Temperature (examples: 32F, 45C, -2.5f):<span class="nt">&lt;/th&gt;</span>
        <span class="nt">&lt;td&gt;&lt;input</span> <span class="na">id=</span><span class="s">&quot;original&quot;</span> <span class="na">onchange=</span><span class="s">&quot;calculate();&quot;</span><span class="nt">&gt;&lt;/td&gt;</span>
      <span class="nt">&lt;/tr&gt;</span>
      <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;th&gt;</span>Converted Temperature:<span class="nt">&lt;/th&gt;</span>
        <span class="nt">&lt;td&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;output&quot;</span> <span class="na">id=</span><span class="s">&quot;converted&quot;</span><span class="nt">&gt;&lt;/span&gt;&lt;/td&gt;</span>
      <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;/table&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
    </pre>
    \end{rawhtml}
  

\parrafo{global.css}


  \begin{latexonly}
    \begin{verbatim}

th, td      { vertical-align: top; text-align: right; font-size:large; }     
#converted  { color: red; font-weight: bold; font-size:large;          }    
input       { text-align: right;  border: none; font-size:large;       }   
body
{
 background-color:#b0c4de;  /* blue */
 font-size:large;
}

    \end{verbatim}
  \end{latexonly}
    \begin{rawhtml}
    <pre>
<span class="nt">th</span><span class="o">,</span> <span class="nt">td</span>      <span class="p">{</span> <span class="k">vertical-align</span><span class="o">:</span> <span class="k">top</span><span class="p">;</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span> <span class="p">}</span>     
<span class="nf">#converted</span>  <span class="p">{</span> <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span> <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span>          <span class="p">}</span>    
<span class="nt">input</span>       <span class="p">{</span> <span class="k">text-align</span><span class="o">:</span> <span class="k">right</span><span class="p">;</span>  <span class="k">border</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span> <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span>       <span class="p">}</span>   
<span class="nt">body</span>
<span class="p">{</span>
 <span class="k">background-color</span><span class="o">:</span><span class="m">#b0c4de</span><span class="p">;</span>  <span class="c">/* blue */</span>
 <span class="k">font-size</span><span class="o">:</span><span class="k">large</span><span class="p">;</span>
<span class="p">}</span>
    </pre>
    \end{rawhtml}
  

\parrafo{temperature.js}


  \begin{latexonly}
    \begin{verbatim}

"use strict"; // Use ECMAScript 5 strict mode in browsers that support it
function calculate() {
  var result;
  var original       = document.getElementById("........");
  var temp = original.value;
  var regexp = /.............................../;
  
  var m = temp.match(......);
  
  if (m) {
    var num = ....;
    var type = ....;
    num = parseFloat(num);
    if (type == 'c' || type == 'C') {
      result = (num * 9/5)+32;
      result = ..............................
    }
    else {
      result = (num - 32)*5/9;
      result = ............................
    }
    converted.innerHTML = result;
  }
  else {
    converted.innerHTML = "ERROR! Try something like '-4.2C' instead";
  }
}

    \end{verbatim}
  \end{latexonly}
    \begin{rawhtml}
    <pre>
<span class="s2">&quot;use strict&quot;</span><span class="p">;</span> <span class="c1">// Use ECMAScript 5 strict mode in browsers that support it</span>
<span class="kd">function</span> <span class="nx">calculate</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">original</span>       <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;........&quot;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">original</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="sr">/.............................../</span><span class="p">;</span>
  
  <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">match</span><span class="p">(......);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="p">....;</span>
    <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="p">....;</span>
    <span class="nx">num</span> <span class="o">=</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="o">||</span> <span class="nx">type</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span> <span class="o">*</span> <span class="mi">9</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">32</span><span class="p">;</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">..............................</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="o">/</span><span class="mi">9</span><span class="p">;</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">............................</span>
    <span class="p">}</span>
    <span class="nx">converted</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">converted</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">&quot;ERROR! Try something like &#39;-4.2C&#39; instead&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    </pre>
    \end{rawhtml}
  

\sectionpractica{Comma Separated Values}

\parrafo{Introducción al formato CSV}

Véase \wikip{Comma Separated Values}{Comma-separated_values} en la Wikipedia:

{\it A comma-separated values (CSV) file stores tabular data (numbers
and text) in plain-text form. 
 A CSV file consists of any number of
records, separated by line breaks of some kind; each record consists
of fields, separated by a comma. All records have an identical
sequence of fields.}

\parrafo{Ejemplo de ejecución}

\begin{latexonly}
\begin{figure}[htb]
\begin{center}
\centerline{\epsfig{file=chapter2/csv.eps, width=17cm}}
\end{center}
\label{figure:csv}
\caption{Ejemplo de pantalla de La aplicación para el Análisis de Datos en Formato CSV}
\end{figure}
\end{latexonly}

\begin{rawhtml}
<DIV ALIGN="CENTER"><A NAME="figure:csv"></A><A NAME="1213"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura:</STRONG>
Ejemplo de pantalla de La aplicación para el Análisis de Datos en Formato CSV</CAPTION>
<TR><TD><IMG
 WIDTH="769" HEIGHT="410" BORDER="0"
 SRC="csv.png"
 ALT="\begin{figure}\begin{center}
\centerline{\epsfig{file=chapter2/csv.eps, width=17cm}}
\end{center}
\end{figure}"></TD></TR>
</TABLE>
</DIV>
\end{rawhtml}



\parrafo{Aproximación al análisis mediante expresiones regulares de CSV}
Una primera aproximación sería hacer \verb|split| por las comas:
\begin{verbatim}
> x = '"earth",1,"moon",9.374'
'"earth",1,"moon",9.374'
> y = x.split(/,/)
[ '"earth"', '1', '"moon"', '9.374' ]
\end{verbatim}

Esta solución deja las comillas dobles en los campos entrecomillados. 
Peor aún, los campos entrecomillados pueden contener comas, en cuyo 
caso la división proporcionada por \verb|split| sería errónea:
\begin{verbatim}
> x = '"earth, mars",1,"moon, fobos",9.374'
'"earth, mars",1,"moon, fobos",9.374'
> y = x.split(/,/)
[ '"earth', ' mars"', '1', '"moon', ' fobos"', '9.374' ]
\end{verbatim}

La siguiente expresión regular reconoce cadenas de comillas dobles
con secuencias de escape seguidas opcionalmente de una coma:
\begin{verbatim}
> x = '"earth, mars",1,"moon, fobos",9.374'
'"earth, mars",1,"moon, fobos",9.374'
> r = /"((?:[^"\\]|\\.)*)"\s*,?/g
/"((?:[^"\\]|\\.)*)"\s*,?/g
> w = x.match(r)
[ '"earth, mars",', '"moon, fobos",' ]
\end{verbatim}

Esta otra expresión regular \verb#/([^,]+),?|\s*,/# actúa de forma parecida al \verb|split|. 
Reconoce secuencias no vacías de caracteres que no contienen comas seguidas opcionalmente
de una coma o bien una sóla coma (precedida opcionalmente de blancos):
\begin{verbatim}
> x = '"earth, mars",1,"moon, fobos",9.374'
'"earth, mars",1,"moon, fobos",9.374'
> r = /([^,]+),?|\s*,/g
/([^,]+),?|\s*,/g
> w = x.match(r)
[ '"earth,', ' mars",', '1,', '"moon,', ' fobos",', '9.374' ]
\end{verbatim}

\parrafo{index.html}
\begin{verbatim}
<html>
  <head>
     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
     <title>CSV Analyzer</title>
     <link href="global.css" rel="stylesheet" type="text/css">

     <script type="text/javascript" src="../../underscore/underscore.js"></script>
     <script type="text/javascript" src="../../jquery/starterkit/jquery.js"></script>
     <script type="text/javascript" src="csv.js"></script>
  </head>
  <body>
    <h1>Comma Separated Value Analyzer</h1>
    <div>
      <i>Write a CSV string. Click the table button. The program outputs a table with the specified data.</i>
    </div>
    <table>
      <tr>
        <th>CSV string:</th> <!-- autofocus attribute is HTML5 -->
        <td><textarea autofocus cols = "80" rows = "5" id="original"></textarea></td> 
      </tr>
    </table>
    <button type="button">table:</button><br>
    <span class="output" id="finaltable"></span>
  </body>
</html>
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{jQuery}{http://jquery.com/} (\htmladdnormallink{Descarga la librería}{http://jquery.com/download/})
\item \htmladdnormallink{Underscore}{http://underscorejs.org/}
\item 
\htmladdnormallink{autofocus}{http://www.w3api.com/wiki/HTML5:INPUT.autofocus}.
Véase también \cite{pilgrimhtml5}
\item \htmladdnormallink{textarea}{http://www.w3schools.com/tags/tag_textarea.asp}
\item \htmladdnormallink{button}{http://www.w3schools.com/tags/tag_button.asp}
\end{enumerate}

\parrafo{global.css}
\begin{verbatim}
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: right; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
body
{
 background-color:#b0c4de;  /* blue */
}
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{Introducción a las pseudo clases de CSS3}{http://www.genbetadev.com/desarrollo-web/introduccion-a-las-pseudo-clases-de-css3}
\item 
\htmladdnormallink{CSS pattern matching}{http://www.w3.org/TR/CSS2/selector.html\#pattern-matching}
\item 
\htmladdnormallink{CSS class selectors}{http://www.w3.org/TR/CSS2/selector.html\#class-html}
\item 
\htmladdnormallink{CSS3: nth-child() selector}{http://www.w3schools.com/cssref/sel_nth-child.asp}
\item 
\htmladdnormallink{CSS: border}{http://www.tizag.com/cssT/border.php}
\item 
\end{enumerate}


\parrafo{csv.js}


  \begin{latexonly}
    \begin{verbatim}

// See http://en.wikipedia.org/wiki/Comma-separated_values
"use strict"; // Use ECMAScript 5 strict mode in browsers that support it

$(document).ready(function() {
   $("button").click(function() {
     calculate();
   });
 });

function calculate() {
  var result;
  var original       = document.getElementById("original");
  var temp = original.value;
  var regexp = /_____________________________________________/g;
  var lines = temp.split(/\n+\s*/);
  var commonLength = NaN;
  var r = [];
  // Template using underscore
  var row = "<%% _.each(items, function(name) { %>"     +
            "                    <td><%%= name %></td>" +
            "              <%% }); %>";

  if (window.localStorage) localStorage.original  = temp;
  
  for(var t in lines) {
    var temp = lines[t];
    var m = temp.match(regexp);
    var result = [];
    var error = false;
    
    if (m) {
      if (commonLength && (commonLength != m.length)) {
        //alert('ERROR! row <'+temp+'> has '+m.length+' items!');
        error = true;
      }
      else {
        commonLength = m.length;
        error = false;
      }
      for(var i in m) {
        var removecomma = m[i].replace(/,\s*$/,'');
        var remove1stquote = removecomma.replace(/^\s*"/,'');
        var removelastquote = remove1stquote.replace(/"\s*$/,'');
        var removeescapedquotes = removelastquote.replace(/\"/,'"');
        result.push(removeescapedquotes);
      }
      var tr = error? '<tr class="error">' : '<tr>';
      r.push(tr+_.template(row, {items : result})+"</tr>");
    }
    else {
      alert('ERROR! row '+temp+' does not look as legal CSV');
      error = true;
    }
  }
  r.unshift('<p>\n<table class="center" id="result">');
  r.push('</table>');
  //alert(r.join('\n')); // debug
  finaltable.innerHTML = r.join('\n');
}

window.onload = function() {
  // If the browser supports localStorage and we have some stored data
  if (window.localStorage && localStorage.original) {
    document.getElementById("original").value = localStorage.original;
  }
};

    \end{verbatim}
  \end{latexonly}
    \begin{rawhtml}
    <pre>
<span class="c1">// See http://en.wikipedia.org/wiki/Comma-separated_values</span>
<span class="s2">&quot;use strict&quot;</span><span class="p">;</span> <span class="c1">// Use ECMAScript 5 strict mode in browsers that support it</span>

<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">calculate</span><span class="p">();</span>
   <span class="p">});</span>
 <span class="p">});</span>

<span class="kd">function</span> <span class="nx">calculate</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">original</span>       <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;original&quot;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">original</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="sr">/_____________________________________________/g</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">lines</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/\n+\s*/</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">commonLength</span> <span class="o">=</span> <span class="kc">NaN</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// Template using underscore</span>
  <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="s2">&quot;&lt;%% _.each(items, function(name) { %&gt;&quot;</span>     <span class="o">+</span>
            <span class="s2">&quot;                    &lt;td&gt;&lt;%%= name %&gt;&lt;/td&gt;&quot;</span> <span class="o">+</span>
            <span class="s2">&quot;              &lt;%% }); %&gt;&quot;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">)</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">original</span>  <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">t</span> <span class="k">in</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">lines</span><span class="p">[</span><span class="nx">t</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">regexp</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">error</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">commonLength</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">commonLength</span> <span class="o">!=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">//alert(&#39;ERROR! row &lt;&#39;+temp+&#39;&gt; has &#39;+m.length+&#39; items!&#39;);</span>
        <span class="nx">error</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="nx">commonLength</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="nx">error</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">removecomma</span> <span class="o">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/,\s*$/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">remove1stquote</span> <span class="o">=</span> <span class="nx">removecomma</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^\s*&quot;/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">removelastquote</span> <span class="o">=</span> <span class="nx">remove1stquote</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/&quot;\s*$/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">removeescapedquotes</span> <span class="o">=</span> <span class="nx">removelastquote</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\&quot;/</span><span class="p">,</span><span class="s1">&#39;&quot;&#39;</span><span class="p">);</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">removeescapedquotes</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">tr</span> <span class="o">=</span> <span class="nx">error</span><span class="o">?</span> <span class="s1">&#39;&lt;tr class=&quot;error&quot;&gt;&#39;</span> <span class="o">:</span> <span class="s1">&#39;&lt;tr&gt;&#39;</span><span class="p">;</span>
      <span class="nx">r</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tr</span><span class="o">+</span><span class="nx">_</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="p">{</span><span class="nx">items</span> <span class="o">:</span> <span class="nx">result</span><span class="p">})</span><span class="o">+</span><span class="s2">&quot;&lt;/tr&gt;&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;ERROR! row &#39;</span><span class="o">+</span><span class="nx">temp</span><span class="o">+</span><span class="s1">&#39; does not look as legal CSV&#39;</span><span class="p">);</span>
      <span class="nx">error</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;\n&lt;table class=&quot;center&quot; id=&quot;result&quot;&gt;&#39;</span><span class="p">);</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;&lt;/table&gt;&#39;</span><span class="p">);</span>
  <span class="c1">//alert(r.join(&#39;\n&#39;)); // debug</span>
  <span class="nx">finaltable</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// If the browser supports localStorage and we have some stored data</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span> <span class="o">&amp;&amp;</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">original</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;original&quot;</span><span class="p">).</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">original</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
    </pre>
    \end{rawhtml}
  

\begin{enumerate}
\item 
\htmladdnormallink{Tutorials:Getting Started with jQuery}{http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery}
\item 
\htmladdnormallink{Underscore: template}{http://underscorejs.org/\#template}
\item 
\htmladdnormallink{Stackoverflow::how to use Underscore template}{http://stackoverflow.com/questions/4778881/how-to-use-underscore-js-as-a-template-engine}
\item 
\htmladdnormallink{Como usar localstorage}{http://html5facil.com/tutoriales/como-usar-local-storage-de-javascript}
\item 
\htmladdnormallink{HTML5 Web Storage}{http://www.w3schools.com/html/html5_webstorage.asp}
\end{enumerate}



\section{Ejercicios}

\begin{enumerate}
\item  Paréntesis:
\begin{verbatim}
> str = "John Smith"
'John Smith'
> newstr = str.replace(re, "$2, $1")
'Smith, John'
\end{verbatim}
\item  El método \verb|exec|.

If your regular expression uses the \verb"g" flag, you can use the \verb|exec|
method multiple times to find successive matches in the same string.
When you do so, the search starts at the substring of str specified
by the regular expression's \verb|lastIndex| property.

\begin{verbatim}
> re = /d(b+)(d)/ig
/d(b+)(d)/gi
> z = "dBdxdbbdzdbd"
'dBdxdbbdzdbd'
> result = re.exec(z)
[ 'dBd', 'B', 'd', index: 0, input: 'dBdxdbbdzdbd' ]
> re.lastIndex
3
> result = re.exec(z)
[ 'dbbd', 'bb', 'd', index: 4, input: 'dBdxdbbdzdbd' ]
> re.lastIndex
8
> result = re.exec(z)
[ 'dbd', 'b', 'd', index: 9, input: 'dBdxdbbdzdbd' ]
> re.lastIndex
12
> z.length
12
> result = re.exec(z)
null
\end{verbatim}
\item JavaScript tiene lookaheads:
\begin{verbatim}
> x = "hello"
'hello'
> r = /l(?=o)/
/l(?=o)/
> z = r.exec(x)
[ 'l', index: 3, input: 'hello' ]
\end{verbatim}
\item JavaScript no tiene lookbehinds:
\begin{verbatim}
> x = "hello"
'hello'
> r = /(?<=l)l/
SyntaxError: Invalid regular expression: /(?<=l)l/: Invalid group
> .exit
\end{verbatim}
\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/csv(master)]$ irb
ruby-1.9.2-head :001 > x = "hello"
 => "hello" 
ruby-1.9.2-head :002 > r = /(?<=l)l/
 => ll 
ruby-1.9.2-head :008 > x =~ r
 => 3 
ruby-1.9.2-head :009 > $&
 => "l" 
\end{verbatim}
\item 
El siguiente ejemplo comprueba la validez de números de teléfono:
\begin{verbatim}
$ cat phone.html 
<!DOCTYPE html>
<html>  
  <head>  
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">  
    <meta http-equiv="Content-Script-Type" content="text/javascript">  
    <script type="text/javascript">  
      var re = /\(?\d{3}\)?([-\/\.])\d{3}\1\d{4}/;  
      function testInfo(phoneInput){  
        var OK = re.exec(phoneInput.value);  
        if (!OK)  
          window.alert(RegExp.input + " isn't a phone number with area code!");  
        else
          window.alert("Thanks, your phone number is " + OK[0]);  
      }  
    </script>  
  </head>  
  <body>  
    <p>Enter your phone number (with area code) and then click "Check".
        <br>The expected format is like ###-###-####.</p>
    <form action="#">  
      <input id="phone"><button onclick="testInfo(document.getElementById('phone'));">Check</button>
    </form>  
  </body>  
</html>
\end{verbatim}
\item 
¿Con que cadenas casa  la expresión regular \verb|/^(11+)\1+$/|?
\begin{verbatim}
> '1111'.match(/^(11+)\1+$/) # 4 unos
[ '1111',
  '11',
  index: 0,
  input: '1111' ]
> '111'.match(/^(11+)\1+$/) # 3 unos
null
> '11111'.match(/^(11+)\1+$/) # 5 unos
null
> '111111'.match(/^(11+)\1+$/) # 6 unos
[ '111111',
  '111',
  index: 0,
  input: '111111' ]
> '11111111'.match(/^(11+)\1+$/) # 8 unos
[ '11111111',
  '1111',
  index: 0,
  input: '11111111' ]
> '1111111'.match(/^(11+)\1+$/)
null
> 
\end{verbatim}
\item

Busque  una solución al siguiente ejercicio 
(véase 'Regex to add space after punctuation sign' en \perlmonk{319742})
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
> x = "a,b,c,1,2,d, e,f"
'a,b,c,1,2,d, e,f'
> x.replace(/,/g,", ")
'a, b, c, 1, 2, d,  e, f'
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique.

\begin{enumerate}
\item 
La siguiente solución logra el segundo objetivo, pero estropea los números:
\begin{verbatim}
> x = "a,b,c,1,2,d, e,f"
'a,b,c,1,2,d, e,f'
> x.replace(/,(\S)/g,", $1")
'a, b, c, 1, 2, d, e, f'
\end{verbatim}
\item 
Esta  otra funciona bien con los números pero no con los espacios ya existentes:
\begin{verbatim}
> x = "a,b,c,1,2,d, e,f"
'a,b,c,1,2,d, e,f'
> x.replace(/,(\D)/g,", $1")
'a, b, c,1,2, d,  e, f'
\end{verbatim}
\item 
Explique cuando casa esta expresión regular:
\begin{verbatim}
> r = /(\d[,.]\d)|(,(?=\S))/g
/(\d[,.]\d)|(,(?=\S))/g
\end{verbatim}
Aproveche que el método \verb|replace| puede recibir como segundo argumento
una función (vea \htmladdnormallink{replace}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace}):
\begin{verbatim}
> z = "a,b,1,2,d, 3,4,e"
'a,b,1,2,d, 3,4,e'
> f = function(match, p1, p2, offset, string) { return (p1 || p2 + " "); }
[Function]
> z.replace(r, f)
'a, b, 1,2, d, 3,4, e'
\end{verbatim}
\end{enumerate}
\end{enumerate}

\sectionpractica{Palabras Repetidas}

Se trata de producir una salida en las que las palabras repetidas consecutivas sean reducidas a una sola aparición.
Rellena las partes que faltan.

\parrafo{Ejemplo de ejecución}

\begin{figure}[htb]
\begin{center}
% \includegraphics[scale=0.5]{chapter2/repeated_words.png}
\end{center}
\label{figure:csv}
\caption{Ejemplo de pantalla de La aplicación para el Análisis de Datos en Formato CSV}
\end{figure}

\parrafo{Estructura}

\begin{rawhtml}
<pre>
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$  tree --charset utf-8 
.
├── README
├── global.css
├── index.html
├── input.txt
├── input2.txt
├── inputhtml1.txt
└── repeated_words.js

0 directories, 7 files
</pre>
\end{rawhtml}

\parrafo{index.html}
\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat index.html 
<html>
  <head>
     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
     <title>File Input</title>
     <link href="global.css" rel="stylesheet" type="text/css">

     <script type="text/javascript" src="../../underscore/underscore.js"></script>
     <script type="text/javascript" src="../../jquery/starterkit/jquery.js"></script>
     <script type="text/javascript" src="repeated_words.js"></script>
  </head>
  <body>
    <h1>File Input</h1>
    <input type="file" id="fileinput" />
    <div id="out" class="hidden">
    <table>
      <tr><th>Original</th><th>Transformed</th></tr>
      <tr>
        <td>
          <pre class="input" id="initialinput"></pre>
        </td>
        <td>
          <pre class="output" id="finaloutput"></pre>
        </td>
      </tr>
    </table>
    </div>
  </body>
</html>
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{Tag input}{http://www.w3.org/TR/html-markup/input.file.html}
\end{enumerate}
\parrafo{global.css}

Rellena los estilos para \verb|hidden| y \verb|unhidden|:
\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat global.css 
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: right; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: ____; }
.unhidden    { display: _____; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }

body
{
 background-color:#b0c4de;  /* blue */
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{CSS display Property}{http://www.w3schools.com/cssref/pr_class_display.asp}
\item 
\htmladdnormallink{Diferencias entre "Display" y "Visibility"}{http://www.luiscanada.com/manualCSS/css-display-visibility.php}
\end{enumerate}
\parrafo{repeated\_words.js}

Rellena las expresiones regulares que faltan:
\begin{verbatim}
[~/srcPLgrado/repeatedwords(master)]$ cat repeated_words.js 
"use strict"; // Use ECMAScript 5 strict mode in browsers that support it

$(document).ready(function() {
   $("#fileinput").change(calculate);
});

function generateOutput(contents) {
  return contents.replace(/____________________/__,'__________________________________');
}

function calculate(evt) {
  var f = evt.target.files[0]; 
  var contents = '';

  if (f) {
    var r = new FileReader();
    r.onload = function(e) { 
      contents = e.target.result;
      var escaped  = escapeHtml(contents);
      var outdiv = document.getElementById("out");
      outdiv.className = 'unhidden';
      finaloutput.innerHTML = generateOutput(escaped);
      initialinput.innerHTML = escaped;

    }
    r.readAsText(f);
  } else { 
    alert("Failed to load file");
  }
}

var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
  };

function escapeHtml(string) {
  return String(string).replace(/_________/g, function (s) {
    return ____________;
  });
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{jQuery event.target}{http://api.jquery.com/event.target/}
\item 
\htmladdnormallink{HTML 5 File API}{http://www.w3.org/TR/FileAPI/}
\item 
\htmladdnormallink{HTML 5 File API: FileReader}{http://www.w3.org/TR/FileAPI/\#dfn-filereader}
\item 
\htmladdnormallink{HTML 5 File API: FileReader}{http://www.w3.org/TR/FileAPI/\#dfn-filereader}
\item 
\htmladdnormallink{element.className}{https://developer.mozilla.org/en-US/docs/DOM/element.className}
\item 
\htmladdnormallink{HTML Entities}{http://www.w3schools.com/html/html_entities.asp}
\item 
\htmladdnormallink{Tutorials:Getting Started with jQuery}{http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery}
\item 
\htmladdnormallink{Underscore: template}{http://underscorejs.org/\#template}
\end{enumerate}

\parrafo{Ficheros de Entrada}
\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat input2.txt 
habia una vez 
vez un viejo viejo
hidalgo que vivia 
vivia
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat input.txt 
one one
nothing rep
is two three
three four
[~/Dropbox/src/javascript/PLgrado/repeatedwords(master)]$ cat inputhtml1.txt 
habia => una vez 
vez & un viejo viejo <puchum>
hidalgo  & <pacham> que vivia 
vivia </que se yo>

\end{verbatim}

\section{Ejercicios}
El formato  \cei{INI} es un formato estandar 
para la escritura de ficheros de configuración. 
Su estrucutra básica se compone de
"secciones" y "propiedades". Véase la entrada de la wikipedia
\wikip{INI}{INI\_file}.
\begin{verbatim}
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.
 
[database]
; use IP address in case network name resolution is not working
server=192.0.2.62     
port=143
file = "payroll.dat"
\end{verbatim}
\begin{enumerate}
\item 
Escriba un programa javascript que obtenga las cabeceras de sección de un fichero 
INI
\item 
Escriba un programa javascript que case con los bloques de un fichero INI (cabecera mas lista de pares \verb|parámetro=valor|)

\item 
Se quieren obtener todos los pares nombre-valor, usando paréntesis con memoria para capturar cada parte.

%  Match INI section headers page 472
%  Match INI section blocks
%  Match INI name-value pairs
%  practica: INI configuration files
\item  ¿Que casa con cada paréntesis en esta regexp para los  pares nombre-valor?
\begin{verbatim}
> x = "h     = 4"
> r = /([^=]*)(\s*)=(\s*)(.*)/
> r.exec(x)
>
\end{verbatim}
\end{enumerate}

\section{Ejercicios}

\begin{enumerate}
\item 
Escriba una expresión regular que reconozca las cadenas de doble comillas.
Debe permitir la presencia de comillas y caracteres escapados.
\item 
¿Cual es la salida?
\begin{verbatim}
> "bb".match(/b|bb/)

> "bb".match(/bb|b/)

\end{verbatim}

\end{enumerate}

\sectionpractica{Ficheros INI}


\parrafo{index.html}
\begin{verbatim}
<html>
  <head>
     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
     <title>INI files</title>
     <link href="global.css" rel="stylesheet" type="text/css">

     <script type="text/javascript" src="../../underscore/underscore.js"></script>
     <script type="text/javascript" src="../../jquery/starterkit/jquery.js"></script>
     <script type="text/javascript" src="______"></script>
  </head>
  <body>
    <h1>INI files</h1>
    <input type="file" id="_________" />
    <div id="out" class="hidden">
    <table>
      <tr><th>Original</th><th>Tokens</th></tr>
      <tr>
        <td>
          <pre class="input" id="____________"></pre>
        </td>
        <td>
          <pre class="output" id="___________"></pre>
        </td>
      </tr>
    </table>
    </div>
  </body>
</html>
\end{verbatim}

\parrafo{global.css}

\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/ini(master)]$ cat global.css
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: left; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: ____; }
.unhidden    { display: _____; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }
span.header { ________________: ____ }
span.comments { ________________: ______ }
span.blanks { ________________: _____ }
span.nameEqualValue { ________________: ____ }
span.error { ________________: ___ }

body
{
 background-color:#b0c4de;  /* blue */
}
\end{verbatim}

\parrafo{Ficheros de Prueba}

\begin{verbatim}
~/Dropbox/src/javascript/PLgrado/ini(master)]$ cat input.ini 
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.

[database]
; use IP address in case network name resolution is not working
server=192.0.2.62     
port=143
file = "payroll.dat"
\end{verbatim}

\begin{verbatim}
$ cat input2.ini 
[special_fields] 
required = "EmailAddr,FirstName,LastName,Mesg" 
csvfile = "contacts.csv" 
csvcolumns = "EmailAddr,FirstName,LastName,Mesg,Date,Time" 

[email_addresses] 
sales = "jack@yahoo.com,mary@my-sales-force.com,president@my-company.com"
\end{verbatim}

\begin{verbatim}
$ cat inputerror.ini
[owner]
name=John Doe
organization$Acme Widgets Inc.
 
[database
; use IP address in case network name resolution is not working
server=192.0.2.62     
port=143
file = "payroll.dat"
\end{verbatim}

\parrafo{ini.js}


\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/ini(master)]$ cat ini.js 
"use ______"; // Use ECMAScript 5 strict mode in browsers that support it

$(document)._____(function() {
   $("#fileinput").______(calculate);
});

function calculate(evt) {
  var f = evt.target.files[0]; 

  if (f) {
    var r = new __________();
    r.onload = function(e) { 
      var contents = e.target.______;
      
      var tokens = lexer(contents);
      var pretty = tokensToString(tokens);
      
      out.className = 'unhidden';
      initialinput._________ = contents;
      finaloutput._________ = pretty;
    }
    r.__________(f); // Leer como texto
  } else { 
    alert("Failed to load file");
  }
}

var temp = '<li> <span class = "<%= ______ %>"> <%= _ %> </span>\n';

function tokensToString(tokens) {
   var r = '';
   for(var i in tokens) {
     var t = tokens[i];
     var s = JSON.stringify(t, undefined, 2);
     s = _.template(temp, {t: t, s: s});
     r += s;
   }
   return '<ol>\n'+r+'</ol>';
}

function lexer(input) {
  var blanks         = /^___/;
  var iniheader      = /^________________/;
  var comments       = /^________/;
  var nameEqualValue = /^________________________/;
  var any            = /^_______/;

  var out = [];
  var m = null;

  while (input != '') {
    if (m = blanks.____(input)) {
      input = input.substr(m.index+___________);
      out.push({ type : ________, match: _ });
    }
    else if (m = iniheader.exec(input)) {
      input = input.substr(___________________);
      _______________________________________ // avanzemos en input
    }
    else if (m = comments.exec(input)) {
      input = input.substr(___________________);
      _________________________________________
    }
    else if (m = nameEqualValue.exec(input)) {
      input = input.substr(___________________);
      _______________________________________________
    }
    else if (m = any.exec(input)) {
      _______________________________________
      input = '';
    }
    else {
      alert("Fatal Error!"+substr(input,0,20));
      input = '';
    }
  }
  return out;
}
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{JSON.stringify}{https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify}
\item 
\htmladdnormallink{www.json.org}{http://www.json.org/}
\item 
\htmladdnormallink{JSON in JavaScript}{http://www.json.org/js.html}
\item 
\htmladdnormallink{Underscore: template}{http://underscorejs.org/\#template}
\item 
\htmladdnormallink{Stackoverflow::how to use Underscore template}{http://stackoverflow.com/questions/4778881/how-to-use-underscore-js-as-a-template-engine}
\end{enumerate}

\sectionpractica{Analizador Léxico para Un Subconjunto de JavaScript}

\begin{enumerate}
\item  Clone el proyecto 
\htmladdnormallink{ull-etsii-grado-pl-minijavascript}{https://github.com/crguezl/ull-etsii-grado-pl-minijavascript} en github. Rellene las partes que faltan en cada fichero.
\end{enumerate}
\section{Definición y Diseño de Lenguajes}
%  ver herramientas firefox y chrome para desarrollo



\section{Expresiones Regulares Posix en C}
Las Expresiones Regulares 'a la Perl' no forman parte de ANSI C. 
La forma mas sencilla de usar regexps en C es utilizando la versión POSIX de la
librería que viene con la mayoría de los Unix.
Sigue un ejemplo que usa regex POSIX en C:
\begin{verbatim}
[~/src/C/regexp]$ cat use_posix.c 
#include <stdio.h>
#include <stdlib.h>
#include <regex.h>        

int main() {
       regex_t regex;
       int reti;
       char msgbuf[100];

/* Compile regular expression */
        reti = regcomp(&regex, "^a[[:alnum:]]", 0);
        if( reti ){ fprintf(stderr, "Could not compile regex\n"); exit(1); }

/* Execute regular expression */
        reti = regexec(&regex, "abc", 0, NULL, 0);
        if( !reti ){
                puts("Match");
        }
        else if( reti == REG_NOMATCH ){
                puts("No match");
        }
        else{
                regerror(reti, &regex, msgbuf, sizeof(msgbuf));
                fprintf(stderr, "Regex match failed: %s\n", msgbuf);
                exit(1);
        }

/* Free compiled regular expression if you want to use the regex_t again */
    regfree(&regex);
}
\end{verbatim}
Compilación y ejecución:
\begin{verbatim}
[~/src/C/regexp]$ cc use_posix.c  -o use_posix
[~/src/C/regexp]$ ./use_posix 
Match
\end{verbatim}


\parrafo{Enlaces Relacionados}
\begin{enumerate}
\item 
\htmladdnormallink{Regular Expression Matching in GNU C}{http://www.gnu.org/software/libc/manual/html_node/Regular-Expressions.html}
\item 
\htmladdnormallink{Pattern Matching in GNU C}{http://www.gnu.org/software/libc/manual/html_node/Pattern-Matching.html\#Pattern-Matching}
\item 
\htmladdnormallink{PCRE}{http://www.pcre.org/}
\item 
\htmladdnormallink{PCRE doc}{http://www.pcre.org/pcre.txt}
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter2/regexp.tex

%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter2/flex.tex
\chapter{Expresiones Regulares en Flex} 
Puede encontrar los ejemplos de este capítulo en
\htmladdnormallink{https://github.com/crguezl/flex-examples}{https://github.com/crguezl/flex-examples}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Un lenguaje regular es aquel que puede ser descrito mediante expresiones
regulares como las que se utilizan en \verb|ex|, \verb|vi|, \verb|sed|,
\verb|perl| y en tantas otras utilidades UNIX. Dado un lenguaje regular,
un analizador l\'exico es un programa capaz de reconocer las entradas
que pertenecen a dicho lenguaje y realizar las acciones sem\'anticas
que se hayan asociado con los estados de aceptaci\'on.
Un generador de analizadores l\'exicos es una herramienta que facilita
la construcci\'on de un analizador l\'exico. Un generador de analizadores
l\'exicos parte, por tanto, de un lenguaje adecuado para la descripci\'on
de lenguajes regulares (y de su sem\'antica) y produce como salida
una funci\'on (en C, por ejemplo) que materializa el correspondiente
analizador l\'exico.
La mayor parte de los generadores producen a partir del conjunto de
expresiones regulares los correspondientes tablas de los autómatas
finitos deterministas. Utilizando dichas tablas y un algoritmo de
simulación genérico del autómata finito determinista se obtiene el
analizador léxico. Una vez obtenido el estado de aceptación a partir de
la entrada es posible, mediante una sentencia \verb|switch| ejecutar la
acción semántica asociada con la correspondiente expresión regular.

\section{Estructura de un programa LEX}
\label{section:estructuraflex}

\parrafo{Estructura de un programa}

\tei{LEX} y \tei{FLEX} son ejemplos de generadores léxicos. \tei{Flex}
lee desde la entrada est\'andar si no se especifica explícitamente
un fichero de entrada. El fichero de entrada \verb|reglen.l| (se suele usar el tipo \verb|l|)
debe tener la forma:\\

\begin{tt}
\noindent \%\{              \\
declaration C1              \\
.\\
.\\
.\\                   \\
declaration CM              \\
\%\}              \\
macro\_name1 regular\_definition1                  \\
.\\
.\\
.\\                       \\
macro\_nameR regular\_definitionR                  \\

\noindent \%x exclusive\_state\\
\%s inclusive\_state\\
\%\%              \\
              \\
regular\_expression1 \{ action1(); \}              \\
.\\
.\\
.\\              \\
regular\_expressionN \{ actionN(); \}              \\
              \\
\%\%              \\
support\_routine1() \{              \\
\}              \\
.\\
.\\
.\\              \\
support\_routineS() \{              \\
\}              \\
\end{tt}

Como vemos,  un programa \verb|LEX| consta de 3 secciones, separadas
por \verb|%%|. La primera secci\'on se denomina \cei{secci\'on de
definiciones},
la segunda \cei{secci\'on de reglas} 
y la tercera \cei{secci\'on de c\'odigo}. 
La primera y la \'ultima son opcionales, as\'{\i} el programa legal \verb|LEX| mas simple es:

\begin{tabular}{|p{8cm}|}
\hline
\begin{verbatim}
%%
\end{verbatim}\\
\hline
\end{tabular}

que genera un analizador que copia su entrada en \verb|stdout|.


\parrafo{Compilación}

\noindent Una vez compilado el fichero de entrada \verb|regleng.l|
mediante la correspondiente orden:

\verb|flex reglen.l| 

\noindent obtenemos un fichero denominado \verb|lex.yy.c|. Este fichero
contiene la rutina \verb|yylex()| que realiza el an\'alisis l\'exico
del lenguaje descrito en \verb|regleng.l|. Supuesto que una de las
\verb|support_routines| es una funci\'on \verb|main()| que llama a la
funci\'on \verb|yylex()|, podemos compilar el fichero generado con un
compilador C para obtener un ejecutable \verb|a.out|:

\verb|cc lex.yy.c -lfl| 

\noindent La inclusi\'on de la opci\'on \verb|-fl| enlaza con la
librer\'{\i}a de \verb|flex|, que contiene dos funciones: \verb|main|
y \verb|yywrap()|.

\parrafo{Ejecución}

Cuando ejecutamos el programa \verb|a.out|, la funci\'on \verb|yylex()|
analiza las entradas, buscando la secuencia mas larga que casa con alguna
de las expresiones regulares (\verb|regular_expressionK|) y ejecuta la
correspondiente acci\'on (\verb|actionK()|).
Si no se encuentra ningun  emparejamiento se ejecuta la \cei{regla por defecto}, que es:

\verb@(.|\n)  { printf("%s",yytext); }@

Si encuentran dos expresiones regulares con las que la cadena mas larga
casa, elige la que figura primera en el programa \verb|lex|.
Una vez que \verb|yylex()| ha encontrado el \emph{token}, esto es, el
patr\'on que casa con la cadena mas larga, dicha cadena queda disponible
a trav\'es del puntero global \tei{yytext}, y su longitud queda en la
variable entera global \tei{yyleng}.

Una vez que se ha ejecutado la correspondiente acci\'on, \verb|yylex()|
contin\'ua con el resto de la entrada, buscando por subsiguientes
emparejamientos. Asi continúa hasta encontrar un \verb|end of file|,
en cuyo caso termina, retornando un cero o bien hasta que una de las
acciones explicitamente ejecuta una sentencia \verb|return|.


\parrafo{Secci\'on de definiciones}

La primera secci\'on contiene, si las hubiera,  las definiciones regulares
y las declaraciones de los estados de arranque.

Las definiciones tiene la forma:

\emph{name regular\_definition}

donde \emph{name} puede ser descrito mediante la expresi\'on regular:

\verb|[a-zA-Z_][a-zA-Z_0-9-]*| 

La \emph{regular\_definition} comienza en el primer car\'acter no
blanco que sigue a \emph{name} y termina al final de la l\'{\i}nea. La
definici\'on es una expresi\'on regular extendida. Las subsiguientes
definiciones pueden ``llamar'' a la macro \verb|{name}| escribi\'endola
entre llaves. La macro se expande entonces a \verb|(regular_definition)|
en \verb|flex| y a \verb|regular_definition| en \verb|lex|.

El c\'odigo entre los delimitadores \verb|%{| y \verb|%}| se copia
verbatim al fichero de salida, situ\'andose en la parte de declaraciones
globales. Los delimitadores deben aparecer (s\'olos) al comienzo de
la l\'{\i}nea.

\parrafo{El Lenguaje de las Expresiones Regulares Flex}

La sint\'axis que puede utilizarse para la descripci\'on de las
expresiones regulares es la que se conoce como ``extendida'':

\begin{itemize}
\item
\verb@x@	      Casa con 'x'
\item
\verb@.@	      Cualquier car\'acter, excepto \verb|\n|.
\item
\verb@[xyz]@      Una ``clase''; en este caso una de las letras \verb'x', \verb'y', \verb'z'
\item
\verb@[abj-oZ]@   Una ``clase'' con un rango; casa con  \verb'a',  \verb'b', cualquier letra desde  \verb'j' hasta \verb'o', o una \verb'Z'
\item
\verb@[^A-Z]@     Una ``Clase complementada'' esto es, todos los caracteres que no est\'an en la clase. Cualquier car\'acter, excepto las letras may\'usculas. Obs\'ervese que el retorno de carro \verb|\n| casa
con esta expresion. As\'{\i} es posible que, <un patr\'on como \verb|[^"]+| pueda casar con todo el fichero!.
\item
\verb@[^A-Z\n]@   Cualquier car\'acter, excepto las letras may\'usculas o un \verb|\n|.
\item

\verb|[[:alnum:]]| Casa con cualquier caracter alfanum\'erico. Aqui \verb|[:alnum:]| se refiere a una de las clases predefinidas. Las otras clases son: \verb|[:alpha:]| \verb|[:blank:]| \verb|[:cntrl:]| \verb|[:digit:]| \verb|[:graph:]| \verb|[:lower:]| \verb|[:print:]| \verb|[:punct:]| \verb|[:space:]| \verb|[:upper:]| \verb|[:xdigit:]|. Estas clases designan el mismo conjunto de caracteres que la correspondiente funci\'on C \verb|isXXXX|.

\item
\verb@r*@	Cero o mas \verb|r|.
\item
\verb@r+@       Una o mas \verb|r|.
\item
\verb@r?@	Cero o una  \verb|r|.
\item
\verb@r{2,5}@     Entre 2 y 5  \verb|r|.
\item
\verb@r{2,}@      2 o mas \verb|r|. 
\verb@r{4}@	  Exactamente 4 \verb|r|. 
\item
\verb@{macro_name}@     La expansi\'on de \verb"macro_name" por su \emph{regular\_definition}
\item
\verb@"[xyz]\"foo"@ Exactamente la cadena: [xyz]"foo
\item
\verb@\X@	      Si \verb|X| is an \verb'a', \verb'b', \verb'f', \verb'n', \verb'r', \verb't', o \verb'v', entonces, la interpretaci\'on ANSI-C de \verb|\x|.  En cualquier otro caso \verb'X'.
\item
\verb@\0@	      El car\'acter NUL (ASCII 0).
\item
\verb@\123@	      El car\'acter cuyo c\'odigo octal es 123.
\item
\verb@\x2a@	      El car\'acter cuyo c\'odigo hexadecimal es 2a.
\item
\verb@(r)@	      Los par\'entesis son utilizados para cambiar la precedencia.
\item
\verb@rs@	      Concatenation
\item
\verb@r|s@	      Casa con  \verb|r| o \verb|s|
\item
\verb@r/s@	      Una \verb@r@ pero s\'olo si va seguida de una \verb@s@. El texto casado con \verb@s@ se incluye a la hora de decidir cual es el emparejamiento mas largo, pero se devuelve a la entrada cuando se ejecuta la acci\'on. La acci\'on s\'olo ve el texto asociado con \verb@r@. Este tipo de patr\'on se denomina \emph{trailing context} o \emph{lookahead} positivo.  
\item
\verb@^r@	      Casa con \verb@r@, al comienzo de una l\'{\i}nea.
                      Un \verb|^| que no aparece al comienzo de la l\'{\i}nea o un \verb|$| que no aparece al final de la l\'{\i}nea, pierde su naturaleza de ``ancla'' y es tratado como un car\'acter ordinario. Asi: \verb#foo|(bar$)# se empareja con \verb|bar$|. Si lo que se quer\'{\i}a es la otra interpretaci\'on, es posible escribir \verb#foo|(bar\n)#, o bien:
\begin{verbatim}
foo |
bar$   { /* action */ }
\end{verbatim}
\item
\verb@r$@	      Casa con \verb@r@, al final de una l\'{\i}nea. Este es tambi\'en un operador de \emph{trailing context}. Una regla no puede tener mas de un operador de \emph{trailing context}. Por ejemplo, la expresi\'on \verb|foo/bar$| es incorrecta.
\item
\verb@<s>r@	      Casa con \verb@r@, pero s\'olo si se est\'a en el estado \verb|s|.
\item
\verb@<s1,s2,s3>r@    Idem, si se esta en alguno de los estados \verb|s1|, \verb|s2|, or \verb|s3|
\item
\verb@<*>r@	      Casa con \verb@r@ cualquiera que sea el estado, incluso si este es exclusivo.
\item
\verb@<<EOF>>@        Un final de fichero.
\item
\verb@<s1,s2><<EOF>>@ Un final de fichero, si los estados son \verb|s1| o \verb|s2|
\end{itemize}

Los operadores han sido listados en orden de precedencia, de la
mas alta a la mas baja. Por ejemplo \verb#foo|bar+# es lo mismo que
\verb#(foo)|(ba(r)+)#.

\parrafo{Las Acciones Semánticas}

Cada patrón regular tiene su correspondiente acción asociada. El patrón
termina en el primer espacio en blanco (sin contar aquellos que están
entre comillas dobles o prefijados de secuencias de escape).
Si la acción comienza con \verb|{|, entonces se puede extender a través
de multiples líneas, hasta la correspondiente \verb|}|.  El programa
\verb|flex|  no hace un análisis del código C dentro de la acción.
Existen tres directivas que pueden insertarse dentro de las acciones:
\verb|BEGIN|, \verb|ECHO| y \verb|REJECT|. Su uso se muestra en los
subsiguientes ejemplos.


La secci\'on de c\'odigo se copia verbatim en \verb|lex.yy.c|. Es
utilizada para proveer las funciones de apoyo que se requieran para la
descripci\'on de las acciones asociadas con los patrones que parecen en
la secci\'on de reglas.

\section{Versi\'on Utilizada}
Todos los ejemplos que aparecen en este documento fueron
preparados con la versi\'on 2.5.4 de \emph{flex} en un entorno
Linux 
\begin{verbatim}
$ uname -a
Linux nereida.deioc.ull.es 2.2.12-20 #10 Mon May 8 19:40:16 WEST 2000 i686 unknown
$ flex --version   
flex version 2.5.4      
\end{verbatim}
y con la versi\'on 2.5.2 en un entorno Solaris
\begin{verbatim}
> uname -a
SunOS fonil 5.7 Generic_106541-04 sun4u sparc SUNW,Ultra-5_10
> flex --version
flex version 2.5.2       
\end{verbatim}

\section{Espacios en blanco dentro de la expresión regular}
\label{section:blancos}
La expresión regular va desde el comienzo de la línea hasta el primer espacio en blanco 
no escapado. Todos los espacios en blanco que formen parte de la 
expresión regular 
deben ser escapados o protegidos entre comillas. Así, el siguiente
programa produce un error en tiempo de compilación C:
\begin{verbatim}
> cat spaces.l
%%
one two { printf("spaces\n"; }
%%
nereida:~/public_html/regexpr/lex/src> flex spaces.l
nereida:~/public_html/regexpr/lex/src> gcc lex.yy.c
spaces.l: In function `yylex':
spaces.l:2: `two' undeclared (first use in this function)
spaces.l:2: (Each undeclared identifier is reported only once
spaces.l:2: for each function it appears in.)
spaces.l:2: parse error before `{'
spaces.l:4: case label not within a switch statement
lex.yy.c:632: case label not within a switch statement
lex.yy.c:635: case label not within a switch statement
lex.yy.c:757: default label not within a switch statement
lex.yy.c: At top level:
lex.yy.c:762: parse error before `}'
\end{verbatim}
Deberíamos escapar el blanco entre \verb|one| y \verb|two| o bien
proteger la cadena poniéndola entre comillas: \verb|"one two"|.

\section{Ejemplo Simple}
\label{section:ejemplosimple}
Este primer ejemplo sustituye las apariciones de la palabra 
\emph{username} por el \emph{login} del usuario:
\begin{verbatim}
$ cat subst.l
%option main
%{
#include <unistd.h>
%}
%%
username    printf( "%s",  getlogin());
%%
$ flex -osubst.c subst.l
$ gcc -o subst subst.c
$ subst
Dear username:
Dear pl:
\end{verbatim}
He presionado CTRL-D para finalizar la entrada.\\
Observe el uso de la opci\'on \verb|%option main| en el fichero
\emph{subst.l} para hacer que \emph{flex} genere una funci\'on
\emph{main}. Tambi\'en merece especial
atenci\'on el uso de la opci\'on  \verb|-osubst| para cambiar el
nombre del fichero de salida, que por defecto ser\'a \emph{lex.yy.c}.

\section{Suprimir}
\label{section:suprimir}
Al igual que en \emph{sed} y \emph{awk}, es muy sencillo
suprimir las apariciones de una expresi\'on regular. 
\begin{verbatim}
$ cat delete.l
/* delete all entries of zap me */
%%
"zap me"
$ flex delete.l ; gcc lex.yy.c -lfl; a.out
this is zap me a first zap me phrase
this is  a first  phrase 
\end{verbatim}

\section{Declaraci\'on de yytext}
\label{section:yytextdec}
En la sección de definiciones es posible utilizar las directivas
\verb@%pointer@ o \verb@%array@. Estas directivas hacen que \tei{yytext}
se declare como un puntero o un \emph{array} respectivamente.
La opción por defecto es declararlo como un puntero, salvo que se haya
usado la opción \verb|-l| en la línea de comandos, para garantizar una
mayor compatibilidad con \verb|LEX|.
Sin embargo, y aunque la opci\'on  \verb|%pointer| es la mas eficiente
(el análisis es mas rápido y se evitan los \emph{buffer overflow}),
limita la posible manipulaci\'on de \emph{yytext} y de las llamadas
a \verb|unput()|.
\begin{verbatim}
$ cat yytextp.l
%%
hello {
        strcat(yytext, " world");
        printf("\n%d: %s\n",strlen(yytext),yytext);
      }
$ flex yytextp.l ; gcc lex.yy.c -lfl ; a.out
hello
 
11: hello world
 
fatal flex scanner internal error--end of buffer missed 
\end{verbatim}
Este error no aparece si se utiliza la opci\'on \verb|%array|:
\begin{verbatim}
$ cat yytext.l
%array
%%
hello {
        strcat(yytext, " world");
        printf("\n%d: %s\n",strlen(yytext),yytext);
      }
$ flex yytext.l; gcc lex.yy.c -lfl; a.out
hello
 
11: hello world
                              
\end{verbatim}

Además, algunos programs \verb|LEX|  modifican directamente \verb|yytext|, utilizando la declaración:

\noindent \verb|extern char yytext[]|

\noindent que es incompatible con la directiva \verb@%pointer@ (pero correcta con \verb@%array@).
La directiva \verb@%array@ define \verb|yytext| como un \emph{array} de tamaño \verb|YYLMAX|.
Si deseamos trabajar con un mayor tamaño, basta con redefinir \verb|YYLMAX|.

\section{Declaraci\'on de yylex()}
\label{section:yylexdec}
Por defecto la funci\'on \emph{yylex()} que realiza el an\'alisis l\'exico es
declarada como  \verb|int yylex()|. Es posible cambiar la declaraci\'on
por defecto utilizando la macro \emph{YY\_DECL}. En el siguiente ejemplo
la definici\'on:
\begin{verbatim}
#define YY_DECL char *scanner(int *numcount, int *idcount)
\end{verbatim}
hace que la rutina de an\'alisis l\'exico pase a llamarse 
\emph{scanner} y tenga dos parametros de entrada, retornando
un valor de tipo \verb|char *|.
\begin{verbatim}
$ cat decl.l
%{
#define YY_DECL char *scanner(int *numcount, int *idcount)
%}
 
num [0-9]+
id [a-z]+
%%
{num} {(*numcount)++;}
halt  {return ((char *) strdup(yytext));}
{id}  {(*idcount)++;}
%%
main() {
  int a,b;
  char *t;
 
  a = 0; b = 0;
  t = scanner(&a, &b);
  printf("numcount = %d, idcount = %d, yytext = %s\n",a,b,t);
  t = scanner(&a, &b);
  printf("numcount = %d, idcount = %d, yytext = %s\n",a,b,t);
}
 
int yywrap() {
  return 1;
}                                
\end{verbatim}
La ejecuci\'on del programa anterior produce la siguiente salida:
\begin{verbatim}
$ decl
a b 1 2 3 halt
     numcount = 3, idcount = 2, yytext = halt
 
e 4 5 f
 
numcount = 5, idcount = 4, yytext = (null)
$ decl
a b 1 2 3 halt
     numcount = 3, idcount = 2, yytext = halt
 
e 4 f 5 halt
    numcount = 5, idcount = 4, yytext = halt     
\end{verbatim}

\section{yywrap()}
Cuando el analizador l\'exico alcanza el final del fichero, el
comportamiento en las subsiguientes llamadas a \emph{yylex}
resulta indefinido.  En el momento en que  \emph{yylex()}
alcanza el final del fichero llama a la funci\'on \emph{yywrap}, la cual retorna un
valor de 0 o 1 seg\'un haya mas entrada o no. Si el valor es 0,
la funci\'on \emph{yylex} asume que la propia \emph{yywrap}
se ha encargado de abrir el nuevo fichero y asignarselo
a \tei{yyin}.  Otra manera de continuar es haciendo uso de
la funci\'on \emph{yyrestart(FILE *file)}. 
El siguiente ejemplo cuenta el n\'umero de l\'{\i}neas, palabras y
caracteres en una lista de ficheros proporcionados como entrada.

%\listinginput{1}{../src/countlwc2.l}
\begin{verbatim}
%{
unsigned long charCount = 0, wordCount = 0, lineCount = 0;
%}

word [^ \t\n]+ 
eol \n 

%%
{word} { wordCount++; charCount += yyleng; }
{eol} { charCount++; lineCount++; }
. charCount++;

%%

char **fileList;
unsigned nFiles;
unsigned currentFile = 0;
unsigned long totalCC = 0;
unsigned long totalWC = 0;
unsigned long totalLC = 0;

main ( int argc, char **argv) {
  FILE *file;

  fileList = argv + 1; nFiles = argc - 1;

  if (nFiles == 0) {
    fprintf(stderr,"Usage is:\n%s file1 file2 file3 ...\n",argv[0]);
    exit(1);
  }
  file = fopen (fileList[0], "r");
  if (!file) {
      fprintf (stderr, "could not open %s\n", argv[1]);
      exit (1);
  }
  currentFile = 1; yyrestart(file);
  yylex ();
  printf ("%8lu %8lu %8lu %s\n", lineCount, wordCount,
    charCount, fileList[currentFile - 1]);
  if (argc > 2) {
      totalCC += charCount; totalWC += wordCount; totalLC += lineCount;
      printf ("%8lu %8lu %8lu total\n", totalLC, totalWC, totalCC);
  }
  return 0;
}

int yywrap () {
  FILE *file;

  if (currentFile < nFiles) {
     printf ("%8lu %8lu %8lu %s\n", lineCount, wordCount,
       charCount, fileList[currentFile - 1]);
     totalCC += charCount; totalWC += wordCount; totalLC += lineCount;
     charCount = wordCount = lineCount = 0;
     fclose (yyin);

     while (fileList[currentFile] != (char *) 0) {
       file = fopen (fileList[currentFile++], "r");
       if (file != NULL) { yyrestart(file); break; }
	  fprintf (stderr, "could not open %s\n", fileList[currentFile - 1]);
     }
     return (file ? 0 : 1);
    }
    return 1;
}
\end{verbatim}

La figura muestra el proceso de compilaci\'on y la ejecuci\'on:
\begin{verbatim}
$ flex countlwc.l;gcc lex.yy.c; a.out *.l
      58      179     1067 ape-05.l
      88      249     1759 countlwc.l
      11       21      126 magic.l
       9       17      139 mgrep.l
       9       16      135 mlg.l
       5       15      181 ml.l
       7       12       87 subst.l
     187      509     3494 total          
\end{verbatim}
La diferencia esencial entre asignar \emph{yyin} o llamar a la
funci\'on \emph{yyrestart} es que esta \'ultima puede ser utilizada para
conmutar entre ficheros en medio de un an\'alisis l\'exico. El
funcionamiento del programa anterior no se modifica si se 
se intercambian asignaciones a \emph{yyin} (\emph{yyin = file})
y llamadas a \emph{yyrestart(file)}.

\section{unput()}
La funci\'on \emph{unput(c)} coloca el car\'acter \emph{c} en el flujo
de entrada, de manera que ser\'a el primer car\'acter le\'{\i}do en pr\'oxima
ocasi\'on.
\begin{verbatim}
$ cat unput2.l
%array
%%
[a-z] {unput(toupper(yytext[0]));}
[A-Z] ECHO;
%%
$ flex unput2.l ; gcc lex.yy.c -lfl;a.out
abcd
ABCD                             
\end{verbatim}
Un problema importante con \emph{unput} es que, cuando se utiliza la
opci\'on \verb|%pointer|, las llamadas a \emph{unput} destruyen los
contenidos de \emph{yytext}. Es por eso que, en el siguiente ejemplo se
hace una copia de \emph{yytext}. La otra alternativa es, por supuesto,
usar la opci\'on \verb|%array|.
\begin{verbatim}
$ cat unput.l
%%
[0-9]+ {
  int i;
  char *yycopy = (char *) strdup(yytext);
 
  unput(')');
  for(i=strlen(yycopy)-1; i>=0; --i)
    unput(yycopy[i]);
  unput('(');
  free(yycopy);
}
\([0-9]+\) printf("Num inside parenthesis: %s\n",yytext);
.|\n
$ flex unput.l ; gcc lex.yy.c -lfl ; a.out
32
Num inside parenthesis: (32)
(43)
Num inside parenthesis: (43)            
\end{verbatim}

\section{input()}
\label{section:input}
La funci\'on \emph{input()} lee desde el flujo de entrada 
el siguiente car\'acter. Normalmente la utilizaremos si queremos 
tomar ``personalmente el control''  del an\'alisis. El ejemplo 
permite ``engullir'' los comentarios (no anidados):
\begin{verbatim}
$ cat input.l
%%
"/*" {
        int c;
        for(;;) {
          while ((c=input()) != '*' && c != EOF)
            ;
          if (c == '*')  {
            while ((c = input()) == '*')
              ;
            if (c == '/') break;
          }
          if (c == EOF) {
            fprintf(stderr,"Error: EOF in comment");
            yyterminate();
          }
        }
      }                                              
\end{verbatim}
La funci\'on \verb|yyterminate()| termina la rutina de an\'alisis l\'exico y devuelve un cero indicándole a la rutina que llama que todo se ha acabado. 
Por defecto, \verb|yyterminate()| es llamada cuando se encuentra 
un final de fichero. Es una macro y puede ser redefinida.
\begin{verbatim}
$ flex input.l ; gcc lex.yy.c -lfl ; a.out
hello /* world */
hello
unfinished /* comment
unfinished Error: EOF in comment
\end{verbatim}
He presionado CTRL-D despu\'es de entrar la palabra \emph{comment}.

%\section{Uso de Tablas para Palabras Reservadas e Identificadores}
%Desde el punto de vista de la eficiencia no es una buena idea mantener una 
%expresi\'on regular separada para cada \emph{token} del lenguaje. La alternativa 
%es utilizar dos tablas: una primera para las palabras reservadas y la otra 
%para los identificadores y definiciones de tipo.
%
%El siguiente  ejemplo muestra los contenidos de un analizador 
%léxico típico. Comenzemos con el código de cabecera:
%
%\begin{verbatim}
%%{
%/*
% * samplecl.l at /home/pl/src/samplec_casiano/lexer
% */
%
%#ifdef LDEBUG
%
%#define Identifier 257
%#define Constant 258
%#define INT 259
%#define IF 260
%#define ELSE 261
%#define WHILE 262
%#define BREAK 263
%#define CONTINUE 264
%#define RETURN 265
%#define GE 266
%#define LE 267
%#define EQ 268
%#define NE 269
%#define PE 270
%#define ME 271
%#define TE 272
%#define DE 273
%#define RE 274
%#define PP 275
%#define MM 276
%
%main() {
%  int p;
%
%  while (p = yylex())
%    printf("%d is \"%s\"\n",p,yytext);
%}
%
%s_lookup() {}
%
%int yy_nerrs = 0;
%
%#define x x
%
%#else ! LDEBUG /* production version */
%
%#include "y.tab.h"
%#define x x
%
%#endif LDEBUG
%
%#define END(v) (v-1 + sizeof v / sizeof v[0])
%static int screen();
%
%%}
%\end{verbatim}
%
%A continuación siguen las definiciones de macros de expresiones regulares:
%
%\begin{verbatim}
%letter                   [a-zA-Z]
%digit                    [0-9]
%letter_or_digit          [a-zA-Z0-9]
%white_space              [ \t\n]
%blank                    [ \t]
%other                    .
%
%%%
%\end{verbatim}
%
%A continuación siguen las parejas patrón-acción:
%
%\begin{verbatim}
%
%"#"{blank}*{digit}+({blank}+.*)?\n  yymark();
%">="    return GE;
%"<="    return LE;
%"!="    return NE;
%"+="    return PE;
%"-="    return ME;
%"*="    return TE;
%"/="    return DE;
%"%="    return RE;
%"++"    return PP;
%"--"    return MM;
%
%{letter}{letter_or_digit}* return screen();
%
%{digit}+                   {
%                             s_lookup(Constant);
%                             return Constant;
%                           }
%{white_space}+             ;
%
%{other}                    return (yytext[0]);
%
%%%
%\end{verbatim}
%Por último, el código de cola:
%\begin{verbatim}
%/*
% *  reserved word table
% */
%
%static struct rwtable {
%  char * rw_name;
%  int rw_yylex;
%  } rwtable[] = {
%  "break", BREAK,
%  "continue", CONTINUE,
%  "else", ELSE,
%  "if", IF,
%  "int", INT,
%  "return", RETURN,
%  "while", WHILE
%  };
%
%static int screen() {
%  struct rwtable * low = rwtable, *high = END(rwtable), *mid;
%  int c;
%
%  while (low <= high) {
%    mid = low + (high -low)/2;
%    if ((c = strcmp(mid->rw_name, yytext)) == 0)
%      return mid->rw_yylex;
%    else if (c < 0)
%      low = mid+1;
%    else
%      high = mid-1;
%  }
%  s_lookup(Identifier);
%  return Identifier;
%}
%
%int yywrap() { return 1; }
%
%\end{verbatim}
%
%\subsection{popen y freopen}
%La funci\'on \verb|*popen(const char *command, const char *type)| abre
%un \emph{pipe}. Nuestro programa entra en una ejecuci\'on en canal con el
%\emph{command} descrito como primer par\'ametro de la funci\'on. 
%Si la variable \emph{type} es descrita como \verb|"r"|, ello
%significa que nuestro programa ser\'a alimentado por el programa
%descrito en \emph{command} a trav\'es del fichero retornado por la funci\'on.  
%Si el fichero que usaramos fuera
%\emph{stdin} ser\'{\i}a equivalente a:
%\begin{center}
%\verb|command | miprograma|
%\end{center}
%El siguiente ejemplo ilustra su uso:
%\begin{verbatim}
%% cat popenr.c
%#include <stdio.h>
%main() {
%  int c, lineno = 1;
%  char string[80];
%        FILE * yyin;
% 
%  yyin = (FILE *)popen("cat hello.c","r");
%        fprintf(stdout,"%2d ",lineno++);
%  while ((c = fgetc(yyin)) != EOF) {
%    putc(c,stdout);
%    if (c == '\n') fprintf(stdout,"%2d ",lineno++);
%  }
%  pclose(yyin);
%}                                         
%\end{verbatim}
%Su ejecuci\'on es equivalente a: 
%\begin{center}
%\verb|cat hello.c | a.out|
%\end{center}
%en efecto:
%\begin{verbatim}
%% a.out
% 1 #include <stdio.h>
% 2 main() {
% 3   printf("Hello World!\n");
% 4 }
% 5 %     
%\end{verbatim}
%Cuando se usa la opci\'on \verb|"w"| es lo contrario, las
%salidas de nuestro programa a trav\'es del fichero utilizado
%son absorbidas por el programa especificado en \emph{command}.
%He aqui un ejemplo:
%\begin{verbatim}
%% cat popenw.c
%#include <stdio.h>
%main() {
%        FILE *yyout;
% 
%  yyout = (FILE *)popen("sort","w");
%  fprintf(yyout,"6\n5\n4\n3\n2\n1\n");
%  pclose(yyout);
%}                                         
%% gcc popenw.c; a.out
%1
%2
%3
%4
%5
%6                              
%\end{verbatim}
%Se observa que su ejecuci\'on es equivalente a:
%\begin{center}
%\verb|a.out | sort|
%\end{center}
%La otra funci\'on que usamos en el algoritmo de pre-proceso es
%\emph{freopen}. Su formato es:
%
%\begin{center}
%\verb| FILE  *freopen  (const  char *path, const char *mode, FILE *stream);|
%\end{center}
%
%El fichero designado por \emph{path} se asocia con el fichero 
%descrito en \emph{stream}. La cadena \emph{mode} determina el modo de
%lectura. As\'{\i} en el ejemplo que sigue, todas 
%las lecturas posteriores a la llamada a
%\verb|freopen("hello.c","r",stdin);|
%ocurren desde el fichero "hello.c".
%\begin{verbatim}
%% cat freopen.c
%#include <stdio.h>
%main() {
%        int c;
% 
%        freopen("hello.c","r",stdin);
%        while ((c = getchar()) != EOF) {
%                putc(c,stdout);
%        }
%}
%/home/casiano/regexp/lex[55]% gcc freopen.c;a.out
%#include <stdio.h>
%main() {
%  printf("Hello World!\n");
%}                                      
%\end{verbatim}


\section{REJECT}
La directiva  \verb|REJECT| le indica al analizador que proceda con la 
siguiente regla que casa con un prefijo de la entrada. Como es habitual en
\emph{flex}, se elige la siguiente regla que casa  con la cadena mas
larga. Consideremos el siguiente ejemplo:
\begin{verbatim}
$ cat reject.l
%%
a    |
ab   |
abc  |
abcd ECHO; REJECT; printf("Never seen\n");
.|\n                                  
\end{verbatim}
La salida es:
\begin{verbatim}
$ gcc lex.yy.c -lfl;a.out
abcd
abcdabcaba
\end{verbatim}
Observe que \verb|REJECT| supone un cambio en el flujo de control:
El c\'odigo que figura despu\'es de \verb|REJECT| no es ejecutado.

\section{yymore()}
La funci\'on \verb|yymore()| hace que, en vez de vaciar \emph{yytext}
para el siguiente \emph{matching}, el valor actual se mantenga,
concatenando el valor actual de \emph{yytext} con el siguiente:
\begin{verbatim}
$ cat yymore.l
%%
mega- ECHO; yymore();
kludge ECHO;
 
$ flex yymore.l ; gcc lex.yy.c -lfl ; a.out
mega-kludge
mega-mega-kludge             
\end{verbatim}
La variable \verb|yyleng| no deber\'{\i}a ser modificada si se hace uso de la
funci\'on \verb|yymore()|.

\section{yyless()}
La funci\'on \verb|yyless(n)| permite retrasar el puntero de lectura  
de manera que apunta al car\'acter \emph{n} de \emph{yytext}. 
Veamos un ejemplo:
\begin{verbatim}
$ cat yyless.l
%%
foobar ECHO; yyless(4);
[a-z]+ ECHO;
 
$ flex yyless.l; gcc lex.yy.c -lfl; a.out
foobar
foobarar                                   
\end{verbatim}
Veamos un ejemplo mas ``real''. supongamos que tenemos que reconocer 
las cadenas entre comillas dobles, pero que pueden aparecer en las
mismas secuencias de escape \verb|\"|. La estrategia general del algoritmo
es utilizar la expresión regular \verb|\"[^"]+\"| y examinar si
los dos últimos  carácteres en \verb|yytext| son \verb|\"|. En tal caso, 
se concatena la cadena actual (sin la \verb|"| final) como prefijo para
el próximo emparejamiento (utilizando \verb|yymore|). 
La eliminación de la \verb|"| se hace a través de la ejecución de 
\verb|yyless(yyleng-1)|, que al mismo tiempo garantiza que el próximo emparejamiento 
tendrá lugar con este mismo patrón \verb|\"[^"]+\"|.
\begin{verbatim}
$ cat quotes.l
%%
\"[^"]+\" {
            printf("Processing string. %d: %s\n",yyleng,yytext);
            if (yytext[yyleng-2] =='\\') {
             yyless(yyleng-1); /* so that it will match next time */
             yymore(); /* concatenate  with current yytext */
             printf("After yyless. %d: %s\n",yyleng,yytext);
            } else {
              printf("Finished. The string is: %s\n",yytext);
            }
          }                    
\end{verbatim}
El ejemplo no puede entenderse si no se tiene en cuenta que
\verb2yyless(yyleng-1)2 actualiza los valores de \emph{yyleng} 
y \emph{yytext}, como muestra la salida.\\
¿Qu\'e ocurre si intercambiamos las posiciones de \verb|yymore()|
e \verb2yyless(yyleng-1)2 en el c\'odigo? >Cambiara la salida? 
La respuesta es que no. Parece que la concatenaci\'on se hace con el valor
final de \emph{yytext} y no con el valor que este ten\'{\i}a en el momento de
la llamada a \emph{yymore}.\\
Otra observaci\'on  a tener en cuenta es que \emph{yyless()}
es una macro y que, por tanto,
s\'olo puede ser utilizada dentro del fichero \emph{lex} y no en otros
ficheros fuentes.

En general, el uso de estas funciones  nos puede resolver el problema
de reconocer l\'{\i}mites que de otra forma ser\'{\i}an dif\'{\i}ciles de expresar
con una expresi\'on regular.
\begin{verbatim}
$ flex quotes.l ; gcc lex.yy.c -lfl ; a.out
"Hello \"Peter\", nice to meet you"
Procesing string. 9: "Hello \"
After yyless. 8: "Hello \
Procesing string. 16: "Hello \"Peter\"
After yyless. 15: "Hello \"Peter\
Procesing string. 35: "Hello \"Peter\", nice to meet you"
Finished. The string is: "Hello \"Peter\", nice to meet you"
\end{verbatim}

\section{Estados}
Las expresiones regulares pueden ser prefijadas mediante \emph{estados}.
Los estados o condiciones de arranque, se denotan mediante un
identificador entre \'angulos y se declaran
en la parte de las definiciones. Las declaraciones se hacen mediante 
\verb|%s| para los estados ``inclusivos'' o bien \verb|%x| para los estados ``exclusivos'',
seguidos de los nombres de los estados. No pueden haber caracteres en blanco antes de la declaración.
Un \emph{estado} se activa mediante la 
acci\'on BEGIN \emph{estado}. A partir de ese momento, las reglas que esten
prefijadas con el estado pasan a estar activas. En el caso de que el estado
sea inclusivo, las reglas no prefijadas tambi\'en permanecen activas.
Los estados exclusivos son especialmente útiles para especificar ``sub analizadores''
que analizan porciones de la entrada cuya estructura ``sintáctica'' es diferente
de la del resto de la entrada.

El ejemplo ``absorbe'' los comentarios, conservando el numero de
l\'{\i}neas del fichero en la variable \verb|linenum|

\begin{verbatim}
$ cat comments.l
%option noyywrap
%{
  int linenum = 0;
%}
%x comment
%%
 
"/*" BEGIN(comment); printf("comment=%d, YY_START = %d, YYSTATE = %d",comment,YY_START,YYSTATE);
<comment>[^*\n]* /* eat anything that is not a star * /
<comment>"*"+[^*/\n]* /* eat up starts not followed by / */
<comment>\n ++linenum; /* update number of lines */
<comment>"*"+"/" BEGIN(0);
 
\n ECHO; linenum++;
.  ECHO;
%%
main() {
  yylex();
  printf("\n%d lines\n",linenum);
}
\end{verbatim}
La opción \verb|noyywrap| hace que \verb|yylex()| no llame a la función \verb|yywrap()|
al final del fichero y que asuma que no hay mas entrada por procesar.

Los estados se traducen por enteros, pudiendo ser manipulados como tales.
La macro \verb|INITIAL| puede utilizarse para referirse al estado 0.
Las macros \verb|YY_START| y \verb|YYSTATE| contienen el valor del estado actual.
\begin{verbatim}
$ flex comments.l ; gcc lex.yy.c ; a.out < hello.c
main() <%
int a<:1:>; comment=1, YY_START = 1, YYSTATE = 1
  a<:0:> = 4; comment=1, YY_START = 1, YYSTATE = 1
  printf("hello world! a(0) is %d\n",a<:0:>);
%>
 
6 lines     
$ cat hello.c
main() <%
int a<:1:>; /* a comment */
  a<:0:> = 4; /* a comment in
                 two lines */
  printf("hello world! a(0) is %d\n",a<:0:>);
%>                                  
\end{verbatim}
En \emph{flex} es posible asociar un \'ambito con los estados o 
condiciones iniciales. Basta con colocar entre llaves las 
parejas \emph{patr\'on acci\'on} gobernadas por ese estado.
El siguiente ejemplo procesa las cadenas \emph{C}:
\begin{verbatim}
$ cat ststring.l
%option main
%x str
%{
#define MAX_STR_CONST 256
 
  char string_buffer[MAX_STR_CONST];
  char *string_buf_ptr;
%}
 
%%
\"  string_buf_ptr  = string_buffer; BEGIN(str);
<str>{
\"             {BEGIN (INITIAL); *string_buf_ptr = '\0'; printf("%s",string_buffer); }
\n             { printf("Error: non terminated string\n"); exit(1); }
\\[0-7]{1,3}   { int result; /* octal escape sequence */
                        (void) sscanf(yytext+1,"%o",&result);
                         if (result > 0xff) {printf("Error: constant out of bounds\n"); exit(2); }
                         *string_buf_ptr++ = result;
                    }
\\[0-9]+       { printf("Error: bad escape sequence\n"); exit(2); }
\\n            {*string_buf_ptr++ = '\n';}
\\t            {*string_buf_ptr++ = '\t';}
\\b            {*string_buf_ptr++ = '\b';}
\\r            {*string_buf_ptr++ = '\r';}
\\f            {*string_buf_ptr++ = '\f';}
\\(.|\n)       {*string_buf_ptr++ = yytext[1];}
[^\\\n\"]+     {char *yptr = yytext; while(*yptr) *string_buf_ptr++ = *yptr++; }
}
(.|\n)
%%                            
$ flex ststring.l ; gcc lex.yy.c ; a.out < hello.c
        hello
world! a(0) is %d
$ cat hello.c
main() <%
int a<:1:>; /* a comment */
  a<:0:> = 4; /* a comment in
                 two lines */
  printf("\thell\157\nworld! a(0) is %d\n",a<:0:>);
%>                                   
\end{verbatim}
Obsérve la conducta del programa ante las siguientes entradas:
\begin{itemize}
\item
Entrada:
\begin{verbatim}
"hello \
dolly"
\end{verbatim}
¿Cuál será la salida? ¿Que patrón del programa anterior es el que casa aqui?
%hello
%dolly
\item
Entrada:
\verb|"hello\ndolly"|.
¿Cuál será la salida? ¿Que patrón del programa anterior es el que casa aqui?
%hello
%dolly
\item
\begin{verbatim}|
"hello

\end{verbatim}
Donde hay un retorno del carro después de \verb|hello|.
¿Cuál será la salida? %Error: non terminated string
\end{itemize}

\section{La pila de estados}
Mediante el uso de la opción

\verb|%option stack|

\noindent tendremos acceso a una pila de estados y a tres rutinas para  manipularla:\\
\begin{itemize}
\item
\verb|void yy_push_state(int new_state)|\\
Empuja el estado actual y bifurca a \verb|new_state|.\\
\item
\verb|void yy_pop_state()|\\
Saca el estado en el \emph{top} de la pila y bifurca a el mismo.\\
\item
\verb|int yy_top_state()|\\
Nos devuelve el estado en el \emph{top} de la pila, sin alterar
los contenidos de la misma.
\end{itemize}

\subsection{Ejemplo}
El siguiente programa \verb|flex| utiliza las funciones de la pila
de estados para reconocer el lenguaje (no regular) 
$\{a^n b^n\ /\ n \in N\}$

% \ listinginput{1}{../src/ab2.l}
\begin{verbatim}
%option main
%option noyywrap
%option stack
%{
#include <stdio.h>
#include  <stdlib.h>
%}
%x estado_a
%%
^a { yy_push_state(estado_a);}
<estado_a>{
a      { yy_push_state(estado_a); }
b      { yy_pop_state();  }
b[^b\n]+    {   printf ("Error\n"); 
        while (YYSTATE != INITIAL)
          yy_pop_state();
        while (input() != '\n') ;
      }
(.|\n)  {  printf ("Error\n"); 
        while (YYSTATE != INITIAL)
          yy_pop_state();
        while (input() != '\n') ;
      }
}
.      {  printf ("Error\n");
        while (input() != '\n') ;
      }
\n      { printf("Aceptar\n");}
%%
\end{verbatim}

%\subsection{Ejemplo}
%El siguiente programa \verb|flex| utiliza las funciones de la pila de estados para reconocer el lenguaje (no regular) \{$x \in \{a,b\} $/ número de $a$es es igual al número de $b$es  y cualquier prefijo de $x$ contiene no menos $a$es que $b$es  \}.
%\begin{verbatim}
%$ cat push.l
%%option stack
%%x A ACCEPT
%%%
%"a"      {  ECHO; yy_push_state(A); printf("State: %d\n",YYSTATE); }
%[^a\n]+.*\n  { printf("error\n"); }
%[\n ]+
%(.|\n)   { printf("Error!\n"); }
%<A>{
%"a" {  ECHO; yy_push_state(A); printf("State: %d\n",YYSTATE); }
%"b" { ECHO;
%       if (yy_top_state()) {
%         yy_pop_state();
%         printf("State: %d\n",YYSTATE);
%       }
%       else {
%         printf("State: %d\n",YYSTATE);
%         BEGIN(ACCEPT);
%       }
%    }
%(.|\n)   { printf("Error!\n"); BEGIN(0); }
%}
%<ACCEPT>\n { BEGIN(0); printf("Accept\n"); }
%<ACCEPT>. { BEGIN(0); printf("Error\n"); }
%%%   
%$ flex push.l ; gcc lex.yy.c -lfl ; a.out
%ab
%aState: 1
%bState: 1
%Accept
%abb
%aState: 1
%bState: 1
%Error
%bbbbbbbbbba
%error                             
%\end{verbatim}

\section{Final de Fichero}
El patrón \verb|<<EOF>>| permite asociar acciones que se deban 
ejecutar cuando se ha encontrado un \emph{end of file} y la 
macro \verb|yywrap()| ha devuelto un valor no nulo. 

Cualquiera que sea, la acción asociada deberá de optar por una de estas 
cuatro alternativas:
\begin{itemize}
\item
Asignar \verb|yyin| a un nuevo fichero de entrada
\item
Ejecutar \verb|return|
\item
Ejecutar \verb|yyterminate()| (véase  la sección \ref{section:input})
\item
Cambiar de \emph{buffer} de entrada utilizando la función
\verb|yy_switch_buffer| (véase  la sección \ref{section:include}).
\end{itemize}

El patrón \verb|<<EOF>>| no puede usarse con otras expresiones regulares. Sin embargo, es correcto prefijarlo con estados.

Si  \verb|<<EOF>>| aparece sin condiciones de arranque, la regla se aplica a todos los estados que no tienen una regla  \verb|<<EOF>>| específica.
Si lo que se quiere es que la regla se restringa al ámbito del estado inicial se deberá escribir:

\verb|<INITIAL><<EOF>>| 

Sigue un programa que reconoce los comentarios anidados en C.
Para detectar comentarios incacabados usaremos  \verb|<<EOF>>|.
\label{nestedcomments}
%\listinginput{1}{../src/nestedcom2.l}
\begin{verbatim}
%option stack
%x comment
%%
"/*"   { yy_push_state(comment); }
(.|\n) ECHO;
<comment>"/*"     { yy_push_state(comment); } 
<comment>"*/"     { yy_pop_state(); } 
<comment>(.|\n)   ;
<comment><<EOF>>  { fprintf(stderr,"Error\n"); exit(1); }
%%
\end{verbatim}

\begin{verbatim}
$ cat hello.c
main() {
int a[1]; /* a /* nested comment */. */
  a[0] = 4; /* a  /* nested comment in
                 /* two */ lines  */ *****/
}                                                   
$ flex nestedcom.l ; gcc lex.yy.c -lfl ; a.out < hello.c
main() {
int a[1];
  a[0] = 4;
}
$ cat hello4.c
main() {
int a[1]; /* a /* nested comment */. */
  a[0] = 4; /* an  /* incorrectly nested comment in
                 /* two  lines  */ *****/
}
$ a.out < hello4.c
main() {
int a[1];
Error
  a[0] = 4; 
\end{verbatim}

\section{Uso de Dos Analizadores}
La opción \verb|-Pprefix| de flex cambia el prefijo por defecto \verb|yy|
para todas las variables globales y funciones. Por ejemplo 
\verb|-Pfoo| cambia el nombre de  \verb|yytext| \verb|footext|.  
También cambia el nombre del fichero de salida 
de  \verb|lex.yy.c|  a \verb|lex.foo.c|.  
Sigue la lista de identificadores afectados:
\begin{verbatim} 
yy_create_buffer
yy_delete_buffer
yy_flex_debug
yy_init_buffer
yy_flush_buffer
yy_load_buffer_state
yy_switch_to_buffer
yyin
yyleng
yylex
yylineno
yyout
yyrestart
yytext
yywrap
\end{verbatim} 
Desde dentro del analizador léxico puedes referirte a las 
variables globales y funciones por cualquiera de los nombres,
pero externamente tienen el nombre cambiado.
Esta opción nos permite enlazar diferentes programas flex en un mismo ejecutable.

Sigue un ejemplo de uso de dos analizadores l\'exicos dentro del mismo programa:
\begin{verbatim}
$ cat one.l
%%
one {printf("1\n"); return 1;}
.   {printf("First analyzer: %s\n",yytext);}
%%
 
int onewrap(void) {
  return 1;
}
 
$ cat two.l
%%
two {printf("2\n"); return 2;}
.   {printf("Second analyzer: %s\n",yytext);}
%%
int twowrap(void) {
  return 1;
}
$ cat onetwo.c
main() {
  onelex();
  twolex();
}                                 
\end{verbatim}
Como hemos mencionado, la compilaci\'on \emph{flex} se debe realizar con el opci\'on \verb|-P|,
que cambia el prefijo por defecto \verb|yy| de las funciones
y variables accesibles por el usuario.
El mismo efecto puede conseguirse utilizando la opción \verb|prefix|, escribiendo
\verb|%option prefix="one"| y \verb|%option prefix="two"| en los respectivos programas 
\verb|one.l| y \verb|two.l|. 
\begin{verbatim}
$ flex -Pone one.l
$ flex -Ptwo two.l
$ ls -ltr | tail -2
-rw-rw----   1 pl       casiano     36537 Nov  7 09:52 lex.one.c
-rw-rw----   1 pl       casiano     36524 Nov  7 09:52 lex.two.c
$ gcc onetwo.c lex.one.c lex.two.c
$ a.out
two
First analyzer: t
First analyzer: w
First analyzer: o
 
one
1
one
Second analyzer: o
Second analyzer: n
Second analyzer: e
 
two
2
$             
\end{verbatim}

\section{La Opción {\tt outfile}}
Es posible utilizar la opción \verb|-ooutput.c|  para escribir el 
analizador léxico en el fichero \verb|output.c| en vez de  en \verb|lex.yy.c|.
El mismo efecto puede obtenerse usando la opción \verb|outfile="output.c"| dentro
del programa \verb|lex|.

\section{Leer desde una Cadena: YY\_INPUT}
En general, la rutina que hace el an\'alisis l\'exico,
\emph{yylex()}, lee su entrada a trav\'es de la macro
\verb|YY_INPUT|. Esta macro es llamada con tres par\'ametros
\begin{center}
\verb|YY_INPUT(buf,result,max)| 
\end{center}
el primero, \emph{buf} es utilizado para guardar la entrada.
el tercero \emph{max} indica el n\'umero de caracteres que \emph{yylex()}
pretende leer de la entrada. El segundo \emph{result} contendr\'a el n\'umero 
de caracteres realmente le\'{\i}dos. Para poder leer desde una cadena
(\emph{string}) basta
con modificar \verb|YY_INPUT| para que copie los datos de la cadena en
el \emph{buffer} pasado como par\'ametro a \verb|YY_INPUT|. 
Sigue un ejemplo: 
\begin{verbatim}
$ cat string.l
%{
#undef YY_INPUT
#define YY_INPUT(b,r,m) (r = yystringinput(b,m))
#define min(a,b) ((a<b)?(a):(b))
%}
 
%%
[0-9]+ printf("Num-");
[a-zA-Z][a-zA-Z_0-9]* printf("Id-");
[ \t]+
. printf("%c-",yytext[0]);
%%
 
extern char string[];
extern char *yyinputptr;
extern char *yyinputlim;
 
int yystringinput(char *buf, int maxsize) {
  int n = min(maxsize, yyinputlim-yyinputptr);
 
  if (n > 0) {
    memcpy(buf, yyinputptr, n);
    yyinputptr += n;
  }
  return n;
}
 
int yywrap() { return 1; }              
\end{verbatim}
Este es el fichero conteniendo la funci\'on \emph{main}:
\begin{verbatim}
$ cat stringmain.c
char string[] = "one=1;two=2";
char *yyinputptr;
char *yyinputlim;
 
main() {
  yyinputptr = string;
  yyinputlim = string + strlen(string);
  yylex();
  printf("\n");
}                              
\end{verbatim}
Y esta es la salida:
\begin{verbatim}
$ a.out
Id-=-Num-;-Id-=-Num-    
\end{verbatim}
La cadena \verb|string = "one=1;two=2"| definida en la línea 2 ha sido utilizada 
como entrada para el análisis léxico.

\section{El operador de ``trailing context'' o ``lookahead'' positivo}
En el lenguaje FORTRAN original los ``blancos'' no eran significativos
y no se distinguía entre mayúsculas y minúsculas.
Así pues la cadena \verb|do i = 1, 10| es equivalente a la cadena
\verb|DOI=1,10|. Un conocido conflicto ocurre entre una cadena 
con la estructura \verb|do i = 1.10| (esto es \verb|DOI=1.10|) y  
la cadena anterior. En la primera \verb|DO| e \verb|I| son dos
``tokens'' diferentes, el primero correspondiendo a la palabra reservada que indica un bucle. En la segunda, \verb|DOI| constituye un único ``token''
y la sentencia se refiere a una asignación.
El conflicto puede resolverse utilizando el operador de ``trailing'' \verb@r/s@. 
Como se mencionó, el operador de ``trailing''\verb@r/s@ permite reconocer una \verb@r@ pero s\'olo si va seguida de una \verb@s@. El texto casado con \verb@s@ se incluye a la hora de decidir cual es el emparejamiento mas largo, pero se devuelve a la entrada cuando se ejecuta la acci\'on. La acci\'on s\'olo ve el texto asociado con \verb@r@.  El fichero \verb|fortran4.l| ilustra una posible solución:
\begin{verbatim}
 cat fortran4.l
%array
%{
#include <string.h>
#undef YY_INPUT
#define YY_INPUT(buf,result,max) (result = my_input(buf,max))
%}
number [0-9]+
integer [+-]?{number}
float ({integer}\.{number}?|\.{number})(E{integer})?
label [A-Z0-9]+
id   [A-Z]{label}*
%%
DO/{label}={number}\, { printf("do loop\n"); }
{id} { printf("Identifier %s\n",yytext); }
{number} { printf("Num %d\n",atoi(yytext)); }
{float} { printf("Float %f\n",atof(yytext)); }
(.|\n)
%%

int my_input(char *buf, int max)
{
  char *q1, *q2, *p = (char *) malloc(max);
  int i;
  if ('\0' != fgets(p,max,yyin)) {
    for(i=0, q1=buf, q2=p;(*q2 != '\0');q2++) {
      if (*q2 != ' ') { *q1++ = toupper(*q2); i++; };
    }
    free(p);
    return i;
  }
  else exit(1);
}
\end{verbatim}
La función 

\verb|char *fgets(char *s, int size, FILE *stream)| 

lee a lo mas uno menos que \verb|size| caracteres desde \verb|stream| y los almacena en el \emph{buffer}
apuntado por \verb|s|. La lectura termina después de un  \verb|EOF| o un retorno de carro.
Si se lee un \verb|\n|, se almacena en el \emph{buffer}. La función pone un carácter nulo \verb|\0| 
como último carácter en el \emph{buffer}.

A continuación, puedes ver los detalles de una ejecución:
\begin{verbatim}
$ flex fortran4.l; gcc lex.yy.c -lfl; a.out
do j = 1 . 10
Identifier DOJ
Float 1.100000
do k = 1, 5
do loop
Identifier K
Num 1
Num 5                           
\end{verbatim}

\section{Manejo de directivas {\tt include}}
\label{section:include}
El analisis l\'exico de algunos lenguajes requiere que, durante la
ejecuci\'on, se realice la lectura desde
di\-fe\-ren\-tes ficheros de entrada. El ejemplo t\'{\i}pico es el manejo de las
directivas \emph{include file} existentes en la mayor\'{\i}a de los lenguajes de
programaci\'on.\\
¿Donde est\'a el problema? La dificultad reside en que los
analizadores generados por \emph{flex}
proveen almacenamiento intermedio (\emph{buffers}) para aumentar el
rendimiento. No basta con reescribir nuestro propio \emph{YY\_INPUT} de
manera que tenga en cuenta con que fichero se esta trabajando. 
El analizador s\'olo llama a \emph{YY\_INPUT} cuando alcanza el final de su
\emph{buffer}, lo cual puede ocurrir bastante despu\'es de haber
encontrado la sentencia \emph{include} que requiere el cambio de
fichero de entrada.
\begin{verbatim}
$ cat include.l
%x incl
%{
#define yywrap() 1
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}
%%
include          BEGIN(incl);
.                ECHO;
<incl>[ \t]*
<incl>[^ \t\n]+  { /* got the file name */
                   if (include_stack_ptr >= MAX_INCLUDE_DEPTH) {
                     fprintf(stderr,"Includes nested too deeply\n");
                     exit(1);
                   }
                   include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
                   yyin = fopen(yytext,"r");
                   if (!yyin) {
                     fprintf(stderr,"File %s not found\n",yytext);
                     exit(1);
                   }
                   yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
                   BEGIN(INITIAL);
                 }
<<EOF>> {
          if ( --include_stack_ptr < 0) {
            yyterminate();
          } else {
            yy_delete_buffer(YY_CURRENT_BUFFER);
            yy_switch_to_buffer(include_stack[include_stack_ptr]);
          }
        }
%%
main(int argc, char ** argv) {
 
  yyin = fopen(argv[1],"r");
  yylex();
}
\end{verbatim}
La funci\'on \verb|yy_create_buffer(yyin, YY_BUF_SIZE));| crea  un \emph{buffer}
lo suficientemente grande para mantener \verb|YY_BUF_SIZE| caracteres. Devuelve un 
\verb|YY_BUFFER_STATE|, que puede ser pasado a otras rutinas. \verb|YY_BUFFER_STATE| es un puntero a
una estructura de datos opaca (\verb|struct yy_buffer_state|) que contiene la informaci\'on para la manipulaci\'on
del \emph{buffer}. Es posible por tanto inicializar un puntero \verb|YY_BUFFER_STATE|
usando la expresión \verb|((YY_BUFFER_STATE) 0)|.

La funci\'on \verb|yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);| conmuta la entrada 
del analizador l\'exico. La funci\'on \verb|void yy_delete_buffer( YY_BUFFER_STATE buffer )|
se usa para recuperar la memoria consumida por un \emph{buffer}.  Tambi\'en se pueden limpiar 
los contenidos actuales de un buffer llamando a:
\verb|void yy_flush_buffer( YY_BUFFER_STATE buffer )|

La regla especial \verb|<<EOF>>| indica la acci\'on a ejecutar cuando 
se ha encontrado un final de fichero e \verb|yywrap()| retorna un valor
distinto de cero. Cualquiera que sea la acci\'on asociada, esta debe terminar 
con uno de estos cuatro supuestos:
\begin{enumerate}
\item Asignar \verb|yyin| a un nuevo fichero de entrada.
\item Ejecutar \verb|return|.
\item Ejecutar \verb|yyterminate()|.
\item Cambiar a un nuevo buffer usando \verb|yy_switch_to_buffer()|.
    
La regla \verb|<<EOF>>| no se puede mezclar con otros patrones.
\end{enumerate}

Este es el resultado de una ejecuci\'on del programa:
\begin{verbatim}
$ cat hello.c
#include hello2.c
main() <%
int a<:1:>; /* a comment */
  a<:0:> = 4; /* a comment in
                 two lines */
  printf("\thell\157\nworld! a(0) is %d\n",a<:0:>);
%>
$ cat hello2.c
#include hello3.c
/* file hello2.c  */
$ cat hello3.c
/*
third file
*/
$ flex include.l ; gcc lex.yy.c ; a.out hello.c
##/*
third file
*/
 
/* file hello2.c  */
 
main() <%
int a<:1:>; /* a comment */
  a<:0:> = 4; /* a comment in
                 two lines */
  printf("\thell\157\nworld! a(0) is %d\n",a<:0:>);
%>                                                            
\end{verbatim}
Una alternativa a usar el patrón \verb|<<EOF>>|
es dejar la responsabilidad de recuperar el \emph{buffer} anterior
a \verb|yywrap()|. En tal caso suprimiríamos esta parajea patrón-acción
y reescribiríamos \verb|yywrap()|:
\begin{verbatim}
%x incl
%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}
%%
include          BEGIN(incl);
.                ECHO;
<incl>[ \t]*
<incl>[^ \t\n]+  { /* got the file name */
                   if (include_stack_ptr >= MAX_INCLUDE_DEPTH) {
		     fprintf(stderr,"Includes nested too deeply\n");
		     exit(1);
		   }
		   include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
		   yyin = fopen(yytext,"r");
		   if (!yyin) {
		     fprintf(stderr,"File %s not found\n",yytext);
		     exit(1);
		   }
		   yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
		   BEGIN(INITIAL);
		 }
%%
main(int argc, char ** argv) {

  yyin = fopen(argv[1],"r");
  yylex();
}

int yywrap() {
  if ( --include_stack_ptr < 0) { 
    return 1;
  } else {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(include_stack[include_stack_ptr]);
    return 0;
  }
}
\end{verbatim}


\section{An\'alisis Léxico desde una Cadena: {\tt yy\_scan\_string}}
El objetivo de este ejercicio es mostrar como realizar un
an\'alisis l\'exico de los argumentos pasados en la l\'{\i}nea de
comandos. Para ello \emph{flex} provee la funci\'on \verb|yy_scan_string(const char * str)|.
Esta rutina crea un nuevo \emph{buffer} de entrada y devuelve el correspondiente
manejador \verb|YY_BUFFER_STATE| asociado con la cadena
\verb|str|. Esta cadena debe estar terminada por un car\'acter \verb|\0|. 
Podemos liberar la memoria asociada con
dicho \emph{buffer} utilizando \verb|yy_delete_buffer(BUFFER)|.
La siguiente llamada a \verb|yylex()| realizar\'a el an\'alisis l\'exico
de la cadena \verb|str|.

\begin{verbatim}
$ cat scan_str.l
%%
[0-9]+     printf("num\n");
[a-zA-Z]+  printf("Id\n");
%%
main(int argc, char ** argv) {
int i;
 
  for(i=1;i<argc;i++) {
    yy_scan_string(argv[i]);
    yylex();
    yy_delete_buffer(YY_CURRENT_BUFFER);
  }
}
 
int yywrap() { return 1; }
$ flex scan_str.l ; gcc lex.yy.c ; a.out Hello World! 1234
Id
Id
!num                       
\end{verbatim}
Alternativamente, la función \verb|main()| podría haber sido escrita asi:
\begin{verbatim}
main(int argc, char ** argv) {
int i;
YY_BUFFER_STATE p;

  for(i=1;i<argc;i++) {
    p = yy_scan_string(argv[i]);
    yylex();
    yy_delete_buffer(p);
  }
}
\end{verbatim}
La funci\'on \verb|yy_scan_bytes(const char * bytes, int len)| hace lo mismo que 
\verb|yy_scan_string| pero en vez de una cadena terminada en
el car\'acter nulo, se usa la longitud \verb|len|.
Ambas funciones \verb|yy_scan_string(const char * str)| y
\verb|yy_scan_bytes(const char * bytes, int len)| hacen una copia
de la cadena pasada como argumento.

Estas dos funciones crean una copia de la cadena original. Es mejor que sea asi, ya que \verb|yylex()|
modifica los contenidos del \emph{buffer} de trabajo. Si queremos evitar la copia,
podemos usar 

\verb|yy_scan_buffer(char *base, yy_size_t size)|,

la cual trabaja directamente con el \emph{buffer} que comienza en \verb|base|, 
de tamaño \verb|size| \emph{bytes}, los últimos dos de los cuáles deben
ser \verb|YY_END_OF_BUFFER_CHAR| (ASCII  NUL).   
Estos dos últimos \emph{bytes} no son ``escaneados''. El área de rastreo va
desde \verb|base[0]| a \verb|base[size-2]|, inclusive.
Si nos olvidamos de hacerlo de este modo y no establecemos los dos \emph{bytes} finales,
la función \verb|yy_scan_buffer()| devuelve un puntero nulo
y no llega a crear el nuevo buffer de entrada.
El tipo  \verb|yy_size_t| es un tipo entero.
Como cabe esperar, \verb|size| se refiere al tamaño del \emph{buffer}.

\section{An\'alisis de la L\'{\i}nea de Comandos y 2 Analizadores}
El objetivo de este ejercicio es mostrar como realizar un
an\'alisis l\'exico de los argumentos pasados en la l\'{\i}nea de
comandos.  Para ello dise\~naremos una librer\'{\i}a que proporcionar\'a un 
funci\'on \verb|yylexarg(argc,argv)| que hace el an\'alisis
de la l\'{\i}nea de acuerdo con la especificaci\'on
\emph{flex} correspondiente. En el ejemplo, esta descripci\'on del analizador l\'exico
es proporcionada en el fichero \emph{fl.l}.  Para complicar un poco mas
las cosas, supondremos que queremos hacer el an\'alisis l\'exico
de un fichero (especificado en la l\'{\i}nea de comandos) seg\'un 
se especifica en un segundo analizador l\'exico \emph{trivial.l}.
El siguiente ejemplo de ejecuci\'on muestra la conducta del programa:
\begin{verbatim}
$ fl -v -V -f tokens.h
verbose mode is on
version 1.0
File name is: tokens.h
Analyzing tokens.h
#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks
-int-blanks-#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks-int-blanks-
\end{verbatim}
Los contenidos del fichero \emph{Makefile} definen las dependencias 
y la estructura de la aplicaci\'on:
\begin{verbatim}
$ cat Makefile
LIBS=-lflarg
CC=gcc -g
LIBPATH=-L. -L~/lib
INCLUDES=-I. -I~/include
 
fl: main.c lex.arg.c lex.yy.c libflarg.a tokens.h
        $(CC) $(LIBPATH) $(INCLUDES) main.c lex.arg.c lex.yy.c $(LIBS) -o fl
lex.arg.c: fl.l
        flex -Parg fl.l
lex.yy.c: trivial.l tokens.h
        flex trivial.l
libflarg.a: flarg.o
        ar r libflarg.a flarg.o
flarg.o: flarg.c
        $(CC) -c flarg.c
clean:                                 
$ make clean;make
rm lex.arg.c lex.yy.c *.o  fl
flex -Parg fl.l
flex trivial.l
gcc -g -c flarg.c
ar r libflarg.a flarg.o
gcc -g -L. -L~/lib -I. -I~/include main.c lex.arg.c lex.yy.c -lflarg -o fl  
\end{verbatim}
Observa el uso de la opci\'on \verb|-Parg| en la traducci\'on del fichero 
\emph{fl.l}. As\'{\i} no solo el fichero generado por \emph{flex}, sino todas las variables
y rutinas accesibles estar\'an prefijadas por \emph{arg} en vez de \emph{yy}. 
La librer\'{\i}a la denominamos \emph{libflarg.a}. (\emph{flarg} 
por \underline{fl}ex \underline{arg}uments). 
El correspondiente fichero cabecera ser\'a \emph{flarg.h}.
Los fuentes de las rutinas que compondr\'an la 
librer\'{\i}a se mantendr\'an en el fichero \emph{flarg.c}.


Lo que haremos ser\'a redefinir \verb|YY_INPUT(buf, result, max)| para que
lea su entrada desde la l\'{\i}nea de argumentos.
\begin{verbatim}
$ cat flarg.h
int yyarglex(int argc, char **argv);
int YY_input_from_argv(char *buf, int max);
int argwrap(void);
 
#undef YY_INPUT
#define YY_INPUT(buf,result,max) (result = YY_input_from_argv(buf,max))   
\end{verbatim}
La funci\'on \verb|int YY_input_from_argv(char *buf, int max)| utiliza los punteros
\verb|char **YY_targv| y \verb|char **YY_arglim| para moverse a trav\'es
de la familia de argumentos. Mientras que el primero es utilizado para el
recorrido, el segundo marca el l\'{\i}mite final. Su inicializaci\'on ocurre en

\begin{center}
\verb|yyarglex(int argc, char **argv)|
\end{center}
con las asignaciones:
\begin{verbatim}
  YY_targv = argv+1;
  YY_arglim = argv+argc;
\end{verbatim}

despues, de lo cual, se llama al analizador l\'exico generado, \emph{arglex} .

\begin{verbatim}
$ cat flarg.c
char **YY_targv;
char **YY_arglim;
 
int YY_input_from_argv(char *buf, int max)
{
  static unsigned offset = 0;
 
  int len, copylen;
 
    if (YY_targv >= YY_arglim) return 0;        /* EOF */
    len = strlen(*YY_targv)-offset;     /* amount of current arg */
    if(len >= max) {copylen = max-1; offset += copylen; }
    else copylen = len;
    if(len > 0) memcpy(buf, YY_targv[0]+offset, copylen);
    if(YY_targv[0][offset+copylen] == '\0') {   /* end of arg */
      buf[copylen] = ' '; copylen++; offset = 0; YY_targv++;
    }
    return copylen;
}
 
int yyarglex(int argc, char **argv) {
  YY_targv = argv+1;
  YY_arglim = argv+argc;
  return arglex();
}
 
int argwrap(void) {
  return 1;
}    
\end{verbatim}
El fichero \emph{fl.l} contiene el analizador l\'exico de la l\'{\i}nea de comandos:
\begin{verbatim}
$ cat fl.l
%{
unsigned verbose;
unsigned thereisfile;
char *progName;
char fileName[256];
#include "flarg.h"
#include "tokens.h"
%}
 
%%
-h      |
"-?"    |
-help   { printf("usage is: %s [-help | -h | -? ] [-verbose | -v]"
         " [-Version | -V]"
         " [-f filename]\n", progName);
        }
 
-v      |
-verbose { printf("verbose mode is on\n"); verbose = 1; }
 
-V      |
-version { printf("version 1.0\n"); }
 
-f[[:blank:]]+[^ \t\n]+ {
              strcpy(fileName,argtext+3);
              printf("File name is: %s\n",fileName);
              thereisfile = 1;
            }
.
 
\n                                 
\end{verbatim}
Observe el uso de la clase \verb|[:blank:]| para reconocer
los blancos. Las clases son las mismas que las introducidas
en \emph{gawk}.

El an\'alisis l\'exico del fichero que se lee despu\'es de procesar la
l\'{\i}nea de comandos es descrito en \emph{trivial.l}.
Partiendo de \emph{trivial.l}, la ejecuci\'on del \emph{Makefile}
da lugar a la construcci\'on por parte de \emph{flex} del fichero 
\emph{lex.yy.c} conteniendo la rutina \emph{yylex}.
\begin{verbatim}
$ cat trivial.l
%{
#include "tokens.h"
%}
digit [0-9]
id [a-zA-Z][a-zA-Z0-9]+
blanks [ \t\n]+
operator [+*/-]
%%
{digit}+ {return INTTOKEN; }
{digit}+"."{digit}+ {return FLOATTOKEN; }
{id} {return IDTOKEN;}
{operator} {return OPERATORTOKEN;}
{blanks} {return BLANKTOKEN;}
. {return (int) yytext[0];}
%%
int yywrap() {
  return 1;
}
\end{verbatim}
El fichero \emph{tokens.h} contiene la definici\'on de los \emph{tokens}
y es compartido con \emph{main.c}. 
\begin{verbatim}
$ cat tokens.h
#define INTTOKEN  256
#define FLOATTOKEN 257
#define IDTOKEN 258
#define OPERATORTOKEN 259
#define BLANKTOKEN 260         
\end{verbatim}
Nos queda por presentar el fichero \emph{main.c}:
\begin{verbatim}
$ cat main.c
#include <stdio.h>
#include "flarg.h"
#include "tokens.h"
extern unsigned verbose;
extern unsigned thereisfile;
extern char *progName;
extern char fileName[256];
extern FILE * yyin;
 
main(int argc, char **argv) {
  unsigned lookahead;
  FILE * file;
 
  progName = *argv;
  yyarglex(argc,argv);
  if (thereisfile) {
    if (verbose) printf("Analyzing %s\n",fileName);
    file = (fopen(fileName,"r"));
    if (file == NULL) exit(1);
    yyin = file;
    while (lookahead = yylex()) {
      switch (lookahead) {
        case INTTOKEN:
            printf("int-");
            break;
          case FLOATTOKEN:
            printf("float-");
            break;
          case IDTOKEN:
            printf("id-");
            break;
          case OPERATORTOKEN:
            printf("operator-");
            break;
          case BLANKTOKEN:
            printf("blanks-");
            break;
          default: printf("%c-",lookahead);
       }
    } /* while */
    printf("\n");
  } /* if */
}                                       
\end{verbatim}

\section{Declaraciones pointer y array}
Como se coment\'o, las opciones \verb|%pointer| y \verb|%array|
controlan la definici\'on que
\emph{flex} hace de \emph{yytext}. en el caso en que eligamos la opci\'on 
\verb|%array| la variable \verb|YYLMAX| controla el tama\~no del
\emph{array}. Supongamos que en el fichero \emph{trivial.l} del ejemplo
anterior introducimos las siguientes modificaciones:
\begin{verbatim}
$ cat trivial.l
%array
%{
#undef YYLMAX
#define YYLMAX 4
#include "tokens.h"
%}
digit [0-9]
id [a-zA-Z][a-zA-Z0-9]+
blanks [ \t\n]+
operator [+*/-]
%%
{digit}+ {return INTTOKEN; }
{digit}+"."{digit}+ {return FLOATTOKEN; }
{id} {return IDTOKEN;}
{operator} {return OPERATORTOKEN;}
{blanks} {return BLANKTOKEN;}
. {return (int) yytext[0];}
%%
int yywrap() {
  return 1;
  }                                        
\end{verbatim}
En tal caso, la definici\'on excesivamente peque\~na de YYLMAX provoca
un error en tiempo de ejecuci\'on:
\begin{verbatim}
$ fl -V -f tokens.h
version 1.0
File name is: tokens.h
token too large, exceeds YYLMAX 
\end{verbatim}

\section{Las Macros {\tt YY\_USER\_ACTION}, {\tt yy\_act} e {\tt YY\_NUM\_RULES}}
La macro \verb|YY_USER_ACTION| permite ejecutar una acción inmediatamente después del ``emparejamiento'' y antes de  la ejecución de la acción asociada.
cuando se la invoca, la variable \verb|yy_act| contiene el número de la regla que ha emparejado (las reglas se numeran a partir de uno). La macro \verb|YY_NUM_RULES| contiene el número de reglas, incluyendo la regla por defecto.

El siguiente programa aprovecha
dichas macros para mostrar las frecuencias de uso de las reglas.
\begin{verbatim}
$ cat user_action.l
%array
%{
#include <string.h>
 
int ctrl[YY_NUM_RULES];
#undef YY_USER_ACTION
#define YY_USER_ACTION { ++ctrl[yy_act]; }
%}
number [0-9]+
id   [a-zA-Z_]+[a-zA-Z0-9_]*
whites [ \t\n]+
%%
{id}
{number}
{whites}
.
%%
 
int yywrap() {
  int i;
 
  for(i=1;i<YY_NUM_RULES;i++)
    printf("Rule %d: %d occurrences\n",i,ctrl[i]);
}
                                                  
$ flex user_action.l ; gcc lex.yy.c -lfl ; a.out
a=b+2*(c-4)
Rule 1: 3 occurrences
Rule 2: 2 occurrences
Rule 3: 1 occurrences
Rule 4: 6 occurrences     
\end{verbatim}

\section{Las opciones {\tt interactive}}
La opción \verb|option always-interactive|  hace que \verb|flex| genere un analizador que considera que su entrada es ``interactiva''. Concretamente, el analizador para cada nuevo fichero de entrada, intenta determinar si se trata de un a entrada interactiva o desde fichero haciendo una llamada a la función \verb|isatty()|.  Vea un ejemplo de uso de esta función:

\begin{verbatim}
$ cat isatty.c
#include <unistd.h>
#include <stdio.h>
main() {
 
  if (isatty(0))
    printf("interactive\n");
  else
    printf("non interactive\n");
}
$ gcc isatty.c; a.out
interactive
$ a.out < isatty.c
non interactive
$                
\end{verbatim}
cuando se usa la opción \verb|option always-interactive|, se elimina esta llamada.

\section{La macro {\tt YY\_BREAK}}
Las acciones asociadas con los patrones se agrupan en 
la rutina de análisis léxico \verb|yylex()| en una sentencia
\verb|switch| y se separan mediante llamadas a la
macro \verb|YY_BREAK|. Asi, al compilar con
\verb|flex| el siguiente fichero \verb|.l|
\begin{verbatim}
$ cat interactive.l
%%
. printf("::%c",yytext[0]);
\n printf("::%c",yytext[0]);      
\end{verbatim}
tenemos el fichero de salida \verb|lex.yy.c|
que aparece a continuación (hemos omitido 
las líneas de código en las que estamos menos interesados, 
sustituyendolas por puntos suspensivos)
\begin{verbatim}
/* A lexical scanner generated by flex */
....
#define YY_NUM_RULES 3
#line 1 "interactive.l"
#define INITIAL 0
#line 363 "lex.yy.c"
....
YY_DECL {
 ....
#line 1 "interactive.l"
#line 516 "lex.yy.c"
 ....
 if ( yy_init ) {
   yy_init = 0;
#ifdef YY_USER_INIT
   YY_USER_INIT;
#endif
   if ( ! yy_start ) yy_start = 1;  /* first start state */
   if ( ! yyin ) yyin = stdin;
   if ( ! yyout ) yyout = stdout;
   if ( ! yy_current_buffer ) yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
   yy_load_buffer_state();
 }
 while ( 1 )    /* loops until end-of-file is reached */ {
   ............................
yy_match:
   do {
    .....
   }
   ............
yy_find_action:
   ............
   YY_DO_BEFORE_ACTION;
   do_action:  /* This label is used only to access EOF actions. */
     switch ( yy_act ) { /* beginning of action switch */
       case 0: 
         ...................
         goto yy_find_action;
     case 1:
     YY_RULE_SETUP
     #line 2 "interactive.l"
     printf("::%c",yytext[0]);
       YY_BREAK
     case 2:
     YY_RULE_SETUP
     #line 3 "interactive.l"
     printf("::%c",yytext[0]);
       YY_BREAK
     case 3:
     YY_RULE_SETUP
     #line 4 "interactive.l"
     ECHO;
       YY_BREAK
     #line 614 "lex.yy.c"
     case YY_STATE_EOF(INITIAL):
       yyterminate();
       case YY_END_OF_BUFFER:
         { .....  }
     default:
       YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
  } /* end of action switch */
 } /* end of scanning one token */
} /* end of yylex */

#if YY_MAIN
int main()
  { yylex(); return 0; }
#endif
#line 4 "interactive.l"
\end{verbatim}
Por defecto, la macro \verb%YY_BREAK% es simplemente un \verb%break%. Si cada acción de usuario termina en un \verb%return%, puedes encontrarte con que el compilador genera un buen número de \verb%warning! unreachable code%. Puedes entonces redefinir \verb%YY_BREAK% a vacío y evitar estos mensajes.

%suppressed section
%input{typedef}

%%% TEXEXPAND: END FILE ./chapter2/flex.tex

%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter2/sed.tex
\chapter{Expresiones Regulares en sed}·
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
El editor \verb|sed| es un editor no interactivo que actúa
ejecutando los comandos (similares a los de \verb|ex|) que
figuran en el guión \verb|sed| (\cei{script sed}) 
sobre los ficheros de entrada y escribiendo el resultado en la salida estandar.
Normalmente se llama en una de estas dos formas:
\begin{verbatim}
sed [opciones] 'comando' fichero(s)
sed [opciones] -f guion fichero(s)
\end{verbatim}
Si no se especifican ficheros de entrada, \verb|sed| lee su entrada 
desde la entrada estandar.

Todos los comandos en el guión son ejecutados sobre todas las líneas de la
entrada, salvo que las condiciones en el ámbito del comando indiquen lo contrario.

\begin{verbatim}
nereida:~/sed> cat b.without.sed
#example of succesive replacements
s/fish/cow/
s/cow/horse/
nereida:~/sed> cat b.test
fish
cow
nereida:~/sed> sed -f b.without.sed b.test
horse
horse
\end{verbatim}
como se ve en el ejemplo, si un comando cambia la entrada, los siguientes 
comandos se aplican a la línea modificada (denominada \cei{pattern space}).

Los comandos \verb|sed| tienen el formato:

\begin{verbatim}
[direccion1][,direccion2][!]comando[argumentos]
\end{verbatim}

\section{Transferencia de Control}
La orden \emph{b} tiene la sintáxis:\\
{\it [address1][,address2]b[label]}\\
Transfiere el control a la etiqueta especificada. Si no se especifica
la etiqueta, el control se transfiere al final del {\it script}, por lo que
no se aplica ningún otro comando a la línea actual. Los dos siguientes
ejemplos utilizan {\it b}:
\begin{verbatim}
$ cat b.sed
s/fish/cow/
b
s/cow/horse/
$ sed -f b.sed b.test
cow
cow
\end{verbatim}
Utilizando {\it b} con una etiqueta:
\begin{verbatim}
$ cat blabel.sed
s/fish/cow/
b another
s/cow/horse/
:another
s/cow/cat/
$ sed -f blabel.sed b.test
cat
cat
\end{verbatim}

\section{Inserción de Texto}
El uso de llaves \{, \} permite  ejecutar los comandos en la lista entre llaves
a las líneas seleccionadas. La llave que cierra debe estar en su propia línea aparte.
Las llaves nos permiten, como se ve en el ejemplo, anidar selecciones
y expresar condiciones del tipo ``si esta entre estos dos patrones y además 
está entre estos otros dos \ldots''.\\

Los comandos {\it a} e {\it i} tienen una sintaxis parecida:\\
{\it
\begin{tabular}{c|c}
	[address]a$\backslash$ & [address]i$\backslash$\\ 
        text                   & text\\
\end{tabular}\\
}
{\it a} añade ({\it i} inserta) el texto en cada línea que
casa con la dirección especificada.
El {\it text} no queda disponible en el ``{\it pattern space}'',
de manera que los subsiguientes comandos no le afectan. El
siguiente ejemplo convierte un fichero {\it ascii} a {\it html}:
\begin{verbatim}
$ cat aandi.sed
1{
i\
<html>\
<head>\
<title>
p
i\
</title>\
</head>\
<body bgcolor=white>
}
$a\
</pre>\
</body>\
</html>
$ cat aandi.test
hello.world!
$ sed -f aandi.sed aandi.test
<html>
<head>
<title>
hello.world!
</title>
</head>
<body bgcolor=white>
hello.world!
</pre>
</body>
</html>
\end{verbatim}

\section{Trasferencia de Control Condicional}
La sintaxis de la orden {\it t} es:
\begin{center} {\it [address1][,address2]t[label]} \end{center}
Si la sustitución tiene éxito, se bifurca a {\it label}, Si la etiqueta no se especifica, 
se salta al final del {\it script}.\\
Consideremos el siguiente fichero de entrada:
\begin{verbatim}
$ cat t.test
name: "fulano de tal" address: "Leganitos,4" phone: "342255"
name: "fulano de cual"
name: "fulano de alli" address: "Legitos,4"
name: "zutano de tal"  address: "Leg,8"  phone: "342255"
\end{verbatim}
Se asume que siempre que figura el teléfono se ha puesto la dirección y que si está
la dirección se ha escrito el nombre. Se pretenden rellenar las líneas con un campo por defecto:
\begin{verbatim}
$ cat t.sed
/name:/{
s/.*name:[ ]*".*"[ ]*address:[ ]*".*"[ ].*phone:[ ]*".*".*/&/
t
s/.*name:[ ]*".*"[ ]*address:[ ]*".*"/& phone: "????"/
t
s/.*name:[ ]*".*"/& address: "???? ????" phone: "????"/
}
\end{verbatim}
Esta es la llamada al script y la salida generada:
\begin{verbatim}
$ sed -f t.sed t.test
name: "fulano de tal" address: "Leganitos,4" phone: "342255"
name: "fulano de cual" address: "???? ????" phone: "????"
name: "fulano de alli" address: "Legitos,4" phone: "????"
name: "zutano de tal"  address: "Leg,8"  phone: "342255"
$       
\end{verbatim}

\noindent \emph{Ejemplo:}

El fichero de entrada es un \emph{folder} de 
\verb%pine% en el que los mensajes recibidos tienen el formato:

\ldots
\begin{verbatim}
01_NAME: XXX
02_SURNAME: XXX
03_TITLE: SISTEMAS
04_OtherTitle:
05_BIRTHDAY: XXX
06_BIRTHMONTH: XXX
07_BIRTHYEAR: XXX
08_ADDRESSFAMILY: XXX
09_ADDRESSACTUAL: XXX
10_POSTALCODE: XXX
11_EMAIL: XXX@csi.ull.es
12_TELEPHONE: XXX
13_FAX: XXX
14_LABGROUP: xxx
15_COMMENTS:                              
\end{verbatim}
\ldots

Se trata de escribir un script que produzca como salida los \emph{emails}
de los diferentes alumnos. Esta es una solución (suponemos que el \emph{script} se llama con la opción \verb%-n%):
\begin{verbatim}
#!/bin/sed -f
/^11_EMAIL:/{
s/11_EMAIL: *\([a-zA-Z0-9]*@[a-zA-Z0-9.]*\)/\1/
t print
s/11_EMAIL: *\([a-zA-Z0-9]*\)/\1@csi.ull.es/
:print
p
}
\end{verbatim}

Una característica no comentada y observada en algunos \verb|sed|, incluyendo 
la versión Linux, es que, si existen varias sustituciones consecutivas antes de la
sentencia de transferencia de control, basta con que una tenga éxito para que el salto
se realice. 

\section{Rangos}
Cuando se usan dos direcciones separadas por una coma, el rango que
representan se extiende desde la primera línea que casa con el patrón
hasta la siguiente línea que casa con el segundo patrón.
El siguiente {\it script} muestra las tablas que aparecen en un fichero \LaTeX:
\begin{verbatim}
$ cat tables.sed
#Imprime las tablas en un fichero tex
/\\begin{tabular}/,/end{tabular}/p
$ sed -n -f tables.sed *.tex
\begin{tabular}{c|c}
        [address]a$\backslash$ & [address]i$\backslash$\\
        text                   & text\\
\end{tabular}\\
\begin{tabular}{c|c}
        [address]a$\backslash$ & [address]i$\backslash$\\
        text                   & text\\
\end{tabular}\\        
\end{verbatim}

La siguiente selección para un rango comienza después de la
última línea del rango previo; esto es, si el rango es /A/,/B/,
el primer conjunto de líneas que casa va desde la primera
aparicion de /A/ hasta la siguiente aparición de /B/. Asi,
el número mínimo de líneas seleccionadas (si no es cero)
es dos. Sólo en el caso en que la primera dirección es una
expresión regular y la segunda un número de línea que viene
antes de la línea que casa, es que sólo se selecciona una
línea de emparejamiento.  No hay por tanto solapes entre dos
casamientos en un misma rango de direcciones.  
El siguiente ejemplo ilustra la forma en la que \verb|sed| interpreta
los rangos de direcciones. Es una aproximación al problema de escribir
los comentarios de un programa {\it C}.
\begin{verbatim}
$ cat scope.sed
#execute: sed -n -f scope.sed scope.test
/\/\*/,/\*\//p
\end{verbatim}
Este {\it script} puede funcionar con programas cuyos
comentarios (no anidados) empiecen y terminen en líneas 
diferentes, como el del ejemplo:
\begin{verbatim}
$ cat scope2.test
#file scope2.test
#include <stdio.h>
 
fact(int n) { /* recursive function
if(n == 0) return 1;
else(return n*fact(n-1));*/
}
 
void toto(id) {
}
 
main() {
  toto();
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */
}
\end{verbatim}
La ejecución del script selecciona los dos grupos de líneas
que contienen comentarios:
\begin{verbatim}
$ sed -n -f scope.sed scope2.test
fact(int n) { /* recursive function
if(n == 0) return 1;
else(return n*fact(n-1));*/
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */  
\end{verbatim}
Sin embargo, el script fallará en este otro ejemplo:
\begin{verbatim}
$ cat scope.test
#include <stdio.h>
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */
}                     
\end{verbatim}
La ejecución del programa da como resultado:
\begin{verbatim}
$ sed -n -f scope.sed scope.test
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */      
\end{verbatim}

\begin{latexonly}
\section{Uso de la negación}
El ejemplo muestra como convertir los carácteres españoles en
un fichero \LaTeX{} escrito usando un teclado español a sus secuencias \LaTeX.
puesto que en modo matemático los acentos tienen un significado distinto,
se aprovecha la disponibilidad de las teclas españolas para simplificar 
la labor de tecleado. Obsérvese el uso de la exclamación {\tt !} para indicar
la negación del rango de direcciones seleccionadas.

\begin{verbatim}
> cat sp2en.sed
/begin{verbatim}/,/end{verbatim}/!{
/begin{math}/,/end{math}/!{
s/á/\\'a/g
s/é/\\'e/g
s/í/\\'{\\i}/g
s/ó/\\'o/g
s/ú/\\'u/g
s/â/\\^a/g
s/ç/\\c{c}/g
s/ñ/\\~n/g
s/Á/\\'A/g
s/É/\\'E/g
s/Í/\\'I/g
s/Ó/\\'O/g
s/Ú/\\'U/g
s/Ñ/\\~N/g
s/¿/>/g
s/¡/</g
}
}
/begin{math}/,/end{math}/{
s/â/\\hat{a}/g
s/á/\\acute{a}/g
s/à/\\grave{a}/g
s/ä/\\ddot{a}/g
s/ê/\\hat{e}/g
s/é/\\acute{e}/g
s/è/\\grave{e}/g
s/ë/\\ddot{e}/g
s/ô/\\hat{o}/g
s/ó/\\acute{o}/g
s/ò/\\grave{o}/g
s/ö/\\ddot{o}/g
s/û/\\hat{u}/g
s/ú/\\acute{u}/g
s/ù/\\grave{u}/g
s/ü/\\ddot{u}/g
}                           
\end{verbatim}
Supongamos el siguiente fichero \LaTeX{} de entrada:
\begin{verbatim}
	> cat sp2en.tex
	\documentclass[11pt,a4paper,oneside,onecolumn]{article}
	\usepackage{isolatin1}
	\title{Stream Editor. Convirtiendo a Ingles en LaTex}
	\author{Casiano R. León \thanks{DEIOC Universidad de La Laguna}}
	\begin{document}
	\maketitle
	Esto es un ejemplo de uso de sp2en.sed:
	\begin{center}
	áéíóú ÁÉÍÓÚ ñÑ ¿? ¡!\\
	\begin{math}
	â^{é^{2}} \neq â^{2é}
	\end{math}
	\end{center}
	comienza el verbatim\\
	\begin{listing}{1}
	Lo que salga en verbatim depende de los packages
	que hayan sido cargados: \'a \'e áéíóú ÁÉÍÓÚ ñÑ ¿? ¡!
	\end {verbatim}
	Termina el verbatim:\\
	\begin{center}
	áéíóú ÁÉÍÓÚ ñÑ ¿? ¡!
	\end{center}
	\end{document}                      
\end{verbatim}
Al ejecutar:
\begin{verbatim}
> sed -f sp2en.sed sp2en.tex
\end{verbatim}
Obtenemos la salida:
\begin{verbatim}
	\documentclass[11pt,a4paper,oneside,onecolumn]{article}
	\usepackage{isolatin1}
	\title{Stream Editor. Convirtiendo a Ingles en LaTex}
	\author{Casiano R. Le\'on \thanks{DEIOC Universidad de La Laguna}}
	\begin{document}
	\maketitle
	Esto es un ejemplo de uso de sp2en.sed:
	\begin{center}
	\'a\'e\'{\i}\'o\'u \'A\'E\'I\'O\'U \~n\~N >? <!\\
	\begin{math}
	\hat{a}^{\acute{e}^{2}} \neq \hat{a}^{2\acute{e}}
	\end{math}
	\end{center}
	comienza el verbatim\\
	\begin{listing}{1}
	Lo que salga en verbatim depende de los packages
	que hayan sido cargados: \'a \'e áéíóú ÁÉÍÓÚ ñÑ ¿? ¡!
	\end{ verbatim}
	Termina el verbatim:\\
	\begin{center}
	\'a\'e\'{\i}\'o\'u \'A\'E\'I\'O\'U \~n\~N >? <!
	\end{center}                          
	\end{document} 
\end{verbatim}
\end{latexonly}

\section{Siguiente Línea: La orden {\it n}}
Mediante la orden {\it n} podemos reemplazar el espacio de
patrones actual por la siguiente línea. Si no se ha utilizado
la opción \verb|-n| en la ejecución de \verb|sed|, el contenido del espacio
de patrones se imprimirá antes de ser eliminada. El control
pasa al comando siguiendo al comando {\it n} y no al primer
comando del {\it script}. Se trata, por tanto, de una orden que
altera la conducta habitual de \verb|sed|: Lo común es que, cuando se lee una nueva
línea, se ejecute el primer comando del guión.

El siguiente ejemplo extrae los comentarios de un programa {\it C}.
Se asume que, aunque los comentarios se pueden extender sobre
varias líneas, no existe mas de un comentario por línea.
\begin{verbatim}
$ cat n.sed
# run it with: sed -n -f n.sed n.test
# write commented lines in a C program
#If current line matches /* ...
/\/\*/{
# Comienzo de comentario, aseguremonos que la línea no casa con un cierre
# de comentario.
:loop
/\*\//!{
p
n
b loop
}
p
}                
\end{verbatim}
Supongamos el siguiente programa de prueba:
\begin{verbatim}
$ cat n.test
#include <stdio.h>
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) { /* This function */ /* is
                   still empty */
}
 
main() {
  toto();
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */
  toto();
  /* and here is
     a comment
     extended on 3 lines
  */
}                         
\end{verbatim}
La salida al ejecutar el programa es la siguiente:
\begin{verbatim}
$ sed -n -f n.sed n.test
fact(int n) { /* recursive function */
void toto(id) { /* This function */ /* is
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */
  /* and here is
     a comment
     extended on 3 lines
  */                   
\end{verbatim}
Observe la desaparición de la línea \mbox{`` still empty */''} 
debido a la existencia de dos comentarios, uno de ellos inacabado 
en la línea anterior. 

\section{Manipulando tablas numéricas}
El siguiente ejemplo intercambia la primera y ultima columnas
de un fichero como el que sigue:
\begin{verbatim}
$ cat columns.test
11111 22222 33333 44444 55555
  111    22    33  4444  5555
11111 22222 33333 44444 55555
   11    22     3   444  5555
\end{verbatim}
La parte mas complicada es preservar el sangrado.
El truco reside, en parte, en el patrón central $\backslash$2, que 
memoriza los blancos después de la primera columna y un sólo blanco 
antes de la última.
\begin{verbatim}
$ cat columns.sed
s/^\( *[0-9][0-9]*\)\( .*[0-9] \)\( *[0-9][0-9]*\)$/\3\2\1/
$ sed -f columns.sed columns.test
55555 22222 33333 44444 11111
 5555    22    33  4444   111
55555 22222 33333 44444 11111
 5555    22     3   444    11  
\end{verbatim}
El siguiente ejemplo utiliza
una opción del operador de sustitución que permite decidir que aparición
del patrón deseamos sustituir. Asi,

\verb|s/A/B/3|

sustituirá la 3 aparición de \verb|A| por \verb|B|, obviando las otras.

El ejemplo selecciona la columna dos del fichero:
\begin{verbatim}
$ cat col2.sed
#extracts the second column
s/^  *//
s/\<[0-9][0-9]*\>//1
s/\<[0-9][0-9]*\>//2
s/\<[0-9][0-9]*\>//2
s/\<[0-9][0-9]*\>//2
s/  *$//
$ sed -f col2.sed columns.test
 22222
    22
 22222
    22                
\end{verbatim}
Mas general que el anterior, el siguiente ejemplo elimina 
un número de columnas arbitrario \verb|$1| por la izquierda y otro 
número \verb|$2| por la derecha.
Para lograrlo, es necesario utilizar un un guión para la \verb|shell| 
que llama al correspondiente guión \verb|sed|. Los parámetros 
son introducidos en el guión \verb|sed| mediante el uso apropiado
de las comillas dobles y simples:

\begin{verbatim}
> cat colbranch.sh
#!/bin/bash
sed -e '
s/^\( *[0-9]\+\)\{'"$1"'\}//
s/\( *[0-9]\+\)\{'"$2"'\}$//
'
\end{verbatim}
Veamos un ejemplo de uso:
\begin{verbatim}
> cat columns.test
11111 22222 33333 44444 55555
  111    22    33  4444  5555
11111 22222 33333 44444 55555
   11    22     3   444  5555
> colbranch.sh 2 1 < columns.test
 33333 44444
    33  4444
 33333 44444
     3   444
\end{verbatim}


\section{Traducción entre Tablas}
El  comando {\it y} realiza una traducción entre dos tablas de caracteres.
Observa el ejemplo:
\begin{verbatim}
$ cat toupper.sed
y/aáéíóúäëïöübcdefghijklmnopqrstuvxyzñ/AÁÉÍÓÚÄËÏÖÜBCDEFGHIJKLMNOPQRSTUVXYZÑ/
$ cat sp2en.test
¡Coño! ¿Es plím el que hizo plúm?
\end{verbatim}
Obtenemos asi los contenidos del fichero en mayúsculas:
\begin{verbatim}
$ sed -f toupper.sed sp2en.test
¡COÑO! ¿ES PLÍM EL QUE HIZO PLÚM?  
\end{verbatim}

\section{Del espacio de Patrones al de Mantenimiento}
En \verb|sed| se dispone, como en muchos otros editores
de una zona de memoria a la que se puede enviar texto ``cortado''
o `copiado'' y desde la cual se puede recuperar el texto para 
insertarlo en la zona de trabajo  ({\it pattern space}).
en la jerga \verb|sed| dicho espacio se conoce como \emph{hold space}.
El contenido del espacio de patrones ({\it pattern space}) puede moverse al espacio 
de mantenimiento (\emph{hold space}) y recíprocamente:

\vspace{1cm}
\begin{tabular}{|l|c|l|}
\hline
\emph{Hold}     & h ó H & Copia o añade (append) los contenidos del {\it pattern space} al {\it hold space}. \\
\hline
\emph{Get}      & g ó G & Copia o añade los contenidos del {\it hold space} al {\it pattern space}.\\
\hline
\emph{Exchange} &   x   & Intercambia los contenidos del {\it hold space} y el {\it pattern space} \\
\hline
\end{tabular}
\vspace{1cm}

Los comandos en minúsculas sobrescriben mientras que los que van en mayúsculas añaden.
Asi {\it h} copia los contenidos del {\it pattern space} en el {\it hold space}, borrando los
contenidos previos que estuvieran en el {\it hold space}. Las orden {\it G} añade (paste)
los contenidos del {\it hold space} al espacio de patrones actual (por el final).  
Las dos cadenas se enlazan a través de un retorno de carro.

\noindent {\bf Ejemplo}
Este guión intenta mediante una heurística poner la definiciones de 
funciones C al final del fichero, suponiendo que una definición de función
comienza en la columna 1 y que se caracterizan mediante uno o dos identificadores 
seguidos de un paréntesis:
\begin{verbatim}
$ cat G.sed
/\<if\>/s/.*/&/
t
/\<else\>/s/.*/&/
t
#... lo mismo para las otras palabras clave
/^[a-zA-Z][a-zA-Z]*([A-Z]*/H
t
/^[a-zA-Z][a-zA-Z]*  *[a-zA-Z][a-zA-Z]*(/H
${
G
}                        
\end{verbatim}
Ejemplo de uso:
\begin{verbatim}
$ cat p.test
#include <stdio.h>
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */
}                              
\end{verbatim}
Al ejecutar nuestro {\it script} obtenemos la salida:
\begin{verbatim}
$ sed -f G.sed p.test
#include <stdio.h>
 
fact(int n) { /* recursive function */
if(n == 0) return 1;
else(return n*fact(n-1));
}
 
void toto(id) {
}
 
main() {
  toto();
  printf("Hello world! factorial of 4 = %d\n",fact(4)); /* the
         comment takes two lines */
}
 
fact(int n) { /* recursive function */
void toto(id) {
main() {                        
\end{verbatim}

\noindent {\bf Ejemplo}
El siguiente guión invierte los contenidos de un fichero:
\begin{verbatim}
> cat reverse.sed
$!{
:loop
h
n
G
$!b loop
}
${
p
}                                      
\end{verbatim}
He aqui el resultado de una ejecución:

\begin{verbatim}
> cat reverse.test
one
two
three
> sed -n -f reverse.sed reverse.test
three
two
one                                  
\end{verbatim}


\noindent {\bf Ejemplo}

Supuesto un fichero de entrada con formato:
\label{section:alumnos}
\ldots
\begin{verbatim}
NAME: xxx
SURNAME: xxx
TITLE: SISTEMAS
OtherTitle: 
BIRTHDAY: xxx
BIRTHMONTH: xxx
BIRTHYEAR: xxx
ADDRESSFAMILY: xxx
ADDRESSACTUAL: xxx
POSTALCODE: xxx
EMAIL: XXXXXXX@csi.ull.es
TELEPHONE: xxx
FAX: xxx
LABGROUP: xxx
COMMENTS: 
\end{verbatim}
\ldots

Se pretenden extraer los apellidos y el nombre, concatenados con una coma. He aqui una posible solución:
\begin{verbatim}
#!/bin/sed -f
/^NAME:/ {
  s/^NAME://
  h
  n
  s/^SURNAME://
  G
  s/\n/,/
  y/áéíóúabcdefghijklmnñopqrstuvwxyz/ÁÉÍÓÚABCDEFGHIJKLMNÑOPQRSTUVWXYZ/
  p
}
\end{verbatim}

\section{La orden {\it N}}
{\it N} añade la siguiente línea de entrada al espacio de
patrones. Las dos líneas se separan mediante un retorno de
carro. Después de su ejecución, el comando {\it N} pasa el control a los
subsiguientes comandos en el {\it script}.\\
El siguiente ejemplo propuesto en \cite{sedawk} muestra una
búsqueda y sustitución multilínea. Se trata de sustituir la
cadena ``Owner and Operator Guide'' por ``Installation Guide'', cualquiera que sea su posición en una línea o entre ellas.
Los autores de \cite{sedawk} y \cite{power} proponen la siguiente
solución:
\begin{verbatim}
$ cat multiline2.sed
#Assume the pattern is in no more than two lines
s/Owner and Operator Guide/Installation Guide/g
/Owner/{
  N
  s/ *\n/ /g
  s/Owner  *and  *Operator  *Guide/Installation Guide/g
}                    
\end{verbatim}
Veamos primero los contenidos del fichero de prueba:
\begin{verbatim}
$ cat multiline.test
Dear Owner: Consult
Section 3.1 in the Owner and
Operator Guide for a description of the tape drives available for the Owner
of your system.
 
Consult Section 3.1 in the Owner and Operator
Guide for a description of the tape drives
available on your system.
 
Look in the Owner and Operator Guide, we mean the Owner
and Operator Guide shipped with your system.
 
Two manuals are provided including the Owner and
Operator Guide and the User Guide.
 
The Owner and Operator Guide is shipped with your system.
 
Look in the Owner
and Operator Guide shipped with your system.
 
The Owner
and
Operator
Guide is shipped with your system.   
\end{verbatim}
La ejecución del {\it script} da la siguiente salida:
\begin{verbatim}
$ sed -f multiline2.sed multiline.test
Dear Owner: Consult Section 3.1 in the Owner and
Operator Guide for a description of the tape drives available for the Owner
of your system.
 
Consult Section 3.1 in the Installation Guide for a description of the tape
drives
available on your system.
 
Look in the Installation Guide, we mean the Installation Guide shipped with
your system.
 
Two manuals are provided including the Installation Guide and the User Guide.
 
The Installation Guide is shipped with your system.
 
Look in the Installation Guide shipped with your system.
 
The Owner and
Operator
Guide is shipped with your system.  
\end{verbatim}
Uno de los problemas, que aparece en el primer párrafo del
ejemplo de prueba, es que la segunda línea leída debe ser
"reciclada"
para su uso en la siguiente búsqueda. El segundo fallo, 
que aparece en el último párrafo, es consecuencia de la
limitación del {\it script} para trabajar con  patrones partidos
en más de dos líneas.\\
Consideremos esta otra solución:
\begin{verbatim}
$ cat multiline.sed
s/Owner and Operator Guide/Installation Guide/g
/Owner/{
:label
  N
  s/\n/ /g
  s/Owner  *and  *Operator  *Guide/Installation Guide/g
  /Owner *$/b label
  /Owner  *and *$/b label
  /Owner  *and  *Operator *$/b label
  }                       
\end{verbatim}
Este otro {\it script} hace que {\tt sed} permanezca en un bucle mientras
la línea adjuntada en segundo lugar contenga un prefijo estricto 
de la cadena buscada. 

\begin{verbatim}
$sed -f multiline.sed multiline.test
Dear Owner: Consult Section 3.1 in the Installation Guide for \
a description of the tape drives available for the Owner  of \
your system.
 
Consult Section 3.1 in the Installation Guide for a description of the tape drives
available on your system.
 
Look in the Installation Guide, we mean the Installation Guide \
shipped with your system.
 
Two manuals are provided including the Installation Guide and the User Guide.
 
The Installation Guide is shipped with your system.
 
Look in the Installation Guide shipped with your system.
 
The Installation Guide is shipped with your system.
\end{verbatim}
Un problema que aparece con esta aproximación es la presencia
de líneas muy largas. Las líneas permanecen en el espacio de trabajo
mientras terminen en un prefijo de la cadena buscada. Para
que la salida quepa en la hoja he
tenido que partir las líneas del fichero de salida, lo que he indicado con los
símbolos $\backslash$. Considere esta modificación:
\begin{verbatim}
#!/bin/sed -f
s/Owner and Operator Guide/Installation Guide/g
/Owner/{
:label
  N
  s/Owner\([ \n]*\)and\([ \n]*\)Operator\([ \n]*\)Guide/Installation\1\2Guide\3/g
  /Owner *$/b label
  /Owner  *and *$/b label
  /Owner  *and  *Operator *$/b label
  }
\end{verbatim}
Es indudable la ventaja de disponer de esta
capacidad de búsqueda multilínea no puede realizarse con 
otras utilidades como {\it ex} o {\it vi}.

\section{Suprimir: El Comando {\it D}}
El comando {\it D} suprime la primera parte (hasta el retorno de
carro empotrado) en un espacio de patrones multilínea y bifurca al
primer comando en el {\it script}. El retorno de carro empotrado puede
describirse mediante la secuencia de escape \verb%\n%. En el caso en que
el espacio de patrones quede vacío como consecuencia de la supresión,
se lee una nueva línea.

El siguiente ejemplo compacta una secuencia de líneas vacías en una sóla línea vacía.
\begin{verbatim}
1 > cat N.sed
2 /^$/{
3 N
4 /^\n$/D
5 }                                
\end{verbatim}
Si la línea  es vacía se lee la línea siguiente. Si esta también es vacía el espacio de patrones contiene
\verb%^\n$%. La orden \verb%D% deja en el espacio de trabajo una línea vacía y bifurca al comienzo del {\it script}
(sin que se lea una nueva línea).
Por tanto nada ha sido impreso, no se ejecuta el comnado final \verb|p| que actúa por defecto.
Como el espacio de trabajo contiene \verb%^$%, ``casa''
con el patrón especificado en línea 2
y se lee la siguiente línea. Si esta nueva línea es no vacía, no se ejecutará la orden
\verb%D% de la línea 4 y si que lo hará la orden por defecto final, imprimiéndose la línea
vacía y la nueva línea no vacía.

Al ejecutar este ``{\it script}'' sobre un fichero conteniendo una secuencia de líneas en blanco:

\begin{verbatim}
> cat N.test
one empty
 
two empty lines
 
 
three empty lines
 
 
 
end of file
\end{verbatim}
Se obtiene el resultado:
\begin{verbatim}
> sed -f N.sed N.test
one empty
 
two empty lines
 
three empty lines
 
end of file                      
\end{verbatim}
Un buen ejercicio es intentar predecir la conducta de esta otra solución alternativa,
en la que la supresión \emph{D}  es sustituida por la \emph{d}:
\begin{verbatim}
/^$/{
N
/^\n$/d
}                                
\end{verbatim}
¿Qué ocurrirá? ¿Es correcta esta segunda solución? 

\section{Búsqueda entre líneas}
Este otro caso, tambien esta tomado de \cite{sedawk} y \cite{power}.
Se trata de extender la capacidad de búsqueda de \emph{grep}, de modo que el 
patrón pueda ser encontrado incluso si se encuentra diseminado
entre a lo mas dos líneas. El {\it script} presentado es una ligera variante
del que aparece en \cite{sedawk} y escribe la(s) líneas que
casan precedidas del número de la segunda línea.
\begin{verbatim}
$ cat phrase
#! /bin/sh
# phrase -- search for words across two lines.
# Prints the line number
# $1 = search string; remaining args = filenames
search=$1
shift
for file
do
sed -n '
  /'"$search"'/b final
  N
  h
  s/.*\n//
  /'"$search"'/b final
  g
  s/ *\n//
  /'"$search"'/{
    g
    b final
  }
  g
  D
:final
  =
  p
' $file
done                     
\end{verbatim}
Así, con el ejemplo ``multiline.test'' usado anteriormente
obtenemos la siguiente salida:
\begin{verbatim}
$ phrase "Owner and Operator Guide" multiline.test
3
Section 3.1 in the Owner and
Operator Guide for a description of the tape drives available for the Owner
7
Consult Section 3.1 in the Owner and Operator
Guide for a description of the tape drives
10
Look in the Owner and Operator Guide, we mean the Owner
14
Two manuals are provided including the Owner and
Operator Guide and the User Guide.
16
The Owner and Operator Guide is shipped with your system.
19
Look in the Owner
and Operator Guide shipped with your system.
\end{verbatim}
Primero se busca el patrón \verb1/'"$search"'/1 en la línea actual.
Observe el habilidoso uso de las comillas simples y dobles para permitir
la sustitución de la variable. La primera comilla simple cierra
la comilla simple al final de la línea 10. Las comillas dobles
hacen que la \emph{shell} sustituya \verb%$search% por su valor. La nueva comilla simple
permite continuar el texto sin sustituciones.

Si se encuentra el patrón de búsqueda, imprimimos el número de línea (comando {\tt =}) y la línea.
Si no, leemos la siguiente línea, formando un patrón multilínea. 
Salvamos las dos líneas en el {\it hold space}.
Entonces intentamos buscar el patrón \verb1/'"$search"'/1 en
la línea que acaba de incorporarse. Es por eso que eliminamos 
del espacio de patrones la primera línea con la orden 
\verb1s/ *\n//1. Si se encuentra, imprimimos y se repite el ciclo.
Si no, recuperamos las dos líneas del {\it hold space} 
sustituimos el retorno de carro por un blanco y realizamos 
una nueva busqueda.
Si tiene éxito, se obtienen las dos líneas y se imprimen.
En caso contrario, esto es, si el patrón no se ha encontrado en ninguna
de las dos líneas, es necesario preservar la última para el siguiente
ciclo. Por eso, se obtienen una vez mas las líneas del {\it hold space}
y se suprime con \emph{D} la primera de ellas. Dado que \emph{D} 
devuelve el control al comienzo del {\it script}, la segunda línea no es eliminada. 
De todos modos,  el {\it script} no es capaz de captar cuando un prefijo del patrón 
aparece  al final de esta segunda línea, como muestra el
ejemplo de prueba. En el primer párrafo el patrón se encuentra
dos veces y sólo es encontrado una.

\section{Seleccionando Items en un Registro Multilínea}
El ejercicio resuelto aqui consiste en listar los alumnos que han seleccionado un determinado grupo de prácticas.
Suponemos la organización del fichero de entrada descrita en la sección  \ref{section:alumnos}. 
El \emph{script} recibe como primer argumento el nombre del fichero conteniendo la carpeta de correo (\verb%pine%) 
asociada con la asignatura y como segundo argumento el grupo. Un primer \emph{script} que no es descrito
aqui, denominado \verb|makefichas.sed| produce como salida el archivo con la estructura
descrita en la sección \ref{section:alumnos}. El segundo guión, denominado \verb|grupo.sh| y que es
el que nos ocupa, produce como salida los alumnos que pertenecen a ese grupo ed prácticas.

Estos son los contenidos del \emph{script} \verb|grupo|:
\begin{verbatim}
~/bin/makefichas.sed -n ~/mail/$1 | grupo.sh $2 | sort -u
\end{verbatim}
Los contenidos del fichero \verb%grupo.sh% son:
\begin{verbatim}
 1  #!/bin/bash
 2  search=$1
 3  sed -n '
 4  /^NAME:/ {
 5    s/^NAME://
 6    h
 7    n
 8    s/^SURNAME://
 9    G
10    s/\n/,/
11    y/ÁÉÍÓÚáéíóúabcdefghijklmnñopqrstuvxyz/AEIOUAEIOUABCDEFGHIJKLMNÑOPQRSTUVXYZ/
12   h
13 }
14 /^LABGROUP:/ {
15   y/ÁÉÍÓÚáéíóúabcdefghijklmnñopqrstuvxyz/AEIOUAEIOUABCDEFGHIJKLMNÑOPQRSTUVXYZ/
16   s/'"$search"'/&/
17   t print
18   b 
19 :print
20   g
21   p
22 }
23 ' 
\end{verbatim}
De nuevo hacemos uso de las comillas simples y dobles
en este ejemplo.
Obsérvese como se proteje el guión \verb|sed| entre las líneas 3 y 16. 
En la línea 16 el cierre de la comilla simple y el uso de la doble comilla 
permite la actuación de la interpretación de la \verb|shell|, sustituyendo 
\verb|$search| que coincide con el
parámetro pasado en la llamada como \verb|$2|. La siguiente comilla 
simple en esa línea permite la protección del resto
del guión.

%%% TEXEXPAND: END FILE ./chapter2/sed.tex

%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter2/perlregexp.tex
\chapter{Expresiones Regulares en Perl}
\label{chapter:regulares}

\section{Introducción}
Los rudimentos de las expresiones regulares pueden encontrarse
en los trabajos pioneros de McCullogh y Pitts (1940) sobre redes neuronales.
El lógico Stephen Kleene definió formalmente el algebra que denominó
\emph{conjuntos regulares} y desarrollo una notación para la descripción de dichos conjuntos, las \emph{expresiones regulares}.

Durante las décadas de 1960 y 1970 hubo un desarrollo formal de las expresiones regulares.
Una de las priemras publicaciones que utilizan las expresiones
regulares en un marco informático es el artículo de 1968 de Ken
Thompson \emph{Regular Expression Search Algorithm} en el que describe
un compilador de expresiones regulares que produce código objeto para
un IBM 7094.
Este compilador dió lugar al editor \emph{qed}, en el cual se basó el
editor de Unix
\emph{ed}. Aunque las expresiones regulares de este último no eran
tan sofisticadas como las de \emph{qed}, fueron las primeras en ser
utilizadas en un contexto no académico.
Se dice que el comando global \verb|g| en su formato \verb|g/re/p| que utilizaba 
para imprimir (opción \verb|p|) las líneas que casan con la expresión regular  \verb|re|
dió lugar a un programa separado al que se denomino \man{grep}.

Las expresiones regulares facilitadas por las primeras versiones de estas herramientas 
eran limitadas. Por ejemplo, se disponía del cierre de Kleene \verb|*| pero no del cierre
positivo \verb|+| o del operador opcional \verb|?|. 
Por eso, posteriormente, se han introducido los metacaracteres \verb|\+| y \verb|\?|.
Existían numerosas limitaciones en dichas versiones, por ej. \verb|$| sólo significa ``final
de línea'' al final de la expresión regular. Eso  dificulta expresiones como 
\begin{verbatim}
grep 'cierre$\|^Las' viq.tex
\end{verbatim}
Sin embargo, la mayor parte de las versiones
actuales resuelven correctamente estos problemas:
\begin{verbatim}
nereida:~/viq> grep 'cierre$\|^Las' viq.tex
Las expresiones regulares facilitadas por las primeras versiones de estas herramientas
eran limitadas. Por ejemplo, se disponía del cierre de Kleene \verb|*| pero no del cierre
nereida:~/viq>
\end{verbatim}
De hecho AT\&T Bell  labs añadió numerosas funcionalidades,
como por ejemplo, el uso de \verb|\{min, max\}|, tomada de \emph{lex}.
Por esa época, Alfred Aho escribió \emph{egrep} que, no sólo proporciona un conjunto
mas rico de operadores sino que mejoró la implementación.
Mientras que el \emph{grep} de Ken Thompson usaba un autómata finito no determinista
(NFA), la versión de \emph{egrep}
de Aho usa un autómata finito determinista (DFA).

En 1986 Henry Spencer desarrolló la librería \emph{regex} para el lenguaje \verb|C|, que 
proporciona un conjunto consistente de funciones que permiten el manejo de expresiones
regulares. Esta librería ha contribuido a ``homogeneizar'' la sintáxis y semántica 
de las diferentes herramientas que utilizan expresiones regulares (como \emph{awk},
\emph{lex}, \emph{sed}, \ldots).

\parrafo{Véase También}

\begin{itemize}
\item
La sección
{\it Expresiones Regulares en Otros Lenguajes}
\ref
{section:otroslenguajes}
\item
\htmladdnormallink
{Regular Expressions Cookbook. Jan Goyvaerts, Steven Levithan}
{http://oreilly.com/catalog/9780596520687/preview.html}
\item
\htmladdnormallink
{PCRE (Perl Compatible Regular Expressions) en la Wikipedia}
{http://en.wikipedia.org/wiki/Perl\_Compatible\_Regular\_Expressions}
\item
\htmladdnormallink{PCRE (Perl Compatible Regular Expressions)}
{http://www.pcre.org/pcre.txt}
\item
\htmladdnormallink
{Java Regular Expressions}
{http://java.sun.com/docs/books/tutorial/essential/regex/}
\item
\htmladdnormallink
{C\# Regular Expressions}
{http://oreilly.com/lpt/a/2299}
\item
\htmladdnormallink
{.NET Framework Regular Expressions}
{http://msdn.microsoft.com/en-us/library/hs600312(VS.71).aspx}
\end{itemize}

\subsection{Un ejemplo sencillo}
\label{section:ejemplo}
%%%%%%%%%%%%%%%listinginput: Input from: "../src/convert.pl"

\parrafo{Matching en Contexto Escalar}


\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n c2f.pl
  1    #!/usr/bin/perl -w
  2    use strict;
  3  
  4    print "Enter a temperature (i.e. 32F, 100C):\n";
  5    my $input = <STDIN>;
  6    chomp($input);
  7  
  8    if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
  9      warn "Expecting a temperature, so don't understand \"$input\".\n";
 10    }
 11    else {
 12      my $InputNum = $1;
 13      my $type = $3;
 14      my ($celsius, $farenheit);
 15      if ($type eq "C" or $type eq "c") {
 16        $celsius = $InputNum;
 17        $farenheit = ($celsius * 9/5)+32;
 18      }
 19      else {
 20        $farenheit = $InputNum;
 21        $celsius = ($farenheit -32)*5/9;
 22      }
 23      printf "%.2f C = %.2f F\n", $celsius, $farenheit;
 24    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n c2f.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">print</span> <span class="synConstant">&quot;Enter a temperature (i.e. 32F, 100C):</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = <span class="synIdentifier">&lt;STDIN&gt;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> !~ <span class="synStatement">m/</span><span class="synConstant">^</span><span class="synSpecial">([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])</span><span class="synConstant">$</span><span class="synStatement">/i</span>) {
<span class="synLinenum">    9</span>     <span class="synStatement">warn</span> <span class="synConstant">&quot;Expecting a temperature, so don't understand </span><span class="synSpecial">\&quot;</span><span class="synIdentifier">$input</span><span class="synSpecial">\&quot;</span><span class="synConstant">.</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   12</span>     <span class="synStatement">my</span> <span class="synIdentifier">$InputNum</span> = <span class="synIdentifier">$1</span>;
<span class="synLinenum">   13</span>     <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$3</span>;
<span class="synLinenum">   14</span>     <span class="synStatement">my</span> (<span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$farenheit</span>);
<span class="synLinenum">   15</span>     <span class="synStatement">if</span> (<span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;C&quot;</span> <span class="synStatement">or</span> <span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;c&quot;</span>) {
<span class="synLinenum">   16</span>       <span class="synIdentifier">$celsius</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   17</span>       <span class="synIdentifier">$farenheit</span> = (<span class="synIdentifier">$celsius</span> * <span class="synConstant">9</span>/<span class="synConstant">5</span>)<span class="synConstant">+32</span>;
<span class="synLinenum">   18</span>     }
<span class="synLinenum">   19</span>     <span class="synStatement">else</span> {
<span class="synLinenum">   20</span>       <span class="synIdentifier">$farenheit</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   21</span>       <span class="synIdentifier">$celsius</span> = (<span class="synIdentifier">$farenheit</span> <span class="synConstant">-32</span>)*<span class="synConstant">5</span>/<span class="synConstant">9</span>;
<span class="synLinenum">   22</span>     }
<span class="synLinenum">   23</span>     <span class="synStatement">printf</span> <span class="synConstant">&quot;%.2f C = %.2f F</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>, <span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$farenheit</span>;
<span class="synLinenum">   24</span>   }
</pre>

\end{rawhtml}
%}}}


Véase también:

\begin{itemize}
\item \verb|perldoc| \perldoc{perlrequick}
\item \verb|perldoc| \perldoc{perlretut}
\item \verb|perldoc| \perldoc{perlre}
\item \verb|perldoc| \perldoc{perlreref}
\end{itemize}

Ejecución con el depurador:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl -wd c2f.pl
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h' for help, or `man perldebug' for more help.
main::(c2f.pl:4):       print "Enter a temperature (i.e. 32F, 100C):\n";
DB<1> c 8
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB<2> n
main::(c2f.pl:12):        my $InputNum = $1;
DB<2> x ($1, $2, $3)
0  32
1  undef
2  'F'
DB<3> use YAPE::Regex::Explain
DB<4> p YAPE::Regex::Explain->new('([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$')->explain
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: '-', '+' (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: '0' to '9' (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       '.'
----------------------------------------------------------------------
      [0-9]*                   any character of: '0' to '9' (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you're using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and " ") (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: 'C', 'F'
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$  <span  class="dbuser">perl -wd c2f.pl</span>
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h' for help, or `man perldebug' for more help.
main::(c2f.pl:4):       print "Enter a temperature (i.e. 32F, 100C):\n";
DB<1>  <span  class="dbuser">c 8</span>
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB<2>  <span  class="dbuser">n</span>
main::(c2f.pl:12):        my $InputNum = $1;
DB<2>  <span  class="dbuser">x ($1, $2, $3)</span>
0  32
1  undef
2  'F'
DB<3>  <span  class="dbuser">use YAPE::Regex::Explain</span>
DB<4>  <span  class="dbuser">p YAPE::Regex::Explain->new('([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$')->explain</span>
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: '-', '+' (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: '0' to '9' (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       '.'
----------------------------------------------------------------------
      [0-9]*                   any character of: '0' to '9' (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you're using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and " ") (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: 'C', 'F'
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------
</pre>
\end{rawhtml}
%}}}

\label{section:dolar1}
Dentro de una expresión regular es necesario 
referirse a los textos que casan con el primer, paréntesis,
segundo, etc. como \verb|\1|, \verb|\2,| etc. La notación 
\verb|$1| se refieré a lo que casó con el primer paréntesis
en el último \emph{matching}, no en el actual. Veamos un ejemplo:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $a = "hola juanito";
   5    my $b = "adios anita";
   6  
   7    $a =~ /(ani)/;
   8    $b =~ s/(adios) *($1)/\U$1 $2/;
   9    print "$b\n";
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$a</span> = <span class="synConstant">&quot;hola juanito&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$b</span> = <span class="synConstant">&quot;adios anita&quot;</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synIdentifier">$a</span> =~<span class="synStatement"> /</span><span class="synSpecial">(</span><span class="synConstant">ani</span><span class="synSpecial">)</span><span class="synStatement">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$b</span> =~ <span class="synStatement">s/</span><span class="synSpecial">(</span><span class="synConstant">adios</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">*(</span><span class="synIdentifier">$1</span><span class="synSpecial">)</span><span class="synStatement">/</span><span class="synSpecial">\U</span><span class="synIdentifier">$1</span><span class="synConstant"> </span><span class="synIdentifier">$2</span><span class="synStatement">/</span>;
<span class="synLinenum">    9</span>   <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$b</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
</pre>

\end{rawhtml}
%}}}
Observe como el \verb|$1| que aparece en la cadena de reemplazo (línea 8)
se refiere a la cadena \verb|adios|
mientras que el \verb|$1| en la primera parte contiene \verb|ani|:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./dollar1slash1.pl
ADIOS ANIta
\end{verbatim}

\begin{exercise}
Indique cuál es la salida del programa anterior si se sustituye la línea 8 por
\begin{verbatim}
$b =~ s/(adios) *(\1)/\U$1 $2/;
\end{verbatim}
\end{exercise}

\parrafo{Número de Paréntesis}

El número de paréntesis con memoria no está limitado:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
            123456789ABCDEF
DB<1> $x = "123456789AAAAAA"
                   1  2  3  4  5  6  7  8  9 10 11  12
DB<2> $r = $x =~ /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/; print "$r\n$10\n$11\n"
1
A
A
\end{verbatim}

Véase el siguiente párrafo de \perldoc{perlre} (sección Capture buffers):
\begin{it}
\begin{quotation}
There is no limit to the number of captured substrings that you may
use. However Perl also uses \verb#\10#, \verb#\11#, etc. as aliases for \verb#\010#, \verb#\011#,
etc. (Recall that \verb#0# means octal, so \verb#\011# is the character at number \verb#9# in
your coded character set; which would be the 10th character, a horizontal
tab under ASCII.) Perl resolves this ambiguity by interpreting \verb#\10# as
a backreference only if at least \verb#10# left parentheses have opened before
it. Likewise \verb#\11# is a backreference only if at least \verb#11# left parentheses
have opened before it. And so on. \verb#\1# through \verb#\9# are always interpreted
as backreferences.
\end{quotation}
\end{it}

\parrafo{Contexto de Lista}

Si se utiliza en un contexto que requiere una lista,
el ``pattern match'' retorna una lista consistente en
las subexpresiones casadas mediante los paréntesis,
esto es \verb|$1|, \verb|$2|, \verb|$3|, \ldots. 
Si no hubiera emparejamiento se retorna la lista vacía.
Si lo hubiera pero no hubieran paréntesis se retorna la lista 
\verb|($&)|.

%%%%%%%%%%%%%%%listinginput: Input from: "../src/escapes.pl"
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ cat -n escapes.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $foo = "one two three four five\nsix seven";
     5  my ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/);
     6  print "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n";
     7
     8  # This is 'almost' the same than:
     9  ($F1, $F2, $Etc) = split(/\s+/, $foo, 3);
    10  print "Split: F1 = $F1, F2 = $F2, Etc = $Etc\n";
\end{verbatim}
Observa el resultado de la ejecución:
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ ./escapes.pl
List Context: F1 = one, F2 = two, Etc = three four five
Split: F1 = one, F2 = two, Etc = three four five
six seven
\end{verbatim}

\parrafo{El modificador {\tt s}}

La opción \verb|s| usada en una regexp 
hace que el punto \verb|'.'| case con el retorno
de carro:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ perl -wd ./escapes.pl
main::(./escapes.pl:4): my $foo = "one two three four five\nsix seven";
DB<1> c 9
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(' ',$foo, 3);
DB<2> ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)
DB<3> p "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n"
List Context: F1 = one, F2 = two, Etc = three four five
six seven
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/src/perl/perltesting$  <span  class="dbuser">perl -wd ./escapes.pl</span>
main::(./escapes.pl:4): my $foo = "one two three four five\nsix seven";
DB<1>  <span  class="dbuser">c 9</span>
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(' ',$foo, 3);
DB<2>  <span  class="dbuser">($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)</span>
DB<3>  <span  class="dbuser">p "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n"</span>
List Context: F1 = one, F2 = two, Etc = three four five
six seven
</pre>
\end{rawhtml}
%}}}


La opción \verb|/s| hace que \verb|.| se empareje con 
un \verb|\n|.
Esto es, casa con cualquier carácter.

Veamos otro ejemplo, que imprime los nombres de los ficheros que
contienen cadenas que casan con un patrón dado, incluso si este
aparece disperso en varias líneas:
%%%%%%%%%%%%%%%listinginput: Input from: "../src/smodifier.pl"
\begin{latexonly}
\begin{verbatim}
   1   #!/usr/bin/perl -w
   2   #use: 
   3   #smodifier.pl 'expr' files
   4   #prints the names of the files that match with the give expr
   5   undef $/; # input record separator
   6   my $what = shift @ARGV;
   7   while(my $file = shift @ARGV) {
   8     open(FILE, "<$file");
   9     $line =  <FILE>;
  10     if ($line =~ /$what/s) {
  11       print "$file\n";
  12     }
  13   }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span>  <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>  <span class="synComment">#use: </span>
<span class="synLinenum">    3</span>  <span class="synComment">#smodifier.pl 'expr' files</span>
<span class="synLinenum">    4</span>  <span class="synComment">#prints the names of the files that match with the give expr</span>
<span class="synLinenum">    5</span>  <span class="synStatement">undef</span> <span class="synIdentifier">$/</span>; <span class="synComment"># input record separator</span>
<span class="synLinenum">    6</span>  <span class="synStatement">my</span> <span class="synIdentifier">$what</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span>;
<span class="synLinenum">    7</span>  <span class="synStatement">while</span>(<span class="synStatement">my</span> <span class="synIdentifier">$file</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span>) {
<span class="synLinenum">    8</span>    <span class="synStatement">open</span>(<span class="synIdentifier">FILE</span>, <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$file</span><span class="synConstant">&quot;</span>);
<span class="synLinenum">    9</span>    <span class="synIdentifier">$line</span> =  <span class="synIdentifier">&lt;FILE&gt;</span>;
<span class="synLinenum">   10</span>    <span class="synStatement">if</span> (<span class="synIdentifier">$line</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$what</span><span class="synStatement">/s</span>) {
<span class="synLinenum">   11</span>      <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$file</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   12</span>    }
<span class="synLinenum">   13</span>  }
</pre>

\end{rawhtml}
%}}}

\noindent Ejemplo de uso:

\begin{verbatim}
> smodifier.pl 'three.*three' double.in split.pl doublee.pl
double.in
doublee.pl 
\end{verbatim}

Vea la sección \ref{section:repetidas} para ver los contenidos 
del fichero \verb|double.in|. En dicho fichero,
el patrón \verb|three.*three| aparece repartido entre
varias líneas.


\parrafo{El modificador {\tt m}}

El modificador \verb|s| se suele usar conjuntamente con el modificador 
\verb|m|. He aquí lo que dice
la seccion {\it Using character classes} de \pd{perlretut}{Using-character-classes}
al respecto:

\begin{it}
\begin{quotation}
\begin{itemize}
    \item \verb|m| modifier (\verb|//m|): Treat string as a set of multiple lines. 
      \verb|'.'| matches any character except \verb"\n". 
      \verb|^| and \verb|$| are able to match at the start or end of any line within the string.
    \item
      both \verb|s| and \verb|m| modifiers (\verb|//sm|): Treat string as a single long line, but detect multiple lines. 
      \verb|'.'| matches any character, even \verb"\n" . 
      \verb|^| and \verb|$| , however, are able to match at the start or end of any line within the string.
\end{itemize}

Here are examples of //s and //m in action:

\begin{verbatim}
   1. $x = "There once was a girl\nWho programmed in Perl\n";
   2.
   3. $x =~ /^Who/; # doesn't match, "Who" not at start of string
   4. $x =~ /^Who/s; # doesn't match, "Who" not at start of string
   5. $x =~ /^Who/m; # matches, "Who" at start of second line
   6. $x =~ /^Who/sm; # matches, "Who" at start of second line
   7.
   8. $x =~ /girl.Who/; # doesn't match, "." doesn't match "\n"
   9. $x =~ /girl.Who/s; # matches, "." matches "\n"
  10. $x =~ /girl.Who/m; # doesn't match, "." doesn't match "\n"
  11. $x =~ /girl.Who/sm; # matches, "." matches "\n"
\end{verbatim}

Most of the time, the default behavior is what is wanted, but \verb|//s| and
\verb|//m| are occasionally very useful. If \verb|//m| is being used, the start of the
string can still be matched with \verb|\A| and the end of the string can still
be matched with the anchors \verb|\Z| (matches both the end and the newline
before, like \verb|$|), and \verb|\z| (matches only the end):

\begin{verbatim}
   1. $x =~ /^Who/m; # matches, "Who" at start of second line
   2. $x =~ /\AWho/m; # doesn't match, "Who" is not at start of string
   3.
   4. $x =~ /girl$/m; # matches, "girl" at end of first line
   5. $x =~ /girl\Z/m; # doesn't match, "girl" is not at end of string
   6.
   7. $x =~ /Perl\Z/m; # matches, "Perl" is at newline before end
   8. $x =~ /Perl\z/m; # doesn't match, "Perl" is not at end of string
\end{verbatim}
\end{quotation}
\end{it}
Normalmente el carácter \verb|^| casa solamente con el comienzo de la
cadena y el carácter \verb|$| con el final. Los \verb|\n| empotrados
no casan
con \verb|^| ni \verb|$|. El modificador \verb|/m| modifica esta
conducta. De este modo \verb|^| y  \verb|$| casan con cualquier frontera
de línea interna. Las anclas \verb|\A| y \verb|\Z| se utilizan entonces
para casar con
el comienzo y final de la cadena.
Véase un ejemplo:
\begin{verbatim}
nereida:~/perl/src> perl -de 0
  DB<1> $a = "hola\npedro"
  DB<2> p "$a"
hola
pedro
  DB<3> $a =~ s/.*/x/m
  DB<4> p $a
x
pedro
  DB<5> $a =~ s/^pedro$/juan/
  DB<6> p "$a"
x
pedro
  DB<7> $a =~ s/^pedro$/juan/m
  DB<8>  p "$a"
x
juan
\end{verbatim}


\parrafo{El conversor de temperaturas reescrito usando contexto de lista}

Reescribamos el ejemplo anterior usando un contexto de lista:

\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
  1    #!/usr/bin/perl -w
  2    use strict;
  3  
  4    print "Enter a temperature (i.e. 32F, 100C):\n";
  5    my $input = <STDIN>;
  6    chomp($input);
  7  
  8    my ($InputNum, $type);
  9  
 10    ($InputNum, $type) = $input =~ m/^
 11                                        ([-+]?[0-9]+(?:\.[0-9]*)?) # Temperature
 12                                        \s*
 13                                        ([cCfF]) # Celsius or Farenheit
 14                                     $/x;
 15  
 16    die "Expecting a temperature, so don't understand \"$input\".\n" unless defined($InputNum);
 17  
 18    my ($celsius, $fahrenheit);
 19    if ($type eq "C" or $type eq "c") {
 20      $celsius = $InputNum;
 21      $fahrenheit = ($celsius * 9/5)+32;
 22    }
 23    else {
 24      $fahrenheit = $InputNum;
 25      $celsius = ($fahrenheit -32)*5/9;
 26    }
 27    printf "%.2f C = %.2f F\n", $celsius, $fahrenheit;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">print</span> <span class="synConstant">&quot;Enter a temperature (i.e. 32F, 100C):</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = <span class="synIdentifier">&lt;STDIN&gt;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> (<span class="synIdentifier">$InputNum</span>, <span class="synIdentifier">$type</span>);
<span class="synLinenum">    9</span> 
<span class="synLinenum">   10</span>   (<span class="synIdentifier">$InputNum</span>, <span class="synIdentifier">$type</span>) = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m/</span><span class="synConstant">^</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                      </span><span class="synSpecial">([-+]?[0-9]+(?:\.[0-9]*)?)</span><span class="synConstant"> # Temperature</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                      </span><span class="synSpecial">\s*</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">([cCfF])</span><span class="synConstant"> # Celsius or Farenheit</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   $</span><span class="synStatement">/x</span>;
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span>   <span class="synStatement">die</span> <span class="synConstant">&quot;Expecting a temperature, so don't understand </span><span class="synSpecial">\&quot;</span><span class="synIdentifier">$input</span><span class="synSpecial">\&quot;</span><span class="synConstant">.</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span> <span class="synStatement">unless</span> <span class="synStatement">defined</span>(<span class="synIdentifier">$InputNum</span>);
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span>   <span class="synStatement">my</span> (<span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$fahrenheit</span>);
<span class="synLinenum">   19</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;C&quot;</span> <span class="synStatement">or</span> <span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;c&quot;</span>) {
<span class="synLinenum">   20</span>     <span class="synIdentifier">$celsius</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   21</span>     <span class="synIdentifier">$fahrenheit</span> = (<span class="synIdentifier">$celsius</span> * <span class="synConstant">9</span>/<span class="synConstant">5</span>)<span class="synConstant">+32</span>;
<span class="synLinenum">   22</span>   }
<span class="synLinenum">   23</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   24</span>     <span class="synIdentifier">$fahrenheit</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   25</span>     <span class="synIdentifier">$celsius</span> = (<span class="synIdentifier">$fahrenheit</span> <span class="synConstant">-32</span>)*<span class="synConstant">5</span>/<span class="synConstant">9</span>;
<span class="synLinenum">   26</span>   }
<span class="synLinenum">   27</span>   <span class="synStatement">printf</span> <span class="synConstant">&quot;%.2f C = %.2f F</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>, <span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$fahrenheit</span>;
</pre>

\end{rawhtml}
%}}}

\parrafo{La opción {\tt x}}

\label{section:x}
La opción \verb|/x| en una regexp permite utilizar comentarios y
espacios dentro de la expresión
regular. Los espacios dentro de la expresión regular dejan de ser significativos.
Si quieres conseguir un espacio que sea significativo, usa \verb|\s| o
bien escápalo.  Véase \pd{perlre}{Modifiers} y 
\pd{perlretut}{Building-a-regexp}.

\parrafo{Paréntesis sin memoria}

La notación \verb|(?: ... )| se usa para introducir paréntesis de agrupamiento sin memoria.
\verb|(?: ...)| 
Permite agrupar las expresiones tal y como lo hacen los 
paréntesis ordinarios. La diferencia es que no ``memorizan''
esto es no guardan nada en \verb|$1|, \verb|$2|, etc.
Se logra así una compilación mas eficiente. Veamos un ejemplo:
\begin{verbatim}
> cat groupingpar.pl
#!/usr/bin/perl

  my $a = shift;

  $a =~ m/(?:hola )*(juan)/;
  print "$1\n";
nereida:~/perl/src> groupingpar.pl 'hola juan'
juan
\end{verbatim}

\parrafo{Interpolación en los patrones: La opción {\tt o}}

El patrón regular puede contener variables, que serán interpoladas
(en tal caso, el patrón será recompilado).
Si quieres que dicho patrón se compile una sóla vez, usa la opción
\verb|/o|.
%%%%%%%%%%%%%%%listinginput: Input from: "../src/mygrep.pl"
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n mygrep.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die "Usage $0 regexp files ...\n";
     3  while (<>) {
     4    print "File $ARGV, rel. line $.: $_" if (/$what/o); # compile only once
     5  }
     6
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./mygrep.pl
Usage ./mygrep.pl regexp files ...
pl@nereida:~/Lperltesting$ ./mygrep.pl if labels.c
File labels.c, rel. line 7:        if (a < 10) goto LABEL;
\end{verbatim}

El siguiente texto es de \pd{perlretut}{Using-regular-expressions-in-Perl}:

\begin{it}
\begin{quotation}
If \verb|$pattern|  won't be changing over the lifetime of the script,
we can add the //o modifier, which directs Perl to only perform variable
substitutions once
\end{quotation}
\end{it}

Otra posibilidad es hacer una compilación previa usando el operador 
\verb|qr| (véase \pd{perlop}{Regexp-Quote-Like-Operators}).
La siguiente variante del programa anterior también compila el patrón
una sóla vez:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n mygrep2.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die "Usage $0 regexp files ...\n";
     3  $what = qr{$what};
     4  while (<>) {
     5    print "File $ARGV, rel. line $.: $_" if (/$what/);
     6  }
\end{verbatim}

Véase 
\begin{itemize}
\item El nodo en perlmonks \pmm{269035}{/o is dead, long live qr//!} por \pmm{194920}{diotalevi}
\end{itemize}
  

\parrafo{Cuantificadores greedy}

El siguiente extracto de la sección {\it Matching Repetitions} en \pd{perlretut}{Matching-repetitions} 
ilustra la semántica {\it greedy} de los operadores de repetición \verb|*+{}?| etc.
\begin{it}
\begin{quotation}
For all of these quantifiers, Perl will try to match as much of the string
as possible, while still allowing the regexp to succeed. Thus with \verb#/a?.../#, 
Perl will first try to match the regexp with the a present; if that
fails, Perl will try to match the regexp without the a  present. For
the quantifier \verb|*| , we get the following:

\begin{verbatim}
   1. $x = "the cat in the hat";
   2. $x =~ /^(.*)(cat)(.*)$/; # matches,
   3. # $1 = 'the '
   4. # $2 = 'cat'
   5. # $3 = ' in the hat'
\end{verbatim}

Which is what we might expect, the match finds the only cat in the string and locks onto it. Consider, however, this regexp:

\begin{verbatim}
   1. $x =~ /^(.*)(at)(.*)$/; # matches,
   2. # $1 = 'the cat in the h'
   3. # $2 = 'at'
   4. # $3 = '' (0 characters match)
\end{verbatim}

One might initially guess that Perl would find the \verb|at| in \verb|cat| and stop
there, but that wouldn't give the longest possible string to the first
quantifier \verb|.*|. Instead, the first quantifier \verb|.*| grabs as much of the
string as possible while still having the regexp match. In this example,
that means having the \verb|at| sequence with the final \verb|at| in the string. 

The
other important principle illustrated here is that when there are two
or more elements in a regexp, the leftmost quantifier, if there is one,
gets to grab as much the string as possible, leaving the rest of the
regexp to fight over scraps. Thus in our example, the first quantifier
\verb|.*| grabs most of the string, while the second quantifier \verb|.*| gets the
empty string. Quantifiers that grab as much of the string as possible
are called maximal match or greedy quantifiers.

When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:

\begin{itemize}
    \item

      {\bf Principle 0:} Taken as a whole, any regexp will be matched at the earliest possible position in the string.
    \item

      {\bf Principle 1:} In an alternation \verb#a|b|c...# , the leftmost alternative that allows a match for the whole regexp will be the one used.
    \item

      {\bf Principle 2:} The maximal matching quantifiers \verb|?|, \verb|*|, \verb|+| and \verb|{n,m}| 
                   will in general match as much of the string as possible while still allowing the whole regexp to match.
    \item
      {\bf Principle 3:} If there are two or more elements in a regexp, the leftmost greedy quantifier, 
                   if any, will match as much of the string as possible while still allowing the whole regexp to match. 
                   The next leftmost greedy quantifier, if any, will try to match as much of 
                   the string remaining available to it as possible, while still allowing 
                   the whole regexp to match. And so on, until all the regexp elements are satisfied.
\end{itemize}

\end{quotation}
\end{it}

\parrafo{Regexp y Bucles Infinitos}

El siguiente párrafo está tomado de \pd{perlre}{Repeated-Patterns-Matching-a-Zero-length-Substring}:
\begin{it}
\begin{quote}
Regular expressions provide a terse and powerful programming language. As
with most other power tools, power comes together with the ability to
wreak havoc.

A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:

\begin{verbatim}
   1. 'foo' =~ m{ ( o? )* }x;
\end{verbatim}

The \verb|o?| matches at the beginning of \verb|'foo'| , and since the position in
the string is not moved by the match, \verb|o?| would match again and again
because of the \verb|*| quantifier.

 Another common way to create a similar cycle is with the looping modifier \verb|//g| :

\begin{verbatim}
   1. @matches = ( 'foo' =~ m{ o? }xg );
\end{verbatim}

or

\begin{verbatim}
   1. print "match: <$&>\n" while 'foo' =~ m{ o? }xg;
\end{verbatim}

or the loop implied by \verb|split()|.

... Perl allows such constructs, by forcefully breaking the infinite
loop. The rules for this are different for lower-level loops given by
the greedy quantifiers \verb|*+{}| , and for higher-level ones like the \verb|/g|
modifier or \verb|split()| operator.

The lower-level loops are interrupted (that is, the loop is broken)
when Perl detects that a repeated expression matched a zero-length
substring. Thus

\begin{verbatim}
   1.  m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
\end{verbatim}

is made equivalent to

\begin{verbatim}
   1.  m{ (?: NON_ZERO_LENGTH )*
   2.  |
   3.  (?: ZERO_LENGTH )?
   4.  }x;
\end{verbatim}

The higher level-loops preserve an additional state between iterations:
whether the last match was zero-length. To break the loop, the following
match after a zero-length match is prohibited to have a length of
zero. This prohibition interacts with backtracking (see Backtracking), and
so the second best match is chosen if the best match is of zero length.

For example:

\begin{verbatim}
   1. $_ = 'bar';
   2. s/\w??/<$&>/g;
\end{verbatim}

results in \verb|<><b><><a><><r><>| . At each position of the string the best
match given by non-greedy \verb|??| is the zero-length match, and the second
best match is what is matched by \verb|\w| . Thus zero-length matches alternate
with one-character-long matches.

Similarly, for repeated \verb|m/()/g| the second-best match is the match at
the position one notch further in the string.

The additional state of being matched with zero-length is associated with
the matched string, and is reset by each assignment to \verb|pos()|. Zero-length
matches at the end of the previous match are ignored during \verb|split|.
\end{quote}
\end{it}

\begin{exercise}
\begin{itemize}
\item
Explique la conducta del siguiente matching:
\begin{latexonly}
\begin{verbatim}
  DB<25> $c = 0

  DB<26>  print(($c++).": <$&>\n") while 'aaaabababab' =~ /a*(ab)*/g;
0: <aaaa>
1: <>
2: <a>
3: <>
4: <a>
5: <>
6: <a>
7: <>
8: <>
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
  DB&lt;25>  <span class="dbuser">$c = 0</span>

  DB&lt;26>  <span class="dbuser"> print(($c++).": &lt;$&>\n") while 'aaaabababab' =~ /a*(ab)*/g;</span>
0: &lt;aaaa>
1: &lt;>
2: &lt;a>
3: &lt;>
4: &lt;a>
5: &lt;>
6: &lt;a>
7: &lt;>
8: &lt;>
</pre>
\end{rawhtml}
%}}}
\end{itemize}
\end{exercise}

\parrafo{Cuantificadores {\it lazy}}

\label{section:nogreedy}
Las expresiones \emph{lazy} o \emph{no greedy} hacen que el NFA se detenga en la cadena mas corta que 
casa con la expresión. Se denotan como sus análogas \emph{greedy} añadiéndole el
postfijo \verb|?|:

\begin{itemize}
\item \verb|{n,m}?|
\item \verb|{n,}?|
\item \verb|{n}?|
\item \verb|*?|
\item \verb|+?|
\item \verb|??|
\end{itemize}

Repasemos lo que dice la sección Matching Repetitions en \pd{perlretut}{Matching-repetitions}:
\begin{it}
\begin{quotation}
Sometimes greed is not good. At times, we would like quantifiers to match
a minimal piece of string, rather than a maximal piece. For this purpose,
Larry Wall created the minimal match or non-greedy quantifiers \verb|??| ,\verb|*?|, \verb|+?|, and \verb|{}?|. 
These are the usual quantifiers with a ? appended to
them. They have the following meanings:


\begin{itemize}
   \item
      \verb|a??| means: match 'a' 0 or 1 times. Try 0 first, then 1.
    \item

      \verb|a*?| means: match 'a' 0 or more times, i.e., any number of times, but as few times as possible
    \item

      \verb|a+?| means: match 'a' 1 or more times, i.e., at least once, but as few times as possible
    \item

      \verb|a{n,m}?| means: match at least n times, not more than m times, as few times as possible
    \item

      \verb|a{n,}?| means: match at least n times, but as few times as possible
    \item

      \verb|a{n}?| means: match exactly n times. Because we match exactly n times, a{n}? is equivalent to a{n} and is just there for notational consistency.
\end{itemize}

Let's look at the example above, but with minimal quantifiers:

\begin{verbatim}
   1. $x = "The programming republic of Perl";
   2. $x =~ /^(.+?)(e|r)(.*)$/; # matches,
   3. # $1 = 'Th'
   4. # $2 = 'e'
   5. # $3 = ' programming republic of Perl'
\end{verbatim}

The minimal string that will allow both the start of the string \verb|^| and
the alternation to match is \verb|Th| , with the alternation \verb#e|r# matching \verb|e|. 
The second quantifier \verb|.*| is free to gobble up the rest of the string.

\begin{verbatim}
   1. $x =~ /(m{1,2}?)(.*?)$/; # matches,
   2. # $1 = 'm'
   3. # $2 = 'ming republic of Perl'
\end{verbatim}

The first string position that this regexp can match is at the first
\verb'm' in programming . At this position, the minimal \verb|m{1,2}?| matches just
one \verb'm' . Although the second quantifier \verb|.*?| would prefer to match no
characters, it is constrained by the end-of-string anchor \verb|$| to match
the rest of the string.

\begin{verbatim}
   1. $x =~ /(.*?)(m{1,2}?)(.*)$/; # matches,
   2. # $1 = 'The progra'
   3. # $2 = 'm'
   4. # $3 = 'ming republic of Perl'
\end{verbatim}

In this regexp, you might expect the first minimal quantifier \verb|.*?| to match
the empty string, because it is not constrained by a \verb|^| anchor to match
the beginning of the word. Principle 0 applies here, however. Because it
is possible for the whole regexp to match at the start of the string, it
will match at the start of the string. Thus the first quantifier has to
match everything up to the first m. The second minimal quantifier matches
just one \verb|m| and the third quantifier matches the rest of the string.

\begin{verbatim}
   1. $x =~ /(.??)(m{1,2})(.*)$/; # matches,
   2. # $1 = 'a'
   3. # $2 = 'mm'
   4. # $3 = 'ing republic of Perl'
\end{verbatim}

Just as in the previous regexp, the first quantifier \verb|.??| can match
earliest at position \verb'a' , so it does. The second quantifier is greedy,
so it matches mm , and the third matches the rest of the string.

We can modify principle 3 above to take into account non-greedy quantifiers:

\begin{itemize}
    \item

      {\bf Principle 3:} If there are two or more elements in a regexp, the
      leftmost greedy (non-greedy) quantifier, if any, will match as much
      (little) of the string as possible while still allowing the whole
      regexp to match. The next leftmost greedy (non-greedy) quantifier,
      if any, will try to match as much (little) of the string remaining
      available to it as possible, while still allowing the whole regexp
      to match. And so on, until all the regexp elements are satisfied.
\end{itemize}
\end{quotation}
\end{it}

\begin{exercise}
Explique cuál será el resultado de el segundo comando de matching
introducido en el depurador: 
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
  DB<1> x ('1'x34) =~ m{^(11+)\1+$}
0  11111111111111111
  DB<2> x ('1'x34) =~ m{^(11+?)\1+$}
????????????????????????????????????
\end{verbatim}
\end{exercise}

\parrafo{Descripción detallada del proceso de matching}
Veamos en detalle lo que ocurre durante un matching.
Repasemos lo que dice la sección Matching Repetitions en \pd{perlretut}{Matching-repetitions}:

\begin{it}
\begin{quotation}
Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example

\begin{verbatim}
   1. $x = "the cat in the hat";
   2. $x =~ /^(.*)(at)(.*)$/; # matches,
   3. # $1 = 'the cat in the h'
   4. # $2 = 'at'
   5. # $3 = '' (0 matches)
\end{verbatim}

\begin{enumerate}
    \item

      Start with the first letter in the string 't'.
    \item

      The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.
    \item

      'a' in the regexp element 'at' doesn't match the end of the string. Backtrack one character.
    \item

      'a' in the regexp element 'at' still doesn't match the last letter of the string 't', so backtrack one more character.
    \item

      Now we can match the 'a' and the 't'.
    \item

      Move on to the third element '.*'. Since we are at the end of the string and '.*' can match 0 times, assign it the empty string.
    \item

      We are done!
\end{enumerate}
\end{quotation}
\end{it}

\parrafo{Rendimiento}

La forma en la que se escribe una regexp puede dar lugar agrandes variaciones
en el rendimiento.
Repasemos lo que dice la sección Matching Repetitions en \pd{perlretut}{Matching-repetitions}:
\begin{it}
\begin{quotation}
Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string. A typical structure that blows up in your face is of the form

\begin{verbatim}
            /(a|b+)*/;
\end{verbatim}

The problem is the nested indeterminate quantifiers. 
There are many
different ways of partitioning a string of length n between the \verb|+| 
and \verb|*|: one repetition with \verb|b+| of length $n$, 
two repetitions with the first \verb|b+|
length $k$ and the second with length $n-k$, $m$ repetitions whose bits add
up to length $n$, etc. 

In fact there are an exponential number of ways
to partition a string as a function of its length. A regexp may get
lucky and match early in the process, but if there is no match, Perl
will try every possibility before giving up. So be careful with nested 
\verb|*|'s, \verb|{n,m}|'s, and \verb|+| 's. 

The book 
\htmladdnormallink{Mastering Regular Expressions}{http://books.google.es/books?id=NYEX-Q9evKoC\&dq=Mastering+Regular+Expressions\&printsec=frontcover\&source=bn\&hl=en\#v=onepage\&q=\&f=false} 
by Jeffrey Friedl \cite{friedl} gives a wonderful discussion of this and other efficiency issues.
\end{quotation}
\end{it}

\parrafo{Eliminación de Comentarios de un Programa C}
\label{parrfo:comments}

El siguiente ejemplo elimina los comentarios de un programa \verb|C|.
\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n comments.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $progname = shift @ARGV or die "Usage:\n$0 prog.c\n";
   5    open(my $PROGRAM,"<$progname") || die "can't find $progname\n";
   6    my $program = '';
   7    {
   8      local $/ = undef;
   9      $program = <$PROGRAM>;
  10    }
  11    $program =~ s{
  12      /\*  # Match the opening delimiter
  13      .*?  # Match a minimal number of characters
  14      \*/  # Match the closing delimiter
  15    }[]gsx;
  16  
  17    print $program;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@millo:~/Lperltesting$ cat -n comments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">&quot;Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$progname</span><span class="synConstant">&quot;</span>) || <span class="synStatement">die</span> <span class="synConstant">&quot;can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = &lt;<span class="synIdentifier">$PROGRAM</span>&gt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]gsx;
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>

\end{rawhtml}
%}}}
Veamos un ejemplo de ejecución. Supongamos el fichero de entrada:
\begin{verbatim}
> cat hello.c
#include <stdio.h>
/* first
comment
*/
main() {
  printf("hello world!\n"); /* second comment */
}
\end{verbatim}

Entonces la ejecución con ese fichero de entrada produce
la salida:
\begin{verbatim}
> comments.pl hello.c
#include <stdio.h>
 
main() {
  printf("hello world!\n");
}
\end{verbatim}
Veamos la diferencia de comportamiento entre \verb|*| y \verb|*?|
en el ejemplo anterior:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ perl5_10_1 -wde 0
main::(-e:1):   0
  DB<1>  use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*\*/)}; print "\n$1\n"
Compiling REx "(/\*.*\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT <*/> (9)
   9: CLOSE1 (11)
  11: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 <; /* 3c > <*/ }>       |  7:  EXACT <*/>(9)
  43 <; /* 3c */> < }>       |  9:  CLOSE1(11)
  43 <; /* 3c */> < }>       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: "(/\*.*\*/)"

  DB<2>  use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*?\*/)}; print "\n$1\n"
Compiling REx "(/\*.*?\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT <*/> (10)
  10: CLOSE1 (12)
  12: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*?\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*?\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:MINMOD(6)
   9 <() /*> < 1c */ { />    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 <* 1c > <*/ { /* 2c>    |  8:  EXACT <*/>(10)
  15 <1c */> < { /* 2c *>    | 10:  CLOSE1(12)
  15 <1c */> < { /* 2c *>    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: "(/\*.*?\*/)"

  DB<3>
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/src/perl/perltesting$  <span class="dbuser">perl5_10_1 -wde 0</span>
main::(-e:1):   0
  DB<1>  <span class="dbuser"> use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*\*/)}; print "\n$1\n"</span>
Compiling REx "(/\*.*\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT <*/> (9)
   9: CLOSE1 (11)
  11: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 <; /* 3c > <*/ }>       |  7:  EXACT <*/>(9)
  43 <; /* 3c */> < }>       |  9:  CLOSE1(11)
  43 <; /* 3c */> < }>       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: "(/\*.*\*/)"

  DB<2>  <span class="dbuser"> use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*?\*/)}; print "\n$1\n"</span>
Compiling REx "(/\*.*?\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT <*/> (10)
  10: CLOSE1 (12)
  12: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*?\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*?\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:MINMOD(6)
   9 <() /*> < 1c */ { />    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 <* 1c > <*/ { /* 2c>    |  8:  EXACT <*/>(10)
  15 <1c */> < { /* 2c *>    | 10:  CLOSE1(12)
  15 <1c */> < { /* 2c *>    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: "(/\*.*?\*/)"

  DB<3>
</pre>
\end{rawhtml}
%}}}

Véase también la documentación en \pd{perlretut}{Matching-repetitions} y \pd{perlre}{Quantifiers}.

\parrafo{Negaciones y operadores {\it lazy}}
A menudo las expresiones
\verb|X[^X]*X|
y \verb|X.*?X|, donde \verb|X| es un carácter arbitrario se usan de forma casi equivalente.

\begin{itemize}
\item
La primera significa:

\begin{it}
Una cadena que no contiene \verb|X| en su interior y que está delimitada por \verb|X|s
\end{it}
\item
La segunda significa:

\begin{it}
Una cadena que comienza en \verb|X| y termina en la \verb|X| mas próxima a la \verb|X| de comienzo
\end{it}
\end{itemize}

Esta equivalencia se rompe si no se cumplen las hipótesis establecidas.

En el siguiente ejemplo se intentan detectar 
las cadenas entre comillas dobles que terminan en el signo de exclamación:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n negynogreedy.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $b = 'Ella dijo "Ana" y yo contesté: "Jamás!". Eso fué todo.';
     5  my $a;
     6  ($a = $b) =~ s/".*?!"/-$&-/;
     7  print "$a\n";
     8
     9  $b =~ s/"[^"]*!"/-$&-/;
    10  print "$b\n";
\end{verbatim}

Al ejecutar el programa obtenemos:
\begin{verbatim}
> negynogreedy.pl
Ella dijo -"Ana" y yo contesté: "Jamás!"-. Eso fué todo.
Ella dijo "Ana" y yo contesté: -"Jamás!"-. Eso fué todo.
\end{verbatim}

\parrafo{Copia y sustitución simultáneas}
\label{section:copia}
El operador de \emph{binding} \verb|=~| nos permite ``asociar'' la variable 
con la operación de casamiento o sustitución. Si se trata de una sustitución
y se quiere conservar la cadena, es necesario hacer una copia:
\begin{verbatim}
$d = $s;
$d =~ s/esto/por lo otro/;
\end{verbatim}
en vez de eso, puedes abreviar un poco usando la siguiente ``perla'':
\begin{verbatim}
($d = $s) =~ s/esto/por lo otro/;
\end{verbatim}
Obsérvese la asociación por la izquierda del operador de asignación.

\parrafo{Referencias a Paréntesis Previos}

Las referencias relativas permiten escribir expresiones
regulares mas reciclables.
Véase la documentación
en 
\pd{perlretut}{Relative-backreferences}:

\begin{it}
\begin{quotation}
Counting the opening parentheses to get the correct number for a
backreference is errorprone as soon as there is more than one capturing
group. A more convenient technique became available with Perl 5.10:
relative backreferences. To refer to the immediately preceding capture
group one now may write \verb|\g{-1}| , the next but last is available 
via \verb|\g{-2}|, and so on.

Another good reason in addition to readability and maintainability for
using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:

\begin{verbatim}
   1. $a99a = '([a-z])(\d)\2\1'; # matches a11a, g22g, x33x, etc.
\end{verbatim}

Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:

\begin{verbatim}
   1. $line = "code=e99e";
   2. if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   3.   print "$1 is valid\n";
   4. } else {
   5.   print "bad line: '$line'\n";
   6. }
\end{verbatim}

But this doesn't match -- at least not the way one might expect. Only
after inserting the interpolated \verb|$a99a| and looking at the resulting full
text of the regexp is it obvious that the backreferences have backfired --
the subexpression \verb|(\w+)| has snatched number 1 and demoted the groups in
\verb|$a99a| by one rank. This can be avoided by using relative backreferences:

\begin{verbatim}
   1. $a99a = '([a-z])(\d)\g{-1}\g{-2}'; # safe for being interpolated
\end{verbatim}
\end{quotation}
\end{it}

El siguiente programa ilustra lo dicho:
\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n backreference.pl
   1    use strict;
   2    use re 'debug';
   3  
   4    my $a99a = '([a-z])(\d)\2\1';
   5    my $line = "code=e99e";
   6    if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   7      print "$1 is valid\n";
   8    } else {
   9      print "bad line: '$line'\n";
  10    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@millo:~/Lperltesting$ cat -n backreference.pl
<span class="synLinenum">    1</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>re <span class="synConstant">'debug'</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$a99a</span> = <span class="synConstant">'([a-z])(\d)\2\1'</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">&quot;code=e99e&quot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$line</span> =~<span class="synStatement"> /</span><span class="synConstant">^</span><span class="synSpecial">(\w+)</span><span class="synConstant">=</span><span class="synIdentifier">$a99a</span><span class="synConstant">$</span><span class="synStatement">/</span>){ <span class="synComment"># unexpected behavior!</span>
<span class="synLinenum">    7</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$1</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    8</span>   } <span class="synStatement">else</span> {
<span class="synLinenum">    9</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;bad line: '</span><span class="synIdentifier">$line</span><span class="synConstant">'</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   10</span>   }
</pre>

\end{rawhtml}
%}}}
Sigue la ejecución:
\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -wd backreference.pl
main::(backreference.pl:4):     my $a99a = '([a-z])(\d)\2\1';
  DB<1> c 6
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB<2> x ($line =~ /^(\w+)=$a99a$/)
  empty array
  DB<4> $a99a = '([a-z])(\d)\g{-1}\g{-2}'
  DB<5> x ($line =~ /^(\w+)=$a99a$/)
0  'code'
1  'e'
2  9
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
casiano@millo:~/Lperltesting$  <span class="dbuser">perl5.10.1 -wd backreference.pl</span>
main::(backreference.pl:4):     my $a99a = '([a-z])(\d)\2\1';
  DB<1>  <span class="dbuser">c 6</span>
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB<2>  <span class="dbuser">x ($line =~ /^(\w+)=$a99a$/)</span>
  empty array
  DB<4>  <span class="dbuser">$a99a = '([a-z])(\d)\g{-1}\g{-2}'</span>
  DB<5>  <span class="dbuser">x ($line =~ /^(\w+)=$a99a$/)</span>
0  'code'
1  'e'
2  9
</pre>
\end{rawhtml}
%}}}

\parrafo{Usando Referencias con Nombre (Perl 5.10)}

El siguiente texto esta tomado de 
\pd{perlretut}{Named-backreferences}:

\begin{it}
\begin{quotation}
Perl 5.10 also introduced named capture buffers and named
backreferences. To attach a name to a capturing group, you write either
\verb#(?<name>...)# or \verb#(?'name'...)#. The backreference may then be written
as \verb#\g{name}# . 

It is permissible to attach the same name to more than
one group, but then only the leftmost one of the eponymous set can be
referenced. Outside of the pattern a named capture buffer is accessible
through the \verb|%+| hash.

Assuming that we have to match calendar dates which may be given in one
of the three formats \verb|yyyy-mm-dd|, \verb|mm/dd/yyyy| or \verb|dd.mm.yyyy|, 
we can write
three suitable patterns where we use \verb|'d'|, \verb|'m'| and \verb|'y'| respectively as the
names of the buffers capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:

\begin{verbatim}
   1.  $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
   2.  $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
   3.  $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
   4.  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
   5.    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
   6.      print "day=$+{d} month=$+{m} year=$+{y}\n";
   7.    }
   8.  }
\end{verbatim}

If any of the alternatives matches, the hash \verb|%+| 
is bound to contain the three key-value pairs.
\end{quotation}
\end{it}
En efecto, al ejecutar el programa:
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n namedbackreferences.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
     5  my $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
     6  my $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
     7
     8  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
     9    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
    10      print "day=$+{d} month=$+{m} year=$+{y}\n";
    11    }
    12  }
\end{verbatim}
Obtenemos la salida:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -w namedbackreferences.pl
day=21 month=10 year=2006
day=15 month=01 year=2007
day=31 month=10 year=2005
\end{verbatim}

Como se comentó:

\begin{it}
\begin{quotation}
... It is permissible to attach the same name to more than
one group, but then only the leftmost one of the eponymous set can be
referenced. 
\end{quotation}
\end{it}

Veamos un ejemplo:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
DB<1>  # ... only the leftmost one of the eponymous set can be referenced
DB<2> $r = qr{(?<a>[a-c])(?<a>[a-f])}
DB<3> print $+{a} if 'ad' =~ $r
a
DB<4> print $+{a} if 'cf' =~ $r
c
DB<5> print $+{a} if 'ak' =~ $r

\end{verbatim}

Reescribamos el ejemplo de conversión de temperaturas usando
paréntesis con nombre:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n c2f_5_10v2.pl
 1  #!/usr/local/bin/perl5_10_1 -w
 2  use strict;
 3
 4  print "Enter a temperature (i.e. 32F, 100C):\n";
 5  my $input = <STDIN>;
 6  chomp($input);
 7
 8  $input =~ m/^
 9              (?<farenheit>[-+]?[0-9]+(?:\.[0-9]*)?)\s*[fF]
10              |
11              (?<celsius>[-+]?[0-9]+(?:\.[0-9]*)?)\s*[cC]
12           $/x;
13
14  my ($celsius, $farenheit);
15  if (exists $+{celsius}) {
16    $celsius = $+{celsius};
17    $farenheit = ($celsius * 9/5)+32;
18  }
19  elsif (exists $+{farenheit}) {
20    $farenheit = $+{farenheit};
21    $celsius = ($farenheit -32)*5/9;
22  }
23  else {
24    die "Expecting a temperature, so don't understand \"$input\".\n";
25  }
26
27  printf "%.2f C = %.2f F\n", $celsius, $farenheit;
\end{verbatim}

La función \perldocf{exists} retorna verdadero si existe la clave en el hash
y falso en otro caso.  

\parrafo{Grupos con Nombre y Factorización}

El uso de nombres hace mas robustas y mas factorizables
las expresiones regulares.
Consideremos la siguiente regexp que usa notación posicional:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> x "abbacddc" =~ /(.)(.)\2\1/
0  'a'
1  'b'
\end{verbatim}
Supongamos que queremos reutilizar la regexp con repetición
\begin{verbatim}
  DB<2> x "abbacddc" =~ /((.)(.)\2\1){2}/
  empty array
\end{verbatim}
¿Que ha ocurrido? La introducción del nuevo paréntesis 
nos obliga a renombrar las referencias a las posiciones:
\begin{verbatim}
  DB<3> x "abbacddc" =~ /((.)(.)\3\2){2}/
0  'cddc'
1  'c'
2  'd'
  DB<4> "abbacddc" =~ /((.)(.)\3\2){2}/; print "$&\n"
abbacddc
\end{verbatim}
Esto no ocurre si utilizamos nombres. 
El operador \verb|\k<a>| sirve para hacer referencia
al valor que ha casado con el paréntesis con nombre \verb|a|:
\begin{verbatim}
  DB<5> x "abbacddc" =~ /((?<a>.)(?<b>.)\k<b>\k<a>){2}/
0  'cddc'
1  'c'
2  'd'
\end{verbatim}
El uso de grupos con nombre y 
\verb|\k|\footnote{
Una diferencia entre {\tt $\backslash k$} y {\tt $\backslash g$} es que el primero 
sólo admite un nombre como argumento  mientras que {\tt $\backslash g$}
admite enteros}
en lugar de referencias numéricas absolutas
hace que la regexp sea mas reutilizable.

\parrafo{LLamadas a expresiones regulares via paréntesis con memoria}

Es posible también llamar a la expresión regular
asociada con un paréntesis.

Este parrafo tomado de
\pd{perlre}{Extended-Patterns} 
explica el modo de uso:

\begin{it}
\verb|(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)|
\begin{quotation}

\verb|PARNO| is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture buffer to recurse to. 

....

Capture buffers contained by the pattern will have the value as determined by the outermost recursion.
....

If \verb|PARNO| {\bf is preceded by a plus or minus sign then it is assumed to
be relative, with negative numbers indicating preceding capture buffers
and positive ones following}. Thus \verb|(?-1)| refers to the most recently
declared buffer, and \verb|(?+1)| indicates the next buffer to be declared. 

{\bf Note
that the counting for relative recursion differs from that of relative
backreferences, in that with recursion unclosed buffers are included.}
\end{quotation}
\end{it}

Veamos un ejemplo:

\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> x "AABB" =~ /(A)(?-1)(?+1)(B)/
0  'A'
1  'B'
  # Parenthesis:       1   2   2                  1
  DB<2> x 'ababa' =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  'ababa'
1  'a'
  DB<3> x 'bbabababb' =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  'bbabababb'
1  'b'
\end{verbatim}

Véase también:
\begin{itemize}
\item
\htmladdnormallink
{Perl Training Australia: Regular expressions in Perl 5.10}
{http://perltraining.com.au/tips/2008-02-08.html}
\item
\htmladdnormallink
{Perl 5.10 Advanced Regular Expressions by Yves Orton}
{http://www.regex-engineer.org/slides/perl510_regex.html}
\item
\htmladdnormallink
{Gabor: Regular Expressions in Perl 5.10}
{http://szabgab.com/blog/2007/12/1198488988.html}
\end{itemize}

\parrafo{Reutilizando Expresiones Regulares}

La siguiente reescritura de nuestro ejemplo básico
utiliza el módulo \cpan{Regexp::Common} para factorizar
la expresión regular:

\begin{verbatim}
casiano@millo:~/src/perl/perltesting$ cat -n c2f_5_10v3.pl
 1  #!/soft/perl5lib/bin/perl5.10.1 -w
 2  use strict;
 3  use Regexp::Common;
 4
 5  print "Enter a temperature (i.e. 32F, 100C):\n";
 6  my $input = <STDIN>;
 7  chomp($input);
 8
 9  $input =~ m/^
10              (?<farenheit>$RE{num}{real})\s*[fF]
11              |
12              (?<celsius>$RE{num}{real})\s*[cC]
13           $/x;
14
15  my ($celsius, $farenheit);
16  if ('celsius' ~~ %+) {
17    $celsius = $+{celsius};
18    $farenheit = ($celsius * 9/5)+32;
19  }
20  elsif ('farenheit' ~~ %+) {
21    $farenheit = $+{farenheit};
22    $celsius = ($farenheit -32)*5/9;
23  }
24  else {
25    die "Expecting a temperature, so don't understand \"$input\".\n";
26  }
27
28  printf "%.2f C = %.2f F\n", $celsius, $farenheit;
\end{verbatim}

Véase:
\begin{itemize}
\item La documentación del módulo \cpan{Regexp::Common} por Abigail
\item Smart Matching: \htmladdnormallink
{Perl Training Australia: Smart Match}
{http://perltraining.com.au/tips/2008-04-18.html}
\item
Rafael García Suárez:
\pd{perlsyn}{Smart-matching-in-detail}
\item
\htmladdnormallink{Enrique Nell (Barcelona Perl Mongers): Novedades en Perl 5.10}{www.opensourceworldconference.com/papers/.../Nell\_370.pdf}
%\item
%\htmladdnormallink
%{Rafael García Suárez: Smart matching in detail}
%{http://search.cpan.org/~rgarcia/perl-5.10.0/pod/perlsyn.pod#Smart_matching_in_detail}
\end{itemize}


\parrafo{El Módulo Regexp::Common}

El módulo \cpan{Regexp::Common} provee un extenso número 
de expresiones regulares que son accesibles vía el hash \verb|%RE|.
sigue un ejemplo de uso:
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n regexpcommonsynopsis.pl
     1  use strict;
     2  use Perl6::Say;
     3  use Regexp::Common;
     4
     5  while (<>) {
     6      say q{a number}              if /$RE{num}{real}/;
     7
     8      say q{a ['"`] quoted string} if /$RE{quoted}/;
     9
    10      say q{a /.../ sequence}      if m{$RE{delimited}{'-delim'=>'/'}};
    11
    12      say q{balanced parentheses}  if /$RE{balanced}{'-parens'=>'()'}/;
    13
    14      die q{a #*@%-ing word}."\n"  if /$RE{profanity}/;
    15
    16  }
    17
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl regexpcommonsynopsis.pl
43
a number
"2+2 es" 4
a number
a ['"`] quoted string
x/y/z
a /.../ sequence
(2*(4+5/(3-2)))
a number
balanced parentheses
fuck you!
a #*@%-ing word
\end{verbatim}

El siguiente fragmento de la documentación 
de \cpan{Regexp::Common}
explica el modo simplificado de uso:

\begin{it}
\begin{quote}
To access a particular pattern, \verb|%RE| is treated as a hierarchical hash of
hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you specify:

\begin{verbatim}
        $RE{num}{real}
\end{verbatim}

and to access the pattern that matches integers:

\begin{verbatim}
        $RE{num}{int}
\end{verbatim}

Deeper layers of the hash are used to specify flags: 
arguments that modify
the resulting pattern in some way. 

\begin{itemize}
\item
The keys used to access these layers
are prefixed with a minus sign and may have a value; 
\item
if a value is given,
it's done by using a multidimensional key. 
\end{itemize}
For example, to access the
pattern that matches base-2 real numbers with embedded commas separating
groups of three digits (e.g. \verb|10,101,110.110101101|):

\begin{verbatim}
        $RE{num}{real}{-base => 2}{-sep => ','}{-group => 3}
\end{verbatim}

Through the magic of Perl, these flag layers may be specified in any
order (and even interspersed through the identifier keys!) so you could
get the same pattern with:

\begin{verbatim}
        $RE{num}{real}{-sep => ','}{-group => 3}{-base => 2}
\end{verbatim}

or:

\begin{verbatim}
        $RE{num}{-base => 2}{real}{-group => 3}{-sep => ','}
\end{verbatim}

or even:

\begin{verbatim}
        $RE{-base => 2}{-group => 3}{-sep => ','}{num}{real}
\end{verbatim}

etc.

Note, however, that the relative order of amongst the identifier keys is significant. That is:

\begin{verbatim}
        $RE{list}{set}
\end{verbatim}

would not be the same as:

\begin{verbatim}
        $RE{set}{list}
\end{verbatim}
\end{quote}
\end{it}

Veamos un ejemplo con el depurador:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
  DB<1> x 'numero: 10,101,110.110101101 101.1e-1 234' =~ m{($RE{num}{real}{-base => 2}{-sep => ','}{-group => 3})}g
0  '10,101,110.110101101'
1  '101.1e-1'
\end{verbatim}

La expresión regular para un número real es 
relativamente compleja:

\begin{verbatim}
casiano@millo:~/src/perl/perltesting$ perl5.10.1 -wd c2f_5_10v3.pl
main::(c2f_5_10v3.pl:5):     print "Enter a temperature (i.e. 32F, 100C):\n";
  DB<1> p $RE{num}{real}
(?:(?i)(?:[+-]?)(?:(?=[0123456789]|[.])(?:[0123456789]*)(?:(?:[.])(?:[0123456789]{0,}))?)(?:(?:[E])(?:(?:[+-]?)(?:[0123456789]+))|))
\end{verbatim}

Si se usa la opción \verb|-keep| el patrón proveído usa paréntesis con memoria:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
DB<2> x 'one, two, three, four, five' =~ /$RE{list}{-pat => '\w+'}/
0  1
DB<3> x 'one, two, three, four, five' =~ /$RE{list}{-pat => '\w+'}{-keep}/
0  'one, two, three, four, five'
1  ', '
\end{verbatim}
%Sigue un ejemplo de ejecución:
%
%\begin{verbatim}
%casiano@millo:~/Lperltesting$ env | grep -i perl
%MANPATH=:/soft/perl5lib/man/
%PERL5LIB=/soft/perl5lib/share/perl/5.8.8/:/soft/perl5lib/lib/perl/5.8.8:/soft/perl5lib/lib/perl/5.8:/soft/perl5lib/share/perl/5.8/
%PATH=.:/usr/lib/oracle/11.1.0.1/client/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:
%      /soft/perl5lib/bin:/soft/perl5lib/src/parrot-0.8.0/:/home/casiano/bin
%PWD=/home/casiano/Lperltesting
%casiano@millo:~/Lperltesting$ unset PERL5LIB
%casiano@millo:~/Lperltesting$ env | grep -i perl
%MANPATH=:/soft/perl5lib/man/
%PATH=.:/usr/lib/oracle/11.1.0.1/client/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:...:/soft/perl5lib/src/parrot-0.8.0/
%PWD=/home/casiano/Lperltesting
%casiano@millo:~/Lperltesting$ ./c2f_5_10v3.pl
%Can't locate Regexp/Common.pm in @INC (@INC contains: /soft/perl5lib/perl5_10_1/lib/5.10.1/i686-linux-thread-multi 
%                                                      /soft/perl5lib/perl5_10_1/lib/5.10.1 
%                                                      /soft/perl5lib/perl5_10_1/lib/site_perl/5.10.1/i686-linux-thread-multi 
%                                                      /soft/perl5lib/perl5_10_1/lib/site_perl/5.10.1 .) 
%at ./c2f_5_10v3.pl line 3.
%BEGIN failed--compilation aborted at ./c2f_5_10v3.pl line 3.
%\end{verbatim}
%
%Reutilicemos la versión de la librería instalada para la 5.8.8:
%
%\begin{verbatim}
%casiano@millo:~/Lperltesting$ export PERL5LIB=/soft/perl5lib/share/perl/5.8.8/:/soft/perl5lib/lib/perl/5.8.8:...
%casiano@millo:~/Lperltesting$ perldoc -l Regexp::Common
%/soft/perl5lib/share/perl/5.8.8/Regexp/Common.pm
%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl
%Enter a temperature (i.e. 32F, 100C):
%-32.0e-1f
%-19.56 C = -3.20 F
%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl
%Enter a temperature (i.e. 32F, 100C):
%-0.0e-0c
%-0.00 C = 32.00 F
%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl
%Enter a temperature (i.e. 32F, 100C):
%45
%Expecting a temperature, so don't understand "45".
%\end{verbatim}
%En general, no es buena idea mezclar librerías de diferentes instalaciones.

\parrafo{Smart Matching}

Perl 5.10 introduce el operador de smart matching.
El siguiente texto es tomado casi verbatim del site de la compañía 
\htmladdnormallink{Perl Training Australia}{http://perltraining.com.au/tips/2008-04-18.html}\footnote{
This Perl tip and associated text is copyright Perl Training Australia}:
\begin{it}
\begin{quotation}
Perl 5.10 introduces a new-operator, called smart-match, written \verb|~~|. As
the name suggests, smart-match tries to compare its arguments in an
intelligent fashion. Using smart-match effectively allows many complex
operations to be reduces to very simple statements.

Unlike many of the other features introduced in Perl 5.10, there's no
need to use the feature pragma to enable smart-match, as long as you're
using 5.10 it's available.

The smart-match operator is always commutative. That means that 
\verb|$x ~~ $y| works the same way as 
\verb|$y ~~ $x|. You'll never have to remember which
order to place to your operands with smart-match.
Smart-match in action.

As a simple introduction, we can use smart-match to do a simple string comparison between simple scalars. For example:

\begin{verbatim}
    use feature qw(say);

    my $x = "foo";
    my $y = "bar";
    my $z = "foo";

    say '$x and $y are identical strings' if $x ~~ $y;
    say '$x and $z are identical strings' if $x ~~ $z;    # Printed
\end{verbatim}

If one of our arguments is a number, then a numeric comparison is performed:

\begin{verbatim}
    my $num   = 100;
    my $input = <STDIN>;

    say 'You entered 100' if $num ~~ $input;
\end{verbatim}

This will print our message if our user enters 100, 100.00, +100, 1e2, or
any other string that looks like the number 100. 

We can also smart-match
against a regexp:

\begin{verbatim}
    my $input  = <STDIN>;

    say 'You said the secret word!' if $input ~~ /xyzzy/;
\end{verbatim}

Smart-matching with a regexp also works with saved regexps created with qr{}.

So we can use smart-match to act like eq, \verb|==| and 
\verb|=~|, so what? Well, it does much more than that. 

We can use smart-match to search a list:

\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB<2> print "You're a friend" if 'Pippin' ~~ @friends
You're a friend
  DB<3> print "You're a friend" if 'Mordok' ~~ @friends

\end{verbatim}

It's important to note that searching an array with smart-match is
extremely fast. It's faster than using grep, it's faster than using
\verb|first| from \cpan{Scalar::Util}, and it's faster than walking through the loop
with \verb|foreach|, even if you do know all the clever optimisations.

Esta es la forma típica de buscar un elemento en un array en 
versiones anteriores a la 5.10:
\begin{verbatim}
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB<1> use List::Util qw{first}
  DB<2> @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB<3> x first { $_ eq 'Pippin'} @friends
0  'Pippin'
  DB<4> x first { $_ eq 'Mordok'} @friends
0  undef
\end{verbatim}

We can also use smart-match to compare arrays:

\begin{verbatim}
  DB<4> @foo = qw(x y z xyzzy ninja)
  DB<5> @bar = qw(x y z xyzzy ninja)
  DB<7> print "Identical arrays" if @foo ~~ @bar
Identical arrays
  DB<8> @bar = qw(x y z xyzzy nOnjA)
  DB<9> print "Identical arrays" if @foo ~~ @bar
  DB<10>     
\end{verbatim}

And even search inside an array using a string:

\begin{verbatim}
 DB<11> x @foo = qw(x y z xyzzy ninja)
0  'x'
1  'y'
2  'z'
3  'xyzzy'
4  'ninja'
  DB<12> print "Array contains a ninja " if @foo ~~ 'ninja'
\end{verbatim}

or using a regexp:

\begin{verbatim}
  DB<13> print "Array contains magic pattern" if @foo ~~ /xyz/
Array contains magic pattern
  DB<14> print "Array contains magic pattern" if @foo ~~ /\d+/

\end{verbatim}

Smart-match works with array references, too\footnote{En este caso la conmutatividad no funciona}:

\begin{verbatim}
  DB<16> $array_ref = [ 1..10 ]
  DB<17> print "Array contains 10" if 10 ~~ $array_ref
Array contains 10
  DB<18> print "Array contains 10" if $array_ref ~~ 10
  DB<19>     
\end{verbatim}

En el caso de un número y un array devuelve cierto si el escalar aparece 
en un array anidado:

\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -E 'say "ok" if 42 ~~  [23, 17, [40..50], 70];'
ok
casiano@millo:~/Lperltesting$ perl5.10.1 -E 'say "ok" if 42 ~~  [23, 17, [50..60], 70];'
casiano@millo:~/Lperltesting$                                                           
\end{verbatim}

Of course, we can use smart-match with more than just arrays and scalars,
it works with searching for the key in a hash, too!

\begin{verbatim}
  DB<19> %colour = ( sky   => 'blue', grass => 'green', apple => 'red',)
  DB<20> print "I know the colour" if 'grass' ~~ %colour
I know the colour
  DB<21> print "I know the colour" if 'cloud' ~~ %colour
  DB<22>
  DB<23> print "A key starts with 'gr'" if %colour ~~ /^gr/
A key starts with 'gr'
  DB<24> print "A key starts with 'clou'" if %colour ~~ /^clou/
  DB<25>
\end{verbatim}

You can even use it to see if the two hashes have identical keys:

\begin{verbatim}
  DB<26> print 'Hashes have identical keys' if %taste ~~ %colour;
Hashes have identical keys
\end{verbatim}
\end{quotation}
\end{it}

La conducta del operador de smart matching viene dada por la siguiente
tabla tomada de \pd{perlsyn}{Smart-matching-in-detail}:

\begin{it}
\begin{quotation}
The behaviour of a smart match depends on what type of thing its arguments
are. The behaviour is determined by the following table: 
the first
row that applies determines the match behaviour (which is thus mostly
determined by the type of the right operand). 
Note that the smart match
implicitly dereferences any non-blessed hash or array ref, so the "Hash"
and "Array" entries apply in those cases. (For blessed references, the
"Object" entries apply.)

Note that the "Matching Code" column is not always an exact rendition. For
example, the smart match operator short-circuits whenever possible,
but grep does not.

\begin{center}
\begin{verbatim}
 $a      $b        Type of Match Implied    Matching Code
 ======  =====     =====================    =============
 Any     undef     undefined                !defined $a

 Any     Object    invokes ~~ overloading on $object, or dies

 Hash    CodeRef   sub truth for each key[1] !grep { !$b->($_) } keys %$a
 Array   CodeRef   sub truth for each elt[1] !grep { !$b->($_) } @$a
 Any     CodeRef   scalar sub truth          $b->($a)

 Hash    Hash      hash keys identical (every key is found in both hashes)
 Array   Hash      hash slice existence     grep { exists $b->{$_} } @$a
 Regex   Hash      hash key grep            grep /$a/, keys %$b
 undef   Hash      always false (undef can't be a key)
 Any     Hash      hash entry existence     exists $b->{$a}

 Hash    Array     hash slice existence     grep { exists $a->{$_} } @$b
 Array   Array     arrays are comparable[2]
 Regex   Array     array grep               grep /$a/, @$b
 undef   Array     array contains undef     grep !defined, @$b
 Any     Array     match against an array element[3]
                                            grep $a ~~ $_, @$b

 Hash    Regex     hash key grep            grep /$b/, keys %$a
 Array   Regex     array grep               grep /$b/, @$a
 Any     Regex     pattern match            $a =~ /$b/

 Object  Any       invokes ~~ overloading on $object, or falls back:
 Any     Num       numeric equality         $a == $b
 Num     numish[4] numeric equality         $a == $b
 undef   Any       undefined                !defined($b)
 Any     Any       string equality          $a eq $b
\end{verbatim}
\end{center}

\end{quotation}
\end{it}

\parrafo{Ejercicios}

\begin{exercise}
\begin{itemize}
\item
Indique la salida del siguiente programa:
\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat twonumbers.pl
  2  $_ = "I have 2 numbers: 53147";
  3  @pats = qw{
  4    (.*)(\d*)
  5    (.*)(\d+)
  6    (.*?)(\d*)
  7    (.*?)(\d+)
  8    (.*)(\d+)$
  9    (.*?)(\d+)$
 10    (.*)\b(\d+)$
 11    (.*\D)(\d+)$
 12  };
 13  
 14  print "$_\n";
 15  for $pat (@pats) {
 16    printf "%-12s ", $pat;
 17    <>;
 18    if ( /$pat/ ) {
 19      print "<$1> <$2>\n";
 20    } else {
 21      print "FAIL\n";
 22    }
 23  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat twonumbers</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synIdentifier">$_</span><span class="synConstant"> = &quot;I have 2 numbers: 53147&quot;;</span>
<span class="synLinenum">    3</span> <span class="synIdentifier">@pats</span><span class="synConstant"> = qw{</span>
<span class="synLinenum">    4</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d*)</span>
<span class="synLinenum">    5</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d+)</span>
<span class="synLinenum">    6</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d*)</span>
<span class="synLinenum">    7</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d+)</span>
<span class="synLinenum">    8</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">    9</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   10</span> <span class="synConstant">  </span><span class="synSpecial">(.*)\b(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   11</span> <span class="synConstant">  </span><span class="synSpecial">(.*\D)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   12</span> <span class="synConstant">};</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">print &quot;</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">&quot;;</span>
<span class="synLinenum">   15</span> <span class="synConstant">for </span><span class="synIdentifier">$pat</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@pats</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synLinenum">   16</span> <span class="synConstant">  printf &quot;%-12s &quot;, </span><span class="synIdentifier">$pat</span><span class="synConstant">;</span>
<span class="synLinenum">   17</span> <span class="synConstant">  &lt;&gt;;</span>
<span class="synLinenum">   18</span> <span class="synConstant">  if </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synStatement">/</span><span class="synIdentifier">$pat</span>/ ) {
<span class="synLinenum">   19</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$1</span><span class="synConstant">&gt; &lt;</span><span class="synIdentifier">$2</span><span class="synConstant">&gt;</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   20</span>   } <span class="synStatement">else</span> {
<span class="synLinenum">   21</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;FAIL</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   22</span>   }
<span class="synLinenum">   23</span> }
</pre>

\end{rawhtml}
%}}}
\end{itemize}

\end{exercise}


\subsection{Depuración de Expresiones Regulares}

Para obtener información sobre la forma en que es compilada una expresión regular
y como se produce el proceso de matching podemos usar la opción
\verb|'debug'| del módulo \verb|re|. La versión de Perl 5.10 da una información 
algo mas legible que la de las versiones anteriores:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5_10_1 -wde 0

Loading DB routines from perl5db.pl version 1.32
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(-e:1):   0
  DB<1> use re 'debug'; 'astr' =~ m{[sf].r}
Compiling REx "[sf].r"
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT <r> (15)
  15: END (0)
anchored "r" at 2 (checking anchored) stclass ANYOF[fs][] minlen 3
Guessing start of match in sv for REx "[sf].r" against "astr"
Found anchored substr "r" at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx "[sf].r" against "str"
   1 <a> <str>               |  1:ANYOF[fs][](12)
   2 <as> <tr>               | 12:REG_ANY(13)
   3 <ast> <r>               | 13:EXACT <r>(15)
   4 <astr> <>               | 15:END(0)
Match successful!
Freeing REx: "[sf].r"
\end{verbatim}

Si se usa la opción \verb|debug| de \verb|re| con 
objetos expresión regular, se obtendrá información durante el proceso de 
matching:
\begin{verbatim}
 DB<3> use re 'debug'; $re = qr{[sf].r}
Compiling REx "[sf].r"
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT <r> (15)
  15: END (0)
anchored "r" at 2 (checking anchored) stclass ANYOF[fs][] minlen 3

  DB<4> 'astr' =~ $re
Guessing start of match in sv for REx "[sf].r" against "astr"
Found anchored substr "r" at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx "[sf].r" against "str"
   1 <a> <str>               |  1:ANYOF[fs][](12)
   2 <as> <tr>               | 12:REG_ANY(13)
   3 <ast> <r>               | 13:EXACT <r>(15)
   4 <astr> <>               | 15:END(0)
Match successful!
\end{verbatim}

\subsection{Tablas de Escapes, Metacarácteres, Cuantificadores, Clases}
\label{section:abreviadas}
Sigue una sección de tablas con 
notaciones tomada de \perldoc{perlre}:

%\begin{tabular}{l|l}
%C\'{o}digo    & Significado \\
%\hline
%\verb|\d| & \verb|[0-9]|\\
%\verb|\D| & \verb|[^0-9]|\\
%\verb|\w| & \verb|[a-zA-Z0-9_]|\\
%\verb|\W| & \verb|[^a-zA-Z0-9_]|\\
%\verb|\s| & \verb|[ \t\n\r\f]|\\
%\verb|\S| & \verb|[^ \t\n\r\f]|\\
%\end{tabular}

\parrafo{Metacharacters}

The following metacharacters have their standard egrep-ish meanings:

\begin{verbatim}
   1. \ Quote the next metacharacter
   2. ^ Match the beginning of the line
   3. . Match any character (except newline)
   4. $ Match the end of the line (or before newline at the end)
   5. | Alternation
   6. () Grouping
   7. [] Character class
\end{verbatim}


\parrafo{Standard greedy quantifiers}

The following standard greedy quantifiers are recognized:

\begin{verbatim}
   1. * Match 0 or more times
   2. + Match 1 or more times
   3. ? Match 1 or 0 times
   4. {n} Match exactly n times
   5. {n,} Match at least n times
   6. {n,m} Match at least n but not more than m times
\end{verbatim}

\parrafo{Non greedy quantifiers}

The following non greedy quantifiers are recognized:

\begin{verbatim}
   1. *? Match 0 or more times, not greedily
   2. +? Match 1 or more times, not greedily
   3. ?? Match 0 or 1 time, not greedily
   4. {n}? Match exactly n times, not greedily
   5. {n,}? Match at least n times, not greedily
   6. {n,m}? Match at least n but not more than m times, not greedily
\end{verbatim}


\parrafo{Possesive quantifiers}

The following possesive quantifiers are recognized:

\begin{verbatim}
   1. *+ Match 0 or more times and give nothing back
   2. ++ Match 1 or more times and give nothing back
   3. ?+ Match 0 or 1 time and give nothing back
   4. {n}+ Match exactly n times and give nothing back (redundant)
   5. {n,}+ Match at least n times and give nothing back
   6. {n,m}+ Match at least n but not more than m times and give nothing back
\end{verbatim}

\parrafo{Escape sequences}

\begin{verbatim}
   1. \t tab (HT, TAB)
   2. \n newline (LF, NL)
   3. \r return (CR)
   4. \f form feed (FF)
   5. \a alarm (bell) (BEL)
   6. \e escape (think troff) (ESC)
   7. \033 octal char (example: ESC)
   8. \x1B hex char (example: ESC)
   9. \x{263a} long hex char (example: Unicode SMILEY)
  10. \cK control char (example: VT)
  11. \N{name} named Unicode character
  12. \l lowercase next char (think vi)
  13. \u uppercase next char (think vi)
  14. \L lowercase till \E (think vi)
  15. \U uppercase till \E (think vi)
  16. \E end case modification (think vi)
  17. \Q quote (disable) pattern metacharacters till \E
\end{verbatim}

\begin{exercise}
Explique la salida:
\begin{verbatim}
casiano@tonga:~$ perl -wde 0
main::(-e:1):   0
  DB<1> $x = '([a-z]+)'
  DB<2> x 'hola' =~ /$x/
0  'hola'
  DB<3> x 'hola' =~ /\Q$x/
  empty array
  DB<4> x '([a-z]+)' =~ /\Q$x/
0  1
\end{verbatim}
\end{exercise}

\parrafo{Character Classes and other Special Escapes}

\begin{verbatim}
   1. \w Match a "word" character (alphanumeric plus "_")
   2. \W Match a non-"word" character
   3. \s Match a whitespace character
   4. \S Match a non-whitespace character
   5. \d Match a digit character
   6. \D Match a non-digit character
   7. \pP Match P, named property. Use \p{Prop} for longer names.
   8. \PP Match non-P
   9. \X Match eXtended Unicode "combining character sequence",
  10.    equivalent to (?>\PM\pM*)
  11. \C Match a single C char (octet) even under Unicode.
  12.    NOTE: breaks up characters into their UTF-8 bytes,
  13.    so you may end up with malformed pieces of UTF-8.
  14.    Unsupported in lookbehind.
  15. \1 Backreference to a specific group.
  16. '1' may actually be any positive integer.
  17. \g1 Backreference to a specific or previous group,
  18. \g{-1} number may be negative indicating a previous buffer and may
  19.        optionally be wrapped in curly brackets for safer parsing.
  20. \g{name} Named backreference
  21. \k<name> Named backreference
  22. \K Keep the stuff left of the \K, don't include it in $&
  23. \v Vertical whitespace
  24. \V Not vertical whitespace
  25. \h Horizontal whitespace
  26. \H Not horizontal whitespace
  27. \R Linebreak
\end{verbatim}

\parrafo{Zero width assertions}

Perl defines the following zero-width assertions:

\begin{verbatim}
   1. \b Match a word boundary
   2. \B Match except at a word boundary
   3. \A Match only at beginning of string
   4. \Z Match only at end of string, or before newline at the end
   5. \z Match only at end of string
   6. \G Match only at pos() (e.g. at the end-of-match position
   7. of prior m//g)
\end{verbatim}


\subsubsection{The POSIX character class syntax}

The POSIX character class syntax:

\begin{verbatim}
   1. [:class:]
\end{verbatim}

is also available. Note that the \verb|[| and \verb|]| brackets are literal; 
they must always be used within a character class expression.

\begin{verbatim}
   1. # this is correct:
   2. $string =~ /[[:alpha:]]/;
   3.
   4. # this is not, and will generate a warning:
   5. $string =~ /[:alpha:]/;
\end{verbatim}

\parrafo{Available classes}

The available classes and their backslash equivalents (if available) are as follows:

\begin{verbatim}
   1. alpha
   2. alnum
   3. ascii
   4. blank
   5. cntrl
   6. digit \d
   7. graph
   8. lower
   9. print
  10. punct
  11. space \s 
  12. upper
  13. word \w 
  14. xdigit
\end{verbatim}


For example use \verb|[:upper:]| to match all the uppercase characters. 
Note that the \verb|[]| are part of the \verb|[::]|
construct, not part of the whole character class. For example:

\begin{verbatim}
   1. [01[:alpha:]%]
\end{verbatim}

matches zero, one, any alphabetic character, and the percent sign.

\parrafo{Equivalences to Unicode}

The following equivalences to Unicode 
\verb|\p{}| constructs and equivalent backslash 
character classes (if available), will hold:

\begin{verbatim}
   1. [[:...:]] \p{...} backslash
   2.
   3. alpha IsAlpha
   4. alnum IsAlnum
   5. ascii IsASCII
   6. blank
   7. cntrl IsCntrl
   8. digit IsDigit \d
   9. graph IsGraph
  10. lower IsLower
  11. print IsPrint 
  12. punct IsPunct 
  13. space IsSpace
  14. IsSpacePerl \s
  15. upper IsUpper
  16. word IsWord \w
  17. xdigit IsXDigit
\end{verbatim}

\parrafo{Negated character classes}

You can negate the \verb|[::]| character classes by prefixing 
the class name with a \verb|'^'|. This is a Perl extension. For example:

\begin{verbatim}
   1. POSIX traditional Unicode
   2.
   3. [[:^digit:]] \D \P{IsDigit}
   4. [[:^space:]] \S \P{IsSpace}
   5. [[:^word:]] \W \P{IsWord}
\end{verbatim}


\subsection{Variables especiales después de un emparejamiento}
\label{section:variablesmagicasereg}
Despues de un emparejamiento con éxito, las siguientes variables 
especiales quedan definidas:

\vspace{0.5cm}
\begin{tabular}{|l|l|}
\hline
\verb|$&| & El texto que casó\\
\hline
\verb|$`| & El texto que está a la izquierda de lo que casó\\
\hline
\verb|$'| & El texto que está a la derecha de lo que casó\\
\hline
\verb|$1, $2, $3|, etc. & Los textos capturados por los paréntesis\\
\hline
\verb|$+| & Una copia del \verb|$1, $2,| \ldots con número mas alto\\
\hline
\verb|@-| & Desplazamientos de las subcadenas que casan en \verb|$1| \ldots \\
\hline
\verb|@+| & Desplazamientos de los finales de las subcadenas  en \verb|$1| \ldots \\
\hline
\verb|$#-| & El índice del último paréntesis que casó\\
\hline
\verb|$#+| & El índice del último paréntesis en la última expresión regular\\
\hline
\end{tabular}

\parrafo{Las Variables de match, pre-match y post-mach}
\label{parrafo:prematch}

\vspace{0.5cm}
Ejemplo:
%%%%%%%%%%%%%%%listinginput: Input from: "../src/matchvariables.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 if ("Hello there, neighbor" =~ /\s(\w+),/) {
   3   print "That was: ($`)($&)($').\n",
   4 }
\end{verbatim}

\begin{verbatim}
> matchvariables.pl
That was: (Hello)( there,)( neighbor).
\end{verbatim}

El uso de estas variables tenía un efecto negativo en el rendimiento de la
regexp. Véase
\perldoc{perlfaq6} la sección 
\verb|Why does using $&, $`, or $' slow my program down?|.
%\pd{perlfaq6}{Why-does-using-\$\&,-\$`,-or-\$'-slow-my-program-down?}
%\htmladdnormallink
%{perlfaq6}
%{http://search.cpan.org/~dapm/perl-5.10.1-RC2/pod/perlfaq6.pod}:

\begin{it}
\begin{quotation}
Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of
it to \verb|$`|, part to \verb|$&|, and part to \verb|$'|. 
Thus the penalty is most severe
with long strings and patterns that match often. Avoid \verb|$&|, \verb|$'|, and \verb|$`|
if you can, but if you can't, once you've used them at all, use them at
will because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the \verb|$&| variable is no
longer "expensive" the way the other two are.

Since Perl 5.6.1 the special variables \verb|@-| and \verb|@+| can functionally replace
\verb|$`|, \verb|$&| and \verb|$'|. These arrays contain pointers to the beginning and end of
each match (see \perldoc{perlvar} for the full story), so they give you essentially
the same information, but without the risk of excessive string copying.

Perl 5.10 added three specials, \verb|${^MATCH}|, \verb|${^PREMATCH}|, and \verb|${^POSTMATCH}|
to do the same job but without the global performance penalty. Perl
5.10 only sets these variables if you compile or execute the regular
expression with the \verb|/p| modifier.
\end{quotation}
\end{it}

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat ampersandoldway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

'hola juan' =~ /ju/;
my ($a, $b, $c) = ($`, $&, $');


cmpthese( -1, {
    oldway => sub { 'hola juan' =~ /ju/  },
});
pl@nereida:~/Lperltesting$ cat ampersandnewway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

'hola juan' =~ /ju/p;
my ($a, $b, $c) = (${^PREMATCH}, ${^MATCH}, ${^POSTMATCH});


cmpthese( -1, {
    newway => sub { 'hola juan' =~ /ju/  },
});

pl@nereida:~/Lperltesting$ time ./ampersandoldway.pl
            Rate oldway
oldway 2991861/s     --

real    0m3.761s
user    0m3.740s
sys     0m0.020s
pl@nereida:~/Lperltesting$ time ./ampersandnewway.pl
            Rate newway
newway 8191999/s     --

real    0m6.721s
user    0m6.704s
sys     0m0.016s
\end{verbatim}

Véase 
\begin{itemize}
\item
\perldoc{perlvar} (busque por \verb|$MATCH|)
\end{itemize}


\parrafo{Texto Asociado con el Último Paréntesis}

La variable \verb|$+| contiene el texto que casó
con el último paréntesis en el patrón. Esto es útil
en situaciones en las cuáles una de un conjunto de alternativas 
casa, pero no sabemos cuál:

\begin{verbatim}
  DB<9> "Revision: 4.5" =~ /Version: (.*)|Revision: (.*)/ && ($rev = $+);
  DB<10> x $rev
0  4.5
  DB<11> "Version: 4.5" =~ /Version: (.*)|Revision: (.*)/ && ($rev = $+);
  DB<12> x $rev
0  4.5
\end{verbatim}

\parrafo{Los Offsets de los Inicios de los Casamientos: {\tt @-}}
\label{parrafo:iniciocas}

El vector \verb|@-| contiene los \emph{offsets} o desplazamientos
de los casamientos en la última expresión regular.
La entrada \verb|$-[0]| es el desplazamiento del último casamiento con éxito
y \verb|$-[n]| es el desplazamiento de la subcadena que casa
con el \verb|n|-ésimo paréntesis (o \verb|undef| si el párentesis
no casó). Por ejemplo:

\begin{verbatim}
#           012345678
DB<1> $z = "hola13.47"
DB<2> if ($z =~ m{a(\d+)(\.(\d+))?}) { print "@-\n"; }
3 4 6 7
\end{verbatim}
El resultado se interpreta como sigue:
\begin{itemize}
\item 3 = desplazamiento de comienzo de \verb|$& = a13.47| 
\item 4 = desplazamiento de comienzo de \verb|$1 = 13|
\item 6 = desplazamiento de comienzo de \verb|$2 = .|
\item 7 = desplazamiento de comienzo de \verb|$3 = 47|
\end{itemize}

Esto es lo que dice \perldoc{perlvar} sobre \verb|@-|:

\begin{it}\begin{quotation}
This array holds the offsets of the beginnings of the last successful
submatches in the currently active dynamic scope. \verb|$-[0]| is the offset
into the string of the beginning of the entire match. The nth element of
this array holds the offset of the nth submatch, so \verb|$-[1]| is the offset
where \verb|$1| begins, \verb|$-[2]| the offset where \verb|$2| begins, and so on.

    After a match against some variable \verb|$var|:

\begin{verbatim}
    $` is the same as substr($var, 0, $-[0])
    $& is the same as substr($var, $-[0], $+[0] - $-[0])
    $' is the same as substr($var, $+[0])
    $1 is the same as substr($var, $-[1], $+[1] - $-[1])
    $2 is the same as substr($var, $-[2], $+[2] - $-[2])
    $3 is the same as substr($var, $-[3], $+[3] - $-[3])
\end{verbatim}


\end{quotation}\end{it}

\parrafo{Desplazamientos de los Finales de los Emparejamientos: {\tt @+}}
\label{parrafo:fincas}

El array \verb|@+| contiene los desplazamientos de 
los finales de los emparejamientos.
La entrada \verb|$+[0]| contiene el desplazamiento del final de la cadena
del emparejamiento completo.
Siguiendo con el ejemplo anterior:
\begin{verbatim}
#            0123456789
DB<17> $z = "hola13.47x"
DB<18> if ($z =~ m{a(\d+)(\.)(\d+)?}) { print "@+\n"; }
9 6 7 9
\end{verbatim}
El resultado se interpreta como sigue:
\begin{itemize}
\item 9 = desplazamiento final de \verb|$& = a13.47x| 
\item 6 = desplazamiento final de \verb|$1 = 13|
\item 7 = desplazamiento final de \verb|$2 = .|
\item 9 = desplazamiento final de \verb|$3 = 47|
\end{itemize}

\parrafo{Número de paréntesis en la última regexp con éxito}

Se puede usar \verb|$#+| para determinar cuantos parentesis
había en el último emparejamiento que tuvo éxito.
\begin{verbatim}
  DB<29> $z = "h"
  DB<30> print "$#+\n" if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
3
  DB<31> $z = "ab"
  DB<32> print "$#+\n" if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
2
\end{verbatim}

\parrafo{Indice del Ultimo Paréntesis}
\label{parrafo:lastpar}

La variable \verb|$#-| contiene el índice del último paréntesis
que casó. Observe la siguiente ejecución con el depurador:
\begin{verbatim}
  DB<1> $x = '13.47'; $y = '125'
  DB<2> if ($y =~ m{(\d+)(\.(\d+))?}) { print "last par = $#-, content = $+\n"; }
last par = 1, content = 125
  DB<3> if ($x =~ m{(\d+)(\.(\d+))?}) { print "last par = $#-, content = $+\n"; }
last par = 3, content = 47
\end{verbatim}

\parrafo{{\tt @-} y {\tt @+} no tienen que tener el mismo tamaño}

En general no puede asumirse que \verb|@-| y \verb|@+| sean 
del mismo tamaño.
\begin{verbatim}
  DB<1> "a" =~ /(a)|(b)/; @a = @-; @b = @+
  DB<2> x @a
0  0
1  0
  DB<3> x @b
0  1
1  1
2  undef
\end{verbatim}

%\begin{exercise}
%Estudie el siguiente programa:
%\begin{verbatim}
%pl@nereida:~/Lperltesting$ cat -n orton_mod1.pl
% 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
% 2  use v5.10;
% 3  use re 'debug';
% 4
% 5  my $input;
% 6
% 7  local $" = ", ";
% 8
% 9  $parser = qr/(?<foo>foo)((?&foo))/;
%10  $input = <>;
%11  chomp($input);
%12  if ($input =~ $parser) {
%13    say "matches: & = ($&) 1 = ($1) 2 = ($2)";
%14    say "At the very end:\n\@- = (@-)\t ".scalar(@-)
%15        ." items\t\$#- = $#-\n\@+ = (@+)\t ".scalar(@+)
%16        ." items\t\$#+ = $#+ \n";
%17  }
%18  __END__
%\end{verbatim}
%Explique el resultado de la ejecución del programa cuando 
%recibe la entrada \verb|foofoo|?
%\begin{verbatim}
%pl@nereida:~/Lperltesting$ ./orton_mod1.pl
%Compiling REx "(?<foo>foo)((?&foo))"
%Final program:
%   1: OPEN1 'foo' (3)
%   3:   EXACT <foo> (5)
%   5: CLOSE1 'foo' (7)
%   7: OPEN2 (9)
%   9:   GOSUB1[-8] (12)
%  12: CLOSE2 (14)
%  14: END (0)
%anchored "foofoo" at 0 (checking anchored) minlen 6
%foofoo
%Guessing start of match in sv for REx "(?<foo>foo)((?&foo))" against "foofoo"
%Found anchored substr "foofoo" at offset 0...
%Guessed: match at offset 0
%Matching REx "(?<foo>foo)((?&foo))" against "foofoo"
%   0 <> <foofoo>             |  1:OPEN1 'foo'(3)
%   0 <> <foofoo>             |  3:EXACT <foo>(5)
%   3 <foo> <foo>             |  5:CLOSE1 'foo'(7)
%   3 <foo> <foo>             |  7:OPEN2(9)
%   3 <foo> <foo>             |  9:GOSUB1[-8](12)
%   3 <foo> <foo>             |  1:  OPEN1 'foo'(3)
%   3 <foo> <foo>             |  3:  EXACT <foo>(5)
%   6 <foofoo> <>             |  5:  CLOSE1 'foo'(7)
%                                    EVAL trying tail ... 0
%   6 <foofoo> <>             | 12:    CLOSE2(14)
%   6 <foofoo> <>             | 14:    END(0)
%Match successful!
%matches: & = (foofoo) 1 = (foo) 2 = (foo)
%At the very end:
%@- = (0, 0, 3)   3 items        $#- = 2
%@+ = (6, 3, 6)   3 items        $#+ = 2
%
%Freeing REx: "(?<foo>foo)((?&foo))"
%\end{verbatim}
%\end{exercise}

\parrafo{Véase También}

Para saber más sobre las variables especiales disponibles
consulte 

\begin{itemize}
\item \verb|perldoc| \perldoc{perlretut}
\item \verb|perldoc| \perldoc{perlvar}.
\end{itemize}

\subsection{Ambito Automático}

Como sabemos, ciertas variables (como \verb|$1|, \verb|$&| \ldots )
reciben autom\'aticamente un valor con cada operaci\'{o}n
de ``matching''.  

Considere el siguiente c\'{o}digo:
\begin{verbatim}
if (m/(...)/) {
  &do_something();
  print "the matched variable was $1.\n";
}
\end{verbatim}
Puesto que \verb|$1| es autom\'aticamente declarada \verb|local|
a la entrada de cada bloque, no importa lo que se haya
hecho en la funci\'{o}n \verb| &do_something()|, el valor de 
\verb|$1| en la sentencia \verb|print| es el correspondiente
al ``matching'' realizado en el \verb|if|.

\subsection{Opciones}
\label{section:opciones}
\begin{tabular}{l|l}
Modificador & Significado\\
\hline
e           & evaluar: evaluar el lado derecho de una sustitución como una expresión\\
g           & global: Encontrar todas las ocurrencias\\
i           & ignorar: no distinguir entre mayúsculas y minúsculas\\
m           & multilínea (\verb|^| y \verb|$| casan con \verb|\n| internos)\\
o           & optimizar: compilar una sola vez\\
s           & \verb|^| y \verb|$| ignoran \verb|\n| pero el punto \verb|.| ``casa'' con \verb|\n|\\
x           & extendida: permitir comentarios\\
\end{tabular}

\parrafo{El Modificador {\tt /g}}
\label{section:g}
La conducta de este modificador depende del contexto. En un contexto de
listas devuelve una lista con todas las subcadenas casadas
por todos los paréntesis en la expresión regular. Si no hubieran 
paréntesis devuelve una lista con todas las cadenas casadas
(como si hubiera paréntesis alrededor del patrón global).

%%%%%%%%%%%%%%%listinginput: Input from: "../src/glist.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 ($one, $five, $fifteen) = (`uptime` =~ /(\d+\.\d+)/g);
   3 print "$one, $five, $fifteen\n";
\end{verbatim}

Observe la salida:
\begin{verbatim}
> uptime
  1:35pm  up 19:22,  0 users,  load average: 0.01, 0.03, 0.00
> glist.pl
0.01, 0.03, 0.00 
\end{verbatim}

En un contexto escalar \verb|m//g| itera sobre la cadena, devolviendo
cierto cada vez que casa, y falso cuando deja de casar. En otras 
palabras, recuerda donde se quedo la última vez y se recomienza la búsqueda
desde ese punto. Se puede averiguar la posicion del emparejamiento
utilizando la función \cei{{\tt pos}}. 
Si por alguna razón modificas la cadena en cuestión, 
la posición de emparejamiento se reestablece al comienzo de la cadena.
%%%%%%%%%%%%%%%listinginput: Input from: "../src/gscalar.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 # count sentences in a document
   3 #defined as ending in [.!?] perhaps with
   4 # quotes or parens on either side.
   5 $/ = ""; # paragraph mode
   6 while ($paragraph = <>) {
   7   print $paragraph;
   8   while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
   9     $sentences++;
  10   }
  11 }
  12 print "$sentences\n";
\end{verbatim}

Observe el uso de la variable especial \verb|$/|. 
Esta variable contiene el separador de registros en el fichero de 
entrada. Si se iguala a la cadena vacía usará las líneas 
en blanco como separadores. Se le puede dar el valor de una cadena multicarácter
para usarla como delimitador. Nótese que establecerla a \verb|\n\n|
es diferente de asignarla a \verb|""|. Si se deja \verb|undef|, 
la siguiente lectura leerá todo el fichero.

Sigue un ejemplo de ejecución. El programa se llama \verb|gscalar.pl|.
Introducimos el texto desde \verb|STDIN|. El programa escribe el
número de párrafos:

\begin{verbatim}
> gscalar.pl
este primer parrafo. Sera seguido de un
segundo parrafo.
 
"Cita de Seneca".
 
3 
\end{verbatim}

\parrafo{La opción {\tt e}: Evaluación del remplazo}
\label{section:regeval}
La opción \verb|/e| permite la evaluación como expresión perl de la
cadena de reemplazo (En vez de considerarla como una cadena delimitada 
por doble comilla).

%%%%%%%%%%%%%%%listinginput: Input from: "../src/replacement.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 $_ = "abc123xyz\n";
   3 s/\d+/$&*2/e;
   4 print;
   5 s/\d+/sprintf("%5d",$&)/e;
   6 print;
   7 s/\w/$& x 2/eg;
   8 print;
\end{verbatim}
El resultado de la ejecución es:
\begin{verbatim}
> replacement.pl
abc246xyz
abc  246xyz
aabbcc  224466xxyyzz 
\end{verbatim}

Véase un ejemplo con anidamiento de {\tt /e}:
%%%%%%%%%%%%%%%listinginput: Input from: "../src/enested.pl"
\begin{verbatim}
   1 #!/usr/bin/perl 
   2 $a ="one";
   3 $b = "two";
   4 $_ = '$a $b';
   5 print "_ = $_\n\n";
   6 s/(\$\w+)/$1/ge;
   7 print "After 's/(\$\w+)/$1/ge' _ = $_\n\n";
   8 s/(\$\w+)/$1/gee;
   9 print "After 's/(\$\w+)/$1/gee' _ = $_\n\n";
\end{verbatim}
El resultado de la ejecución es:
\begin{verbatim} 
> enested.pl
_ = $a $b
 
After 's/($w+)/$b/ge' _ = $a $b
 
After 's/($w+)/$b/gee' _ = one two  
\end{verbatim}

He aqui una solución que hace uso de \verb|e| al siguiente ejercicio 
(véase 'Regex to add space after punctuation sign' en \perlmonk{319742})
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
s/,/, /g;
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique

\begin{verbatim}
s/(\d[,.]\d)|(,(?!\s))/$1 || "$2 "/ge; 
\end{verbatim}

Se hace uso de un lookahead negativo \verb|(?!\s)|.
Véase la sección \ref{subsection:lookaheadlookbehind} para entender como funciona
un lookahead negativo.

\section{Algunas Extensiones}

\subsection{Comentarios}
\verb|(?#text)| Un comentario. Se ignora \verb|text|. 
Si se usa la opción \verb|x| basta con poner \verb|#|.

\subsection{Modificadores locales}

Los modificadores de la conducta de una expresión regular pueden ser 
empotrados en una subexpresión usando el formato \verb|(?pimsx-imsx)|.

Véase el correspondiente texto {\it Extended Patterns} de 
\pd{perlre}{Extended-Patterns}:
\begin{it}
\begin{quotation}
One or more embedded pattern-match modifiers, to be turned on (or turned
off, if preceded by '\verb|-|' ) for the remainder of the pattern or the remainder
of the enclosing pattern group (if any). This is particularly useful
for dynamic patterns, such as those read in from a configuration file,
taken from an argument, or specified in a table somewhere. Consider
the case where some patterns want to be case sensitive and some do not:
The case insensitive ones merely need to include (?i) at the front of
the pattern. For example:

\begin{verbatim}
   1. $pattern = "foobar";
   2. if ( /$pattern/i ) { }
   3.
   4. # more flexible:
   5.
   6. $pattern = "(?i)foobar";
   7. if ( /$pattern/ ) { }
\end{verbatim}

These modifiers are restored at the end of the enclosing group. For example,

\begin{verbatim}
   1. ( (?i) blah ) \s+ \1
\end{verbatim}

will match \verb|blah| in any case, some spaces, and an exact (including the
case!) repetition of the previous word, assuming the \verb|/x| modifier, and
no \verb|/i| modifier outside this group.
\end{quotation}
\end{it}

El siguiente ejemplo extiende el ejemplo visto en
la sección
\ref{parrfo:comments}
eliminando los comentarios \verb|/* ... */| y \verb|// ... |
de un programa C. En dicho ejemplo se usaba el modificador \verb|s| 
para hacer que el punto casara con cualquier carácter:

\begin{latexonly}
\begin{verbatim}
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $progname = shift @ARGV or die "Usage:\n$0 prog.c\n";
   5    open(my $PROGRAM,"<$progname") || die "can't find $progname\n";
   6    my $program = '';
   7    {
   8      local $/ = undef;
   9      $program = <$PROGRAM>;
  10    }
  11    $program =~ s{(?xs)
  12      /\*  # Match the opening delimiter
  13      .*?  # Match a minimal number of characters
  14      \*/  # Match the closing delimiter
  15      |
  16        (?-s)//.* # C++ // comments. No s modifier
  17    }[]g;
  18  
  19    print $program;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">&quot;Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$progname</span><span class="synConstant">&quot;</span>) || <span class="synStatement">die</span> <span class="synConstant">&quot;can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = &lt;<span class="synIdentifier">$PROGRAM</span>&gt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span><span class="synSpecial">(?xs)</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">    |</span>
<span class="synLinenum">   16</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">-s</span><span class="synSpecial">)</span><span class="synConstant">//</span><span class="synSpecial">.*</span><span class="synConstant"> # C</span><span class="synSpecial">++</span><span class="synConstant"> // comments</span><span class="synSpecial">.</span><span class="synConstant"> No s modifier</span>
<span class="synLinenum">   17</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]g;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>

\end{rawhtml}
%}}}
Sigue un ejemplo de ejecución. Usaremos como entrada el programa C:
\begin{verbatim}
casiano@tonga:~/Lperltesting$ cat -n ehello.c
     1  #include <stdio.h>
     2  /* first
     3  comment
     4  */
     5  main() { // A C++ comment
     6    printf("hello world!\n"); /* second comment */
     7  } // final comment
\end{verbatim}
Al ejecutar el programa eliminamos los comentarios:
\begin{verbatim}
casiano@tonga:~/Lperltesting$ extendedcomments.pl ehello.c | cat -n
     1  #include <stdio.h>
     2
     3  main() {
     4    printf("hello world!\n");
     5  }

\end{verbatim}


\subsection{Mirando hacia adetrás y hacia adelante}
\label{subsection:lookaheadlookbehind}

El siguiente fragmento esta 'casi' literalmente tomado
de \pd{perlretut}{Looking-ahead-and-looking-behind}:

\begin{it}

\parrafo{Las zero-width assertions como caso particular de mirar atrás-adelante}

In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match. For instance, the regexp element
\verb|[abc}]| eats up one character of the string when it matches, in the sense
that Perl moves to the next character position in the string after the
match. There are some elements, however, that don't eat up characters
(advance the character position) if they match. 

The examples we have seen
so far are the anchors. The anchor \verb|^| matches the beginning of the line,
but doesn't eat any characters. 

Similarly, the word boundary anchor
\verb|\b| matches wherever a character matching \verb|\w| is next to a character that
doesn't, but it doesn't eat up any characters itself. 

Anchors are examples
of \cei{zero-width assertions}. Zero-width, because they consume no characters,
and assertions, because they test some property of the string. 

In the
context of our walk in the woods analogy to regexp matching, most regexp
elements move us along a trail, but anchors have us stop a moment and
check our surroundings. If the local environment checks out, we can
proceed forward. But if the local environment doesn't satisfy us, we
must backtrack.

Checking the environment entails either looking ahead on the trail,
looking behind, or both. 

\begin{itemize}
\item
\verb|^| looks behind, to see that there are no
characters before. 
\item
\verb|$| looks ahead, to see that there are no characters
after. 
\item
\verb|\b| looks both ahead and behind, to see if the characters on either
side differ in their "word-ness".
\end{itemize}

The lookahead and lookbehind assertions are generalizations of the anchor
concept. 
Lookahead and lookbehind are zero-width assertions that let us
specify which characters we want to test for. 

\parrafo{Lookahead assertion}

The lookahead assertion
is denoted by \verb|(?=regexp)| and the lookbehind assertion is denoted by
\verb|(?<=fixed-regexp)|. 

En español, operador de ``trailing'' o ``mirar-adelante'' positivo. 
Por ejemplo, \verb|/\w+(?=\t)/| solo casa una palabra si va seguida de un tabulador, pero el tabulador no formará parte de \verb|$&|.
Ejemplo:
\begin{latexonly}
\begin{verbatim}
> cat -n lookahead.pl
   1  #!/usr/bin/perl
   2  
   3   $a = "bugs the rabbit";
   4   $b = "bugs the frog";
   5   if ($a =~ m{bugs(?= the cat| the rabbit)}i) { print "$a matches. \$& = $&\n"; }
   6   else { print "$a does not match\n"; }
   7   if ($b =~ m{bugs(?= the cat| the rabbit)}i) { print "$b matches. \$& = $&\n"; }
   8   else { print "$b does not match\n"; }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
> cat -n lookahead.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span> 
<span class="synLinenum">    3</span>  <span class="synIdentifier">$a</span> = <span class="synConstant">&quot;bugs the rabbit&quot;</span>;
<span class="synLinenum">    4</span>  <span class="synIdentifier">$b</span> = <span class="synConstant">&quot;bugs the frog&quot;</span>;
<span class="synLinenum">    5</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$a</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$a</span><span class="synConstant"> matches. </span><span class="synSpecial">\$</span><span class="synConstant">&amp; = </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
<span class="synLinenum">    6</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$a</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
<span class="synLinenum">    7</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$b</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$b</span><span class="synConstant"> matches. </span><span class="synSpecial">\$</span><span class="synConstant">&amp; = </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
<span class="synLinenum">    8</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$b</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
</pre>

\end{rawhtml}
%}}}
Al ejecutar el programa obtenemos:
\begin{verbatim}
> lookahead.pl
bugs the rabbit matches. $& = bugs
bugs the frog does not match
>
\end{verbatim}

Some examples using the debugger\footnote{catnip: 
La nepeta cataria, también llamada menta de los gatos, de la familia del tomillo y la lavanda. 
Su perfume desencadena un comportamiento en el animal, similar al del celo}:

\begin{latexonly}
\begin{verbatim}
  DB<1>      #012345678901234567890
  DB<2> $x = "I catch the housecat 'Tom-cat' with catnip"
  DB<3> print "($&) (".pos($x).")\n" if $x  =~ /cat(?=\s)/g
(cat) (20)                    # matches 'cat' in 'housecat'

  DB<5> $x = "I catch the housecat 'Tom-cat' with catnip" # To reset pos
  DB<6> x @catwords = ($x =~ /(?<=\s)cat\w+/g)
0  'catch'
1  'catnip'

  DB<7>      #012345678901234567890123456789
  DB<8> $x = "I catch the housecat 'Tom-cat' with catnip"
  DB<9> print "($&) (".pos($x).")\n" if $x =~ /\bcat\b/g
(cat) (29) # matches 'cat' in 'Tom-cat'

  DB<10> $x = "I catch the housecat 'Tom-cat' with catnip"
  DB<11> x  $x =~ /(?<=\s)cat(?=\s)/
  empty array
  DB<12> # doesn't match; no isolated 'cat' in middle of $x
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
  DB<1>  <span class="dbuser">     #012345678901234567890</span>
  DB<2>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<3>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x  =~ /cat(?=\s)/g</span>
(cat) (20)                    # matches 'cat' in 'housecat'

  DB<5>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip" # To reset pos</span>
  DB<6>  <span class="dbuser">x @catwords = ($x =~ /(?<=\s)cat\w+/g)</span>
0  'catch'
1  'catnip'

  DB<7>  <span class="dbuser">     #012345678901234567890123456789</span>
  DB<8>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<9>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x =~ /\bcat\b/g</span>
(cat) (29) # matches 'cat' in 'Tom-cat'

  DB<10>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<11>  <span class="dbuser">x  $x =~ /(?<=\s)cat(?=\s)/</span>
  empty array
  DB<12>  <span class="dbuser"># doesn't match; no isolated 'cat' in middle of $x</span>
</pre>
\end{rawhtml}
%}}}

\parrafo{A hard RegEx problem}

Véase el nodo {\it A hard RegEx problem} en \perlmonk{645882}. 
Un monje solicita:

\begin{it}
\begin{quotation}
Hi Monks,

I wanna to match this issues:

\begin{enumerate}
   \item The string length is between 3 and 10
   \item The string ONLY contains [0-9] or [a-z] or [A-Z], but
   \item The string must contain a number AND a letter at least 
\end{enumerate}

Pls help me check. Thanks
\end{quotation}
\end{it}

Solución:

\begin{verbatim}
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB<1> x 'aaa2a1' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
  DB<2> x 'aaaaaa' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB<3> x '1111111' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB<4> x '1111111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB<5> x '111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
\end{verbatim}

\parrafo{Los paréntesis looakehaed and lookbehind no capturan}

Note that the parentheses in \verb|(?=regexp)| and \verb|(?<=regexp)|
are non-capturing, since these are zero-width assertions. 

\parrafo{Limitaciones del lookbehind}

Lookahead
\verb|(?=regexp)| can match arbitrary regexps, but lookbehind 
\verb|(?<=fixed-regexp)|
only works for regexps of fixed width, i.e., a fixed number of characters
long. 

Thus \verb#(?<=(ab|bc))# is fine, but \verb#(?<=(ab)*)# is not. 

\parrafo{Negación de los operadores de lookahead y lookbehind}

The negated
versions of the lookahead and lookbehind assertions are denoted by
\verb|(?!regexp)| and \verb#(?<!fixed-regexp)# respectively. 
They evaluate true if
the regexps do not match:
\begin{verbatim}
    $x = "foobar";
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?<!\s)foo/;  # matches, there is no \s before 'foo'
\end{verbatim}

\parrafo{Ejemplo: split con lookahead y lookbehind}

Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components. 

Using \verb#/\s+/#
alone won't work, because spaces are not required between dashes, or a
word or a dash. Additional places for a split are established by looking
ahead and behind:
\begin{verbatim}
casiano@tonga:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> $str = "one two - --6-8"
  DB<2> x @toks = split / \s+ | (?<=\S) (?=-) | (?<=-)  (?=\S)/x, $str
0  'one'
1  'two'
2  '-'
3  '-'
4  '-'
5  6
6  '-'
7  8
\end{verbatim}
\end{it}

\parrafo{Look Around en perlre}

El siguiente párrafo ha sido extraído \pd{pelre}{Look-Around-Assertions}.
Usémoslo como texto de repaso:
\begin{it}
\begin{quotation}
Look-around assertions are zero width patterns which match a specific
pattern without including it in \verb|$&|. Positive assertions match when their
subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.

\begin{itemize}
\item \verb|(?=pattern)|

A zero-width positive look-ahead assertion. For example, \verb|/\w+(?=\t)/| 
matches a word followed by a tab, without including the tab in \verb|$&|.

\item \verb|(?!pattern)|

A zero-width negative look-ahead assertion. For example \verb|/foo(?!bar)/| 
matches any occurrence of \verb"foo" that isn't followed by \verb"bar". 

Note however that look-ahead and look-behind are NOT the same thing. 
You cannot use this for look-behind.

If you are looking for a \verb"bar" that isn't preceded by a \verb"foo",
\verb|/(?!foo)bar/| will not do what you want. 

That's because the 
\verb#(?!foo)# is just saying that the next thing cannot be \verb"foo"
--and it's not, it's a \verb"bar", so \verb"foobar" will match. 

You would have to do something like \verb#/(?!foo)...bar/# for that. 

We say "like" because there's the case of your \verb"bar" not having
three characters before it. 

You could cover that this way:
\verb#/(?:(?!foo)...|^.{0,2})bar/#. Sometimes it's still easier just to say:

\begin{verbatim}
    if (/bar/ && $` !~ /foo$/)
\end{verbatim}

For look-behind see below.

\item \verb|(?<=pattern)|

A zero-width positive look-behind assertion. 

For example, \verb#/(?<=\t)\w+/#
matches a word that follows a tab, without including the tab in \verb|$&|. 
Works only for fixed-width look-behind.

\item \verb|\K| 

There is a special form of this construct, called \verb|\K| , which causes
the regex engine to 'keep' everything it had matched prior to the \verb|\K|
and not include it in \verb|$&|. This effectively provides variable length
look-behind. The use of \verb|\K| inside of another look-around assertion is
allowed, but the behaviour is currently not well defined.

For various reasons \verb|\K| may be significantly more efficient than the
equivalent \verb|(?<=...)| construct, and it is especially useful in situations
where you want to efficiently remove something following something else
in a string. For instance
\begin{verbatim}
  s/(foo)bar/$1/g;
\end{verbatim}

can be rewritten as the much more efficient
\begin{verbatim}
  s/foo\Kbar//g;
\end{verbatim}

Sigue una sesión con el depurador que ilustra la semántica
del operador:

\begin{verbatim}
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])[a-z]/
& = <phab> 1 = <pha>
  DB<2> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /\K([^aeiou][a-z][aeiou])[a-z]/
& = <phab> 1 = <pha>
  DB<3> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou]\K[a-z][aeiou])[a-z]/
& = <hab> 1 = <pha>
  DB<4> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z]\K[aeiou])[a-z]/
& = <ab> 1 = <pha>
  DB<5> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])\K[a-z]/
& = <b> 1 = <pha>
  DB<6> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])[a-z]\K/
& = <> 1 = <pha>
  DB<7> @a = "alphabet" =~ /([aeiou]\K[^aeiou])/g; print "$&\n"
t
  DB<8> x @a
0  'al'
1  'ab'
2  'et'
\end{verbatim}

Otro ejemplo: eliminamos los blancos del final en una cadena:
\begin{verbatim}
  DB<23> $x = '  cadena entre blancos  '
  DB<24> ($y = $x) =~ s/.*\b\K.*//g
  DB<25> p "<$y>"
<  cadena entre blancos>
\end{verbatim}

\item \verb|(?<!pattern)| 

A zero-width negative look-behind assertion. 

For example \verb|/(?<!bar)foo/| matches any occurrence of 
 \verb"foo" that does not follow \verb"bar". Works only for fixed-width look-behind.
\end{itemize}

\end{quotation}
\end{it}


Veamos un ejemplo de uso. Se quiere
sustituir las extensiones \verb|.something| por \verb|.txt|
en cadenas que contienen una ruta a un fichero:

\begin{verbatim}
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> ($b = $a = 'abc/xyz.something') =~ s{\.[^.]*$}{.txt}
  DB<2> p $b
abc/xyz.txt
  DB<3> ($b = $a = 'abc/xyz.something') =~ s/\.\K[^.]*$/txt/;
  DB<4> p $b
abc/xyz.txt
  DB<5> p $a
abc/xyz.something
\end{verbatim}

Véase también:
\begin{itemize}
\item \cpan{Regexp::Keep} por Jeff Pinyan 
\item El nodo {\it positive look behind regexp mystery} en \perlmonk{701618}
\end{itemize}

\parrafo{Operador de predicción negativo: Última ocurrencia}

Escriba una expresión regular que encuentre la última aparición de la cadena \verb|foo|
en una cadena dada.
\begin{verbatim}
  DB<6> x ($a = 'foo foo bar bar foo bar bar') =~ /foo(?!.*foo)/g; print pos($a)."\n"
19
  DB<7> x ($a = 'foo foo bar bar foo bar bar') =~ s/foo(?!.*foo)/\U$&/
0  1
  DB<8> x $a
0  'foo foo bar bar FOO bar bar'
\end{verbatim}


\parrafo{Diferencias entre mirar adelante negativo y mirar adelante con clase negada}

Aparentemente el operador ``mirar-adelante'' negativo es parecido a usar el operador ``mirar-adelante'' positivo
con la negación de una clase. 

\begin{center}
\begin{tabular}{p{4cm}|p{4cm}}
\hline
\begin{verbatim}
/regexp(?![abc])/
\end{verbatim}
&
\begin{verbatim}
/regexp(?=[^abc])/
\end{verbatim}\\
\hline
\end{tabular}
\end{center}

Sin embargo existen al menos dos diferencias:

\begin{itemize}
\item
Una negación de una clase debe casar algo para tener éxito. Un `mirar-adelante'' negativo
tiene éxito si, en particular no logra casar con algo. 
Por ejemplo:

\verb|\d+(?!\.)| casa con \verb|$a = '452'|, mientras que \verb|\d+(?=[^.])| lo hace, pero porque 
\verb|452| es \verb|45| seguido de un carácter que no es el punto:
\begin{verbatim}
> cat lookaheadneg.pl
#!/usr/bin/perl

 $a = "452";
 if ($a =~ m{\d+(?=[^.])}i) { print "$a casa clase negada. \$& = $&\n"; }
 else { print "$a no casa\n"; }
 if ($a =~ m{\d+(?!\.)}i) { print "$a casa predicción negativa. \$& = $&\n"; }
 else { print "$b no casa\n"; }
nereida:~/perl/src> lookaheadneg.pl
452 casa clase negada. $& = 45
452 casa predicción negativa. $& = 452
\end{verbatim}
\item
Una clase negada casa un único carácter. Un `mirar-adelante'' negativo
puede tener longitud arbitraria.
\end{itemize}

\parrafo{AND y AND NOT} 

Otros dos ejemplos: 

\begin{itemize}
\item
\verb|^(?![A-Z]*$)[a-zA-Z]*$| 

casa con líneas formadas por secuencias de
letras tales que no todas son mayúsculas.
(Obsérvese el uso de las anclas).

\item
\verb|^(?=.*?esto)(?=.*?eso)| 

casan con cualquier línea en la que aparezcan 
\verb|esto| y \verb|eso|. Ejemplo:
\begin{verbatim}
> cat estoyeso.pl
#!/usr/bin/perl

 my $a = shift;

 if ($a =~ m{^(?=.*?esto)(?=.*?eso)}i) { print "$a matches.\n"; }
 else { print "$a does not match\n"; }

>estoyeso.pl 'hola eso y esto'
hola eso y esto matches.
> estoyeso.pl 'hola esto y eso'
hola esto y eso matches.
> estoyeso.pl 'hola aquello y eso'
hola aquello y eso does not match
> estoyeso.pl 'hola esto y aquello'
hola esto y aquello does not match
\end{verbatim}
El ejemplo muestra que la interpretación es que cada 
operador mirar-adelante se interpreta siempre a partir de
la posición actual de búsqueda. La expresión regular anterior
es básicamente equivalente a \verb|(/esto/ && /eso/)|.
\item
\verb|(?!000)(\d\d\d)| 

casa con cualquier cadena de tres dígitos que no
sea la cadena \verb|000|.
\end{itemize}

\parrafo{Lookahead negativo versus lookbehind}

Nótese que el ``mirar-adelante'' negativo
no puede usarse fácilmente para imitar un ``mirar-atrás'',
esto es, que no se puede imitar la conducta de
\verb|(?<!foo)bar| mediante
algo como \verb|(/?!foo)bar|. Tenga en cuenta que:

\begin{itemize}

\item
Lo que 
dice \verb|(?!foo)| es que los tres caracteres que siguen no puede ser \verb"foo".  

\item
Así, \verb|foo| no pertenece a \verb|/(?!foo)bar/|, pero
\verb|foobar| pertenece a  \verb|(?!foo)bar/| porque \verb|bar| es una cadena
cuyos tres siguientes caracteres son \verb|bar| y no son \verb|foo|.

\item
Si quisieramos conseguir algo parecido a \verb|(?<!foo)bar| usando un lookahead negativo
tendríamos que escribir algo asi como
\verb|/(?!foo)...bar/| que casa con una cadena de tres caracteres que no sea \verb|foo| seguida de 
\verb|bar| (pero que tampoco es exactamente equivalente):
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n foobar.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $a = shift;
     5
     6  for my $r (q{(?<!foo)bar}, q{(?!foo)bar}, q{(?!foo)...bar}) {
     7    if ($a =~ /$r/) {
     8      say "$a casa con $r"
     9    }
    10    else {
    11      say "$a no casa con $r"
    12    }
    13  }
\end{verbatim}

\item
Al ejecutar con diferentes entradas el programa anterior vemos que la solución 
\verb|q{(?!foo)...bar}| se apróxima mas a \verb|(q{(?<!foo)bar}|:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl foobar
foobar no casa con (?<!foo)bar
foobar casa con (?!foo)bar
foobar no casa con (?!foo)...bar

pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl bar
bar casa con (?<!foo)bar
bar casa con (?!foo)bar
bar no casa con (?!foo)...bar
\end{verbatim}

\begin{exercise}
Explique porqué \verb|bar| casa con \verb|(?<!foo)bar| pero no con \verb|(?!foo)...bar|.
¿Sabría encontrar una expresión regular mas apropiada usando lookahead negativo?
\end{exercise}

\item
En realidad, posiblemente sea mas legible una solución como:
\begin{verbatim}
        if (/bar/ and $` !~ /foo$/) 
\end{verbatim}
o aún mejor (véase \ref{parrafo:prematch}):
\begin{verbatim}
        if (/bar/p && ${^PREMATCH} =~ /foo$/)
\end{verbatim}
El siguiente programa puede ser utilizado para ilustrar la equivalencia:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n foobarprematch.pl
 1  use v5.10;
 2  use strict;
 3
 4  $_ = shift;
 5
 6  if (/bar/p && ${^PREMATCH} =~ /foo$/) {
 7    say "$_ no cumple ".q{/bar/p && ${^PREMATCH} =~ /foo$/};
 8  }
 9  else {
10    say "$_ cumple ".q{/bar/p && ${^PREMATCH} =~ /foo$/};
11  }
12  if (/(?<!foo)bar/) {
13    say "$_ casa con (?<!foo)bar"
14  }
15  else {
16    say "$_ no casa con (?<!foo)bar"
17  }
\end{verbatim}
Siguen dos ejecuciones:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl bar
bar cumple /bar/p && ${^PREMATCH} =~ /foo$/
bar casa con (?<!foo)bar
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl foobar
foobar no cumple /bar/p && ${^PREMATCH} =~ /foo$/
foobar no casa con (?<!foo)bar
\end{verbatim}
\end{itemize}

\parrafo{Ejercicios}

\begin{exercise}
\begin{itemize}
\item Escriba una sustitución que reemplaze todas las apariciones
de \verb|foo| por \verb|foo,| usando \verb|\K| o lookbehind
%0\begin{verbatim}
%0casiano@millo:~$ perl5.10.1 -wdE 0
%0main::(-e:1):   0
%0  DB<1> ($a = 'bar foo foobar bar barfoo bar baz') =~ s/foo\K/,/g
%0  DB<2> p $a
%0bar foo, foo,bar bar barfoo, bar baz
%0\end{verbatim}
\item Escriba una sustitución que reemplaze todas las apariciones
de \verb|lookahead| por \verb|look-ahead| usando lookaheads y lookbehinds
%\begin{verbatim}
%casiano@millo:~$ perl5.10.1 -wdE 0
%  DB<3> ($a = 'bar lookahead bar barlookahead bar baz') =~ s/look\K(?=ahead)/-/g
%  DB<4> p $a
%bar look-ahead bar barlook-ahead bar baz
%\end{verbatim}
\item
Escriba una expresión regular que capture todo lo que hay 
entre las cadenas \verb|foo| y \verb|bar| siempre que no se incluya la
palabra \verb|baz|
%\begin{verbatim}
%/foo  # Match starting at foo
% (         # Capture
% (?:       # Complex expression:
%   (?!baz) #   make sure we're not at the beginning of baz 
%   .       #   accept any character
% )*        # any number of times
% )         # End capture
% bar  # and ending at bar
%/x;
%\end{verbatim}
\item
¿Cuál es la salida?
\begin{verbatim}
  DB<1> x 'abc' =~ /(?=(.)(.)(.))a(b)/
\end{verbatim}
%\begin{verbatim}
%  DB<13> x 'abc' =~ /(?=(.)(.)(.))a(b)/
%0  'a'
%1  'b'
%2  'c'
%3  'b'
%\end{verbatim}
\item
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
s/,/, /g;
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos.
%\begin{verbatim}
%  DB<1> $a = 'ab,cd,e,02,34,56,ef,273,457,c'
%  DB<4> ($b = $a) =~ s{(?<!\d),|,(?!\d)}{, }g
%  DB<5> p $b
%ab, cd, e, 02,34,56, ef, 273,457, c
%  DB<6> $a = 'ab,cd,e,02,34,56,ef,273,457,c,'
%  DB<7> ($b = $a) =~ s{(?<!\d),|,(?!\d)}{, }g
%  DB<9> p "<$b>"
%<ab, cd, e, 02,34,56, ef, 273,457, c, >
%  DB<10> $a = ',ab,cd,e,02,34,56,ef,273,457,c,'
%  DB<11> ($b = $a) =~ s{(?<!\d),|,(?!\d)}{, }g
%  DB<12> p "<$b>"
%<, ab, cd, e, 02,34,56, ef, 273,457, c, >
%  DB<13>
%\end{verbatim}
\item
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
s/,/, /g;
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique

%\begin{verbatim}
%  DB<25> p $a
%,ab, cd, e,02,34,56,ef,273,457,c,
%  DB<24> ($b = $a) =~ s{(?<!\d),(?!\s)|,(?!\s)(?!\d)}{, }g
%  DB<26> p $b
%, ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}

%\begin{verbatim}
%  DB<32> $a = ',ab, cd, e,02,34,56,ef,273,457,c,'
%  DB<33> ($b = $a) =~ s{(?!\d,\d)(.,)(?!\s)}{$1 }g
%  DB<34> p $b
%,ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}

%Con 5.10
%\begin{verbatim}
%>> $a = ',ab, cd, e,02,34,56,ef,273,457,c,'
%>> #save deb
%  DB<6> ($b = $a) =~ s{(?!\d,\d)(.,\K)(?!\s)}{ }g
%  DB<7> p $b
%,ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}


%Abigail http://www.perlmonks.org/?node_id=319742
%\begin{verbatim}
%  DB<40> p $a
%,ab, cd, e,02,34,56,ef,273,457,c,
%  DB<41> ($b = $a) =~ s{(\d,\d)|(,(?!\s))}{$1 || "$2 "}ge
%  DB<42> p $b
%, ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}

\item
¿Cuál es la salida?
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ABC123.pl
  1  use warnings;
  2  use strict;
  3
  4  my $c = 0;
  5  my @p = ('^(ABC)(?!123)', '^(\D*)(?!123)',);
  6
  7  for my $r (@p) {
  8    for my $s (qw{ABC123 ABC445}) {
  9      $c++;
 10      print "$c: '$s' =~ /$r/ : ";
 11      <>;
 12      if ($s =~ /$r/) {
 13        print " YES ($1)\n";
 14      }
 15      else {
 16        print " NO\n";
 17      }
 18    }
 19  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n ABC123</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  use warnings;</span>
<span class="synConstant">     2  use strict;</span>
<span class="synConstant">     3</span>
<span class="synConstant">     4  my </span><span class="synIdentifier">$c</span><span class="synConstant"> = 0;</span>
<span class="synConstant">     5  my </span><span class="synIdentifier">@p</span><span class="synConstant"> = </span><span class="synSpecial">(</span><span class="synConstant">'^</span><span class="synSpecial">(</span><span class="synConstant">ABC</span><span class="synSpecial">)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">', '^</span><span class="synSpecial">(\D*)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">',</span><span class="synSpecial">)</span><span class="synConstant">;</span>
<span class="synConstant">     6</span>
<span class="synConstant">     7  for my </span><span class="synIdentifier">$r</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@p</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     8    for my </span><span class="synIdentifier">$s</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synConstant">qw{ABC123 ABC445}</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     9      </span><span class="synIdentifier">$c</span><span class="synSpecial">++</span><span class="synConstant">;</span>
<span class="synConstant">    10      print &quot;</span><span class="synIdentifier">$c</span><span class="synConstant">: '</span><span class="synIdentifier">$s</span><span class="synConstant">' =~ </span><span class="synStatement">/</span><span class="synIdentifier">$r</span>/ : <span class="synConstant">&quot;;</span>
<span class="synConstant">    11      &lt;&gt;;</span>
<span class="synConstant">    12      if (</span><span class="synIdentifier">$s</span><span class="synConstant"> =~ /</span><span class="synIdentifier">$r</span><span class="synConstant">/) {</span>
<span class="synConstant">    13        print &quot;</span> YES (<span class="synIdentifier">$1</span>)\n<span class="synConstant">&quot;;</span>
<span class="synConstant">    14      }</span>
<span class="synConstant">    15      else {</span>
<span class="synConstant">    16        print &quot;</span> NO\n<span class="synConstant">&quot;;</span>
<span class="synConstant">    17      }</span>
<span class="synConstant">    18    }</span>
<span class="synConstant">    19  }</span>
</pre>

\end{rawhtml}
%}}}
%\begin{verbatim}
%pl@nereida:~/Lperltesting$ perl ABC123.pl
%1: 'ABC123' =~ /^(ABC)(?!123)/ :
% NO
%2: 'ABC445' =~ /^(ABC)(?!123)/ :
% YES (ABC)
%3: 'ABC123' =~ /^(\D*)(?!123)/ :
% YES (AB)
%4: 'ABC445' =~ /^(\D*)(?!123)/ :
% YES (ABC)
%\end{verbatim}
\end{itemize}
\end{exercise}

\subsection{Definición de Nombres de Patrones}
Perl 5.10 introduce la posibilidad de definir 
subpatrones en una sección del patrón. 

\parrafo{Lo que dice {\tt perlretut} sobre la definición de nombres de patrones}

Citando la sección {\it Defining named patterns}
en el documento \pd{perlretut}{Defining-named-patterns} para
perl5.10:

\begin{it}
\begin{quotation}
Some regular expressions use identical subpatterns in several
places. Starting with Perl 5.10, it is possible to define named
subpatterns in a section of the pattern so that they can be called up by
name anywhere in the pattern. 
This syntactic pattern for this definition group is
\verb|"(?(DEFINE)(?<name>pattern)...)"|  
An
insertion of a named pattern is written as \verb"(?&name)".
\end{quotation}
\end{it}

Veamos un ejemplo que define el lenguaje de los números en punto flotante:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n definingnamedpatterns.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3
 4  my $regexp = qr{
 5     ^ (?<num>
 6               (?&osg)[\t\ ]* (?: (?&int)(?&dec)? | (?&dec) )
 7       )
 8       (?: [eE]
 9       (?<exp> (?&osg)(?&int)) )?
10     $
11        (?(DEFINE)
12         (?<osg>[-+]?)         # optional sign
13         (?<int>\d++)          # integer
14         (?<dec>\.(?&int))     # decimal fraction
15        )
16  }x;
17
18  my $input = <>;
19  chomp($input);
20  my @r;
21  if (@r = $input =~ $regexp) {
22    my $exp = $+{exp} || '';
23    say "$input matches: (num => '$+{num}', exp => '$exp')";
24  }
25  else {
26    say "does not match";
27  }
\end{verbatim}
\perldoc{perlretut} comenta sobre este ejemplo:
\begin{it}
\begin{quotation}
The example above illustrates this feature.
The three subpatterns that
are used more than once are the optional sign, 
the digit sequence for
an integer 
and the decimal fraction. The \verb|DEFINE| 
group at the end of
the pattern contains their definition. Notice that the decimal fraction
pattern is the first place where we can reuse the integer pattern.
\end{quotation}
\end{it}


\parrafo{Lo que dice {\tt perlre} sobre la definición de patrones}

Curiosamente, \verb|(DEFINE)| se considera un caso particular de 
las expresiones regulares condicionales de la forma \verb|(?(condition)yes-pattern)|
(véase la sección \ref{subsection:regexpcondicionales}).
Esto es lo que dice \pd{perlre}{Extended-Patterns} al respecto:
\begin{it}
\begin{quotation}
A special form is the \verb|(DEFINE)|  predicate, which never executes
directly its yes-pattern, and does not allow a no-pattern. This allows
to define subpatterns which will be executed only by using the recursion
mechanism. This way, you can define a set of regular expression rules
that can be bundled into any pattern you choose.

It is recommended that for this usage you put the \verb|DEFINE| block at the
end of the pattern, and that you name any subpatterns defined within it.

Also, it's worth noting that patterns defined this way probably will not
be as efficient, as the optimiser is not very clever about handling them.

An example of how this might be used is as follows:

\begin{verbatim}
   1. /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
   2.        (?(DEFINE)
   3.          (?<NAME_PAT>....)
   4.          (?<ADRESS_PAT>....)
   5. )/x
\end{verbatim}

Note that {\bf capture buffers matched inside of recursion are not accessible
after the recursion returns}, so the extra layer of capturing buffers is
necessary. Thus \verb|$+{NAME_PAT}| would not be defined even though 
\verb|$+{NAME}|
would be.
\end{quotation}
\end{it}

\parrafo{Lo que dice {\tt perlvar} sobre patrones con nombre}
Esto es lo que dice \perldoc{perlvar} respecto a las variables implicadas \verb|%+|
y \verb|%-|. Con respecto a el hash \verb|%+|:

\begin{it}
\begin{quotation}
\begin{itemize}
\item \verb|%LAST_PAREN_MATCH|, \verb|%+|

Similar to \verb|@+| , the \verb|%+| hash allows access to the named capture buffers,
should they exist, in the last successful match in the currently active
dynamic scope.

For example, \verb|$+{foo}| is equivalent to \verb|$1| after the following match:

\begin{verbatim}
   1. 'foo' =~ /(?<foo>foo)/;
\end{verbatim}

The keys of the \verb|%+| hash list only the names of buffers that have
captured (and that are thus associated to defined values).

The underlying behaviour of \verb|%+| is provided by the \cpan{Tie::Hash::NamedCapture} 
module.

Note: \verb|%-| and \verb|%+| are tied views into a common internal
hash associated with the last successful regular expression. Therefore
mixing iterative access to them via \verb|each| may have unpredictable
results. Likewise, if the last successful match changes, then the results
may be surprising.

\item \verb|%-|

Similar to \verb|%+| , this variable allows access to the named capture
buffers in the last successful match in the currently active dynamic
scope. {\bf To each capture buffer name found in the regular expression,
it associates a reference to an array containing the list of values
captured by all buffers with that name (should there be several of them),
in the order where they appear}.

Here's an example:

\begin{verbatim}
   1. if ('1234' =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
   2.   foreach my $bufname (sort keys %-) {
   3.     my $ary = $-{$bufname};
   4.     foreach my $idx (0..$#$ary) {
   5.       print "\$-{$bufname}[$idx] : ",
   6.             (defined($ary->[$idx]) ? "'$ary->[$idx]'" : "undef"),
   7.             "\n";
   8.     }
   9.   }
  10. }
\end{verbatim}

would print out:

\begin{verbatim}
   1. $-{A}[0] : '1'
   2. $-{A}[1] : '3'
   3. $-{B}[0] : '2'
   4. $-{B}[1] : '4'
\end{verbatim}

The keys of the \verb|%-| hash correspond to all buffer names found in
the regular expression.

\end{itemize}
\end{quotation}
\end{it}

\subsection{Patrones Recursivos}

Perl 5.10 introduce la posibilidad de definir 
subpatrones en una sección del patrón. 
Citando la versión del documento \perldoc{perlretut} para
perl5.10:

\begin{it}
\begin{quotation}
This feature (introduced in Perl 5.10) significantly extends the power
of Perl’s pattern matching.  By referring to some other capture group
anywhere in the
pattern with the construct \verb"(?group-ref)", the pattern within the
referenced group is used as an independent subpattern in place of the
group reference itself.
Because the group reference may be contained within the group it refers
to, it is now possible to apply pattern matching to tasks that hitherto
required a
recursive parser.

...

In \verb"(?...)" both absolute and relative backreferences may be used.  
The entire pattern can be reinserted with \verb"(?R)" or \verb"(?0)".  If you prefer to name your
buffers, you can use \verb"(?&name)" to recurse into that buffer.
\end{quotation}
\end{it}

\parrafo{Palíndromos}
\label{parrafo:palabrapalindromos}

Véase un ejemplo que reconoce los palabra-palíndromos (esto es, 
la lectura directa y la inversa  de la cadena
pueden diferir en los signos de puntuación):

\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n palindromos.pl
  1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  2  use v5.10;
  3
  4  my $regexp = qr/^(\W*
  5                       (?:
  6                             (\w) (?1) \g{-1}  # palindromo estricto
  7                           |
  8                             \w?               # no recursiva
  9                       )
 10                    \W*)$/ix;
 11
 12  my $input = <>;
 13  chomp($input);
 14  if ($input =~ $regexp) {
 15    say "$input is a palindrome";
 16  }
 17  else {
 18    say "does not match";
 19  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano<span class="synIdentifier">@millo</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n palindromos</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
     <span class="synConstant">3</span>
     <span class="synConstant">4</span>  <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span>
<span class="synConstant">     5                       </span><span class="synSpecial">(?:</span>
<span class="synConstant">     6                             </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\g</span><span class="synConstant">{-1}  # palindromo estricto</span>
<span class="synConstant">     7                           |</span>
<span class="synConstant">     8                             </span><span class="synSpecial">\w?</span><span class="synConstant">               # no recursiva</span>
<span class="synConstant">     9                       </span><span class="synSpecial">)</span>
<span class="synConstant">    10                    </span><span class="synSpecial">\W*)</span><span class="synConstant">$/ix</span>;
    <span class="synConstant">11</span>
    <span class="synConstant">12</span>  <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
    <span class="synConstant">13</span>  <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
    <span class="synConstant">14</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
    <span class="synConstant">15</span>    say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome&quot;</span>;
    <span class="synConstant">16</span>  }
    <span class="synConstant">17</span>  <span class="synStatement">else</span> {
    <span class="synConstant">18</span>    say <span class="synConstant">&quot;does not match&quot;</span>;
    <span class="synConstant">19</span>  }
</pre>

\end{rawhtml}
%}}}


\begin{exercise}
¿Cuál es el efecto del modificador \verb|i|
en la regexp \verb#qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix#?
\end{exercise}


Siguen algunos ejemplos de ejecución\footnote{
\begin{itemize}
\item saippuakauppias: Vendedor de jabón (suomi)
\item yam: batata (inglés)
\item cam: leva
\end{itemize}
}
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a canal: Panama!
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a cam, a yak, a yam, a canal – Panama!
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
saippuakauppias
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
dfghjgfd
does not match
pl@nereida:~/Lperltesting$ ./palindromos.pl
...,;;;;
...,;;;; is a palindrome
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a canal: Panama!</span>
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cam, a yak, a yam, a canal – Panama!</span>
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!</span>
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">saippuakauppias</span>
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">dfghjgfd</span>
does not match
<span class="dbuser">pl@nereida:~/Lperltesting$ ./palindromos.pl</span>
<span class="dbuser">...,;;;;</span>
...,;;;; is a palindrome
</pre>
\end{rawhtml}
%}}}

\parrafo{Lo que dice {\tt perlre} sobre recursividad}


\begin{it}
\begin{quotation}
\verb|(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)|

Similar to \verb|(??{ code })| (véase la sección
\ref{subsection:tiempodematching})
except it does not involve compiling any code,
instead it treats the contents of a capture buffer as an independent
pattern that must match at the current position. Capture buffers
contained by the pattern will have the value as determined by the
outermost recursion.

\verb|PARNO| is a sequence of digits (not starting with 0) whose value
reflects the paren-number of the capture buffer to recurse to. 

\verb|(?R)|
recurses to the beginning of the whole pattern. \verb|(?0)| is an alternate
syntax for \verb|(?R)|. 

If \verb|PARNO| is preceded by a plus or minus sign then it
is assumed to be relative, with negative numbers indicating preceding
capture buffers and positive ones following. Thus (?-1) refers to the
most recently declared buffer, and (?+1) indicates the next buffer to
be declared. 

Note that the counting for relative recursion differs from
that of relative backreferences, in that with recursion unclosed buffers
are included.
\end{quotation}
\end{it}
Hay una diferencia fundamental entre \verb|\g{-1}| y \verb|(?-1)|.
El primero significa {\it lo que casó con el último paréntesis}.
El segundo significa que se debe {\it llamar a la expresión regular 
que define el último paréntesis}. Véase un ejemplo:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1>  x ($a = "12 aAbB 34") =~ s/([aA])(?-1)(?+1)([bB])/-\1\2-/g
0  1
  DB<2> p $a
12 -aB- 34
\end{verbatim}

En \perldoc{perlre} también se comenta sobre este punto:
\begin{it}\begin{quotation} 
If there is no corresponding capture buffer defined, then it is a fatal
error. Recursing deeper than 50 times without consuming any input string
will also result in a fatal error. The maximum depth is compiled into
perl, so changing it requires a custom build.
\end{quotation}
\end{it}


\parrafo{Paréntesis Equilibrados}

El siguiente programa (inspirado en uno
que aparece en \perldoc{perlre})
reconoce una llamada a una función \verb|foo()|
que puede contener una secuencia de expresiones con paréntesis equilibrados
como argumento:

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat perlrebalancedpar.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
  3  use v5.10;
  4  use strict;
  5  
  6  my $regexp = qr{ (                      # paren group 1 (full function)
  7                  foo
  8                     (                    # paren group 2 (parens)
  9                       \(
 10                          (               # paren group 3 (contents of parens)
 11                             (?:
 12                                  [^()]+  # Non-parens
 13                                |
 14                                  (?2) # Recurse to start of paren group 2
 15                             )*
 16                          )               # 3
 17                       \)
 18                      )                   # 2
 19                )                         # 1
 20      }x;
 21  
 22  my $input = <>;
 23  chomp($input);
 24  my @res = ($input =~ /$regexp/);
 25  if (@res) {
 26    say "<$&> is balanced\nParen: (@res)";
 27  }
 28  else {
 29    say "does not match";
 30  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat perlrebalancedpar</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span>  <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(</span><span class="synConstant">                      # paren group 1 </span><span class="synSpecial">(</span><span class="synConstant">full function</span><span class="synSpecial">)</span>
<span class="synLinenum">    7</span> <span class="synConstant">                foo</span>
<span class="synLinenum">    8</span> <span class="synConstant">                   </span><span class="synSpecial">(</span><span class="synConstant">                    # paren group 2 </span><span class="synSpecial">(</span><span class="synConstant">parens</span><span class="synSpecial">)</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">\(</span>
<span class="synLinenum">   10</span> <span class="synConstant">                        </span><span class="synSpecial">(</span><span class="synConstant">               # paren group 3 </span><span class="synSpecial">(</span><span class="synConstant">contents of parens</span><span class="synSpecial">)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                </span><span class="synSpecial">[^()]+</span><span class="synConstant">  # Non-parens</span>
<span class="synLinenum">   13</span> <span class="synConstant">                              |</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                </span><span class="synSpecial">(?</span><span class="synConstant">2</span><span class="synSpecial">)</span><span class="synConstant"> # Recurse to start of paren group 2</span>
<span class="synLinenum">   15</span> <span class="synConstant">                           </span><span class="synSpecial">)*</span>
<span class="synLinenum">   16</span> <span class="synConstant">                        </span><span class="synSpecial">)</span><span class="synConstant">               # 3</span>
<span class="synLinenum">   17</span> <span class="synConstant">                     </span><span class="synSpecial">\)</span>
<span class="synLinenum">   18</span> <span class="synConstant">                    </span><span class="synSpecial">)</span><span class="synConstant">                   # 2</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span><span class="synConstant">                         # 1</span>
<span class="synLinenum">   20</span> <span class="synConstant">    }x</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">my</span> <span class="synIdentifier">@res</span> = (<span class="synIdentifier">$input</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$regexp</span><span class="synStatement">/</span>);
<span class="synLinenum">   25</span> <span class="synStatement">if</span> (<span class="synIdentifier">@res</span>) {
<span class="synLinenum">   26</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; is balanced</span><span class="synSpecial">\n</span><span class="synConstant">Paren: (</span><span class="synIdentifier">@res</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   27</span> }
<span class="synLinenum">   28</span> <span class="synStatement">else</span> {
<span class="synLinenum">   29</span>   say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   30</span> }
</pre>

\end{rawhtml}
%}}}
Al ejecutar obtenemos:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./perlrebalancedpar.pl
foo(bar(baz)+baz(bop))
<foo(bar(baz)+baz(bop))> is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$  <span class="dbuser">./perlrebalancedpar.pl</span>
<span class="dbuser">foo(bar(baz)+baz(bop))</span>
&lt;foo(bar(baz)+baz(bop))&gt; is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
</pre>
\end{rawhtml}
%}}}



Como se comenta en \perldoc{perlre} es conveniente usar 
índices relativos si se quiere tener una expresión regular reciclable:

\begin{it}
\begin{quotation}
The following shows how using negative indexing can make it easier to
embed recursive patterns inside of a \verb|qr//| construct for later use:

\begin{verbatim}
   1. my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
   2. if (/foo $parens \s+ + \s+ bar $parens/x) {
   3.   # do something here...
   4. }
\end{verbatim}
\end{quotation} 
\end{it}
Véase la sección 
\ref{subsection:cuantificadoresposesivos}
para comprender el uso de los operadores posesivos como \verb|++|.

\parrafo{Capturando los bloques de un programa}
\label{parrafo:bloquesanidados}

El siguiente programa presenta una heurística 
para determinar los bloques de un programa:

\begin{latexonly}
\begin{verbatim}
  1    pl@nereida:~/Lperltesting$ cat blocks.pl
  2    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3    use v5.10;
  4    use strict;
  5    #use re 'debug';
  6    
  7    my $rb = qr{(?x)
  8        (
  9          \{               # llave abrir
 10             (?:
 11                 [^{}]++   # no llaves
 12             |
 13                  [^{}]*+  # no llaves
 14                  (?1)     # recursivo
 15                  [^{}]*+  # no llaves
 16             )*+
 17           \}              # llave cerrar
 18        )
 19      };
 20    
 21    local $/ = undef;
 22    my $input = <>;
 23    my@blocks = $input =~ m{$rb}g;
 24    my $i = 0;
 25    say($i++.":\n$_\n===") for @blocks;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span>   pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocks</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span>   <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span>   
<span class="synLinenum">    7</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">      </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">        </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">               </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">           |</span>
<span class="synLinenum">   13</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   14</span> <span class="synConstant">                </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">     # recursivo</span>
<span class="synLinenum">   15</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   16</span> <span class="synConstant">           </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   17</span> <span class="synConstant">         </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">    }</span>;
<span class="synLinenum">   20</span>   
<span class="synLinenum">   21</span>   <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   25</span>   say(<span class="synIdentifier">$i</span>++.<span class="synConstant">&quot;:</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">===&quot;</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>

\end{rawhtml}
%}}}

Veamos una ejecución. Le daremos como entrada el siguiente programa:
Al ejecutar el programa con esta entrada obtenemos:

\begin{tabular}{|p{8cm}|p{8cm}|}
\hline
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n blocks.c
     1  main() { /* 1 */
     2    { /* 2 */ }
     3    { /* 3 */ }
     4  }
     5
     6  f(){  /* 4 */
     7    {   /* 5 */
     8      { /* 6 */ }
     9    }
    10    {   /* 7 */
    11      { /* 8 */ }
    12    }
    13  }
    14
    15  g(){ /* 9 */
    16  }
    17
    18  h() {
    19  {{{}}}
    20  }
    21  /* end h */
\end{verbatim}
&
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 blocks.pl blocks.c
0:
{ /* 1 */
  { /* 2 */ }
  { /* 3 */ }
}
===
1:
{  /* 4 */
  {   /* 5 */
    { /* 6 */ }
  }
  {   /* 7 */
    { /* 8 */ }
  }
}
===
2:
{ /* 9 */
}
===
3:
{
{{{}}}
}
===
\end{verbatim}
\\
\hline
\end{tabular}

\parrafo{Reconocimiento de Lenguajes Recursivos: Un subconjunto de \LaTeX{}}
\label{subsection:regexp510lenrec}

La posibilidad de combinar en las expresiones regulares Perl 5.10 
la recursividad con los constructos \verb|(?<name>...)| 
y \verb|?&name)| así como las secciones \verb|(?(DEFINE) ...)|
permiten la escritura de expresiones regulares que reconocen lenguajes recursivos. 
El siguiente 
ejemplo muestra un reconocedor de un subconjunto del lenguaje 
\LaTeX{} (véase \wikip{la entrada LaTeX en la wikipedia}{LaTeX}):

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat latex5_10.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3  use strict;
  4  use v5.10;
  5  
  6  my $regexp = qr{
  7      \A(?&File)\z
  8  
  9      (?(DEFINE)
 10          (?<File>     (?&Element)*+\s*
 11          )
 12  
 13          (?<Element>  \s* (?&Command)
 14                    |  \s* (?&Literal)
 15          )
 16  
 17          (?<Command>  \\ \s* (?<L>(?&Literal)) \s* (?<Op>(?&Options)?) \s* (?<A>(?&Args))
 18             (?{
 19                say "command: <$+{L}> options: <$+{Op}> args: <$+{A}>"
 20             })
 21          )
 22  
 23          (?<Options>  \[ \s* (?:(?&Option) (?:\s*,\s* (?&Option) )*)? \s* \]
 24          )
 25  
 26          (?<Args>     (?: \{ \s* (?&Element)* \s* \} )*
 27          )
 28  
 29          (?<Option>   \s* [^][\$&%#_{}~^\s,]+
 30          )
 31  
 32          (?<Literal>  \s* ([^][\$&%#_{}~^\s]+)
 33          )
 34      )
 35  }xms;
 36  
 37  my $input = do{ local $/; <>};
 38  if ($input =~ $regexp) {
 39    say "$@: matches:\n$&";
 40  }
 41  else {
 42    say "does not match";
 43  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat latex5_10</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    7</span> <span class="synConstant">    </span><span class="synSpecial">\A(?</span><span class="synConstant">&amp;File</span><span class="synSpecial">)\z</span>
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synConstant">    </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;File&gt;     </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Element</span><span class="synSpecial">)*+\s*</span>
<span class="synLinenum">   11</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> 
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Element&gt;  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Command</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                  |  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Literal</span><span class="synSpecial">)</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Command&gt;  </span><span class="synSpecial">\\</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;L&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Literal</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Op&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Options</span><span class="synSpecial">)?)</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;A&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Args</span><span class="synSpecial">))</span>
<span class="synLinenum">   18</span> <span class="synConstant">           </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   19</span> <span class="synConstant">              say &quot;command: &lt;</span><span class="synIdentifier">$+</span><span class="synConstant">{L}</span>&gt; options: &lt;<span class="synIdentifier">$+</span>{Op}&gt; args: &lt;<span class="synIdentifier">$+</span>{A}&gt;<span class="synConstant">&quot;</span>
<span class="synLinenum">   20</span> <span class="synConstant">           })</span>
<span class="synLinenum">   21</span> <span class="synConstant">        )</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span> <span class="synConstant">        (?&lt;Options&gt;  </span><span class="synSpecial">\[</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?:(?&amp;Option) (?:</span><span class="synSpecial">\s</span><span class="synConstant">*,</span><span class="synSpecial">\s</span><span class="synConstant">* (?&amp;Option) )*)? </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">\]</span>
<span class="synLinenum">   24</span> <span class="synConstant">        )</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">        (?&lt;Args&gt;     (?: </span><span class="synSpecial">&#92;{</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?&amp;Element)* </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">&#92;}</span><span class="synConstant"> )*</span>
<span class="synLinenum">   27</span> <span class="synConstant">        )</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        (?&lt;Option&gt;   </span><span class="synSpecial">\s</span><span class="synConstant">* [^][</span><span class="synSpecial">\$</span><span class="synConstant">&amp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">,]+</span>
<span class="synLinenum">   30</span> <span class="synConstant">        )</span>
<span class="synLinenum">   31</span> 
<span class="synLinenum">   32</span> <span class="synConstant">        (?&lt;Literal&gt;  </span><span class="synSpecial">\s</span><span class="synConstant">* ([^][</span><span class="synSpecial">\$</span><span class="synConstant">&amp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">]+)</span>
<span class="synLinenum">   33</span> <span class="synConstant">        )</span>
<span class="synLinenum">   34</span> <span class="synConstant">    )</span>
<span class="synLinenum">   35</span> <span class="synConstant">}xms;</span>
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span> <span class="synConstant">my </span><span class="synIdentifier">$input</span><span class="synConstant"> = do{ local </span><span class="synIdentifier">$/</span><span class="synConstant">; &lt;&gt;};</span>
<span class="synLinenum">   38</span> <span class="synConstant">if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$regexp</span><span class="synConstant">) {</span>
<span class="synLinenum">   39</span> <span class="synConstant">  say &quot;</span><span class="synIdentifier">$@</span>: matches:\n<span class="synIdentifier">$&amp;</span><span class="synConstant">&quot;;</span>
<span class="synLinenum">   40</span> <span class="synConstant">}</span>
<span class="synLinenum">   41</span> <span class="synConstant">else {</span>
<span class="synLinenum">   42</span> <span class="synConstant">  say &quot;</span>does <span class="synStatement">not</span> match<span class="synConstant">&quot;;</span>
<span class="synLinenum">   43</span> <span class="synConstant">}</span>
</pre>

\end{rawhtml}
%}}}


Añadimos una acción semántica al final de la aceptación de un \verb|<Command>|.

\begin{verbatim}
         (?<Command>  \\ \s* (?<L>(?&Literal)) \s* (?<Op>(?&Options)?) \s* (?<A>(?&Args)?)
            (?{
               say "command: <$+{L}> options: <$+{Op}> args: <$+{A}>"
            })
         )
\end{verbatim}
Esta acción es ejecutada pero no afecta al proceso de análisis.
(véase la sección
\ref{subsection:codigoenregexp} para mas información sobre las acciones semánticas
en medio de una regexp).
La acción se limita a mostrar que ha casado con cada una de las tres componentes:
el comando, las opciones y los argumentos.

Los paréntesis adicionales, como en \verb|(?<L>(?&Literal))| son necesarios 
para guardar lo que casó.

Cuando se ejecuta produce la siguiente salida\footnote{
\begin{itemize}
\item peasy:A disagreeable taste of very fresh green peas
\item easy peasy: 
\begin{enumerate}
  \item (uk) very easy (short for easy-peasy-lemon-squeezy) 
  \item         
  the first half of a rhyming phrase with several alternate second halves,
  all of which connote an activity or a result that is, respectively,
  simple to perform or achieve.

\begin{it}
\begin{verse}
  Tie your shoes? Why that's easy peasy lemon squeezy!\\
  Beat your meat? Why that's easy peasy Japanesey!\\
  As a red-stater, condemn books and films without having read or seen them? Why that's easy peasy puddin'n'pie!\\
\end{verse}
\end{it}
  \item
  It comes from a 1970's british TV commercial for Lemon Squeezy
  detergent. They were with a little girl who points out dirty greasy
  dishes to an adult (mom or relative) and then this adult produces
  Lemon Squeezy and they clean the dishes quickly. At the end of the
  commercial the girl says {\it Easy Peasy Lemon Squeezy}.

  Today it is a silly way to state something was or will be very easy. 
\end{enumerate}
\end{itemize}
}: % end footnote
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat prueba.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba.tex
command: <documentclass> options: <[a4paper,11pt]> args: <{article}>
command: <usepackage> options: <> args: <{latexsym}>
command: <author> options: <> args: <{D. Conway}>
command: <LaTeX> options: <> args: <{}>
command: <title> options: <> args: <{Parsing \LaTeX{}}>
command: <begin> options: <> args: <{document}>
command: <maketitle> options: <> args: <>
command: <tableofcontents> options: <> args: <>
command: <section> options: <> args: <{Description}>
command: <emph> options: <> args: <{necessarily}>
command: <footnote> options: <> args: <{But not\\ \emph{necessarily} simple}>
command: <end> options: <> args: <{document}>
: matches:
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}

\end{verbatim}
La siguiente entrada \verb|prueba3.tex| no pertenece
al lenguaje definido por el patrón regular,
debido a la presencia de la cadena \verb|$In$|
en la última línea:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat prueba3.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
\comm{a}{b}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
$In$ fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba3.tex
command: <documentclass> options: <[a4paper,11pt]> args: <{article}>
command: <usepackage> options: <> args: <{latexsym}>
command: <author> options: <> args: <{D. Conway}>
command: <LaTeX> options: <> args: <{}>
command: <title> options: <> args: <{Parsing \LaTeX{}}>
command: <begin> options: <> args: <{document}>
command: <maketitle> options: <> args: <>
command: <tableofcontents> options: <> args: <>
command: <section> options: <> args: <{Description}>
command: <comm> options: <> args: <{a}{b}>
command: <emph> options: <> args: <{necessarily}>
command: <footnote> options: <> args: <{But not\\ \emph{necessarily} simple}>
does not match
\end{verbatim}

\begin{exercise}
Obsérvese el uso del cuantificador posesivo en:
\begin{verbatim}
 10          (?<File>     (?&Element)*+\s*
 11          )
\end{verbatim}
¿Que ocurrre si se quita el posesivo 
y se vuelve a ejecutar \verb|$ ./latex5_10.pl prueba3.tex|?
\end{exercise}

\parrafo{Reconocimiento de Expresiones Aritméticas}

Véase el nodo \pmm{585167}{Complex regex for maths formulas}
en perlmonks
para la formulación del problema. Un monje pregunta:

\begin{it}\begin{quotation} 
Hiya monks,

Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...

There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than \verb|a-z,A-Z,0-9,+,-,*,/,(,)| can be used

Can anyone offer a hand on how best to tackle this problem?

many thanks 
\end{quotation}\end{it} 

La solución parte de que una {\it expresión} es o bien un {\it término} o bien 
un {\it término} seguido de una operador y un {\it término}, esto es:

\begin{itemize}
\item \verb|termino|
\item \verb|termino op termino op termino| \ldots
\end{itemize}
que puede ser unificado como \verb|termino (op termino)*|.
  
Un {\it término} es un número o un identificador o una {\it expresión}
entre paréntesis, esto es:

\begin{itemize}
\item \verb|numero|
\item \verb|identificador|
\item \verb| ( expresión ) |
\end{itemize}
 
 La siguiente expresión regular recursiva sigue esta idea:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3    use strict;
  4    use warnings;
  5  
  6    local our ($skip, $term, $expr);
  7    $skip = qr/\s*/;
  8    $expr = qr{ (?<EXPR>
  9                       (?<TERM>              # An expression is a TERM  ...
 10                              $skip (?<ID>[a-zA-Z]+)
 11                            | $skip (?<INT>[1-9]\d*)
 12                            | $skip \(
 13                              $skip  (?&EXPR)
 14                              $skip \)
 15                       ) (?: $skip           # possibly followed by a sequence of ...
 16                             (?<OP>[-+*/])
 17                             (?&TERM)        # ... operand TERM pairs
 18                         )*
 19                )
 20              }x;
 21    my $re = qr/^ $expr $skip \z/x;
 22    sub is_valid { shift =~ /$re/o }
 23  
 24    my @test = ( '(a + 3)', '(3 * 4)+(b + x)', '(5 - a)*z',
 25                  '((5 - a))*((((z)))+2)', '3 + 2', '!3 + 2', '3 + 2!',
 26                  '3 a', '3 3', '3 * * 3',
 27                  '2 - 3 * 4',  '2 - 3 + 4',
 28                );
 29    foreach (@test) {
 30      say("$_:");
 31      say(is_valid($_) ? "\n<$_> is valid" : "\n<$_> is not valid")
 32    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    7</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;EXPR&gt;</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">&lt;TERM&gt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;ID&gt;</span><span class="synSpecial">[a-zA-Z]+)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;INT&gt;</span><span class="synSpecial">[1-9]\d*)</span>
<span class="synLinenum">   12</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\(</span>
<span class="synLinenum">   13</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">&amp;EXPR</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\)</span>
<span class="synLinenum">   15</span> <span class="synConstant">                     </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant">           # possibly followed by a sequence of </span><span class="synSpecial">...</span>
<span class="synLinenum">   16</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">&lt;OP&gt;</span><span class="synSpecial">[-+*/])</span>
<span class="synLinenum">   17</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">&amp;TERM</span><span class="synSpecial">)</span><span class="synConstant">        # </span><span class="synSpecial">...</span><span class="synConstant"> operand TERM pairs</span>
<span class="synLinenum">   18</span> <span class="synConstant">                       </span><span class="synSpecial">)*</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   20</span> <span class="synConstant">            }x</span>;
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   22</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   25</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   26</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   28</span>               );
<span class="synLinenum">   29</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   30</span>     say(<span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant">:&quot;</span>);
<span class="synLinenum">   31</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is valid&quot;</span> : <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is not valid&quot;</span>)
<span class="synLinenum">   32</span>   }
</pre>

\end{rawhtml}
%}}}
Podemos usar acciones semánticas empotradas para 
ver la forma en la que trabaja la expresión regular
(véase la sección
\ref{subsection:codigoenregexp}):

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3    use strict;
  4    use warnings;
  5  
  6    use re 'eval'; # to allow Eval-group at runtime
  7  
  8    local our ($skip, $term, $expr);
  9    $skip = qr/\s*/;
 10    $expr = qr{ (?<EXPR>
 11                       (?<TERM>              # An expression is a TERM  ...
 12                              $skip (?<ID>[a-zA-Z]+)  (?{ print "[ID $+{ID}] "  })
 13                            | $skip (?<INT>[1-9]\d*)  (?{ print "[INT $+{INT}] " })
 14                            | $skip \(                (?{ print "[(] " })
 15                              $skip  (?&EXPR)
 16                              $skip \)                (?{ print "[)] " })
 17                       ) (?: $skip           # possibly followed by a sequence of ...
 18                             (?<OP>[-+*/])            (?{ print "[OP $+{OP}] " })
 19                             (?&TERM)        # ... operand TERM pairs
 20                         )*
 21                )
 22              }x;
 23    my $re = qr/^ $expr $skip \z/x;
 24    sub is_valid { shift =~ /$re/o }
 25  
 26    my @test = ( '(a + 3)', '(3 * 4)+(b + x)', '(5 - a)*z',
 27                  '((5 - a))*((((z)))+2)', '3 + 2', '!3 + 2', '3 + 2!',
 28                  '3 a', '3 3', '3 * * 3',
 29                  '2 - 3 * 4',  '2 - 3 + 4',
 30                );
 31    foreach (@test) {
 32      say("$_:");
 33      say(is_valid($_) ? "\n<$_> is valid" : "\n<$_> is not valid")
 34    }
\end{verbatim}
\end{latexonly}
%{{{ simpleexpressions.pl
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">   10</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;EXPR&gt;</span>
<span class="synLinenum">   11</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">&lt;TERM&gt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   12</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;ID&gt;</span><span class="synSpecial">[a-zA-Z]+)</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">{ print &quot;</span><span class="synSpecial">[ID $+{ID}]</span><span class="synConstant"> &quot;  }</span>)
<span class="synLinenum">   13</span>                           | <span class="synIdentifier">$skip</span> (?<span class="synIdentifier">&lt;INT&gt;</span>[<span class="synConstant">1-9</span>]\d*)  (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[INT </span><span class="synIdentifier">$+</span><span class="synConstant">{INT}] &quot;</span> })
<span class="synLinenum">   14</span>                           | <span class="synIdentifier">$skip</span> \(                (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[(] &quot;</span> })
<span class="synLinenum">   15</span>                             <span class="synIdentifier">$skip</span>  (?<span class="synIdentifier">&amp;EXPR</span>)
<span class="synLinenum">   16</span>                             <span class="synIdentifier">$skip</span> \)                (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[)] &quot;</span> })
<span class="synLinenum">   17</span>                      ) (?: <span class="synIdentifier">$skip</span>           <span class="synComment"># possibly followed by a sequence of ...</span>
<span class="synLinenum">   18</span>                            (?<span class="synIdentifier">&lt;OP&gt;</span>[-+*/])            (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[OP </span><span class="synIdentifier">$+</span><span class="synConstant">{OP}] &quot;</span> })
<span class="synLinenum">   19</span>                            (?<span class="synIdentifier">&amp;TERM</span>)        <span class="synComment"># ... operand TERM pairs</span>
<span class="synLinenum">   20</span>                        )*
<span class="synLinenum">   21</span>               )
<span class="synLinenum">   22</span>             }x;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   24</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   28</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   29</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   30</span>               );
<span class="synLinenum">   31</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   32</span>     say(<span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant">:&quot;</span>);
<span class="synLinenum">   33</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is valid&quot;</span> : <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is not valid&quot;</span>)
<span class="synLinenum">   34</span>   }
</pre>

\end{rawhtml}
%}}}

Ejecución:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./simpleexpressions.pl
(a + 3):
[(] [ID a] [OP +] [INT 3] [)]
<(a + 3)> is valid
(3 * 4)+(b + x):
[(] [INT 3] [OP *] [INT 4] [)] [OP +] [(] [ID b] [OP +] [ID x] [)]
<(3 * 4)+(b + x)> is valid
(5 - a)*z:
[(] [INT 5] [OP -] [ID a] [)] [OP *] [ID z]
<(5 - a)*z> is valid
((5 - a))*((((z)))+2):
[(] [(] [INT 5] [OP -] [ID a] [)] [)] [OP *] [(] [(] [(] [(] [ID z] [)] [)] [)] [OP +] [INT 2] [)]
<((5 - a))*((((z)))+2)> is valid
3 + 2:
[INT 3] [OP +] [INT 2]
<3 + 2> is valid
!3 + 2:

<!3 + 2> is not valid
3 + 2!:
[INT 3] [OP +] [INT 2]
<3 + 2!> is not valid
3 a:
[INT 3]
<3 a> is not valid
3 3:
[INT 3]
<3 3> is not valid
3 * * 3:
[INT 3] [OP *]
<3 * * 3> is not valid
2 - 3 * 4:
[INT 2] [OP -] [INT 3] [OP *] [INT 4]
<2 - 3 * 4> is valid
2 - 3 + 4:
[INT 2] [OP -] [INT 3] [OP +] [INT 4]
<2 - 3 + 4> is valid
\end{verbatim}

\subsection{Cuantificadores Posesivos}
\label{subsection:cuantificadoresposesivos}

Por defecto, cuando un subpatrón con un cuantificador impide que 
el patrón global tenga éxito, se produce un backtrack.
Hay ocasiones en las que esta conducta 
da lugar a ineficiencia.

Perl 5.10 provee los cuantificadores posesivos:
Un cuantificador posesivo actúa como un cuantificador greedy
pero no se produce backtracking.

\begin{tabular}{|p{2cm}|l}
\hline
    \verb|*+| &     Casar 0 o mas veces y no retroceder\\
\hline
    \verb|++| &     Casar 1 o mas veces y no retroceder\\
\hline
    \verb|?+| &     Casar 0 o 1 veces y no retroceder\\
\hline
    \verb|{n}+| &   Casar exactamente n veces y no retroceder (redundante)\\
\hline
    \verb|{n,}+| &  Casar al menos n veces y no retroceder\\
\hline
    \verb|{n,m}+| & Casar al menos n veces y no mas de m veces y no retroceder\\
\hline
\end{tabular}
Por ejemplo, la cadena \verb|'aaaa'| no casa con \verb|/(a++a)/| porque no 
hay retroceso después de leer las 4 aes:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> x 'aaaa' =~ /(a+a)/
0  'aaaa'
  DB<2> x 'aaaa' =~ /(a++a)/
  empty array
\end{verbatim}

\parrafo{Cadenas Delimitadas por Comillas Dobles}

Los operadores posesivos sirven para poder escribir expresiones regulares mas eficientes
en aquellos casos en los que sabemos que el retroceso no conducirá a nuevas soluciones, como
es el caso del reconocimiento de las cadenas delimitadas por 
comillas dobles:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./quotedstrings.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
     2  use v5.10;
     3
     4  my $regexp = qr/
     5    "             # double quote
     6    (?:           # no memory
     7        [^"\\]++  # no " or escape: Don't backtrack
     8      | \\.       # escaped character
     9    )*+
    10    "             # end double quote
    11  /x;
    12
    13  my $input = <>;
    14  chomp($input);
    15  if ($input =~ $regexp) {
    16    say "$& is a string";
    17  }
    18  else {
    19    say "does not match";
    20  }
\end{verbatim}

\parrafo{Paréntesis Posesivos}

Los paréntesis posesivos \verb|(?> ...)| dan lugar a un reconocedor 
que rechaza las demandas de retroceso. 
De hecho, los operadores posesivos pueden ser reescritos 
en términos de los paréntesis posesivos:
La notación \verb|X++| es equivalente a \verb|(?>X+)|.

\parrafo{Paréntesis Balanceados}

El siguiente ejemplo reconoce el lenguaje de los paréntesis balanceados:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./balancedparenthesis.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3
 4  my $regexp =
 5      qr/^(
 6             [^()]*+ # no hay paréntesis, no backtrack
 7            \(
 8                (?>        # subgrupo posesivo
 9                   [^()]++ # no hay paréntesis, + posesivo, no backtrack
10                  |(?1)    # o es un paréntesis equilibrado
11                )*
12             \)
13             [^()]*+ # no hay paréntesis
14           )$/x;
15
16  my $input = <>;
17  chomp($input);
18  if ($input =~ $regexp) {
19    say "$& is a balanced parenthesis";
20  }
21  else {
22    say "does not match";
23  }
\end{verbatim}
Cuando se ejecuta produce una salida como:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5)*2
(2*(3+4)-5)*2 is a balanced parenthesis
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5))*2
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
2*(3+4
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
4*(2*(3+4)-5)*2
4*(2*(3+4)-5)*2 is a balanced parenthesis
\end{verbatim}

\parrafo{Encontrando los bloques de un programa}

El uso de los operadores posesivos nos permite reescribir 
la solución al problema de encontrar los bloques maximales
de un código dada en la
sección
\ref{parrafo:bloquesanidados}
de la siguiente manera:

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat blocksopti.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3  use v5.10;
  4  use strict;
  5  #use re 'debug';
  6  
  7  my $rb = qr{(?x)
  8      (
  9        \{               # llave abrir
 10           (?:
 11               [^{}]++   # no llaves
 12           |
 13               (?1)      # recursivo
 14               [^{}]*+   # no llaves
 15           )*+
 16         \}              # llave cerrar
 17      )
 18    };
 19  
 20  local $/ = undef;
 21  my $input = <>;
 22  my@blocks = $input =~ m{$rb}g;
 23  my $i = 0;
 24  say($i++.":\n$_\n===") for @blocks;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocksopti</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">    </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">      </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">         </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">         |</span>
<span class="synLinenum">   13</span> <span class="synConstant">             </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">      # recursivo</span>
<span class="synLinenum">   14</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   15</span> <span class="synConstant">         </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   16</span> <span class="synConstant">       </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   17</span> <span class="synConstant">    </span><span class="synSpecial">)</span>
<span class="synLinenum">   18</span> <span class="synConstant">  }</span>;
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   21</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   22</span> <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   23</span> <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   24</span> say(<span class="synIdentifier">$i</span>++.<span class="synConstant">&quot;:</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">===&quot;</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>

\end{rawhtml}
%}}}

\parrafo{Véase también}

\begin{itemize}
\item
\htmladdnormallink
{Possessive Quantifiers}
{http://www.regular-expressions.info/possessive.html}
en 
\htmladdnormallink
{http://www.regular-expressions.info/}
{http://www.regular-expressions.info/tutorial.html}
\item 
Nodo \emph{Possessive Quantifiers in Perl 5.10 regexps} en \perlmonk{793521}
\item 
perldoc \perldoc{perlre}
\end{itemize}

\subsection{Perl 5.10: Numeración de los Grupos en Alternativas}

A veces conviene tener una forma de acceso 
uniforme a la lista proporcionada por los paréntesis con memoria.
Por ejemplo, la siguiente expresión regular reconoce el 
lenguaje de las horas en notaciones civil y militar:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> '23:12' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print "1->$1 2->$2\n"
1->23 2->12

  DB<2> '2312' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print "3->$3 4->$4\n"
3->23 4->12
\end{verbatim}
Parece inconveniente tener los resultados en variables distintas.
El constructo \verb#(?| ...)# hace que los paréntesis se enumeren
relativos a las alternativas:

\begin{verbatim}
  DB<3> '2312' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print "1->$1 2->$2\n"
1->23 2->12

  DB<4> '23:12' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print "1->$1 2->$2\n"
1->23 2->12
\end{verbatim}
Ahora en ambos casos \verb|$1| y \verb|$2| contienen las horas y minutos.

%\subsection{Grupos de Captura de Enumeración en Alternativas}
%
%El siguiente texto tomado de la sección 
%Alternative capture group numbering
%de
%\pd{perlretut}{Alternative-capture-group-numbering}
%explica el propósito de esta extensión:
%
%\begin{it}
%\begin{quotation}
%Yet another capturing group numbering technique (also as from Perl
%5.10) deals with the problem of referring to groups within a set of
%alternatives. Consider a pattern for matching a time of the day, civil
%or military style:
%
%\begin{verbatim}
%   1. if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
%   2. # process hour and minute
%   3. }
%\end{verbatim}
%
%Processing the results requires an additional if statement to determine
%whether \verb|$1| and \verb|$2| or \verb|$3| and \verb|$4| contain the goodies. It would be easier if
%we could use buffer numbers 1 and 2 in second alternative as well, and
%this is exactly what the parenthesized construct \verb#(?|...)#, set around an
%alternative achieves. Here is an extended version of the previous pattern:
%
%\begin{verbatim}
%   1. if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){
%   2. print "hour=$1 minute=$2 zone=$3\n";
%   3. }
%\end{verbatim}
%
%Within the alternative numbering group, buffer numbers start at the same
%position for each alternative. After the group, numbering continues with
%one higher than the maximum reached across all the alternatives.
%\end{quotation}
%\end{it}


\subsection{Ejecución de Código dentro de una Expresión Regular}
\label{subsection:codigoenregexp}

Es posible introducir código Perl dentro de una expresión regular.
Para ello se usa la notación \verb|(?{code})|.

El siguiente texto esta tomado de \pd{perlretut}{A-bit-of-magic:-executing-Perl-code-in-a-regular-expression}:

\begin{it}\begin{quote} 
Normally, regexps are a part of Perl expressions. Code evaluation
expressions turn that around by allowing arbitrary Perl code to be a
part of a regexp. A code evaluation expression is denoted (?{code}),
with code a string of Perl statements.

Be warned that this feature is considered experimental, and may be
changed without notice.

Code expressions are zero-width assertions, and the value they return
depends on their environment. 

There are two possibilities: either the
code expression is used as a conditional in a conditional expression
\verb|(?(condition)...)|, or it is not. 
\begin{itemize}
\item \begin{quote} 
If the code expression is a conditional,
the code is evaluated and the result (i.e., the result of the last
statement) is used to determine truth or falsehood. 

\end{quote} \item \begin{quote} If the code expression
is not used as a conditional, the assertion always evaluates true and
the result is put into the special variable \verb|$^R| . The variable \verb|$^R| can
then be used in code expressions later in the regexp
\end{quote}
\end{itemize}
\end{quote}\end{it} 

\parrafo{Resultado de la última ejecución}

Las expresiones de código son \cei{zero-width assertions}: no consumen entrada.
El resultado de la ejecución se salva en la variable especial \verb|$^R|.

Veamos un ejemplo:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> $x = "abcdef"
  DB<2> $x =~ /abc(?{ "Hi mom\n" })def(?{ print $^R })$/
Hi mom
  DB<3> $x =~ /abc(?{ print "Hi mom\n"; 4 })def(?{ print "$^R\n" })/
Hi mom
4
  DB<4> $x =~ /abc(?{ print "Hi mom\n"; 4 })ddd(?{ print "$^R\n" })/ # does not match
  DB<5>                                 
\end{verbatim}
En el último ejemplo (línea \verb|DB<4>|) ninguno de los \verb|print| se ejecuta dado que no hay matching.

\parrafo{El Código empotrado no es interpolado}

Tomado de \pd{perlre}{Extended-Patterns}:

\begin{it}\begin{quote}
This zero-width assertion evaluates any embedded Perl code. It always
succeeds, and its code  is not interpolated. Currently, the rules to
determine where the code  ends are somewhat convoluted.
\end{quote}\end{it}

\parrafo{Contenido del último paréntesis y la variable por defecto en acciones empotradas}

Tomado de \pd{perlre}{Extended-Patterns}:
\begin{it}\begin{quote}
\ldots{} can be used with the special variable \verb|$^N| to
capture the results of submatches in variables without having to keep
track of the number of nested parentheses. For example:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> $x = "The brown fox jumps over the lazy dog"
  DB<2> x $x =~ /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i
0  'brown'
1  'fox'
  DB<3> p "color=$color animal=$animal\n"
color=brown animal=fox
  DB<4> $x =~ /the (\S+)(?{ print (substr($_,0,pos($_)))."\n" }) (\S+)/i
The brown
\end{verbatim}

Inside the \verb|(?{...})| block, \verb|$_| refers to the string the
regular expression is matching against. You can also use \verb|pos()| to know
what is the current position of matching within this string.
\end{quote}\end{it}

\parrafo{Los cuantificadores y el código empotrado}

Si se usa un cuantificador sobre un código empotrado,
actúa como un bucle:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> $x = "aaaa"
  DB<2>  $x =~ /(a(?{ $c++ }))*/
  DB<3> p $c
4
  DB<4> $y = "abcd"
  DB<5> $y =~ /(?:(.)(?{ print "-$1-\n" }))*/
-a-
-b-
-c-
-d-
\end{verbatim}

\parrafo{Ámbito}

Tomado (y modificado el ejemplo) de \pd{perlre}{Extended-Patterns}:

\begin{it}\begin{quote}
\ldots The code  is properly scoped in the following sense: If the
assertion is backtracked (compare \pd{perlre}{Backtracking}), all changes introduced
after localization are undone, so that

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  use strict;

  our ($cnt, $res);

  sub echo {
 local our $pre = substr($_,0,pos($_));
 local our $post = (pos($_) < length)? (substr($_,1+pos($_))) : '';

 print("$pre(count = $cnt)$post\n");
  }

  $_ = 'a' x 8;
  m<
 (?{ $cnt = 0 }) # Initialize $cnt.
 (
   a
   (?{
     local $cnt = $cnt + 1; # Update $cnt, backtracking-safe.
     echo();
   })
 )*
 aaaa
 (?{ $res = $cnt }) # On success copy to non-localized
 # location.
  >x;

  print "FINAL RESULT: cnt = $cnt res =$res\n";
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  <span class="synStatement">use strict</span>;

  <span class="synStatement">our</span> (<span class="synIdentifier">$cnt</span>, <span class="synIdentifier">$res</span>);

<span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> echo </span>{
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$pre</span> = <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">0</span>,<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>));
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$post</span> = (<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>) &lt; <span class="synStatement">length</span>)? (<span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">1</span>+<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>))) : <span class="synConstant">''</span>;

    <span class="synStatement">print</span>(<span class="synConstant">&quot;</span><span class="synIdentifier">$pre</span><span class="synConstant">(count = </span><span class="synIdentifier">$cnt</span><span class="synConstant">)</span><span class="synIdentifier">$post</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>);
  }

  <span class="synIdentifier">$_</span> = <span class="synConstant">'a'</span> x <span class="synConstant">8</span>;
  m&lt;
    (?{ <span class="synIdentifier">$cnt</span> = <span class="synConstant">0</span> }) <span class="synComment"># Initialize $cnt.</span>
    (
      a
      (?{
        <span class="synStatement">local</span> <span class="synIdentifier">$cnt</span> = <span class="synIdentifier">$cnt</span> + <span class="synConstant">1</span>; <span class="synComment"># Update $cnt, backtracking-safe.</span>
        echo();
      })
    )*
    aaaa
    (?{ <span class="synIdentifier">$res</span> = <span class="synIdentifier">$cnt</span> }) <span class="synComment"># On success copy to non-localized</span>
    <span class="synComment"># location.</span>
  &gt;x;

  <span class="synStatement">print</span> <span class="synConstant">&quot;FINAL RESULT: cnt = </span><span class="synIdentifier">$cnt</span><span class="synConstant"> res =</span><span class="synIdentifier">$res</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
</pre>

\end{rawhtml}
%}}}

will set \verb|$res = 4| . Note that after the match, \verb|$cnt| returns to the
globally introduced value, because the scopes that restrict local
operators are unwound.
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.8.8 -w embededcodescope.pl
a(count = 1)aaaaaa
aa(count = 2)aaaaa
aaa(count = 3)aaaa
aaaa(count = 4)aaa
aaaaa(count = 5)aa
aaaaaa(count = 6)a
aaaaaaa(count = 7)
aaaaaaaa(count = 8)
FINAL RESULT: cnt = 0 res =4
\end{verbatim}
\end{quote}\end{it}

\parrafo{Caveats}

\begin{itemize}
\item
\begin{it}\begin{quote}
Due to an unfortunate implementation issue, the Perl code contained
in these blocks is treated as a compile time \wikip{closure}{/Closure\_(computer\_science)} that can have
seemingly bizarre consequences when used with \wikip{lexically scoped variables}{Static\_scoping\_.28also\_known\_as\_lexical\_scoping.29}
inside of subroutines or loops. There are various workarounds for this,
including simply using global variables instead. If you are using this
construct and strange results occur then check for the use of lexically
scoped variables.
\end{quote}\end{it}
\item
\begin{it}\begin{quote}
For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous \verb|use re 'eval'| pragma has been used (see \cpan{re}),
or the variables
contain results of \verb|qr//| operator (see \verb|"qr/STRING/imosx"| in 
\perldoc{perlop}).

This restriction is due to the wide-spread and remarkably convenient
custom of using run-time determined strings as patterns. For example:

\begin{verbatim}
   1. $re = <>;
   2. chomp $re;
   3. $string =~ /$re/;
\end{verbatim}

Before Perl knew how to execute interpolated code within a pattern, this
operation was completely safe from a security point of view, although
it could raise an exception from an illegal pattern. If you turn on the
\verb|use re 'eval'| , though, it is no longer secure, so you should only do
so if you are also using \wikip{taint}{Taint\_checking} checking. Better yet, use the carefully
constrained evaluation within a \cpan{Safe} compartment. See perlsec for details
about both these mechanisms. (Véase \pd{perlsec}{Taint-mode})
\end{quote}\end{it} 

\item
\begin{it}\begin{quote}
Because Perl's regex engine is currently \emph{not re-entrant}, interpolated
code may not invoke the regex engine either directly with \verb|m//| or 
\verb|s///|, or indirectly with functions such as \perldocf{split}.
\end{quote}\end{it}
\end{itemize}

\parrafo{Depurando con código empotrado Colisiones en los Nombres de las Subexpresiones Regulares}

Las acciones empotradas pueden utilizarse como mecanismo de 
depuración y de descubrimiento del comportamiento de nuestras expresiones 
regulares.

En el siguiente programa se produce una colisión
entre los nombres \verb|<i>| y \verb|<j>| de los patrones 
que ocurren en el patrón \verb|<expr>|
y en el patrón principal:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    my $input;
  5  
  6    local $" = ", ";
  7  
  8    my $parser = qr{
  9        ^ (?<i> (?&expr)) (?<j> (?&expr)) \z
 10          (?{
 11               say "main \$+ hash:";
 12               say " ($_ => $+{$_}) " for sort keys %+;
 13           })
 14  
 15        (?(DEFINE)
 16            (?<expr>
 17                (?<i> . )
 18                (?<j> . )
 19                  (?{
 20                      say "expr \$+ hash:";
 21                      say " ($_ => $+{$_}) " for sort keys %+;
 22                  })
 23            )
 24        )
 25    }x;
 26  
 27    $input = <>;
 28    chomp($input);
 29    if ($input =~ $parser) {
 30      say "matches: ($&)";
 31    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$&quot;</span> = <span class="synConstant">&quot;, &quot;</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;i&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;j&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say &quot;main </span><span class="synSpecial">\$+</span><span class="synConstant"> hash:&quot;;</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say &quot; </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =&gt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?&lt;expr&gt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?&lt;i&gt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?&lt;j&gt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say &quot;</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">&quot;;</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say &quot;</span> (<span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = &lt;&gt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say &quot;</span>matches: (<span class="synIdentifier">$&amp;</span>)<span class="synConstant">&quot;;</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>

\end{rawhtml}
%}}}
La colisión hace que la salida sea esta:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./clashofnamedofssets.pl
abab
expr $+ hash:
 (i => a)
 (j => b)
expr $+ hash:
 (i => ab)
 (j => b)
main $+ hash:
 (i => ab)
 (j => ab)
matches: (abab)
\end{verbatim}
Si se evitan las colisiones, 
se evita la pérdida de información:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    my $input;
  5  
  6    local $" = ", ";
  7  
  8    my $parser = qr{
  9        ^ (?<i> (?&expr)) (?<j> (?&expr)) \z
 10          (?{
 11               say "main \$+ hash:";
 12               say " ($_ => $+{$_}) " for sort keys %+;
 13           })
 14  
 15        (?(DEFINE)
 16            (?<expr>
 17                (?<i_e> . )
 18                (?<j_e> . )
 19                  (?{
 20                      say "expr \$+ hash:";
 21                      say " ($_ => $+{$_}) " for sort keys %+;
 22                  })
 23            )
 24        )
 25    }x;
 26  
 27    $input = <>;
 28    chomp($input);
 29    if ($input =~ $parser) {
 30      say "matches: ($&)";
 31    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$&quot;</span> = <span class="synConstant">&quot;, &quot;</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;i&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;j&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say &quot;main </span><span class="synSpecial">\$+</span><span class="synConstant"> hash:&quot;;</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say &quot; </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =&gt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?&lt;expr&gt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?&lt;i_e&gt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?&lt;j_e&gt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say &quot;</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">&quot;;</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say &quot;</span> (<span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = &lt;&gt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say &quot;</span>matches: (<span class="synIdentifier">$&amp;</span>)<span class="synConstant">&quot;;</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>

\end{rawhtml}
%}}}

que al ejecutarse produce:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./namedoffsets.pl
abab
expr $+ hash:
 (i_e => a)
 (j_e => b)
expr $+ hash:
 (i => ab)
 (i_e => a)
 (j_e => b)
main $+ hash:
 (i => ab)
 (j => ab)
matches: (abab)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expresiones Regulares en tiempo de matching}
\label{subsection:tiempodematching}

Los paréntesis especiales:
\begin{verbatim}
                (??{ Código Perl })
\end{verbatim}
hacen que el \verb|Código Perl| sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular. El match continuará 
intentando casar con la expresión regular retornada.

\parrafo{Paréntesis con memoria dentro de una {\it pattern code expression}}

Los paréntesis en la expresión regular retornada no cuentan
en el patrón exterior. Véase el siguiente 
ejemplo:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
   1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2    use v5.10;
   3    use strict;
   4  
   5    my $r = qr{(?x)                # ignore spaces
   6                ([ab])             # save 'a' or 'b' in \$1
   7                (??{ "($^N)"x3 })  # 3 more of the same as in \$1
   8              };
   9    say "<$&> lastpar = $#-" if 'bbbb' =~ $r;
  10    say "<$&> lastpar = $#-" if 'aaaa' =~ $r;
  11    say "<abab> didn't match" unless 'abab' =~ $r;
  12    say "<aaab> didn't match" unless 'aaab' =~ $r;
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              </span><span class="synSpecial">([ab])</span><span class="synConstant">             # save 'a' or 'b' in </span><span class="synSpecial">\$</span><span class="synConstant">1</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(??</span><span class="synConstant">{ &quot;</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant">&quot;x3 }</span>)  <span class="synComment"># 3 more of the same as in \$1</span>
<span class="synLinenum">    8</span>             };
<span class="synLinenum">    9</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'bbbb'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   10</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'aaaa'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   11</span>   say <span class="synConstant">&quot;&lt;abab&gt; didn't match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'abab'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   12</span>   say <span class="synConstant">&quot;&lt;aaab&gt; didn't match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'aaab'</span> =~ <span class="synIdentifier">$r</span>;
</pre>

\end{rawhtml}%%}}}

Como se ve, hemos accedido desde el código interior 
al último paréntesis usando \verb|$^N|.
Sigue una ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./postponedregexp.pl
<bbbb> lastpar = 1
<aaaa> lastpar = 1
<abab> didn't match
<aaab> didn't match
\end{verbatim}

\parrafo{Ejemplo: Secuencias de dígitos de longitud especificada por el primer dígito}

Consideremos el problema de escribir una expresión regular
que reconoce secuencias no vacías de dígitos tales que la longitud 
de la secuencia restante viene
determinada por el primer dígito.
Esta es una solución:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n intints.pl
   1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2  use v5.10;
   3  use strict;
   4  
   5  my $r = qr{(?x)                # ignore spaces
   6             (\d)                # a digit
   7             ( (??{
   8                 "\\d{$^N}"      # as many as the former
   9               })                # digit says
  10             )
  11            };
  12  say "<$&> <$1> <$2>" if '3428' =~ $r;
  13  say "<$&> <$1> <$2>" if '228' =~ $r;
  14  say "<$&> <$1> <$2>" if '14' =~ $r;
  15  say "24 does not match" unless '24' =~ $r;
  16  say "4324 does not match" unless '4324' =~ $r;
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n intints.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">           </span><span class="synSpecial">(\d)</span><span class="synConstant">                # a digit</span>
<span class="synLinenum">    7</span> <span class="synConstant">           </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">(??</span><span class="synConstant">{</span>
<span class="synLinenum">    8</span> <span class="synConstant">               &quot;</span><span class="synSpecial">\\</span><span class="synConstant">d{</span><span class="synIdentifier">$^</span><span class="synConstant">N}&quot;      # as many as the former</span>
<span class="synLinenum">    9</span> <span class="synConstant">             })                # digit says</span>
<span class="synLinenum">   10</span> <span class="synConstant">           )</span>
<span class="synLinenum">   11</span> <span class="synConstant">          };</span>
<span class="synLinenum">   12</span> <span class="synConstant">say &quot;</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">&quot; if '3428' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   13</span> <span class="synConstant">say &quot;</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">&quot; if '228' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   14</span> <span class="synConstant">say &quot;</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">&quot; if '14' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   15</span> <span class="synConstant">say &quot;24</span> does <span class="synStatement">not</span> match<span class="synConstant">&quot; unless '24' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   16</span> <span class="synConstant">say &quot;4324</span> does <span class="synStatement">not</span> match<span class="synConstant">&quot; unless '4324' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
</pre>

\end{rawhtml}%%}}}

Cuando se ejecuta se obtiene:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./intints.pl
<3428> <3> <428>
<228> <2> <28>
<14> <1> <4>
24 does not match
4324 does not match
\end{verbatim}

\parrafo{Ejemplo: Secuencias de dígitos no repetidos}

Otro ejemplo: queremos escribir una expresión regular que reconozca secuencias
de  \verb|$n| dígitos en las que no todos los dígitos se repiten. Donde quizá \verb|$n| es capturado
de un paréntesis anterior en la expresión regular. Para simplificar la ilustración
de la técnica supongamos que \verb|$n = 7|:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> x join '', map { "(?!".$_."{7})" } 0..9
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB<2> x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
  empty array
  DB<3> x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
0  7777778
  DB<4> x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
  empty array
  DB<5> x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
0  4422444
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~$  <span class="dbuser">perl5.10.1 -wdE 0</span>
main::(-e:1):   0
  DB&lt;1&gt;  <span class="dbuser">x join '', map { "(?!".$_."{7})" } 0..9</span>
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB&lt;2&gt;  <span class="dbuser">x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;3&gt;  <span class="dbuser">x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  7777778
  DB&lt;4&gt;  <span class="dbuser">x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;5&gt;  <span class="dbuser">x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  4422444
</pre>
\end{rawhtml}
%}}}

\parrafo{Palíndromos con independencia del acento}
\label{parrafo:palindromospostregexp}

Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
\ref{parrafo:palabrapalindromos}
para reconocer los palabra-palíndromos. 

Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo {\it dábale arroz a la zorra 
el abad}). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion:
 

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat actionspanishpalin.pl 
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w -CIOEioA
  3  use v5.10;
  4  use strict;
  5  use utf8;
  6  use re 'eval';
  7  use Switch;
  8  
  9  sub f {
 10    my $char = shift;
 11  
 12    switch($char) {
 13      case [ qw{a á} ] { return '[aá]' }
 14      case [ qw{e é} ] { return '[eé]' }
 15      case [ qw{i í} ] { return '[ií]' }
 16      case [ qw{o ó} ] { return '[oó]' }
 17      case [ qw{u ú} ] { return '[uú]' }
 18      else             { return $char  };
 19    }
 20  }
 21  
 22  my $regexp = qr/^(\W* (?: 
 23                              (\w) (?-2)(??{ f($^N) })
 24                            | \w? 
 25                        ) \W*
 26                    )
 27                  $
 28                 /ix;
 29  
 30  my $input = <>; # Try: 'dábale arroz a la zorra el abad';
 31  chomp($input);
 32  if ($input =~ $regexp) {
 33    say "$input is a palindrome";
 34  }
 35  else {
 36    say "$input does not match";
 37  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat actionspanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl </span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>;
<span class="synLinenum">    7</span> <span class="synStatement">use </span>Switch;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synStatement">sub</span><span class="synIdentifier"> f </span>{
<span class="synLinenum">   10</span>   <span class="synStatement">my</span> <span class="synIdentifier">$char</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synStatement">switch</span>(<span class="synIdentifier">$char</span>) {
<span class="synLinenum">   13</span>     case [ <span class="synConstant">qw{a á}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[aá]'</span> }
<span class="synLinenum">   14</span>     case [ <span class="synConstant">qw{e é}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[eé]'</span> }
<span class="synLinenum">   15</span>     case [ <span class="synConstant">qw{i í}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[ií]'</span> }
<span class="synLinenum">   16</span>     case [ <span class="synConstant">qw{o ó}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[oó]'</span> }
<span class="synLinenum">   17</span>     case [ <span class="synConstant">qw{u ú}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[uú]'</span> }
<span class="synLinenum">   18</span>     <span class="synStatement">else</span>             { <span class="synStatement">return</span> <span class="synIdentifier">$char</span>  };
<span class="synLinenum">   19</span>   }
<span class="synLinenum">   20</span> }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">   23</span> <span class="synConstant">                            </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">-2</span><span class="synSpecial">)(??</span><span class="synConstant">{ f</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant"> }</span><span class="synSpecial">)</span>
<span class="synLinenum">   24</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant"> </span>
<span class="synLinenum">   25</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span>
<span class="synLinenum">   26</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">                $</span>
<span class="synLinenum">   28</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   31</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   32</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   33</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome&quot;</span>;
<span class="synLinenum">   34</span> }
<span class="synLinenum">   35</span> <span class="synStatement">else</span> {
<span class="synLinenum">   36</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match&quot;</span>;
<span class="synLinenum">   37</span> }
</pre>

\end{rawhtml}
%}}}

Sigue un ejemplo de ejecución:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
dábale arroz a la zorra el abad
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
éoíúaáuioé
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
dáed
dáed does not match
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$<span class="dbuser"> ./actionspanishpalin.pl </span>
<span class="dbuser">éoíúaáuioé</span>
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dáed</span>
dáed does not match
</pre>
\end{rawhtml}
%}}}


\parrafo{Postponiendo para conseguir recursividad}

Véase el nodo \pmm{585167}{Complex regex for maths formulas}
para la formulación del problema:

\begin{it}\begin{quotation} 
Hiya monks,

Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...

There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than \verb|a-z,A-Z,0-9,+,-,*,/,(,)| can be used

Can anyone offer a hand on how best to tackle this problem?

many thanks 
\end{quotation}\end{it} 

La respuesta dada por \pmm{381608}{ikegami} usa \verb|(?{{ ... })|
para conseguir una conducta recursiva en versiones de perl anteriores a la 5.10:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
  1    #!/usr/bin/perl
  2    use strict;
  3    use warnings;
  4  
  5    sub is_valid_expr {
  6       use re 'eval'; # to allow Eval-group at runtime
  7  
  8       local our ($skip, $term, $expr);
  9       $skip = qr! \s* !x;
 10       $term = qr! $skip [a-zA-Z]+              # A term is an identifier
 11                 | $skip [1-9][0-9]*            # or a number
 12                 | $skip \( (??{ $expr }) $skip # or an expression
 13                         \)
 14                 !x;
 15       $expr = qr! $term                         # A expr is a term
 16                   (?: $skip [-+*/] $term )*     # or a term + a term ...
 17                 !x;
 18  
 19       return $_[0] =~ / ^ $expr $skip \z /x;
 20    }
 21  
 22    print(is_valid_expr($_) ? "$_ is valid\n" : "$_ is not valid\n") foreach (
 23     '(a + 3)',
 24     '(3 * 4)+(b + x)',
 25     '(5 - a)*z',
 26     '3 + 2',
 27  
 28     '!3 + 2',
 29     '3 + 2!',
 30  
 31     '3 a',
 32     '3 3',
 33     '3 * * 3',
 34  
 35     '2 - 3 * 4',
 36     '2 - 3 + 4',
 37    );
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid_expr </span>{
<span class="synLinenum">    6</span>      <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>      <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>      <span class="synIdentifier">$skip</span> = qr! \s* !x;
<span class="synLinenum">   10</span>      <span class="synIdentifier">$term</span> = qr! <span class="synIdentifier">$skip</span> [a-zA-Z]+              <span class="synComment"># A term is an identifier</span>
<span class="synLinenum">   11</span>                | <span class="synIdentifier">$skip</span> [<span class="synConstant">1-9</span>][<span class="synConstant">0-9</span>]*            <span class="synComment"># or a number</span>
<span class="synLinenum">   12</span>                | <span class="synIdentifier">$skip</span> \( (??{ <span class="synIdentifier">$expr</span> }) <span class="synIdentifier">$skip</span> <span class="synComment"># or an expression</span>
<span class="synLinenum">   13</span>                        \)
<span class="synLinenum">   14</span>                !x;
<span class="synLinenum">   15</span>      <span class="synIdentifier">$expr</span> = qr! <span class="synIdentifier">$term</span>                         <span class="synComment"># A expr is a term</span>
<span class="synLinenum">   16</span>                  (?: <span class="synIdentifier">$skip</span> [-+*/] <span class="synIdentifier">$term</span> )*     <span class="synComment"># or a term + a term ...</span>
<span class="synLinenum">   17</span>                !x;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>      <span class="synStatement">return</span> <span class="synIdentifier">$_</span>[<span class="synConstant">0</span>] =~<span class="synStatement"> /</span><span class="synConstant"> ^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant"> </span><span class="synStatement">/x</span>;
<span class="synLinenum">   20</span>   }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">print</span>(is_valid_expr(<span class="synIdentifier">$_</span>) ? <span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span> : <span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant"> is not valid</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>) <span class="synStatement">foreach</span> (
<span class="synLinenum">   23</span>    <span class="synConstant">'(a + 3)'</span>,
<span class="synLinenum">   24</span>    <span class="synConstant">'(3 * 4)+(b + x)'</span>,
<span class="synLinenum">   25</span>    <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   26</span>    <span class="synConstant">'3 + 2'</span>,
<span class="synLinenum">   27</span> 
<span class="synLinenum">   28</span>    <span class="synConstant">'!3 + 2'</span>,
<span class="synLinenum">   29</span>    <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>    <span class="synConstant">'3 a'</span>,
<span class="synLinenum">   32</span>    <span class="synConstant">'3 3'</span>,
<span class="synLinenum">   33</span>    <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span>    <span class="synConstant">'2 - 3 * 4'</span>,
<span class="synLinenum">   36</span>    <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   37</span>   );
</pre>

\end{rawhtml}
%}}}

Sigue el resultado de la ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl complexformula.pl
(a + 3) is valid
(3 * 4)+(b + x) is valid
(5 - a)*z is valid
3 + 2 is valid
!3 + 2 is not valid
3 + 2! is not valid
3 a is not valid
3 3 is not valid
3 * * 3 is not valid
2 - 3 * 4 is valid
2 - 3 + 4 is valid
\end{verbatim}

\parrafo{Caveats}

Estos son algunos puntos a tener en cuenta cuando se usan patrones postpuestos.
Véase la entrada \verb|(??{ code })| en \pd{perlre}{Extended-Patterns}:

\begin{it}\begin{quote}
WARNING: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that has
side effects may not perform identically from version to version due to
the effect of future optimisations in the regex engine.

This is a \cei{postponed regular subexpression}. The code is evaluated at
run time, at the moment this subexpression may match. The result of
evaluation is considered as a regular expression and matched as if it
were inserted instead of this construct. 

The code {\it is not interpolated}. 

As before, the rules to determine where the code ends are currently somewhat convoluted.

Because perl's regex engine is not currently \wikip{re-entrant}{Reentrant_(subroutine)}, delayed code
may not invoke the regex engine either directly with \verb|m//| or \verb|s///|),
or indirectly with functions such as \perldocf{split}.

{\it Recursing} deeper than 50 times without consuming any input string will
result in a fatal error. The maximum depth is compiled into perl, so
changing it requires a custom build.
\end{quote}\end{it}

\subsection{Expresiones Condicionales}
\label{subsection:regexpcondicionales}

Citando a \perldoc{perlre}:

\begin{it}
\begin{quotation}
A conditional expression is a form of if-then-else
statement that allows one to choose which patterns are
to be matched, based on some condition. 

There are two
types of conditional expression: \verb#(?(condition)yes-regexp)# and
\verb#(?(condition)yes-regexp|no-regexp)#. 

\verb#(?(condition)yes-regexp)# is like an
\verb'if () {}' statement in Perl. 
If the condition is true, the yes-regexp
will be matched. If the condition is false, the yes-regexp will be
skipped and Perl will move onto the next regexp element. 

The second form
is like an \verb'if () {} else {}' statement in Perl. If the condition is true,
the yes-regexp will be matched, otherwise the no-regexp will be matched.

The condition can have several forms. 
\begin{itemize}
\item The first form is simply an
integer in parentheses (integer). It is true if the corresponding
backreference \verb|\integer| matched earlier in the regexp. The same thing
can be done with a name associated with a capture buffer, written as
\verb|(<name>)| or \verb#('name')#. 
\item
The second form is a bare zero width assertion
\verb|(?...)|, either a lookahead, a lookbehind, or a code assertion. 

\item
The third set of forms provides tests that return
true if the expression is executed within a recursion \verb|(R)| or is being
called from some capturing group, referenced either by number \verb|(R1|,
or by name \verb#(R&name)#.
\end{itemize}
\end{quotation}
\end{it}

\parrafo{Condiciones: número de paréntesis}

Una expresión condicional puede adoptar diversas formas.
La mas simple es un entero en paréntesis. 
Es cierta si la correspondiente referencia 
\verb|\integer| casó (también se puede usar un nombre
si se trata de un paréntesis con nombre). 

En la expresión regular \verb#/^(.)(..)?(?(2)a|b)/# si el segundo paréntesis
casa, la cadena debe ir seguida de una \verb|a|, si no casa deberá ir seguida de 
una \verb|b|: 

\begin{verbatim}
  DB<1> x 'hola' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  'ol'
  DB<2> x 'ha' =~ /^(.)(..)?(?(2)a|b)/
  empty array
  DB<3> x 'hb' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  undef
\end{verbatim}

\parrafo{Ejemplo: cadenas de la forma {\it una}-otra-otra-{\it una}}

La siguiente búsqueda casa con patrones de la forma 
\verb"$x$x" o \verb"$x$y$y$x":

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> x 'aa' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  undef
  DB<2> x 'abba' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  'b'
  DB<3> x 'abbc' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
  empty array
  DB<4> x 'juanpedropedrojuan' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'juan'
1  'pedro'
\end{verbatim}

%The lookbehind condition allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,
%
%    /[ATGC]+(?(?<=AA)G|C)$/;
%
%matches a DNA sequence such that it either ends in AAG, or some other base pair combination and C. Note that the form is (?(?<=AA)G|C) and not (?((?<=AA))G|C); for the lookahead, lookbehind or code assertions, the parentheses around the conditional are not needed.
%
\parrafo{Condiciones: Código}

Una expresión condicional también puede ser un código:
\begin{verbatim}
  DB<1> $a = 0; print "$&" if 'hola' =~ m{(?(?{$a})hola|adios)} # No hay matching

  DB<2> $a = 1; print "$&" if 'hola' =~ m{(?(?{$a})hola|adios)}
hola
\end{verbatim}

\parrafo{Ejemplo: Cadenas con posible paréntesis inicial (no anidados)}

La siguiente expresión regular utiliza un condicional
para forzar a que si una cadena comienza por un paréntesis
abrir termina con un paréntesis cerrar. Si la cadena 
no comienza por paréntesis abrir no debe existir un paréntesis
final de cierre:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
   1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2    use v5.10;
   3    use strict;
   4  
   5    my $r = qr{(?x)                # ignore spaces
   6                ^
   7                ( \( )?            # may be it comes an open par
   8                [^()]+             # no parenthesis
   9                (?(1)              # did we sart with par?
  10                  \)               # if yes then close par
  11                )
  12                $
  13              };
  14    say "<$&>" if '(abcd)' =~ $r;
  15    say "<$&>" if 'abc' =~ $r;
  16    say "<(abc> does not match" unless '(abc' =~ $r;
  17    say "<abc)> does not match" unless 'abc)' =~ $r;
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              ^</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">\(</span><span class="synConstant"> </span><span class="synSpecial">)?</span><span class="synConstant">            # may be it comes an open par</span>
<span class="synLinenum">    8</span> <span class="synConstant">              </span><span class="synSpecial">[^()]+</span><span class="synConstant">             # no parenthesis</span>
<span class="synLinenum">    9</span> <span class="synConstant">              </span><span class="synSpecial">(?(</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">              # did we sart with par</span><span class="synSpecial">?</span>
<span class="synLinenum">   10</span> <span class="synConstant">                </span><span class="synSpecial">\)</span><span class="synConstant">               # if yes then close par</span>
<span class="synLinenum">   11</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> <span class="synConstant">              $</span>
<span class="synLinenum">   13</span> <span class="synConstant">            }</span>;
<span class="synLinenum">   14</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt;&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'(abcd)'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   15</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt;&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   16</span>   say <span class="synConstant">&quot;&lt;(abc&gt; does not match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'(abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   17</span>   say <span class="synConstant">&quot;&lt;abc)&gt; does not match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'abc)'</span> =~ <span class="synIdentifier">$r</span>;
</pre>

\end{rawhtml}%%}}}

Al ejecutar este programa se obtiene:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./conditionalregexp.pl
<(abcd)>
<abc>
<(abc> does not match
<abc)> does not match
\end{verbatim}

\parrafo{Expresiones Condicionales con {\tt (R)}}

El siguiente ejemplo muestra el uso de la condición \verb|(R)|, la cual comprueba 
si la expresión ha sido evaluada dentro de una recursión:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> x 'bbaaaabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbaaaabb'
  DB<2> x 'bb' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB<3> x 'bab' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB<4> x 'bbabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbabb'
\end{verbatim}
La sub-expresión regular \verb#(?(R)a+|(?0))# dice:
si  esta siendo evaluada recursivamente admite \verb|a+|
si no, evalúa la regexp completa recursivamente.

\parrafo{Ejemplo: Palíndromos con Equivalencia de Acentos Españoles}

Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
\ref{parrafo:palabrapalindromos}
para reconocer los palabra-palíndromos\footnote{
No sé si existe el término. Significa que 
la lectura directa y la inversa 
pueden diferir en los signos de puntuación
}. Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo {\it dábale arroz a la zorra 
el abad}). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion parcial (por
consideraciones de legibilidad sólo se consideran las vocales \verb|a|
y \verb|o|:


\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat spanishpalin.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w -CIOEioA
  3  use v5.10;
  4  use strict;
  5  use utf8;
  6  
  7  my $regexp = qr/^(?<pal>\W* (?: 
  8                              (?<L>(?<a>[áa])|(?<e>[ée])|\w) # letter
  9                              (?&pal)                        # nested palindrome
 10                              (?(<a>)[áa]                    # if is an "a" group
 11                                    |(?:((?<e>)[ée]          # if is an "e" group
 12                                              |\g{L}         # exact match
 13                                        )                    # end if [ée]
 14                                     )                       # end group
 15                              )                              # end if [áa]
 16                            | \w?                            # non rec. case
 17                        ) \W*                                # punctuation symbols
 18                    )
 19                  $
 20                 /ix;
 21  
 22  my $input = <>; # Try: 'dábale arroz a la zorra el abad';
 23  chomp($input);
 24  if ($input =~ $regexp) {
 25    say "$input is a palindrome";
 26  }
 27  else {
 28    say "$input does not match";
 29  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat spanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(?</span><span class="synConstant">&lt;pal&gt;</span><span class="synSpecial">\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">    8</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">&lt;L&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&lt;a&gt;</span><span class="synSpecial">[áa])</span><span class="synConstant">|</span><span class="synSpecial">(?</span><span class="synConstant">&lt;e&gt;</span><span class="synSpecial">[ée])</span><span class="synConstant">|</span><span class="synSpecial">\w)</span><span class="synConstant"> # letter</span>
<span class="synLinenum">    9</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">&amp;pal</span><span class="synSpecial">)</span><span class="synConstant">                        # nested palindrome</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synSpecial">(?(</span><span class="synConstant">&lt;a&gt;</span><span class="synSpecial">)[áa]</span><span class="synConstant">                    # if is an &quot;a&quot; group</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                  |</span><span class="synSpecial">(?:((?</span><span class="synConstant">&lt;e&gt;</span><span class="synSpecial">)[ée]</span><span class="synConstant">          # if is an &quot;e&quot; group</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                            |</span><span class="synSpecial">\g</span><span class="synConstant">{L}         # exact match</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">)</span><span class="synConstant">                    # end if </span><span class="synSpecial">[ée]</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   </span><span class="synSpecial">)</span><span class="synConstant">                       # end group</span>
<span class="synLinenum">   15</span> <span class="synConstant">                            </span><span class="synSpecial">)</span><span class="synConstant">                              # end if </span><span class="synSpecial">[áa]</span>
<span class="synLinenum">   16</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant">                            # non rec</span><span class="synSpecial">.</span><span class="synConstant"> case</span>
<span class="synLinenum">   17</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span><span class="synConstant">                                # punctuation symbols</span>
<span class="synLinenum">   18</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">                $</span>
<span class="synLinenum">   20</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   25</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome&quot;</span>;
<span class="synLinenum">   26</span> }
<span class="synLinenum">   27</span> <span class="synStatement">else</span> {
<span class="synLinenum">   28</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match&quot;</span>;
<span class="synLinenum">   29</span> }
</pre>

\end{rawhtml}
%}}}


Ejecución:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
dábale arroz a la zorra el abad
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
óuuo
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
éaáe
éaáe is a palindrome
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">óuuo</span>
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">éaáe</span>
éaáe is a palindrome
</pre>
\end{rawhtml}
%}}}


Hemos usado la opción \verb|-CIOEioA| para asegurarnos
que los ficheros de entrada/saldia y error y la línea de
comandos estan en modo UTF-8.
(Véase la sección \ref{section:unicode})

Esto es lo que dice la documentación de \perldoc{perlrun }
al respecto:

\begin{it}
\begin{quotation}
The \verb|-C| flag controls some of the Perl Unicode features.

As of 5.8.1, the \verb|-C| can be followed either by a number or a list of option
letters. The letters, their numeric values, and effects are as follows;
listing the letters is equal to summing the numbers.

\begin{verbatim}
  1   I 1 STDIN is assumed to be in UTF-8
  2   O 2 STDOUT will be in UTF-8
  3   E 4 STDERR will be in UTF-8
  4   S 7 I + O + E
  5   i 8 UTF-8 is the default PerlIO layer for input streams
  6   o 16 UTF-8 is the default PerlIO layer for output streams
  7   D 24 i + o
  8   A 32 the @ARGV elements are expected to be strings encoded
  9   in UTF-8
 10   L 64 normally the "IOEioA" are unconditional,
 11   the L makes them conditional on the locale environment
 12   variables (the LC_ALL, LC_TYPE, and LANG, in the order
 13   of decreasing precedence) -- if the variables indicate
 14   UTF-8, then the selected "IOEioA" are in effect
 15   a 256 Set ${^UTF8CACHE} to -1, to run the UTF-8 caching code in
 16   debugging mode.
 \end{verbatim}

For example, \verb|-COE| and \verb|-C6| will both turn on UTF-8-ness
on both \verb|STDOUT| and \verb|STDERR|. Repeating letters is just redundant, not
cumulative nor toggling.

The io options mean that any subsequent \verb|open()| (or similar I/O operations)
will have the \verb|:utf8| PerlIO layer implicitly applied to them, in other
words, \verb|UTF-8| is expected from any input stream, and \verb|UTF-8| is produced
to any output stream. This is just the default, with explicit layers in
\verb|open()| and with \verb|binmode()| one can manipulate streams as usual.

\verb|-C| on its own (not followed by any number or option list), or the empty string 
\verb|""| for the \verb|PERL_UNICODE| environment variable, has the same effect as \verb|-CSDL| . 
In other words, the standard I/O handles and the default\verb|open()| layer are 
UTF-8-fied but only if the locale environment variables indicate a
UTF-8 locale. This behaviour follows the implicit (and problematic)
UTF-8 behaviour of Perl 5.8.0.

You can use \verb|-C0| (or \verb"0" for \verb|PERL_UNICODE| ) to explicitly disable all
the above Unicode features.
\end{quotation}
\end{it}

El pragma \verb|use utf8| hace que se utilice una semántica de
carácteres (por ejemplo, la regexp \verb|/./| casará con un carácter unicode), el
pragma \verb|use bytes| cambia de semántica de caracteres
a semántica de bytes (la regexp \verb/./ casará con un byte).

%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
lhp<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperl</span><span class="synStatement">/s</span>rc/testing$ cat -n dot_utf8_2.pl
     <span class="synConstant">1</span>  <span class="synComment">#!/usr/local/bin/perl -w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use strict</span>;
     <span class="synConstant">3</span>  <span class="synStatement">use utf8</span>;
     <span class="synConstant">4</span>  <span class="synStatement">use </span>charnames <span class="synConstant">qw{greek}</span>;
     <span class="synConstant">5</span>
     <span class="synConstant">6</span>  <span class="synStatement">binmode</span>(<span class="synIdentifier">STDOUT</span>, <span class="synConstant">':utf8'</span>);
     <span class="synConstant">7</span>
     <span class="synConstant">8</span>  <span class="synStatement">my</span> <span class="synIdentifier">$x</span> = <span class="synConstant">'αβγδεφ'</span>;
     <span class="synConstant">9</span>
    <span class="synConstant">10</span>  <span class="synStatement">my</span> <span class="synIdentifier">@w</span> = <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">11</span>  <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">@w</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
    <span class="synConstant">12</span>
    <span class="synConstant">13</span>  {
    <span class="synConstant">14</span>    <span class="synStatement">use </span>bytes;
    <span class="synConstant">15</span>    <span class="synStatement">my</span> <span class="synIdentifier">@v</span> = <span class="synStatement">map</span> { <span class="synStatement">ord</span> } <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">16</span>    <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">@v</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
    <span class="synConstant">17</span>  }
</pre>

Al ejcutar el programa obtenemos la salida:
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">perl dot_utf8_2.pl</span>
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134

</pre>
\end{rawhtml}
%}}}


\subsection{Verbos que controlan el retroceso}

\parrafo{El verbo de control {\tt (*FAIL)}}

Tomado de \pd{perlretut}{Backtracking-control-verbs}:

\begin{it}
\begin{quotation}
The control verb \verb|(*FAIL)| may be abbreviated as \verb|(*F)|. 
If this is inserted in a regexp it
will cause to fail, just like at some mismatch between the pattern and
the string. Processing of the regexp continues like after any "normal"
failure, so that the next position in the string or
another alternative will be tried. As failing to match doesn't preserve
capture buffers or produce results, it may be necessary to use this in
combination with embedded code.
\end{quotation}
\end{it}

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n vowelcount.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
     2  use strict;
     3
     4  my $input = shift() || <STDIN>;
     5  my %count = ();
     6  $input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
     7  printf("'%s' => %3d\n", $_, $count{$_})  for (sort keys %count);
\end{verbatim}
Al ejecutarse con entrada \verb|supercalifragilistico| produce la salida:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./vowelcount.pl
supercalifragilistico
'a' =>   2
'e' =>   1
'i' =>   4
'o' =>   1
'u' =>   1
\end{verbatim}

\begin{exercise}
¿Que queda en \verb|$1| depués de ejecutado el matching 
\verb|$input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;|?
\end{exercise}


Véase  también:
\begin{itemize}
\item
El nodo en \perlmonk{796576} \emph{The Oldest Plays the Piano}
\item Véase el ejercicio {\it Las tres hijas} en la sección
\ref{parrfo:lastreshijas}
\end{itemize}

\parrafo{El verbo de control {\tt (*ACCEPT)}}

Tomado de \perldoc{perlretut}:

\begin{it}
\begin{quotation}
This pattern matches nothing and causes the end of successful matching
at the point at which the \verb#(*ACCEPT)# pattern was encountered, regardless
of whether there is actually more to match in the string. When inside
of a nested pattern, such as recursion, or in a subpattern dynamically
generated via \verb#(??{})#, only the innermost pattern is ended immediately.

If the \verb#(*ACCEPT)# is inside of capturing buffers then the buffers are
marked as ended at the point at which the \verb#(*ACCEPT)# was encountered. For
instance:

\begin{verbatim}
  DB<1> x 'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'AB'
1  'B'
2  undef
  DB<2> x 'ACDE'  =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'ACD'
1  'C'
2  'E'
\end{verbatim}

\end{quotation}
\end{it}

\parrafo{El verbo {\tt SKIP}}

\begin{it}
\begin{quotation}
This zero-width pattern 
prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern \verb|A (*SKIP) B|,
where \verb|A| and \verb|B| are complex patterns. Until the \verb|(*SKIP)| verb is reached,
\verb|A| may backtrack as necessary to match. Once it is reached, matching
continues in \verb|B|, which may also backtrack as necessary; however, should \verb|B|
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.

It also signifies that whatever text that was matched leading up to the
\verb|(*SKIP)|  pattern being executed cannot be part of any match of this
pattern. This effectively means that the regex engine \verb"skips" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).

The name of the \verb|(*SKIP:NAME)| pattern has special significance. If a
\verb|(*MARK:NAME)| was encountered while matching, then it is that position
which is used as the "skip point". If no \verb|(*MARK)| of that name was
encountered, then the \verb|(*SKIP)| operator has no effect. When used without
a name the "skip point" is where the match point was when executing the
\verb|(*SKIP)| pattern.
\end{quotation}
\end{it}

Ejemplo:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n SKIP.pl
     1  #!/soft/perl5lib/bin/perl5.10.1 -w
     2  use strict;
     3  use v5.10;
     4
     5  say "NO SKIP: /a+b?(*FAIL)/";
     6  our $count = 0;
     7  'aaab' =~ /a+b?(?{print "$&\n"; $count++})(*FAIL)/;
     8  say "Count=$count\n";
     9
    10  say "WITH SKIP: a+b?(*SKIP)(*FAIL)/";
    11  $count = 0;
    12  'aaab' =~ /a+b?(*SKIP)(?{print "$&\n"; $count++})(*FAIL)/;
    13  say "WITH SKIP: Count=$count\n";
    14
    15  say "WITH SKIP /a+(*SKIP)b?(*FAIL)/:";
    16  $count = 0;
    17  'aaab' =~ /a+(*SKIP)b?(?{print "$&\n"; $count++})(*FAIL)/;
    18  say "Count=$count\n";
    19
    20  say "WITH SKIP /(*SKIP)a+b?(*FAIL): ";
    21  $count = 0;
    22  'aaab' =~ /(*SKIP)a+b?(?{print "$&\n"; $count++})(*FAIL)/;
    23  say "Count=$count\n";
\end{verbatim}

Ejecución:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 SKIP.pl
NO SKIP: /a+b?(*FAIL)/
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9

WITH SKIP: a+b?(*SKIP)(*FAIL)/
aaab
WITH SKIP: Count=1

WITH SKIP /a+(*SKIP)b?(*FAIL)/:
aaab
aaa
Count=2

WITH SKIP /(*SKIP)a+b?(*FAIL):
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9
\end{verbatim}

\parrafo{Marcas}

Tomado de \pd{perlretut}{Backtracking-control-verbs}:

\begin{it}
\begin{quotation}
\verb|(*MARK:NAME) (*:NAME)|

This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later \verb|(*SKIP)| pattern will then skip
forward to that point if backtracked into on failure. Any number of
\verb|(*MARK)| patterns are allowed, and the \verb|NAME| portion is optional and may
be duplicated.

In addition to interacting with the \verb|(*SKIP)| pattern, \verb|(*MARK:NAME)| can
be used to \verb"label" a pattern branch, so that after matching, the program
can determine which branches of the pattern were involved in the match.

When a match is successful, the \verb|$REGMARK| variable will be set to the name
of the most recently executed \verb|(*MARK:NAME)| that was involved in the match.

This can be used to determine which branch of a pattern was
matched without using a separate capture buffer for each branch,
which in turn can result in a performance improvement.

When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the \verb|$REGERROR|
variable will be set to the name of the most recently executed
\verb|(*MARK:NAME)|.
\end{quotation}
\end{it}

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n mark.pl
 1  use v5.10;
 2  use strict;
 3
 4  our $REGMARK;
 5
 6  $_ = shift;
 7  say $REGMARK if /(?:x(*MARK:mx)|y(*MARK:my)|z(*MARK:mz))/;
 8  say $REGMARK if /(?:x(*:xx)|y(*:yy)|z(*:zz))/;
\end{verbatim}
Cuando se ejecuta produce:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl y
my
yy
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl z
mz
zz
\end{verbatim}

\parrafo{Poniendo un espacio después de cada signo de puntuación}

Se quiere poner un espacio en blanco después de la aparición de cada coma:

\begin{verbatim}
s/,/, /g;
\end{verbatim}

pero se quiere que la sustitución no tenga lugar si la coma esta
incrustada entre dos dígitos. Además se pide que si hay ya un espacio
después de la coma, no se duplique. Sigue una solución que
usa marcas:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> $a = 'ab,cd, ef,12,34,efg,56,78,df, ef,'
  DB<2> x ($b = $a) =~ s/\d,\d(*:d)|,(?!\s)/($REGMARK eq 'd')? $& : ', '/ge
0  8
  DB<3> p "<$b>"
<ab, cd, ef, 12,34, efg, 56,78, df, ef, >
\end{verbatim}


% section unicode
%%% TEXEXPAND: INCLUDED FILE MARKER ./unicode/unicode.tex
% UTF-8 caracteres no son soportados por LaTeX :-(
\begin{htmlonly}

\section{Unicode}
\label{section:unicode}

\parrafo{Introducción}

\begin{exercise}
Antes de comenzar esta sección, lea los siguientes documentos:
\begin{itemize}
\item \htmladdnormallink{The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)}{http://joelonsoftware.com/articles/Unicode.html}
\end{itemize}
\end{exercise}

La siguiente introducción esta tomada de la sección \pd{perluniintro}{Unicode}:

\begin{it}
\begin{quote}
\cei{Unicode} is a character set standard which plans to codify all of the
writing systems of the world, plus many other symbols.

Unicode and ISO/IEC 10646 are coordinated standards that provide 
\cei{code points} for characters in almost all modern character set standards,
covering more than 30 writing systems and hundreds of languages,
including all commercially-important modern languages. 

All characters
in the largest Chinese, Japanese, and Korean dictionaries are also
encoded. The standards will eventually cover almost all characters in
more than 250 writing systems and thousands of languages. Unicode 1.0
was released in October 1991, and 4.0 in April 2003.

A \cei{Unicode character} is an abstract entity. It is not bound to any
particular integer width, especially not to the C language char . 

Unicode
is language-neutral and display-neutral: it does not encode the language
of the text and it does not generally define fonts or other graphical
layout details. Unicode operates on characters and on text built from
those characters.

Unicode defines characters like 
\verb|LATIN CAPITAL LETTER A| 
or \verb|GREEK SMALL LETTER ALPHA| and unique numbers for the characters, 
in this case \verb|0x0041| and \verb|0x03B1|, respectively. 
These unique numbers are called \cei{code points}.

The Unicode standard prefers using hexadecimal notation for the code
points. 

The Unicode standard uses the
{\bf notation} \verb|U+0041 LATIN CAPITAL LETTER A|, to give the hexadecimal code
point and the normative name of the character.

Unicode also defines various \cei{Unicode properties} for the characters, like
\verb"uppercase" or \verb"lowercase", \verb"decimal digit", or \verb"punctuation"; 
these
properties are independent of the names of the characters. 

Furthermore,
various operations on the characters like uppercasing, lowercasing,
and collating (sorting) are defined.

A \cei{Unicode character} consists either of a single code point, or a
base character (like \verb|LATIN CAPITAL LETTER A| ), followed by one or more
{\bf modifiers} (like \verb|COMBINING ACUTE ACCENT| ). This sequence of base character
and modifiers is called a \cei{combining character sequence}.

Whether to call these combining character sequences "characters" depends on your point of view. 
If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or "character". 
The whole sequence could be seen as one "character", however, from the user's point of view, 
since that's probably what it looks like in the context of the user's language.

With this "whole sequence" view of characters, the total number
of characters is open-ended. But in the programmer's "one unit is
one character" point of view, the concept of "characters" is more
deterministic. 

{\bf In this document, we take that second point of view:
one "character" is one Unicode code point, be it a base character or a
combining character}.

For some combinations, there are \cei{precomposed characters}. 
\verb|LATIN CAPITAL LETTER A WITH ACUTE| , for example, is defined as a single code
point. 

These precomposed characters are, however, only available for
some combinations, and are mainly meant to support round-trip conversions
between Unicode and legacy standards (like the \wikip{ISO 8859}{ISO\_8859}). 

In the general
case, the composing method is more extensible. To support conversion
between different compositions of the characters, various normalization
forms to standardize representations are also defined.

Because of backward compatibility with legacy encodings, the "a unique
number for every character" idea breaks down a bit: instead, there is
"at least one number for every character". 

The same character could be
represented differently in several \wikip{legacy encodings}{/Legacy\_encoding}. 

The converse is also
not true: some code points do not have an assigned character. 

\begin{itemize}
\item
Firstly,
there are unallocated code points within otherwise used blocks.
\item Secondly,
there are special Unicode control characters that do not represent
true characters.
\end{itemize}

A common myth about Unicode is that it would be "16-bit", that is,
Unicode is only represented as 0x10000 (or 65536) characters from 0x0000
to 0xFFFF . This is untrue. Since Unicode 2.0 (July 1996), Unicode has
been defined all the way up to 21 bits (0x10FFFF ), and since Unicode 3.1
(March 2001), characters have been defined beyond 0xFFFF . The first
0x10000 characters are called the Plane 0, or the \cei{Basic Multilingual Plane}
(\cei{BMP}). With Unicode 3.1, 17 (yes, seventeen) \cei{planes} in all were
defined--but they are nowhere near full of defined characters, yet.

Another myth is that the 256-character blocks have something to do
with languages--that each block would define the characters used by a
language or a set of languages. This is also untrue. The division into
blocks exists, but it is almost completely accidental--an artifact of
how the characters have been and still are allocated. Instead, there is
a concept called \wikip{scripts}{Unicode\_scripts}, which is more useful: there is 
\begin{itemize}
\item \wikip{Latin script}{Latin\_characters\_in\_Unicode},
\item \wikip{Greek script}{Greek\_alphabet\#Greek\_in\_Unicode},
\end{itemize}
 and so on. Scripts usually span varied parts of several
blocks. For further information see \perldoc{Unicode::UCD}:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> use Unicode::UCD qw{charinfo charscripts}
  DB<2> x charinfo(0x41)
0  HASH(0xc69a88)
   'bidi' => 'L'
   'block' => 'Basic Latin'
   'category' => 'Lu'
   'code' => 0041
   'combining' => 0
   'comment' => ''
   'decimal' => ''
   'decomposition' => ''
   'digit' => ''
   'lower' => 0061
   'mirrored' => 'N'
   'name' => 'LATIN CAPITAL LETTER A'
   'numeric' => ''
   'script' => 'Latin'
   'title' => ''
   'unicode10' => ''
   'upper' => ''
  DB<3> x @{charscripts()->{Greek}}[0..3]
0  ARRAY(0xd676a8)
   0  880
   1  883
   2  'Greek'
1  ARRAY(0xd86300)
   0  885
   1  885
   2  'Greek'
2  ARRAY(0xd6c718)
   0  886
   1  887
   2  'Greek'
3  ARRAY(0xd6c790)
   0  890
   1  890
   2  'Greek'
\end{verbatim}

The Unicode code points are just abstract numbers. To input and output
these abstract numbers, the numbers must be encoded or serialised
somehow. Unicode defines several character encoding forms, of which UTF-8
is perhaps the most popular. UTF-8 is a variable length encoding that
encodes Unicode characters as 1 to 6 bytes (only 4 with the currently
defined characters). Other encodings include UTF-16 and UTF-32 and their
big- and little-endian variants (UTF-8 is byte-order independent) The
ISO/IEC 10646 defines the UCS-2 and UCS-4 encoding forms.
\end{quote}
\end{it}

\begin{htmlonly}

\parrafo{Operadores, {\tt STDOUT} y Unicode}

Considere el siguiente programa:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8_1.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3
     4  my $x = 'áéíóúñ€';
     5  print "$x\n";
     6  print length($x)."\n";
\end{verbatim}
Cuando lo ejecutamos obtenemos la salida:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ useutf8_1.pl
áéíóúñ€
15
\end{verbatim}
Perl tiene dos modos de procesamiento de datos: el \cei{modo byte} y el \cei{modo carácter}.
El modo por defecto es el \emph{modo byte}.
Este modo es conveniente cuando se trabaja con ficheros binarios (p. ej. una imagen JPEG) 
y con texto codificado con un código que requiere un sólo byte por carácter como es el caso
de Latin 1.

En efecto, la cadena \verb|'áéíóúñ€'| 
- que es una cadena unicode codificada en UTF-8 -
tiene una longitud de 15 bytes. El asunto es que 
no es lo mismo la longitud en bytes que la longitud en caracteres cuando nos salimos de ASCII
y Latin1. Si queremos
que \tei{length} devuelva la longitud en caracteres usemos \tei{utf8}:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8_2.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4
     5  my $x = 'áéíóúñ€';
     6  print "$x\n";
     7  print length($x)."\n";
\end{verbatim}
Al ejecutar obtenemos la longitud en caracteres:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ useutf8_2.pl
Wide character in print at ./useutf8_2.pl line 6.
áéíóúñ€
7
\end{verbatim}
Ahora \verb|length| retorna la longitud en caracteres.

Obsérvese el mensaje de advertencia.  Si queremos asegurar el buen funcionamiento
de la salida por \verb|STDOUT| con caracteres codificados en UTF-8 
debemos
llamar a \tei{binmode} sobre \verb|STDOUT| con la capa \verb|':utf8'|:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8_3.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4  binmode(STDOUT, ':utf8');
     5
     6  my $x = 'áéíóúñ€';
     7  print "$x\n";
     8  print length($x)."\n";
\end{verbatim}
El mensaje de advertencia desaparece:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ useutf8_3.pl
áéíóúñ€
7
\end{verbatim}
Usando la opción \verb|-C| del intérprete Perl se puede conseguir el mismo resultado:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ perl useutf8_1.pl
áéíóúñ€
15
lhp@nereida:~/Lperl/src/testing$ perl -Mutf8 -COE useutf8_1.pl
áéíóúñ€
7
\end{verbatim}

Lea \verb|perldoc| \cpan{perlrun} para mas información sobre estas
opciones:

\begin{verbatim}
As of 5.8.1, the "-C" can be followed either by a number or a list of option
letters.  The letters, their numeric values, and effects are as follows;
listing the letters is equal to summing the numbers.

  I     1    STDIN is assumed to be in UTF-8
  O     2    STDOUT will be in UTF-8
  E     4    STDERR will be in UTF-8
  S     7    I + O + E
  i     8    UTF-8 is the default PerlIO layer for input streams
  o    16    UTF-8 is the default PerlIO layer for output streams
  D    24    i + o
  A    32    the @ARGV elements are expected to be strings encoded in UTF-8
  L    64    normally the "IOEioA" are unconditional,
             the L makes them conditional on the locale environment
             variables (the LC_ALL, LC_TYPE, and LANG, in the order
             of decreasing precedence) -- if the variables indicate
             UTF-8, then the selected "IOEioA" are in effect

\end{verbatim}

En Perl las cadenas tienen un flag que indica si la representación interna 
de la cadena es utf-8.
La función \verb|is_utf8| de \perldoc{utf8} permite conocer
si una cadena esta almacenada internamente como utf-8:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n is_utf8.pl
     1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1 -w -COE
     2  use strict;
     3  use utf8;
     4
     5  my $x = 'áéíóúñ€';
     6  my $y = 'abc';
     7  my $z = 'αβγδη';
     8  print "$x is utf8\n" if utf8::is_utf8($x);
     9  print "$y is utf8\n" if utf8::is_utf8($y);
    10  print "$z is utf8\n" if utf8::is_utf8($z);
\end{verbatim}
Al ejecutar produce la salida:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./is_utf8.pl
áéíóúñ€ is utf8
αβγδη is utf8
\end{verbatim}

\parrafo{Ficheros Unicode en {\tt vim}}

La documentación de vim sobre modo \vimdoc{Multi-byte support}{mbyte.html\#mbyte-utf8}
relativa a unicode dice:
\begin{it}
\begin{quote}
Useful commands:
\begin{itemize}
\item \verb"ga" shows the decimal, hexadecimal and octal value of the character under
  the cursor.  If there are composing characters these are shown too.  (If the
  message is truncated, use ":messages").
\item \verb"g8" shows the bytes used in a UTF-8 character, also the composing
  characters, as hex numbers.
\item \verb":set encoding=utf-8 fileencodings=" forces using UTF-8 for all files.  The
  default is to use the current locale for 'encoding' and set 'fileencodings'
  to automatically detect the encoding of a file.
\end{itemize}

....

If your current \man{locale} is in an utf-8 encoding, Vim will automatically start
in utf-8 mode.

If you are using another locale:

\begin{verbatim}
        set encoding=utf-8
\end{verbatim}

\end{quote}
\end{it}
En nuestro caso, tenemos las \man{locale} usando utf-8:
\begin{verbatim}
casiano@millo:~/Lperltesting$ locale
LANG=es_ES.UTF-8
LC_CTYPE="es_ES.UTF-8"
LC_NUMERIC="es_ES.UTF-8"
LC_TIME="es_ES.UTF-8"
LC_COLLATE="es_ES.UTF-8"
LC_MONETARY="es_ES.UTF-8"
LC_MESSAGES="es_ES.UTF-8"
LC_PAPER="es_ES.UTF-8"
LC_NAME="es_ES.UTF-8"
LC_ADDRESS="es_ES.UTF-8"
LC_TELEPHONE="es_ES.UTF-8"
LC_MEASUREMENT="es_ES.UTF-8"
LC_IDENTIFICATION="es_ES.UTF-8"
LC_ALL=
\end{verbatim}

Hay varias formas de crear ficheros Unicode en lenguajes 
fuera del rango del \tei{latin1} con \vim{}.

Los caracteres unicode en la línea 3 del siguiente fichero
han sido generados en \htmladdnormallink{vim}{http://vimdoc.sourceforge.net/htmldoc/mbyte.html\#unicode} insertandolos
mediante su codificación usando la secuencia \verb|CTRL-V u hexcode|. 
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n utf8file.txt
     1  áéíóúñÑ
     2  àèìòùÇç
     3  ェッニは大き
\end{verbatim}
En concreto los códigos creo que fueron: \verb|30a7|, \verb|30c3|, \verb|30cb|, \verb|306f|, \verb|5927| y \verb|304d|.
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -C7 -E 'say chr($_) for (0x30a7, 0x30c3, 0x30cb, 0x306f,  0x5927, 0x304d)'
ェ
ッ
ニ
は
大
き
\end{verbatim}
Una forma mas cómoda de insertar caracteres Unicode en \vim{} es usar 
\tei{keymaps}:
\begin{enumerate}
\item
Vea que keymaps están disponibles ejecutando el comando \vim{}:

\begin{verbatim}
:echo globpath(&rtp, "keymap/*.vim")
\end{verbatim}
Para entender el comando anterior hay que tener en cuenta que:

\begin{itemize}
\item
La función \vimdoc{globpath}{eval.html\#globpath()} tiene la sintáxis  
\verb|globpath({path}, {expr} [, {flag}])|
y realiza un {\it glob} de \verb|{expr}| sobre la lista de directorios
en \verb|{path}|.
\item
La función \vimdoc{rtp}{options.html\#'rtp'} devuelve el {\it run-time path} de \vim{}
\item
El comando \vimdoc{echo}{eval.html\#:echo} \verb|{expr1} ..| muestra los valores
de \verb|{expr1}|, .. separados por espacios.
\end{itemize}

Esto mostrará algo como:
\begin{verbatim}
/usr/share/vim/vim70/keymap/accents.vim
/usr/share/vim/vim70/keymap/arabic.vim
/usr/share/vim/vim70/keymap/arabic_utf-8.vim
/usr/share/vim/vim70/keymap/bulgarian.vim
/usr/share/vim/vim70/keymap/canfr-win.vim
/usr/share/vim/vim70/keymap/czech.vim
/usr/share/vim/vim70/keymap/czech_utf-8.vim
/usr/share/vim/vim70/keymap/esperanto.vim
/usr/share/vim/vim70/keymap/esperanto_utf-8.vim
/usr/share/vim/vim70/keymap/greek.vim
/usr/share/vim/vim70/keymap/greek_cp1253.vim
/usr/share/vim/vim70/keymap/greek_cp737.vim
/usr/share/vim/vim70/keymap/greek_iso-8859-7.vim
/usr/share/vim/vim70/keymap/greek_utf-8.vim
....
\end{verbatim}
Como se ve el convenio de nombres para los keymaps es:
\begin{verbatim}
<language>_<encoding>.vim
\end{verbatim}
Sigue un ejemplo de fichero de keymap:
\begin{verbatim}
$ cat -n /usr/share/vim/vim70/keymap/greek_utf-8.vim
 1 " Vim Keymap file for greek
 2 " Maintainer: Panagiotis Louridas <louridas@acm.org>
 3 " Last Updated: Thu Mar 23 23:45:02 EET 2006
 4 
 .......................................................................
72 let b:keymap_name = "grk"
73 loadkeymap
74 " PUNCTUATION MARKS - SYMBOLS (GREEK SPECIFIC)
75 "
76 E$	<char-0x20AC>  " EURO SIGN
............................................................................
115 "
116 " GREEK LETTERS
117 "
118 A	<char-0x0391>   " GREEK CAPITAL LETTER ALPHA
119 B	<char-0x0392>   " GREEK CAPITAL LETTER BETA
120 G	<char-0x0393>   " GREEK CAPITAL LETTER GAMMA
121 D	<char-0x0394>   " GREEK CAPITAL LETTER DELTA
122 E	<char-0x0395>   " GREEK CAPITAL LETTER EPSILON
123 Z	<char-0x0396>   " GREEK CAPITAL LETTER ZETA
\end{verbatim}
\item
Ahora ejecute el comando:
\begin{verbatim}
:set keymap=greek 
\end{verbatim}
Cuando estamos en modo {\it inserción} podemos conmutar
entre los dos keymaps tecleando

\begin{verbatim}
CTRL-^.
\end{verbatim}
o bien
\begin{verbatim}
CTRL-6.
\end{verbatim}

\item
Compruebe con que codificación está trabajando \verb|vim|:
\begin{verbatim}
:set encoding
  encoding=utf-8 
\end{verbatim}
Es posible cambiar la codificación con la que se está editando:
\begin{verbatim}
:set encoding latin1
\end{verbatim}
Esto no modifica la codificación del fichero.
\item
Para saber mas sobre como utilizar Unicode y keymaps en \vim{} 
lea las ayudas sobre los tópicos:
\begin{itemize}
\item \verb|:help| \vimdoc{mbyte.txt}{mbyte.html\#mbyte.txt}                     
\item \verb|:help| \vimdoc{mbyte-keymap}{mbyte.html#mbyte-keymap} 
\end{itemize}
\end{enumerate}

\parrafo{Apertura de ficheros UTF-8}

Use  la forma con tres argumentos de \verb|open| y especifique
la capa \verb|:utf8| para que la entrada/salida a ese fichero
se procesada por dicha capa. Por ejemplo:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n abreutf8.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  binmode(STDOUT, "utf8");
 4  open my $f, '<:utf8', shift();
 5  my @a = <$f>;
 6  chomp(@a);
 7  print "$_ tiene longitud ".length($_)."\n" for @a;
\end{verbatim}

Al ejecutar produce una salida como esta:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ abreutf8.pl tutu
ジジェッニgfは大好あき tiene longitud 14
αβγεφγη tiene longitud 7
νμοπ;ρ^αβψδε tiene longitud 12
& ασηφδξδξδη tiene longitud 12
abc tiene longitud 3
αβγδ&αβψ tiene longitud 8
\end{verbatim}

\parrafo{El Módulo {\tt charnames}}

El módulo \verb|charnames| facilita la introducción de caracteres unicode:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n alfabeta.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use charnames qw{:full greek hebrew katakana};
 4  binmode(STDOUT, ':utf8');
 5
 6  print "\N{alpha}+\N{beta} = \N{pi}\n";
 7  print "\N{alef} es la primera letra del alfabeto hebreo\n";
 8  print "Un poco de Katakana: \N{sa}\N{i}\N{n}\N{mo}\n";
 9
10  # Usando el nombre completo definido en el Standard Unicode
11  print "Hello \N{WHITE SMILING FACE}\n";
\end{verbatim}
Cuando se ejecuta produce una salida como:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ alfabeta.pl
α+β = ピ
א es la primera letra del alfabeto hebreo
Un poco de Katakana: サインモ
Hello ☺
\end{verbatim}
Obsérvese como la salida para \verb|\N{pi}| no muestra la letra griega 
\verb|π| sino el correspondiente símbolo Katakana \verb|ピ|: atención a las
colisiones entre alfabetos.

Las funciones \verb|viacode| y \verb|vianame| son recíprocas
y nos dan la relación nombre-código de un carácter:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -COE -Mutf8 -dE 0
main::(-e:1):   0
  DB<1>   use charnames ':full'
  DB<2>  print charnames::viacode(0x2722)
FOUR TEARDROP-SPOKED ASTERISK
  DB<3> printf "%04X", charnames::vianame("FOUR TEARDROP-SPOKED ASTERISK")
2722
\end{verbatim}
\parrafo{Expresiones Regulares y Unicode}

Usando \verb|utf8| es posible usar operadores 
como \verb|tr| y expresiones regulares sobre cadenas UTF-8:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n useutf8.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use utf8;
 4  binmode(STDOUT, ':utf8');
 5
 6  my $x = 'áéíóúñ€';
 7  print "$x\n";
 8  print length($x)."\n";
 9
10  my$y = $x;
11  $y =~ tr/áéíóúñ€/aeioun$/;
12  print "$y\n";
13
14  $y = $x;
15  $y =~ m/áéíóúñ(€)/;
16  print "$1\n";
\end{verbatim}
Al ejecutar, este programa produce la salida:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ useutf8.pl
áéíóúñ€
7
aeioun$
€
\end{verbatim}

\parrafo{Macros: Dígitos y Words}

Macros como \verb|\d| han sido generalizadas.
Los digitos Devanagari tienen códigos
del 2406 (0x966) al 2415 (0x96F):
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ unicode -x 966..96f | egrep '096|\.0'
          .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F
     096.  ॠ  ॡ      ।  ॥  ०  १  २  ३  ४  ५  ६  ७  ८  ९
\end{verbatim}
El siguiente ejemplo muestra que  expresiones regulares como \verb|\d+| 
reconocen los digitos Devanagari:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n regexputf8.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  binmode(STDOUT, "utf8");
 4  use utf8;
 5
 6  # Digitos Devanagari del 0 al 9
 7  my @dd  = map { chr } (2406..2415);
 8  my $x = join '+', @dd;
 9  print "La interpolación ocurre: $x\n";
10  my @number = $x =~ m{(\d+)}g;
11  print "Las expresiones regulares funcionan: @number\n";
12  print "Sin embargo la conversión numérica no es automática: ".($number[0]+$number[1])."\n";
\end{verbatim}

Como se indica en el programa la conversión automática de dígitos en 
otros juegos de caracteres no funciona. Véase la ejecución:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ regexputf8.pl
La interpolación ocurre: ०+१+२+३+४+५+६+७+८+९
Las expresiones regulares funcionan: ० १ २ ३ ४ ५ ६ ७ ८ ९
Argument "\x{967}" isn't numeric in addition (+) at ./regexputf8.pl line 12.
Argument "\x{966}" isn't numeric in addition (+) at ./regexputf8.pl line 12.
Sin embargo la conversión numérica no es automática: 0
\end{verbatim}

Lo mismo ocurre con la macro\verb|\w|:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n words_utf8.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4  use charnames qw{greek};
     5  binmode(STDOUT, ':utf8');
     6
     7  my $x = 'áéíóúñ€αβγδη';
     8  my @w = $x =~ /(\w)/g;
     9  print "@w\n";
lhp@nereida:~/Lperl/src/testing$ words_utf8.pl
á é í ó ú ñ α β γ δ η
\end{verbatim}

\parrafo{Semántica de Carácter versus Semántica de Byte}

Cuando se procesan datos codificados en UTF-8 el punto casa
con un carácter UTF-8. La macro \verb|\C| puede ser 
utilizada para casar un byte:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n dot_utf8.pl
     1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1 -w -COE
     2  use v5.10;
     3  use strict;
     4  use utf8;
     5
     6  my $x = 'αβγδεφ';
     7  my @w = $x =~ /(.)/g;
     8  say "@w";
     9
    10  my @v = map { ord } $x =~ /(\C)/g;
    11  say "@v";
pl@nereida:~/Lperltesting$ ./dot_utf8.pl
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134
\end{verbatim}

El mismo efecto de \verb|\C| puede lograrse mediante el
pragma \verb|use bytes| el cual cambia la semántica de caracteres
a bytes:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n dot_utf8_2.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use utf8;
     4  use charnames qw{greek};
     5
     6  binmode(STDOUT, ':utf8');
     7
     8  my $x = 'αβγδεφ';
     9
    10  my @w = $x =~ /(.)/g;
    11  print "@w\n";
    12
    13  {
    14    use bytes;
    15    my @v = map { ord } $x =~ /(.)/g;
    16    print "@v\n";
    17  }
\end{verbatim}

\parrafo{Caja e Inversión de Cadenas Unicode}

El siguiente ejemplo ilustra el uso de 
las funciones de cambio de caja 
(tales como \tei{uc}, \tei{lc}, \tei{lcfirst} y \tei{ucfirst})
asi como el uso de \tei{reverse} con cadenas unicode:
\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n alfabeta1.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use utf8;
 4  use charnames qw{greek};
 5  binmode(STDOUT, ':utf8');
 6
 7  my $x = "\N{alpha}+\N{beta} = \N{pi}";
 8  print uc($x)."\n";
 9  print scalar(reverse($x))."\n";
10
11  my $y = "áéíóúñ";
12  print uc($y)."\n";
13  print scalar(reverse($y))."\n";
\end{verbatim}
Al ejecutarse, el programa produce la salida:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ alfabeta1.pl
Α+Β = Π
π = β+α
ÁÉÍÓÚÑ
ñúóíéá
\end{verbatim}

\parrafo{Propiedades}

El estandar Unicode declara que cadenas particulares de caracteres
pueden tener propiedades particulares y que una expresión regular puede
casar sobre esas propiedades utilizando la notación \verb|\p{...}|:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ cat -n properties.pl
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use utf8;
 4  use charnames qw{greek};
 5  binmode(STDOUT, ':utf8');
 6
 7  my @a = ('$', 'az', '£', 'α', '€', '￥');
 8  my $x =  "@a\n";
 9
10  print /\p{CurrencySymbol}/? "$_ = Dinero!!\n" : "$_ : No hay dinero\n" for @a;
11  print /\p{Greek}/? "$_ = Griego\n" : "$_ : No es griego\n" for @a;
\end{verbatim}
Al ejecutar este script obtenemos:

\begin{verbatim}
lhp@nereida:~/Lperl/src/testing$ properties.pl
$ = Dinero!!
az : No hay dinero
£ = Dinero!!
α : No hay dinero
€ = Dinero!!
￥ = Dinero!!
$ : No es griego
az : No es griego
£ : No es griego
α = Griego
€ : No es griego
￥ : No es griego
\end{verbatim}

El módulo \cpan{Unicode::Properties} permite obtener las 
propiedades de un carácter:

\begin{verbatim}
casiano@millo:~$ echo $PERL5LIB
/soft/perl5lib/perl5_10_1/lib/:/soft/perl5lib/perl5_10_1/lib/perl5:/soft/perl5lib/perl5_10_1/share/perl/5.8.8/
casiano@millo:~$ perl5.10.1 -COE -Mutf8 -dE 0
main::(-e:1):   0
  DB<1> use Unicode::Properties 'uniprops'
  DB<2> x  uniprops ('☺'); # Unicode smiley face
0  'Alphabetic'
1  'Any'
2  'Assigned'
3  'IDContinue'
4  'IDStart'
5  'InLatin1Supplement'
6  'Latin'
7  'Lowercase'
\end{verbatim}

\parrafo{Conversores}

Hay un buen número de utilidades de conversión 

\begin{itemize}
\item
\tei{unicode} permite hacer consultas sobre los caracteres unicode:

\begin{verbatim}
lhp@nereida:~/Lbook$ unicode 'hebrew letter alef'
U+05D0 HEBREW LETTER ALEF
UTF-8: d7 90  UTF-16BE: 05d0  Decimal: &#1488;
א
Category: Lo (Letter, Other)
Bidi: R (Right-to-Left)

U+FB2E HEBREW LETTER ALEF WITH PATAH
UTF-8: ef ac ae  UTF-16BE: fb2e  Decimal: &#64302;
אַ
Category: Lo (Letter, Other)
Bidi: R (Right-to-Left)
Decomposition: 05D0 05B7
...
\end{verbatim}

\item
\tei{iconv} permite la conversión entre codificaciones. El
siguiente programa usa \verb|iconv|
para convertir ficheros latin1 a utf-8:
\begin{verbatim}
 1  #!/usr/local/bin/perl -w
 2  use strict;
 3  use warnings;
 4  for my $file (@ARGV) {
 5    my $ifile = "$file.ISO_8859-15";
 6
 7    system("cp $file $ifile");
 8    system("iconv -f ISO_8859-15 -t UTF-8 $ifile > $file");
 9  }
\end{verbatim}
\item \tei{piconv} viene con las distribuciones de Perl superiores a la 5.8
\item \tei{paps} permite imprimir ficheros de texto conteniendo unicode

\begin{verbatim}
casiano@nereida:~/Lwiley_book_tracer/Coordinado$ paps --help
Usage:
  paps [OPTION...] [text file]

Help Options:
  -?, --help              Show help options

Application Options:
  --landscape             Landscape output. (Default: portrait)
  --columns=NUM           Number of columns output. (Default: 1)
  --font_scale=NUM        Font scaling. (Default: 12)
  --family=FAMILY         Pango FT2 font family. (Default: Monospace)
  --rtl                   Do rtl layout.
  --justify               Do justify the lines.
  --paper=PAPER           Choose paper size. Known paper sizes are legal,
                          letter, a4. (Default: a4)
  --bottom-margin=NUM     Set bottom margin. (Default: 36)
  --top-margin=NUM        Set top margin. (Default: 36)
  --right-margin=NUM      Set right margin. (Default: 36)
  --left-margin=NUM       Set left margin. (Default: 36)
  --header                Draw page header for each page.
\end{verbatim}
\end{itemize}

\parrafo{Véase también}

\begin{itemize}
\item La documentación en \cpan{perluniintro} (\verb|perldoc perluniintro|) 
\item La documentación en \cpan{perlunicode}
\item Enrique Nell: \htmladdnormallink{Unicode for Perl Programmers}{http://www.haboogo.com/programming/Unicode\%20en\%20Perl.pdf}
\item \htmladdnormallink{Unicode 5.2 Character Code Charts}{http://www.unicode.org/charts/}
\item \htmladdnormallink{Perl Unicode Advice}{http://juerd.nl/site.plp/perluniadvice}
\item \htmladdnormallink{Unicode-processing issues in Perl and how to cope with it}{http://ahinea.com/en/tech/perl-unicode-struggle.html}
\end{itemize}


\end{htmlonly}
%%% TEXEXPAND: END FILE ./unicode/unicode.tex

\section{Expresiones Regulares en Otros Lenguajes}
\label{section:otroslenguajes}

\parrafo{Vim}

\begin{itemize}
\item \pmm{333737}{Learn vi/vim in 50 lines and 15 minutes}
\item  \htmladdnormallink{VIM Regular Expressions}{http://www.geocities.com/volontir/}
\item \pmm{141765}{Editing features for advanced users}
\item \htmladdnormallink{Vim documentation: pattern}{http://www.vim.org/htmldoc/pattern.html}
\item \htmladdnormallink{Vim Regular Expressions Chart}{http://www.softpanorama.org/Editors/Vimorama/vim\_regular\_expressions.shtml}
\end{itemize}

\parrafo{Java}

El siguiente ejemplo muestra un programa estilo \verb|grep|: solicita
una expresión regular para aplicarla luego a una serie de entradas 
leídas desde la entrada estandar.
\begin{verbatim}
casiano@nereida:~/projects/PA/regexp$ cat -n Application.java
 1  /**
 2   * javac Application.java
 3   * java Application
 4   */
 5
 6  import java.io.*;
 7  import java.util.regex.Pattern;
 8  import java.util.regex.Matcher;
 9
10  public class Application {
11
12      public static void main(String[] args){
13          String regexp = "";
14          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
15          try {
16              System.out.print("Enter your regex: ");
17              regexp = br.readLine();
18          } catch (IOException e) { System.exit(1); };
19          while (true) {
20
21              String input = "";
22              try {
23                System.out.print("Enter input string to search: ");
24                input = br.readLine();
25              } catch (IOException e) { System.exit(1); };
26
27              Pattern pattern = Pattern.compile(regexp);
28              Matcher matcher = pattern.matcher(input);
29
30              boolean found = false;
31              while (matcher.find()) {
32                  System.out.println("I found the text "
33                                     + matcher.group()
34                                     + " starting at index "
35                                     + matcher.start()
36                                     + " and ending at index "
37                                     +matcher.end()
38                  );
39                  found = true;
40              }
41              if(!found){
42                  System.out.println("No match found.");
43              }
44          }
45      }
46  }
\end{verbatim}
Ejecución:
\begin{verbatim}
casiano@nereida:~/Ljavatesting$ java Application
Enter your regex: (\d+).(\d+)
Enter input string to search: a4b5d6c7efg
I found the text 4b5 starting at index 1 and ending at index 4
I found the text 6c7 starting at index 5 and ending at index 8
Enter input string to search: abc
No match found.
Enter input string to search:
\end{verbatim}

Véase también 
\htmladdnormallink
{Java Regular Expressions}
{http://java.sun.com/docs/books/tutorial/essential/regex/}

\parrafo{bash}

Esta es una versión en \verb|bash| del conversor de temperaturas
visto en las secciones anteriores:

\begin{verbatim}
pl@nereida:~/src/bash$ cat -n f2c
     1  #!/bin/bash
     2  echo "Enter a temperature (i.e. 32F, 100C):";
     3  read input;
     4
     5  if [ -z "$(echo $input | grep -i '^[-+]\?[0-9]\+\(\.[0-9]*\)\?\ *[CF]$')" ]
     6  then
     7    echo "Expecting a temperature, so don't understand \"$input\"." 1>&2;
     8  else
     9    input=$(echo $input | tr -d ' ');
    10    InputNum=${input:0:${#input}-1};
    11    Type=${input: -1}
    12
    13    if [ $Type = "c" -o $Type = "C" ]
    14    then
    15     celsius=$InputNum;
    16     fahrenheit=$(echo "scale=2; ($celsius * 9/5)+32" | bc -l);
    17    else
    18     fahrenheit=$InputNum;
    19     celsius=$(echo "scale=2; ($fahrenheit -32)*5/9" | bc -l);
    20    fi
    21
    22    echo "$celsius C = $fahrenheit F";
    23  fi
\end{verbatim}

\parrafo{C}

\begin{verbatim}
pl@nereida:~/src/regexpr$ cat -n pcregrep.c
 1  #include <stdio.h>
 2  #include <stdlib.h>
 3  #include <string.h>
 4  #include <assert.h>
 5  #include <pcre.h>
 6
 7  char enter_reverse_mode[] = "\33[7m";
 8  char exit_reverse_mode[] = "\33[0m";
 9
10  int main(int argc, char **argv)
11  {
12    const char *pattern;
13    const char *errstr;
14    int erroffset;
15    pcre *expr;
16    char line[512];
17    assert(argc == 2); /* XXX fixme */
18    pattern = argv[1];
19    if (!(expr = pcre_compile(pattern, 0, &errstr, &erroffset, 0))) {
20      fprintf(stderr, "%s: %s\n", pattern, errstr);
21      return EXIT_FAILURE;
22    }
23    while (fgets(line, sizeof line, stdin)) {
24      size_t len = strcspn(line, "\n");
25      int matches[2];
26      int offset = 0;
27      int flags = 0;
28      line[len] = '\0';
29      while (0 < pcre_exec(expr, 0, line, len, offset, flags, matches, 2)) {
30        printf("%.*s%s%.*s%s",
31          matches[0] - offset, line + offset,
32          enter_reverse_mode,
33          matches[1] - matches[0], line + matches[0],
34          exit_reverse_mode);
35        offset = matches[1];
36        flags |= PCRE_NOTBOL;
37      }
38      printf("%s\n", line + offset);
39    }
40    return EXIT_SUCCESS;
41  }
\end{verbatim}
Compilación:
\begin{verbatim}
pl@nereida:~/src/regexpr$ gcc -lpcre pcregrep.c -o pcregrep
\end{verbatim}

Cuando se ejecuta espera un patrón en la línea de comandos
y pasa a leer desde la entrada estandar. Las cadenas que casan
se muestran resaltadas:
\begin{verbatim}
pl@nereida:~/src/regexpr$ ./pcregrep '\d+'
435 otro 23
\end{verbatim}
\noindent \underline{435} {\tt otro} \underline{23}
\begin{verbatim}
hola
hola
\end{verbatim}

\parrafo{Python}


\begin{verbatim}
pl@nereida:~/src/python$ cat -n c2f.py
 1  #!/usr/local/bin/python
 2  import re
 3
 4  temp = raw_input( ' Introduzca una temperatura (i.e. 32F, 100C): ' )
 5  pattern = re.compile( "^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$", re.IGNORECASE )
 6  mo = pattern.match( temp )
 7
 8  if mo:
 9    inputNum = float(mo.group( 1 ))
10    type = mo.group( 3 )
11    celsius = 0.0
12    fahrenheit = 0.0
13    if ( type == "C" or type == "c" ) :
14      celsius = inputNum
15      fahrenheit = ( celsius * 9/5 ) + 32
16    else :
17      fahrenheit = inputNum
18      celsius = ( fahrenheit - 32 ) * 5/9
19    print " ", '%.2f'%(celsius), " C = ", '%.2f'%(fahrenheit), " F\n"
20  else :
21    print " Se experaba una temperatura, no se entiende", temp, "\n"
\end{verbatim}

\parrafo{Ruby}


\begin{verbatim}
pl@nereida:~/src/ruby$ cat -n f2c_b
 1  #!/usr/bin/ruby
 2
 3  # Primero leemos una temperatura
 4  class Temperature_calculator
 5    def initialize temp
 6    comp = Regexp.new('^([-+]?\d+(\.\d*)?)\s*([CFcf])$')
 7    if temp =~ comp
 8    begin
 9      cifra = Float($1)
10      @C,@F = ( $3 == "F" or $3 == "f")? [(cifra -32) * 5/9, cifra] : [cifra , cifra * 9/5 + 32]
11    end
12    else
13      raise("Entrada incorrecta")
14    end
15  end
16
17    def show
18      puts "Temperatura en Celsius: #{@C}, temperatura en Fahrenheit: #{@F}"
19    end
20  end
21
22  temperatura = Temperature_calculator.new(readline.chop)
23  temperatura.show
\end{verbatim}

\parrafo{Javascript}

\begin{verbatim}
<SCRIPT LANGUAGE="JavaScript"><!--
function demoMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  if (document.demoMatch.subject.value.match(re)) {
    alert("Successful match");
  } else {
    alert("No match");
  }
}

function demoShowMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  var m = re.exec(document.demoMatch.subject.value);
  if (m == null) {
    alert("No match");
  } else {
    var s = "Match at position " + m.index + ":\n";
    for (i = 0; i < m.length; i++) {
      s = s + m[i] + "\n";
    }
    alert(s);
  }
}

function demoReplaceClick() {
  var re = new RegExp(document.demoMatch.regex.value, "g");
  document.demoMatch.result.value = 
    document.demoMatch.subject.value.replace(re, 
      document.demoMatch.replacement.value);
}
// -->
</SCRIPT>

<FORM ID="demoMatch" NAME="demoMatch" METHOD=POST ACTION="javascript:void(0)">
<P>Regexp: <INPUT TYPE=TEXT NAME="regex" VALUE="\bt[a-z]+\b" SIZE=50></P>
<P>Subject string: <INPUT TYPE=TEXT NAME="subject" 
   VALUE="This is a test of the JavaScript RegExp object" SIZE=50></P>
<P><INPUT TYPE=SUBMIT VALUE="Test Match" ONCLICK="demoMatchClick()">
<INPUT TYPE=SUBMIT VALUE="Show Match" ONCLICK="demoShowMatchClick()"></P>

<P>Replacement text: <INPUT TYPE=TEXT NAME="replacement" VALUE="replaced" SIZE=50></P>
<P>Result: <INPUT TYPE=TEXT NAME="result" 
   VALUE="click the button to see the result" SIZE=50></P>
<P><INPUT TYPE=SUBMIT VALUE="Replace" ONCLICK="demoReplaceClick()"></P>
</FORM>
\end{verbatim}

\section{Casos de Estudio}

\subsection{Secuencias de números de tamaño fijo}
\label{section:numeros}
El siguiente problema y sus soluciones se describen en el libro de J.E.F. Friedl
\cite{friedl}.
Supongamos que tenemos un texto conteniendo códigos que son 
números de tamaño fijo, digamos 
seis dígitos, todos pegados, sin separadores entre ellos, como sigue:

\begin{center}
\begin{tt} 
012345678901{\bf123334}234567890123{\bf125934}890123345126
\end{tt} 
\end{center}

El problema es encontrar los códigos que comienzan por {\tt 12}. En negrita 
se han resaltado las soluciones.  Son soluciones sólo aquellas que, comienzan
por \verb|12| en una posición múltiplo de seis. 
Una solución es:

\begin{center}
\begin{verbatim}
@nums = grep {m/^12/} m/\d{6}/g;
\end{verbatim}
\end{center}

que genera una lista con los números y luego selecciona los que comienzan por
\verb|12|.
Otra solución es:

\begin{center}
\begin{verbatim}
@nums = grep { defined } m/(12\d{4})|\d{6}/g;
\end{verbatim}
\end{center}

que aprovecha que la expresión regular devolverá una lista vacía cuando
el número no empieza por \verb|12|:
\begin{verbatim}
DB<1> $x = '012345678901123334234567890123125934890123345126'
DB<2> x  ($x =~ m/(12\d{4})|\d{6}/g)
0  undef
1  undef
2  123334
3  undef
4  undef
5  125934
6  undef
7  undef
\end{verbatim}
Obsérvese que se esta utilizando también que el operador \verb#|# no es \emph{greedy}.

¿Se puede resolver el problema usando sólamente una expresión regular?
Obsérvese que esta solución ``casi funciona'':

\begin{center}
\begin{verbatim}
 DB<3> x @nums = $x =~ m/(?:\d{6})*?(12\d{4})/g;
0  123334
1  125934
2  123345
\end{verbatim}
\end{center}

recoge la secuencia mas corta de grupos de seis dígitos que no casan, seguida 
de una secuencia que casa. 
El problema que tiene esta solución 
es al final, cuando se han casado todas las soluciones, entonces 
la búsqueda exhaustiva hará que nos muestre soluciones que no comienzan en posiciones
múltiplo de seis. Por eso encuentra \verb|123345|:
\begin{center}
\begin{tt} 
012345678901{\bf123334}234567890123{\bf125934}890{\bf123345}126
\end{tt} 
\end{center}
Por eso, Friedl propone esta solución:

\begin{center}
\begin{verbatim}
@nums = m/(?:\d{6})*?(12\d{4})(?:(?!12)\d{6})*/g;
\end{verbatim}
\end{center}

Se asume que existe al menos un éxito en la entrada inicial.
Que es un extraordinario ejemplo de como el uso de paréntesis de agrupamiento
simplifica y mejora la legibilidad de la solución. Es fantástico también el uso
del operador de predicción negativo.

\parrafo{Solución usando el ancla {\tt $\backslash$ G}}

El ancla \verb|\G| ha sido concebida para su uso con la opción \verb|/g|.
Casa con el punto en la cadena en el que terminó el último emparejamiento.
Cuando se trata del primer intento o no se está usando \verb|/g|, usar \verb|\G|
es lo mismo que usar \verb|\A|.

Mediante el uso de este ancla es posible formular la siguiente solución 
al problema planteado:

\begin{center}
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
DB<1> $_ = '012345678901123334234567890123125934890123345126'
DB<2> x m/\G(?:\d{6})*?(12\d{4})/g
0  123334
1  125934
\end{verbatim}
\end{center}


\parrafo{Sustitución}

Si lo que se quiere es sustituir las secuencias deseadas es poisble hacerlo con 
la siguiente expresión regular:
\begin{verbatim}
casiano@nereida:~/docs/curriculums/CV_MEC$ perl -wde 0
DB<1> x $x = '012345678901123334234567890123125934890123345126'
0  012345678901123334234567890123125934890123345126
DB<2> x  ($y = $x) =~ s/(12\d{4})|\d{6}/$1? "-$1-":$& /ge
0  8
DB<3> p $y
012345678901-123334-234567890123-125934-890123345126
\end{verbatim}

\subsection{Palabras Repetidas}
\label{section:repetidas}
Su jefe le pide una herramienta que compruebe la aparición de
duplicaciones consecutivas en un texto texto (como esta esta y la anterior anterior).
La solución debe cumplir las siguientes especificaciones:
\begin{itemize}
\item
Aceptar cualquier número de ficheros. Resaltar las apariciones
de duplicaciones. Cada línea del informe debe estar precedida del nombre del fichero.
\item
Funcionar no sólo cuando la duplicación ocurre en la misma línea.
\item
Funcionar independientemente del \emph{case} y de los blancos usados en medio
de ambas palabras.
\item
Las palabras en cuestión pueden estar separadas por \emph{tags} \verb|HTML|.
\end{itemize}

\begin{latexonly}
\begin{verbatim}
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Term::ANSIScreen qw/:constants/;
  4  
  5  my $bold = BOLD();
  6  my $clear = CLEAR();
  7  my $line = 1;
  8  
  9  # read paragraph
 10  local $/ = ".\n";
 11  while (my $par = <>) {
 12    next unless $par =~ s{
 13          \b                 # start word ...
 14          ([a-z]+)           # grab word in $1 and \1
 15          (                  # save the tags and spaces in $2
 16          (\s|<[^>]+>)+      # spaces or HTML tags 
 17          )   
 18          (\1\b)             # repeated word in $4
 19    }!$bold$1$clear$2$bold$4$clear!igx;
 20  
 21    $par =~ s/^/"$ARGV(".$line++."): "/meg;   # insert filename and line number
 22  
 23    print $par;
 24  }
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use </span>Term::ANSIScreen <span class="synConstant">qw/:constants/</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$bold</span> = BOLD();
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$clear</span> = CLEAR();
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synComment"># read paragraph</span>
<span class="synLinenum">   10</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synConstant">&quot;.</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   11</span> <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$par</span> = &lt;&gt;) {
<span class="synLinenum">   12</span>   <span class="synStatement">next</span> <span class="synStatement">unless</span> <span class="synIdentifier">$par</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">\b</span><span class="synConstant">                 # start word </span><span class="synSpecial">...</span>
<span class="synLinenum">   14</span> <span class="synConstant">        </span><span class="synSpecial">([a-z]+)</span><span class="synConstant">           # grab word in </span><span class="synIdentifier">$1</span><span class="synConstant"> and </span><span class="synSpecial">\1</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">(</span><span class="synConstant">                  # save the tags and spaces in </span><span class="synIdentifier">$2</span>
<span class="synLinenum">   16</span> <span class="synConstant">        </span><span class="synSpecial">(\s</span><span class="synConstant">|&lt;</span><span class="synSpecial">[^&gt;]+</span><span class="synConstant">&gt;</span><span class="synSpecial">)+</span><span class="synConstant">      # spaces or HTML tags </span>
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">)</span><span class="synConstant">   </span>
<span class="synLinenum">   18</span> <span class="synConstant">        </span><span class="synSpecial">(\1\b)</span><span class="synConstant">             # repeated word in </span><span class="synIdentifier">$4</span>
<span class="synLinenum">   19</span> <span class="synConstant">  </span><span class="synStatement">}</span>!<span class="synIdentifier">$bold$1$clear$2$bold$4$clear</span>!igx;
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synIdentifier">$par</span> =~ <span class="synStatement">s/</span><span class="synConstant">^</span><span class="synStatement">/</span><span class="synConstant">&quot;</span><span class="synIdentifier">$ARGV</span><span class="synConstant">(&quot;.</span><span class="synIdentifier">$line</span><span class="synConstant">++.&quot;): &quot;</span><span class="synStatement">/meg</span>;   <span class="synComment"># insert filename and line number</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">print</span> <span class="synIdentifier">$par</span>;
<span class="synLinenum">   24</span> }
</pre>

\end{rawhtml}%%}}}

%Esta es la solución:
%%%%%%%%%%%%%%%%listinginput: Input from: "../src/doublee.pl"
%\begin{verbatim}
%   1 #!/usr/bin/perl -w
%   2 # one <a>one</a>
%   3 # is two three
%   4 # three
%   5 $/ = ".\n";
%   6 while (<>) {
%   7   next if !s{
%   8     \b                 # start word ...
%   9     ([a-z]+)           # grab word in $1 and \1
%  10     (                  # save the tags and spaces in $2
%  11     (\s|<[^>]+>)+      # spaces or HTML tags 
%  12     )   
%  13     (\1\b)             # repeated word in $4
%  14   }
%  15   "\e[7m$1\e[m$2\e[7m$4\e[m"igx;
%  16   s/^([^\e]*\n)+//mg;  # remove lines that don't contain escapes
%  17   s/^/$ARGV: /mg;      # insert filename at the beginning of the lines
%  18   print;
%  19 }
%\end{verbatim}


\begin{rawhtml}
Sigue un ejemplo de uso:
<pre>
pl@nereida:~/Lperltesting$ cat -n t.t
     1  one one
     2  nothing rep
     3  is two three
     4  three four
     5
pl@nereida:~/Lperltesting$ ./repeatedwords2.pl t.t
t.t(1): <font color="blue">one one</font>
t.t(2): nothing rep
t.t(3): is two <font color="blue">three</font>
t.t(4): <font color="blue">three</font> four
t.t(5):
</pre>
\end{rawhtml}

\subsection{Análisis de cadenas con datos separados por comas}
\label{section:csv}
Supongamos que tenemos cierto texto en \verb|$text| proveniente
de un fichero \verb|CSV| (\emph{Comma Separated Values}). Esto es
el fichero contiene líneas con el formato:

\begin{verbatim}
"earth",1,"moon",9.374
\end{verbatim}

Esta línea representa cinco campos.
Es razonable querer guardar esta información en un \emph{array},
digamos \verb|@field|, de manera que \verb|$field[0] == 'earth'|,
\verb|$field[1] == '1'|, etc.
Esto no sólo implica descomponer la cadena en campos sino
también quitar las comillas de los campos entrecomillados.
La primera solución que se nos ocurre es hacer uso de la
función \verb|split|:

\begin{verbatim}
@fields = split(/,/,$text);
\end{verbatim}

Pero esta solución deja las comillas dobles en  los campos
entrecomillados.  Peor aún, los campos entrecomillados pueden contener
comas, en cuyo caso  la división proporcionada por \verb|split| sería
errónea. 

%%%%%%%%%%%%%%%listinginput: Input from: "../src/csv.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 use Text::ParseWords;
   3 
   4 sub parse_csv {
   5   my $text = shift;
   6   my @fields = (); # initialize @fields to be empty
   7 
   8   while ($text =~ 
   9     m/"(([^"\\]|\\.)*)",? # quoted fields
  10       | 
  11       ([^,]+),?           # $3 = non quoted fields
  12       | 
  13       ,                   # allows empty fields
  14     /gx 
  15     )
  16   {
  17     push(@fields, defined($1)? $1:$3); # add the just matched field
  18   }
  19   push(@fields, undef) if $text =~ m/,$/; #account for an empty last field
  20   return @fields;
  21 }
  22        
  23 $test = '"earth",1,"a1, a2","moon",9.374';
  24 print "string = \'$test\'\n";
  25 print "Using parse_csv\n:";
  26 @fields = parse_csv($test);
  27 foreach $i (@fields) {
  28   print "$i\n";
  29 }
  30 
  31 print "Using Text::ParseWords\n:";
  32 #  @words = &quotewords($delim, $keep, @lines);  
  33 #The $keep argument is a boolean flag.  If true, then the
  34 #tokens are split on the specified delimiter, but all other
  35 #characters (quotes, backslashes, etc.) are kept in the
  36 #tokens.  If $keep is false then the &*quotewords()
  37 #functions remove all quotes and backslashes that are not
  38 #themselves backslash-escaped or inside of single quotes
  39 #(i.e., &quotewords() tries to interpret these characters
  40 #just like the Bourne shell). 
  41 
  42 @fields = quotewords(',',0,$test);
  43 foreach $i (@fields) {
  44   print "$i\n";
  45 }
\end{verbatim}

Las subrutinas  en Perl reciben sus argumentos en el \emph{array}
\verb|@_|. Si la lista de argumentos contiene listas, estas 
son ``aplanadas'' en una única lista. Si, como es el caso, la subrutina
ha sido declarada antes de la llamada, los argumentos pueden
escribirse sin paréntesis que les rodeen:
\begin{verbatim}
@fields = parse_csv $test;
\end{verbatim}

Otro modo de llamar una subrutina es usando el prefijo \verb|&|,
pero sin proporcionar lista de argumentos.
\begin{verbatim}
@fields = &parse_csv;
\end{verbatim}
En este caso se le pasa a la rutina el valor actual del  \emph{array} \verb|@_|.

Los operadores \verb|push| (usado en la línea 17) y \verb|pop| trabajan
sobre el final del \emph{array}. De manera análoga los operadores
\verb|shift| y \verb|unshift| lo hacen sobre el comienzo.
El operador ternario \verb|?| trabaja de manera análoga como lo hace en C.

El código del \verb|push| podría sustituirse por este otro:
\begin{verbatim}
push(@fields, $+);
\end{verbatim}
Puesto que la variable \verb|$+| contiene la cadena que ha casado
con el último paréntesis que haya casado en el ultimo ``matching''.

La segunda parte del código muestra que existe un 
módulo en Perl, el módulo \verb|Text::Parsewords| que proporciona la rutina \verb|quotewords| que hace la misma función que nuestra subrutina.

Sigue un ejemplo de ejecución:
\begin{verbatim}
> csv.pl
string = '"earth",1,"a1, a2","moon",9.374'
Using parse_csv
:earth
1
a1, a2
moon
9.374
Using Text::ParseWords
:earth
1
a1, a2
moon
9.374    
\end{verbatim}

\subsection{Las Expresiones Regulares como Exploradores de un Árbol de Soluciones}

\parrafo{Números Primos}

El siguiente programa evalúa si un número es primo o no:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n isprime.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  my $num = shift;
 5  die "Usage: $0 integer\n" unless (defined($num) && $num =~ /^\d+$/);
 6
 7  if (("1" x $num) =~ /^(11+)\1+$/) {
 8    my $factor = length($1);
 9    print "$num is $factor x ".$num/$factor."\n";
10  }
11  else {
12    print "$num is prime\n";
13  }
\end{verbatim}
Siguen varias ejecuciones:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./isprime.pl 35.32
Usage: ./isprime.pl integer
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 147
147 is 49 x 3
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 49
49 is 7 x 7
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
\end{verbatim}


\parrafo{Ecuaciones Diofánticas: Una solución}

Según dice la entrada \wikipedia{Diophantine\_equation}\ en la wikipedia:

\begin{it}
\begin{quotation}
In mathematics, a Diophantine equation is an indeterminate polynomial equation that allows the variables to be integers only. 
\end{quotation}
\end{it}

La siguiente sesión con el depurador muestra como se puede 
resolver una ecuación lineal diofántica con coeficientes 
positivos usando una expresión regular:

\begin{verbatim}
  DB<1> # Resolvamos 3x + 2y + 5z = 40
DB<2> x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
1  'aa'
2  'aaaaa'
DB<3> x map { length }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  33
1  2
2  5
DB<4> @c = (3, 2, 5)
DB<5> x map { length($_) / $c[$i++] }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  11
1  1
2  1
DB<6> p 3*11+2*1+5*1
40
\end{verbatim}

\parrafo{Ecuaciones Diofánticas: Todas las soluciones}


Usando el verbo \verb|(*FAIL)| es posible obtener todas las soluciones:
\begin{verbatim}
main::(-e:1):   0
DB<1>  sub equ { my @c = @_; print "\t3*$c[0]+2*$c[1]+5*$c[2] = ",3*$c[0]+2*$c[1]+5*$c[2],"\n" }
DB<2> sub f { my @c = ((length($1)/3), (length($2)/2), (length($3)/5)); equ(@c); }
DB<3> x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$(?{ f() })(*FAIL)/x
        3*11+2*1+5*1 = 40
        3*9+2*4+5*1 = 40
        3*8+2*3+5*2 = 40
        3*7+2*7+5*1 = 40
        3*7+2*2+5*3 = 40
        3*6+2*6+5*2 = 40
        3*6+2*1+5*4 = 40
        3*5+2*10+5*1 = 40
        3*5+2*5+5*3 = 40
        3*4+2*9+5*2 = 40
        3*4+2*4+5*4 = 40
        3*3+2*13+5*1 = 40
        3*3+2*8+5*3 = 40
        3*3+2*3+5*5 = 40
        3*2+2*12+5*2 = 40
        3*2+2*7+5*4 = 40
        3*2+2*2+5*6 = 40
        3*1+2*16+5*1 = 40
        3*1+2*11+5*3 = 40
        3*1+2*6+5*5 = 40
        3*1+2*1+5*7 = 40
  empty array
DB<4>                                
\end{verbatim}


\parrafo{Ecuaciones Diofánticas: Resolutor general}

El siguiente programa recibe en línea de comandos los coeficientes y 
término inependeinte de una ecuación lineal diofántica con coeficientes 
positivos y muestra todas las soluciones. El
algoritmo primero crea una cadena conteniendo 
el código Perl que contiene la expresión regular adecuada 
para pasar luego a evaluarlo:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n diophantinesolvergen.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3  use strict;
 4
 5  # Writes a Perl solver for
 6  # a1 x1 + a2 x2 + ... + an xn = b
 7  # a_i and b integers > 0
 8  #
 9
10  my $b = pop;
11  my @a = @ARGV;
12  my $debug = 1;
13
14  my $b1 = '1'x$b;
15  my @a1 = map { '1'x$_ } @a;
16  my @index = map { 'length($'.$_.")/".$a[$_-1] } 1..(@a);
17  my $aux = join ",", @index;
18
19  my $regexp = '^';
20  $regexp .= "((?:$_)+)" for @a1;
21
22  $regexp .= '$(?{ f() })(*FAIL)';
23
24  my $solver = <<"SOLVER";
25  my \@stack;
26  sub f {
27    my \@s = ($aux);
28    push \@stack, [ \@s ];
29  }
30
31  q{$b1} =~ m{$regexp}x;
32
33  return \@stack;
34  SOLVER
35
36  print "Solver:\n--------\n$solver\n--------\n" if $debug;
37
38  my @stack = eval $solver;
39
40  say("@$_") for @stack
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./diophantinesolvergen.pl 3 2 5 40
Solver:
--------
my @stack;
sub f {
  my @s = (length($1)/3,length($2)/2,length($3)/5);
  push @stack, [ @s ];
}

q{1111111111111111111111111111111111111111} =~ m{^((?:111)+)((?:11)+)((?:11111)+)$(?{ f() })(*FAIL)}x;

return @stack;

--------
11 1 1
9 4 1
8 3 2
7 7 1
7 2 3
6 6 2
6 1 4
5 10 1
5 5 3
4 9 2
4 4 4
3 13 1
3 8 3
3 3 5
2 12 2
2 7 4
2 2 6
1 16 1
1 11 3
1 6 5
1 1 7
\end{verbatim}

\parrafo{Las  Tres Hijas}
\label{parrfo:lastreshijas}

En la páginas de Retos Matemáticos de

\htmladdnormallink{DIVULGAMAT}{http://divulgamat.ehu.es/weborriak/RetosMatematicos/Problemas/Prob15.asp}

puede encontrarse el siguiente problema:

\begin{exercise}
Dos matemáticos se vieron en la calle después de muchos años sin coincidir.

\begin{itemize}
\item  ¡Hola!, ¿qué tal?, ¿te casaste?, y... ¿cuántos hijos tienes?
\item  Pues tengo tres hijas.
\item  ¿y qué años tienen?
\item  ¡A ver si lo adivinas!: el producto de las edades de las tres es 36, y su suma es el número del portal que ves enfrente...
\item  ¡Me falta un dato!
\item  ¡Ah, sí!, ¡la mayor toca el piano!
\end{itemize}

%Two MIT math grads bump into each other while shopping at Fry’s. They haven't seen each other in over 20 years.
%
%First grad to the second: "How have you been?"
%Second: "Great! I got married and I have three daughters now."
%First: "Really? How old are they?"
%Second: "Well, the product of their ages is 72, and the sum of their ages is the same as the number on that building over there..."
%First: "Right, ok... Oh wait... Hmm, I still don't know."
%Second: "Oh sorry, the oldest one just started to play the piano."
%First: "Wonderful! My oldest is the same age!" 

¿Qué edad tendrán las tres hijas?

¿Podemos ayudarnos de una expresión regular para resolver el problema?
Al ejecutar el siguiente programa:
 
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n playspiano.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
 2  use v5.10;
 3  use strict;
 4  use List::Util qw{sum};
 5
 6  local our %u;
 7  sub f {
 8    my @a = @_;
 9    @a = sort { $b <=> $a } (length($a[1]), length($a[0])/length($a[1]), 36/length($a[0]) );
10
11    local $" = ", ";
12    say "(@a)\t ".sum(@a) unless exists($u{"@a"});
13    $u{"@a"} = undef;
14  }
15
16  say "SOL\t\tNUMBER";
17  my @a =  ('1'x36) =~
18           /^((1+)\2+)(\1+)$
19                     (?{ f($1, $2, $3)
20                      })
21             (*FAIL)
22           /x;
\end{verbatim}

obtenemos la salida:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./playspiano.pl
SOL             NUMBER
(9, 2, 2)        13
(6, 3, 2)        11
(4, 3, 3)        10
(18, 2, 1)       21
(12, 3, 1)       16
(9, 4, 1)        14
(6, 6, 1)        13
\end{verbatim}

Explique el funcionamiento del programa. 
A la vista de la salida ¿Cuáles eran las 
edades de las hijas?
\end{exercise}

\parrafo{Mochila 0-1}

Para una definición del problema vea la sección 
\htmladdnormallink{El Problema de la Mochila 0-1}{http://nereida.deioc.ull.es/~lhp/perlexamples/node205.html}
en los apuntes de LHP
\begin{exercise}
¿Sería capaz de resolver usando expresiones regulares el problema de la mochila 0-1?

¡Si lo logra merece el premio a la solución mas freak que se haya encontrado para dicho problema!
\end{exercise}

\parrafo{Véase también}

Véase  también:
\begin{itemize}
%\item
%\htmladdnormallink
%{http://blog.stevenlevithan.com/archives/algebra-with-regexes}
\item
Véase el nodo en \perlmonk{796576} \emph{The Oldest Plays the Piano}
\item
\htmladdnormallink{Solving Algebraic Equations Using Regular Expressions}{http://blog.stevenlevithan.com/archives/algebra-with-regexes}
\end{itemize}

\subsection{Número de substituciones realizadas}
El operador de substitución devuelve el número de substituciones
realizadas, que puede ser mayor que uno si se usa la opción
\verb|/g|. En cualquier otro caso retorna el valor falso.
%%%%%%%%%%%%%%%listinginput: Input from: "../src/numsust.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 undef($/);
   3 $paragraph = <STDIN>;
   4 $count = 0;
   5 $count = ($paragraph =~ s/Mister\b/Mr./ig);
   6 print "$paragraph";
   7 print "\n$count\n";
\end{verbatim}
El resultado de la ejecución es el siguiente:
\begin{verbatim}
> numsust.pl
Dear Mister Bean,
Is a pleasure for me and Mister Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mister Goofy.
 
Yours sincerely
  Mister Mickey Mouse
Dear Mr. Bean,
Is a pleasure for me and Mr. Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mr. Goofy.
 
Yours sincerely
  Mr. Mickey Mouse
 
4   
\end{verbatim}

\subsection{Expandiendo y comprimiendo tabs}
Este programa convierte los tabs en el número apropiado de blancos.
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  
   4  my @string = <>;
   5  
   6  for (@string) {
   7    while (s/\t+/' ' x (length($&)*8 - length($`)%8)/e) {}
   8    print $_;
   9  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span> <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = &lt;&gt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>   <span class="synStatement">while</span> (<span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$&amp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/e</span>) {}
<span class="synLinenum">    8</span>   <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span> }
</pre>

\end{rawhtml}
%}}}
Sigue un ejemplo de ejecución:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -nt tabs.in
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ ./expandtabs.pl tabs.in | cat -tn
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">cat -nt tabs.in</span>
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ <span class="dbuser">./expandtabs.pl tabs.in | cat -tn</span>
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
</pre>
\end{rawhtml}
%}}}

\begin{exercise}
¿Funciona igual si se cambia el bucle \verb|while| por una opción \verb|/g|?
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my @string = <>;
   5  
   6    for (@string) {
   7      s/\t+/' ' x (length($&)*8 - length($`)%8)/ge;
   8      print $_;
   9    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = &lt;&gt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>     <span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$&amp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/ge</span>;
<span class="synLinenum">    8</span>     <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span>   }
</pre>

\end{rawhtml}
%}}}
¿Porqué?
\end{exercise}

\subsection{Modificación de Múltiples Ficheros: one liner}
Aunque no es la forma de uso habitual, Perl puede ser utilizado en ``modo sed'' para modificar el texto en múltiples ficheros: 

\verb|perl  -e 's/nereida\.deioc\.ull\.es/miranda.deioc.ull.es/gi'  -p  -i.bak  *.html|

Este programa sustituye la palabra original (g)lobalmente e i)gnorando el ``case'') en todos los ficheros \verb|*.html| y para cada uno de ellos crea una copia de seguridad \verb|*.html.bak|. 

Otro ejemplo: la sustitución que sigue ocurre en todos los ficheros \verb|info.txt| en todos
los subdirectorios de los subdirectorios que comiencen por \verb|alu|:

\begin{verbatim}
perl -e 's/\|hyperpage//gi' -p -i.bak  alu*/*/info.txt
\end{verbatim}

Las \cei{opciones de línea} de comandos significan lo siguiente:

\begin{itemize}
\item[-e] puede usarse para definir el script en la línea de comandos. Multiples -e te permiten escribir un multi-script. Cuando se usa -e, perl
      no busca por un fichero de script entre la lista de argumentos. 

\item[-p] La opción \teis{-p}{Opción de perl -p} hace que perl incluya un bucle alrededor de tu ``script'' al estilo sed: 
\begin{verbatim}
while (<>) {
        ...             # your script goes here
} continue {
        print;
}
\end{verbatim}
\item[-n] Nótese que las líneas se imprimen automáticamente. Para suprimir la impresión usa la opción 
\teis{-n}{Opción de perl -n} 

\item[-i[ext]] La opción \teis{-i}{Opción de perl -i} Expresa que los ficheros procesados serán modificados. Se renombra el fichero de entrada \verb|file.in| a \verb|file.in.ext|, abriendo el de salida con el mismo nombre del fichero de entrada \verb|file.in|.
      Se selecciona dicho fichero como de salida por defecto para las sentencias \verb|print|. Si se proporciona una extensión se hace una copia de seguridad. Si no, no se hace copia de seguridad.
\end{itemize}

En general las opciones pueden ponerse en la primera
línea del ``script'', donde se indica el intérprete. 
Asi pues, decir 

\verb|perl -p -i.bak -e "s/foo/bar/;"| 

es equivalente a usar el ``script'': 
\begin{verbatim}
#!/usr/bin/perl -pi.bak
s/foo/bar/;
\end{verbatim}

\section{tr y split}
\label{section:tr}
El operador de traducción permite la conversión de unos caracteres por otros. 
Tiene la sintáxis:

\begin{tabular}{l}
\verb|tr/SEARCHLIST/REPLACEMENTLIST/cds|\\
\verb|y/SEARCHLIST/REPLACEMENTLIST/cds|\\
\end{tabular}

El operador permite el reemplazo carácter a carácter, por ejemplo:
\begin{verbatim}
$ perl -de 0
  DB<1> $a = 'fiboncacci'
  DB<2> $a =~ tr/aeiou/AEIOU/
  DB<3> print $a
fIbOncAccI
  DB<4> $a =~ y/fbnc/FBNC/
  DB<5> print $a
FIBONCACCI
\end{verbatim}
El operador devuelve el número de carácteres reeemplazados
o suprimidos. 
\begin{verbatim}
$cnt = $sky =~ tr/*/*/; # count the stars in $sky
\end{verbatim}

Si se especifica el modificador \verb|/d|, cualquier carácter en  \verb|SEARCHLIST|
que no figure en \verb|REPLACEMENTLIST| es eliminado.
\begin{verbatim}
  DB<6> print $a
FIBONCACCI
  DB<7> $a =~ y/OA//d
  DB<8> print $a
FIBNCCCI
\end{verbatim}


Si se especifica el modificador \verb|/s|, las secuencias de carácteres
consecutivos que serían traducidas al mismo carácter son comprimidas a una sola:

\begin{verbatim}
  DB<1> $b = 'aaghhh!'
  DB<2> $b =~ tr/ah//s
  DB<3> p $b
agh!
\end{verbatim}

Observa que si la cadena \verb|REPLACEMENTLIST| es vacía,
no se introduce ninguna modificación.

Si se especifica el modificador \verb|/c|, se complementa \verb|SEARCHLIST|;
esto es, se buscan los caracteres que no están en \verb|SEARCHLIST|.

\begin{verbatim}
tr/a-zA-Z/ /cs; # change non-alphas to single space
\end{verbatim}

Cuando se dan múltiples traducciones para un mismo carácter, solo la primera es utilizada:

\begin{verbatim}
tr/AAA/XYZ/
\end{verbatim}

traducirá \verb|A| por \verb|X|.

El siguiente \emph{script} busca una expresión regular en el fichero de \verb|passwords|
e imprime los \emph{login} de los usuarios que casan con dicha cadena.
Para evitar posibles confusiones con las vocales acentuadas
se usa el operador \verb|tr|.

%%%%%%%%%%%%%%%listinginput: Input from: "../src/split.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 $search = shift(@ARGV) or die("you must provide a regexpr\n");
   3 $search =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   4 open(FILE,"/etc/passwd");
   5 while ($line = <FILE>) {
   6   $line =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   7   if ($line =~ /$search/io) {
   8     @fields = split(":",$line);
   9     $login = $fields[0];
  10     if ($line !~ /^#/) {
  11       print "$login\n";
  12     }
  13     else {
  14       print "#$login\n";
  15     }
  16   }
  17 }
  18   
\end{verbatim}

Ejecución (suponemos que el nombre del fichero anterior es \verb|split.pl|):
\begin{verbatim}
> split.pl Rodriguez
##direccion
call
casiano
alu5
alu6
##doctorado
paco
falmeida
##ihiu07 
\end{verbatim}


Para familiarizarte con este operador, codifica y prueba el siguiente
código:

%%%%%%%%%%%%%%%listinginput: Input from: "../src/tr.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 $searchlist = shift @ARGV;
   3 $replacelist = shift @ARGV;
   4 $option = "";
   5 $option = shift @ARGV if @ARGV;
   6 
   7 while (<>) {
   8   $num = eval "tr/$searchlist/$replacelist/$option";
   9   die $@ if $@;
  10   print "$num: $_";
  11 }
\end{verbatim}

Perl construye la tabla de traducción en ``tiempo de compilación''. Por ello
ni \verb|SEARCHLIST| ni \verb|REPLACEMENTLIST| son susceptibles de 
ser interpolados. Esto significa que si queremos usar variables tenemos
que recurrir a la función \verb|eval|.

La expresión pasada como parámetro a \verb|eval| en la línea 8 es analizada y ejecutada como si 
se tratara de un pequeño programa Perl. Cualquier asignación a variables permanece
después del \verb|eval|, asi como cualquier definición de subrutina. 
El código dentro de \verb|eval| se trata como si fuera un bloque, de manera
que cualesquiera variables locales (declaradas con \verb|my|) desaparecen
al final del bloque.

La variable \verb|$@| contiene el mensaje de error asociado con la
última ejecución del comando \verb|eval|. Si es nula es que el último comando
se ejecuto correctamente.
Aqui tienes un ejemplo de llamada:

\begin{verbatim}
> tr.pl 'a-z' 'A-Z' s
jose hernandez
13: JOSE HERNANDEZ
joosee hernnandez
16: JOSE HERNANDEZ 
\end{verbatim}

\section{{\tt Pack} y {\tt Unpack}}
\label{section:pack}
El operador \verb|pack| trabaja de forma parecida a \verb|sprintf|.
Su primer argumento es una cadena, seguida de una lista de valores
a formatear y devuelve una cadena:
\begin{verbatim}
pack("CCC", 65, 66, 67, 68) # empaquetamos A B C D
\end{verbatim}
el inverso es el operador \verb|unpack|
\begin{verbatim}
unpack("CCC", "ABCD")
\end{verbatim}
La cadena de formato es una lista de especificadores que indican el
tipo del dato que se va a empaquetar/desempaquetar. Cada especificador
puede opcionalmente seguirse de un contador de repetición
que indica el número de elementos a formatear. Si se pone un
asterisco (\verb|*|) se indica que la especificación
se aplica a todos los elementos restantes de la lista.

\begin{tabular}{|l|l|l}
Formato  & Descripción \\
A & Una cadena completada con blancos\\
a & Una cadena completada con ceros\\
B & Una cadena binaria en orden descendente\\
b & Una cadena binaria en orden ascendente\\
H & Una cadena hexadecimal, los nibble altos primero\\
h & Una cadena hexadecimal, los nibble bajos primero\\
\end{tabular}

Ejemplo de uso del formato \verb|A|:
\begin{verbatim}
DB<1> $a = pack "A2A3", "Pea","rl"
DB<2> p $a
Perl
DB<3> @b = unpack "A2A3", "Perl"
DB<4> p "@b"
Pe rl
\end{verbatim}
La variable \verb|@b| tiene ahora dos cadenas. Una es \verb|Pe| la otra es \verb|rl|.
Veamos un ejemplo con el formato \verb|B|:
\begin{verbatim}
p ord('A')
65
DB<22> $x = pack "B8", "01000001"
DB<23> p $x
A
DB<24> @y = unpack "B8", "A"
DB<25> p "@y"
01000001
DB<26> $x = pack "b8", "10000010"
DB<27> p $x
\end{verbatim}

\sectionpractica{Un lenguaje para Componer Invitaciones}
\label{practica:invitaciones}

En el capítulo 6 (sección 6.4.2.2) del libro 
\htmladdnormallink{The LaTex Web Companion}{http://books.google.es/books?id=B93uJGLZhAoC\&lpg=PP1\&ots=-JFhDfZPwN\&dq=The\%20LaTEX\%20web\%20companion\&hl=en\&pg=PP1\#v=onepage\&q=\&f=false}
se define un lenguaje para componer textos para enviar invitaciones.

Para escribir una invitación en ese lenguaje escribiríamos algo así:

\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  <?xml version="1.0"?>
 2  <!DOCTYPE invitation SYSTEM "invitation.dtd">
 3  <invitation>
 4  <!-- ++++ The header part of the document ++++ -->
 5  <front>
 6  <to>Anna, Bernard, Didier, Johanna</to>
 7  <date>Next Friday Evening at 8 pm</date>
 8  <where>The Web Cafe</where>
 9  <why>My first XML baby</why>
10  </front>
11  <!-- +++++ The main part of the document +++++ -->
12  <body>
13  <par>
14  I would like to invite you all to celebrate
15  the birth of <emph>Invitation</emph>, my
16  first XML document child.
17  </par>
18  <par>
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  </par>
22  <par>
23  I <emph>really</emph> look forward to see you soon!
24  </par>
25  </body>
26  <!-- +++ The closing part of the document ++++ -->
27  <back>
28  <signature>Michel</signature>
29  </back>
30  </invitation>
\end{verbatim}

La sintáxis del lenguaje queda reflejada en la siguiente 
\cei{Document Type Definition} (\cei{DTD}) que aparece en la sección 6.4.3
del libro de Goosens:

\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.dtd
 1  <!-- invitation DTD   -->
 2  <!-- May 26th 1998 mg -->
 3  <!ELEMENT invitation (front, body, back) >
 4  <!ELEMENT front      (to, date, where, why?) >
 5  <!ELEMENT date       (#PCDATA) >
 6  <!ELEMENT to         (#PCDATA) >
 7  <!ELEMENT where      (#PCDATA) >
 8  <!ELEMENT why        (#PCDATA) >
 9  <!ELEMENT body       (par+) >
10  <!ELEMENT par        (#PCDATA|emph)* >
11  <!ELEMENT emph       (#PCDATA) >
12  <!ELEMENT back       (signature) >
13  <!ELEMENT signature  (#PCDATA) >
\end{verbatim}

El  objetivo de esta práctica es escribir un programa Perl
que usando las extensiones para expresiones regulares presentes 
en la versión 5.10 reconozca el lenguaje anterior.

Véase también:

\begin{itemize}
\item
\htmladdnormallink{The LaTex Web Companion}{http://books.google.es/books?id=B93uJGLZhAoC\&lpg=PP1\&ots=-JFhDfZPwN\&dq=The\%20LaTEX\%20web\%20companion\&hl=en\&pg=PP1\#v=onepage\&q=\&f=false}
\item
\htmladdnormallink{Examples from The LaTeX Web Companion}{http://www.ctan.org/tex-archive/info/examples/lwc/} (véanse los subdirectorios
correspondietnes a los capítulos 6 y 7)
%\item
%\htmladdnormallink{CSS Tutorial}{http://www.w3schools.com/css/}
%\item
%\htmladdnormallink{Edición extremadamente simple de HTML}{http://www.psicobyte.com/html/index.html}
%\item
%\htmladdnormallink{Perl-XML Frequently Asked Questions}{http://perl-xml.sourceforge.net/faq/}
\end{itemize}

% see jeff Pinyan Regex::Parser

\section{Analisis Sintáctico con Expresiones Regulares Perl}

\subsection{Introducción al Anaĺisis Sintáctico con Expresiones Regulares}

Como se ha comentado en la sección
\ref{subsection:regexp510lenrec}
Perl 5.10 permite el reconocimiento de expresiones
definidas mediante gramáticas recursivas, siempre que 
estas puedan ser analizadas por un analizador recursivo descendente.
Sin embargo, las expresiones regulares Perl 5.10 
hace difícil construir una representación 
del árbol de análisis sintáctico abstracto. Además, la necesidad
de explicitar en la regexp los blancos existentes entre los símbolos
hace que la descripción sea menos robusta y menos legible.

\parrafo{Ejemplo: Traducción de expresiones aritméticas en infijo a postfijo}

El siguiente ejemplo muestra una expresión regular
que traduce expresiones de diferencias en infijo
a postfijo.

Se usa una variable \verb|$tran| 
para calcular la traducción de
la subexpresión vista hasta el momento.

La gramática original que consideramos
es recursiva a izquierdas:
\begin{verbatim}
 exp ->   exp '-' digits
        | digits
\end{verbatim}
aplicando las técnicas explicadas en
\ref{subsection:eliminaleftrec} y en 
el nodo de perlmonks
\pmm{Operator Associativity and Eliminating Left-Recursion in Parse::RecDescent}{553889}
transformamos la gramática en:
\begin{verbatim}
exp ->   digits rest
rest ->   '-' rest
        | # empty
\end{verbatim}

Sigue el código:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    # Infix to postfix translator using 5.10 regexp
  5    # original grammar:
  6    #  exp ->   exp '-' digits
  7    #         | digits
  8    #
  9    # Applying left-recursion elimination we have:
 10    #  exp ->   digits rest
 11    #  rest ->   '-' rest
 12    #          | # empty
 13    #
 14    my $input;
 15    local our $tran = '';
 16  
 17    my $regexp = qr{
 18        (?&exp)
 19  
 20        (?(DEFINE)
 21            (?<exp>    ((?&digits)) \s* (?{ $tran .= "$^N "; say "tran=$tran"; }) (?&rest)
 22                          (?{
 23                             say "exp -> digits($^N) rest";
 24                          })
 25            )
 26  
 27            (?<rest>     \s* - ((?&digits)) (?{ $tran .= "$^N - "; say "tran=$tran"; }) (?&rest)
 28                            (?{
 29                               say "rest -> - digits($^N) rest";
 30                            })
 31                      |  # empty
 32                            (?{
 33                               say "rest -> empty";
 34                            })
 35            )
 36  
 37            (?<digits>  \s* (\d+)
 38            )
 39        )
 40    }xms;
 41  
 42    $input = <>;
 43    chomp($input);
 44    if ($input =~ $regexp) {
 45      say "matches: $&\ntran=$tran";
 46    }
 47    else {
 48      say "does not match";
 49    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># original grammar:</span>
<span class="synLinenum">    6</span>   <span class="synComment">#  exp -&gt;   exp '-' digits</span>
<span class="synLinenum">    7</span>   <span class="synComment">#         | digits</span>
<span class="synLinenum">    8</span>   <span class="synComment">#</span>
<span class="synLinenum">    9</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   10</span>   <span class="synComment">#  exp -&gt;   digits rest</span>
<span class="synLinenum">   11</span>   <span class="synComment">#  rest -&gt;   '-' rest</span>
<span class="synLinenum">   12</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   13</span>   <span class="synComment">#</span>
<span class="synLinenum">   14</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   15</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$tran</span> = <span class="synConstant">''</span>;
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   21</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">((?</span><span class="synConstant">&amp;digits</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">{ </span><span class="synIdentifier">$tran</span><span class="synConstant"> </span><span class="synSpecial">.</span><span class="synConstant">= &quot;</span><span class="synIdentifier">$^</span><span class="synConstant">N &quot;; say &quot;tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">&quot;; }</span>) (?<span class="synIdentifier">&amp;rest</span>)
<span class="synLinenum">   22</span>                         (?{
<span class="synLinenum">   23</span>                            say <span class="synConstant">&quot;exp -&gt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rest&quot;</span>;
<span class="synLinenum">   24</span>                         })
<span class="synLinenum">   25</span>           )
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span>           (?<span class="synIdentifier">&lt;rest&gt;</span>     \s* - ((?<span class="synIdentifier">&amp;digits</span>)) (?{ <span class="synIdentifier">$tran</span> .= <span class="synConstant">&quot;</span><span class="synIdentifier">$^</span><span class="synConstant">N - &quot;</span>; say <span class="synConstant">&quot;tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">&quot;</span>; }) (?<span class="synIdentifier">&amp;rest</span>)
<span class="synLinenum">   28</span>                           (?{
<span class="synLinenum">   29</span>                              say <span class="synConstant">&quot;rest -&gt; - digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rest&quot;</span>;
<span class="synLinenum">   30</span>                           })
<span class="synLinenum">   31</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   32</span>                           (?{
<span class="synLinenum">   33</span>                              say <span class="synConstant">&quot;rest -&gt; empty&quot;</span>;
<span class="synLinenum">   34</span>                           })
<span class="synLinenum">   35</span>           )
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* (\d+)
<span class="synLinenum">   38</span>           )
<span class="synLinenum">   39</span>       )
<span class="synLinenum">   40</span>   }xms;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>   <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   43</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   44</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   45</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   46</span>   }
<span class="synLinenum">   47</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   48</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   49</span>   }
</pre>

\end{rawhtml}
%}}}
La variable \verb|$^N| contiene el valor que casó con el último paréntesis.
Al ejecutar el código anterior obtenemos:

Véase la ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./infixtopostfix.pl
ab 5 - 3 -2 cd;
tran= 5
tran= 5  3 -
tran= 5  3 - 2 -
rest -> empty
rest -> - digits(2) rest
rest -> - digits( 3) rest
exp -> digits( 5) rest
matches:  5 - 3 -2
tran= 5  3 - 2 -
\end{verbatim}

Como se ve, el recorrido primero profundo se 
traduce en la reconstrucción de una derivación a derechas.

\parrafo{Accediendo a los atributos de paréntesis anteriores mediante acciones intermedias}

Es difícil extender el ejemplo anterior a lenguajes mas complejos debido a la 
limitación de que sólo se dispone de acceso al último paréntesis vía \verb|$^N|.
En muchos casos es necesario poder acceder a paréntesis/atributos anteriores.

El siguiente código considera el caso de expresiones con sumas, restas, multiplicaciones
y divisiones. Utiliza la variable \verb|op| y una acción intermedia (líneas 51-53) 
para almacenar el segundo paréntesis necesitado:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp ->   exp [-+] term
 8    #         | term
 9    #  term ->   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  ->   term re
15    #  re   ->   [+-] term re
16    #          | # empty
17    #  term ->   digits rt
18    #  rt   ->   [*/] rt
19    #          | # empty
20  
21  
22    my $input;
23    my @stack;
24  
25    local our $op = '';
26    my $regexp = qr{
27        (?&exp)
28  
29        (?(DEFINE)
30            (?<exp>    (?&term) (?&re)
31                         (?{ say "exp -> term re" })
32            )
33  
34            (?<re>     \s* ([+-]) (?&term) \s* (?{ push @stack, $^N }) (?&re)
35                         (?{ say "re -> [+-] term re" })
36                     | # empty
37                         (?{ say "re -> empty" })
38            )
39  
40            (?<term>   ((?&digits))
41                          (?{ # intermediate action
42                              push @stack, $^N
43                          })
44                       (?&rt)
45                          (?{
46                              say "term-> digits($^N) rt";
47                          })
48            )
49  
50            (?<rt>     \s*([*/])
51                               (?{ # intermediate action
52                                  local $op = $^N;
53                               })
54                       ((?&digits)) \s*
55                               (?{  # intermediate action
56                                    push @stack, $^N, $op
57                                })
58                       (?&rt) # end of <rt> definition
59                               (?{
60                                    say "rt -> [*/] digits($^N) rt"
61                                })
62                      |  # empty
63                         (?{ say "rt -> empty" })
64            )
65  
66            (?<digits>  \s* \d+
67            )
68        )
69    }xms;
70  
71    $input = <>;
72    chomp($input);
73    if ($input =~ $regexp) {
74      say "matches: $&\nStack=(@stack)";
75    }
76    else {
77      say "does not match";
78    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -&gt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -&gt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -&gt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -&gt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -&gt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -&gt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   24</span> 
<span class="synLinenum">   25</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$op</span> = <span class="synConstant">''</span>;
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   27</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   30</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">(?</span><span class="synConstant">&amp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   31</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say &quot;exp -&gt; term re&quot; }</span>)
<span class="synLinenum">   32</span>           )
<span class="synLinenum">   33</span> 
<span class="synLinenum">   34</span>           (?<span class="synIdentifier">&lt;re&gt;</span>     \s* ([+-]) (?<span class="synIdentifier">&amp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N }) (?<span class="synIdentifier">&amp;re</span>)
<span class="synLinenum">   35</span>                        (?{ say <span class="synConstant">&quot;re -&gt; [+-] term re&quot;</span> })
<span class="synLinenum">   36</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   37</span>                        (?{ say <span class="synConstant">&quot;re -&gt; empty&quot;</span> })
<span class="synLinenum">   38</span>           )
<span class="synLinenum">   39</span> 
<span class="synLinenum">   40</span>           (?<span class="synIdentifier">&lt;term&gt;</span>   ((?<span class="synIdentifier">&amp;digits</span>))
<span class="synLinenum">   41</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   42</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N
<span class="synLinenum">   43</span>                         })
<span class="synLinenum">   44</span>                      (?<span class="synIdentifier">&amp;rt</span>)
<span class="synLinenum">   45</span>                         (?{
<span class="synLinenum">   46</span>                             say <span class="synConstant">&quot;term-&gt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>;
<span class="synLinenum">   47</span>                         })
<span class="synLinenum">   48</span>           )
<span class="synLinenum">   49</span> 
<span class="synLinenum">   50</span>           (?<span class="synIdentifier">&lt;rt&gt;</span>     \s*([*/])
<span class="synLinenum">   51</span>                              (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   52</span>                                 <span class="synStatement">local</span> <span class="synIdentifier">$op</span> = <span class="synIdentifier">$^</span>N;
<span class="synLinenum">   53</span>                              })
<span class="synLinenum">   54</span>                      ((?<span class="synIdentifier">&amp;digits</span>)) \s*
<span class="synLinenum">   55</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   56</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N, <span class="synIdentifier">$op</span>
<span class="synLinenum">   57</span>                               })
<span class="synLinenum">   58</span>                      (?<span class="synIdentifier">&amp;rt</span>) <span class="synComment"># end of &lt;rt&gt; definition</span>
<span class="synLinenum">   59</span>                              (?{
<span class="synLinenum">   60</span>                                   say <span class="synConstant">&quot;rt -&gt; [*/] digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>
<span class="synLinenum">   61</span>                               })
<span class="synLinenum">   62</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   63</span>                        (?{ say <span class="synConstant">&quot;rt -&gt; empty&quot;</span> })
<span class="synLinenum">   64</span>           )
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* \d+
<span class="synLinenum">   67</span>           )
<span class="synLinenum">   68</span>       )
<span class="synLinenum">   69</span>   }xms;
<span class="synLinenum">   70</span> 
<span class="synLinenum">   71</span>   <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   72</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   73</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   74</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   75</span>   }
<span class="synLinenum">   76</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   77</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   78</span>   }
</pre>

\end{rawhtml}
%}}}

Sigue una ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./calc510withactions3.pl
5-8/4/2-1
rt -> empty
term-> digits(5) rt
rt -> empty
rt -> [*/] digits(2) rt
rt -> [*/] digits(4) rt
term-> digits(8) rt
rt -> empty
term-> digits(1) rt
re -> empty
re -> [+-] term re
re -> [+-] term re
exp -> term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
\end{verbatim}

\parrafo{Accediendo a los atributos de paréntesis anteriores mediante {\tt @-}}

Sigue una solución alternativa que obvia la necesidad de introducir
incómodas acciones intermedias. Utilizamos 
las variables \verb|@-| y \verb|@+|:
 
\begin{it}\begin{quotation}
Since Perl 5.6.1 the special variables \verb|@-| and \verb|@+| can functionally replace
\verb|$`|, \verb|$&| and \verb|$'|. These arrays contain pointers to the beginning and end of
each match (see \perldoc{perlvar} for the full story), so they give you essentially
the same information, but without the risk of excessive string copying.
\end{quotation}\end{it}

Véanse los párrafos en las páginas
\pageref{parrafo:fincas}, \pageref{parrafo:iniciocas}) y
\pageref{parrafo:lastpar} para mas información sobre \verb|@-| y \verb|@+|.

Nótese la función \verb|rc| en las líneas
21-28. \verb|rc(1)| nos retorna lo que casó con el último paréntesis,
\verb|rc(2)| lo que casó con el penúltimo, etc.


\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp ->   exp [-+] term
 8    #         | term
 9    #  term ->   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  ->   term re
15    #  re   ->   [+-] term re
16    #          | # empty
17    #  term ->   digits rt
18    #  rt   ->   [*/] rt
19    #          | # empty
20  
21    sub rc {
22      my $ofs = - shift;
23  
24      # Number of parenthesis that matched
25      my $np = @-;
26      #      string, ofsset, length
27      substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
28    }
29  
30    my $input;
31    my @stack;
32  
33    my $regexp = qr{
34        (?&exp)
35  
36        (?(DEFINE)
37            (?<exp>    (?&term) (?&re)
38                         (?{ say "exp -> term re" })
39            )
40  
41            (?<re>     \s* ([+-]) (?&term) \s* (?{ push @stack, rc(1) }) (?&re)
42                         (?{ say "re -> [+-] term re" })
43                     | # empty
44                         (?{ say "re -> empty" })
45            )
46  
47            (?<term>   ((?&digits))
48                          (?{ # intermediate action
49                              push @stack, rc(1)
50                          })
51                       (?&rt)
52                          (?{
53                              say "term-> digits(".rc(1).") rt";
54                          })
55            )
56  
57            (?<rt>     \s*([*/]) ((?&digits)) \s*
58                               (?{  # intermediate action
59                                    push @stack, rc(1), rc(2)
60                                })
61                       (?&rt) # end of <rt> definition
62                               (?{
63                                    say "rt -> [*/] digits(".rc(1).") rt"
64                                })
65                      |  # empty
66                         (?{ say "rt -> empty" })
67            )
68  
69            (?<digits>  \s* \d+
70            )
71        )
72    }xms;
73  
74    $input = <>;
75    chomp($input);
76    if ($input =~ $regexp) {
77      say "matches: $&\nStack=(@stack)";
78    }
79    else {
80      say "does not match";
81    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -&gt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -&gt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -&gt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -&gt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -&gt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -&gt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> rc </span>{
<span class="synLinenum">   22</span>     <span class="synStatement">my</span> <span class="synIdentifier">$ofs</span> = - <span class="synStatement">shift</span>;
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>     <span class="synComment"># Number of parenthesis that matched</span>
<span class="synLinenum">   25</span>     <span class="synStatement">my</span> <span class="synIdentifier">$np</span> = @-;
<span class="synLinenum">   26</span>     <span class="synComment"># $_ contains the string being matched</span>
<span class="synLinenum">   27</span>     <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$-</span>[<span class="synIdentifier">$ofs</span>], <span class="synIdentifier">$+</span>[<span class="synIdentifier">$np</span>+<span class="synIdentifier">$ofs</span>] - <span class="synIdentifier">$-</span>[<span class="synIdentifier">$ofs</span>])
<span class="synLinenum">   28</span>   }
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   31</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   34</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   35</span> 
<span class="synLinenum">   36</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   37</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">(?</span><span class="synConstant">&amp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   38</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say &quot;exp -&gt; term re&quot; }</span>)
<span class="synLinenum">   39</span>           )
<span class="synLinenum">   40</span> 
<span class="synLinenum">   41</span>           (?<span class="synIdentifier">&lt;re&gt;</span>     \s* ([+-]) (?<span class="synIdentifier">&amp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>) }) (?<span class="synIdentifier">&amp;re</span>)
<span class="synLinenum">   42</span>                        (?{ say <span class="synConstant">&quot;re -&gt; [+-] term re&quot;</span> })
<span class="synLinenum">   43</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   44</span>                        (?{ say <span class="synConstant">&quot;re -&gt; empty&quot;</span> })
<span class="synLinenum">   45</span>           )
<span class="synLinenum">   46</span> 
<span class="synLinenum">   47</span>           (?<span class="synIdentifier">&lt;term&gt;</span>   ((?<span class="synIdentifier">&amp;digits</span>))
<span class="synLinenum">   48</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   49</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>)
<span class="synLinenum">   50</span>                         })
<span class="synLinenum">   51</span>                      (?<span class="synIdentifier">&amp;rt</span>)
<span class="synLinenum">   52</span>                         (?{
<span class="synLinenum">   53</span>                             say <span class="synConstant">&quot;term-&gt; digits(&quot;</span>.rc(<span class="synConstant">1</span>).<span class="synConstant">&quot;) rt&quot;</span>;
<span class="synLinenum">   54</span>                         })
<span class="synLinenum">   55</span>           )
<span class="synLinenum">   56</span> 
<span class="synLinenum">   57</span>           (?<span class="synIdentifier">&lt;rt&gt;</span>     \s*([*/]) ((?<span class="synIdentifier">&amp;digits</span>)) \s*
<span class="synLinenum">   58</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   59</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>), rc(<span class="synConstant">2</span>)
<span class="synLinenum">   60</span>                               })
<span class="synLinenum">   61</span>                      (?<span class="synIdentifier">&amp;rt</span>) <span class="synComment"># end of &lt;rt&gt; definition</span>
<span class="synLinenum">   62</span>                              (?{
<span class="synLinenum">   63</span>                                   say <span class="synConstant">&quot;rt -&gt; [*/] digits(&quot;</span>.rc(<span class="synConstant">1</span>).<span class="synConstant">&quot;) rt&quot;</span>
<span class="synLinenum">   64</span>                               })
<span class="synLinenum">   65</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   66</span>                        (?{ say <span class="synConstant">&quot;rt -&gt; empty&quot;</span> })
<span class="synLinenum">   67</span>           )
<span class="synLinenum">   68</span> 
<span class="synLinenum">   69</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* \d+
<span class="synLinenum">   70</span>           )
<span class="synLinenum">   71</span>       )
<span class="synLinenum">   72</span>   }xms;
<span class="synLinenum">   73</span> 
<span class="synLinenum">   74</span>   <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   75</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   76</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   77</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   78</span>   }
<span class="synLinenum">   79</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   80</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   81</span>   }
</pre>

\end{rawhtml}
%}}}

Ahora accedemos a los atributos asociados con los dos paréntesis,
en la regla de \verb|<rt>| usando la función \verb|rc|:

\begin{verbatim}
         (?<rt>     \s*([*/]) ((?&digits)) \s*
                            (?{  # intermediate action
                                 push @stack, rc(1), rc(2)
                             })
\end{verbatim}

Sigue una ejecución del programa:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./calc510withactions4.pl
5-8/4/2-1
rt -> empty
term-> digits(5) rt
rt -> empty
rt -> [*/] digits(2) rt
rt -> [*/] digits(4) rt
term-> digits(8) rt
rt -> empty
term-> digits(1) rt
re -> empty
re -> [+-] term re
re -> [+-] term re
exp -> term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
pl@nereida:~/Lperltesting$
\end{verbatim}

\parrafo{Accediendo a los atributos de paréntesis anteriores mediante paréntesis 
con nombre}

Una nueva solución: dar nombre a los paréntesis y acceder a los mismos:
\begin{verbatim}
47          (?<rt>     \s*(?<op>[*/]) (?<num>(?&digits)) \s*
48                             (?{  # intermediate action
49                                  push @stack, $+{num}, $+{op}
50                              })
\end{verbatim}

Sigue el código completo:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp ->   exp [-+] term
 8    #         | term
 9    #  term ->   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  ->   term re
15    #  re   ->   [+-] term re
16    #          | # empty
17    #  term ->   digits rt
18    #  rt   ->   [*/] rt
19    #          | # empty
20  
21    my @stack;
22  
23    my $regexp = qr{
24        (?&exp)
25  
26        (?(DEFINE)
27            (?<exp>    (?&term) (?&re)
28                         (?{ say "exp -> term re" })
29            )
30  
31            (?<re>     \s* ([+-]) (?&term) \s* (?{ push @stack, $^N }) (?&re)
32                         (?{ say "re -> [+-] term re" })
33                     | # empty
34                         (?{ say "re -> empty" })
35            )
36  
37            (?<term>   ((?&digits))
38                          (?{ # intermediate action
39                              push @stack, $^N
40                          })
41                       (?&rt)
42                          (?{
43                              say "term-> digits($^N) rt";
44                          })
45            )
46  
47            (?<rt>     \s*(?<op>[*/]) (?<num>(?&digits)) \s*
48                               (?{  # intermediate action
49                                    push @stack, $+{num}, $+{op}
50                                })
51                       (?&rt) # end of <rt> definition
52                               (?{
53                                    say "rt -> [*/] digits($^N) rt"
54                                })
55                      |  # empty
56                         (?{ say "rt -> empty" })
57            )
58  
59            (?<digits>  \s* \d+
60            )
61        )
62    }xms;
63  
64    my $input = <>;
65    chomp($input);
66    if ($input =~ $regexp) {
67      say "matches: $&\nStack=(@stack)";
68    }
69    else {
70      say "does not match";
71    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -&gt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -&gt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -&gt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -&gt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -&gt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -&gt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   24</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">(?</span><span class="synConstant">&amp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   28</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say &quot;exp -&gt; term re&quot; }</span>)
<span class="synLinenum">   29</span>           )
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>           (?<span class="synIdentifier">&lt;re&gt;</span>     \s* ([+-]) (?<span class="synIdentifier">&amp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N }) (?<span class="synIdentifier">&amp;re</span>)
<span class="synLinenum">   32</span>                        (?{ say <span class="synConstant">&quot;re -&gt; [+-] term re&quot;</span> })
<span class="synLinenum">   33</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   34</span>                        (?{ say <span class="synConstant">&quot;re -&gt; empty&quot;</span> })
<span class="synLinenum">   35</span>           )
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span>           (?<span class="synIdentifier">&lt;term&gt;</span>   ((?<span class="synIdentifier">&amp;digits</span>))
<span class="synLinenum">   38</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   39</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N
<span class="synLinenum">   40</span>                         })
<span class="synLinenum">   41</span>                      (?<span class="synIdentifier">&amp;rt</span>)
<span class="synLinenum">   42</span>                         (?{
<span class="synLinenum">   43</span>                             say <span class="synConstant">&quot;term-&gt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>;
<span class="synLinenum">   44</span>                         })
<span class="synLinenum">   45</span>           )
<span class="synLinenum">   46</span> 
<span class="synLinenum">   47</span>           (?<span class="synIdentifier">&lt;rt&gt;</span>     \s*(?<span class="synIdentifier">&lt;op&gt;</span>[*/]) (?<span class="synIdentifier">&lt;num&gt;</span>(?<span class="synIdentifier">&amp;digits</span>)) \s*
<span class="synLinenum">   48</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   49</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$+</span>{num}, <span class="synIdentifier">$+</span>{op}
<span class="synLinenum">   50</span>                               })
<span class="synLinenum">   51</span>                      (?<span class="synIdentifier">&amp;rt</span>) <span class="synComment"># end of &lt;rt&gt; definition</span>
<span class="synLinenum">   52</span>                              (?{
<span class="synLinenum">   53</span>                                   say <span class="synConstant">&quot;rt -&gt; [*/] digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>
<span class="synLinenum">   54</span>                               })
<span class="synLinenum">   55</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   56</span>                        (?{ say <span class="synConstant">&quot;rt -&gt; empty&quot;</span> })
<span class="synLinenum">   57</span>           )
<span class="synLinenum">   58</span> 
<span class="synLinenum">   59</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* \d+
<span class="synLinenum">   60</span>           )
<span class="synLinenum">   61</span>       )
<span class="synLinenum">   62</span>   }xms;
<span class="synLinenum">   63</span> 
<span class="synLinenum">   64</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   65</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   66</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   67</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   68</span>   }
<span class="synLinenum">   69</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   70</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   71</span>   }
</pre>

\end{rawhtml}
%}}}

Ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./calc510withnamedpar.pl
5-8/4/2-1
rt -> empty
term-> digits(5) rt
rt -> empty
rt -> [*/] digits(2) rt
rt -> [*/] digits(4) rt
term-> digits(8) rt
rt -> empty
term-> digits(1) rt
re -> empty
re -> [+-] term re
re -> [+-] term re
exp -> term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
\end{verbatim}


\parrafo{Véase También}
\begin{itemize}
\item
El nodo {\it Backreference variables in code embedded inside Perl 5.10 regexps} en 
\perlmonk{794424}

\item
El nodo {\it Strange behavior of @- and @+ in perl5.10 regexps} en 
\perlmonk{794736}

\end{itemize}


\subsection{Construyendo el AST con Expresiones Regulares 5.10}

Construiremos en esta sección un traductor de infijo a postfijo
utilizando una aproximación general: construiremos una representación
del Abstract Syntax Tree o AST (véase la sección 
\ref{section:aat}
Árbol de Análisis Abstracto para una definición detallada de que es un árbol sintáctico).

Como la aplicación es un poco mas compleja la hemos dividido en varios ficheros.
Esta es la estructura:

\begin{verbatim}
.
|-- ASTandtrans3.pl    # programa principal
|-- BinaryOp.pm        # clases para el manejo de los nodos del AST
|-- testreegxpparen.pl # prueba para Regexp::Paren
`-- Regexp
    `-- Paren.pm       # módulo de extensión de $^N
\end{verbatim}


La salida del programa puede ser dividida en tres partes.
La primera muestra una antiderivación a derechas inversa:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./ASTandtrans3.pl
2*(3-4)
factor -> NUM(2)
factor -> NUM(3)
rt -> empty
term-> factor rt
factor -> NUM(4)
rt -> empty
term-> factor rt
re -> empty
re -> [+-] term re
exp -> term re
factor -> ( exp )
rt -> empty
rt -> [*/] factor rt
term-> factor rt
re -> empty
exp -> term re
matches: 2*(3-4)
\end{verbatim}
Que leída de abajo a arriba nos da una derivación a derechas de la cadena \verb|2*(3-4)|:
\begin{verbatim}
exp => term re => term => factor rt => 
factor [*/](*) factor rt => factor [*/](*) factor => 
factor [*/](*) ( exp ) => factor [*/](*) ( term re ) =>  
factor [*/](*) ( term [+-](-) term re ) =>  
factor [*/](*) ( term [+-](-) term ) => 
factor [*/](*) ( term [+-](-) factor rt ) =>
factor [*/](*) ( term [+-](-) factor ) => 
factor [*/](*) ( term [+-](-) NUM(4) ) =>
factor [*/](*) ( factor rt [+-](-) NUM(4) ) => 
factor [*/](*) ( factor [+-](-) NUM(4) ) =>
factor [*/](*) ( NUM(3) [+-](-) NUM(4) )  => 
NUM(2) [*/](*) ( NUM(3) [+-](-) NUM(4) )
\end{verbatim}
La segunda parte nos muestra la representación del AST para la entrada dada (\verb|2*(3-4)|):
\begin{tabular}{|p{5cm}|p{4cm}|}
\begin{verbatim}
AST:
$VAR1 = bless( {
  'left' => bless( { 'val' => '2' }, 'NUM' ),
  'right' => bless( {
    'left' => bless( { 'val' => '3' }, 'NUM' ),
    'right' => bless( { 'val' => '4' }, 'NUM' ),
    'op' => '-'
  }, 'ADD' ),
  'op' => '*'
}, 'MULT' );
\end{verbatim}
&
\begin{rawhtml}
<img src="ast234.png" alt="MUL(2,ADD(3,4))" height=200>
\end{rawhtml}
\end{tabular}

La última parte de la salida nos muestra la traducción a postfijo
de la expresión en infijo
suministrada en la entrada (\verb|2*(3-4)|):
\begin{verbatim}
2 3 4 - *
\end{verbatim}

\parrafo{Programa Principal: usando la pila de atributos}

La gramática original que consideramos
es recursiva a izquierdas:
\begin{verbatim}
 exp    ->   exp [-+] term
           | term
 term   ->   term [*/] factor
           | factor
 factor ->  \( exp \)
           | \d+
\end{verbatim}
aplicando las técnicas explicadas en
\ref{subsection:eliminarecesquem}
es posible transformar la gramática 
en una no recursiva por la izquierda:
\begin{verbatim}
 exp       ->   term restoexp
 restoexp  ->   [-+] term restoexp
              | # vacío
 term      ->   term restoterm
 restoterm ->   [*/] factor restoterm
              | # vacío
 factor    ->   \( exp \)
              | \d+
\end{verbatim}

Ahora bien, no basta con transformar la gramática en una equivalente.
Lo que tenemos como punto de partida no es una gramática sino un \cei{esquema de traducción}
(véase la sección 
\ref{section:esquemas})
que construye el AST asociado con la expresión.
Nuestro esquema de traducción conceptual es algo así:
\begin{verbatim}
 exp    ->   exp ([-+]) term       { ADD->new(left => $exp, right => $term, op => $1) }
           | term                  { $term }
 term   ->   term ([*/]) factor    { MULT->new(left => $exp, right => $term, op => $1) } 
           | factor                { $factor }
 factor ->  \( exp \)              { $exp }
           | (\d+)                 { NUM->new(val => $1) }
\end{verbatim}

Lo que queremos conseguir un conjunto de acciones semánticas
asociadas para gramática no recursiva que sea equivalente 
a este.

Este es el programa resultante una vez aplicadas las transformaciones.
La implementación de la asociación entre símbolos y atributos la realizamos
manualmente mediante una pila de atributos:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./ASTandtrans3.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3  use strict;
 4  use Regexp::Paren qw{g};
 5  use BinaryOp;
 6
 7  use Data::Dumper;
 8  $Data::Dumper::Indent = 1;
 9
10  # Builds AST
11  my @stack;
12  my $regexp = qr{
13      (?&exp)
14
15      (?(DEFINE)
16          (?<exp>    (?&term) (?&re)
17                       (?{ say "exp -> term re" })
18          )
19
20          (?<re>     \s* ([+-]) (?&term)
21                        (?{  # intermediate action
22                            local our ($ch1, $term) = splice @stack, -2;
23
24                            push @stack, ADD->new( {left => $ch1, right => $term, op => g(1)});
25                        })
26                     (?&re)
27                       (?{ say "re -> [+-] term re" })
28                   | # empty
29                       (?{ say "re -> empty" })
30          )
31
32          (?<term>   ((?&factor)) (?&rt)
33                        (?{
34                            say "term-> factor rt";
35                        })
36          )
37
38          (?<rt>     \s*([*/]) (?&factor)
39                         (?{  # intermediate action
40                              local our ($ch1, $ch2) = splice @stack, -2;
41
42                              push @stack, MULT->new({left => $ch1, right => $ch2, op => g(1)});
43                          })
44                     (?&rt) # end of <rt> definition
45                         (?{
46                              say "rt -> [*/] factor rt"
47                          })
48                   | # empty
49                         (?{ say "rt -> empty" })
50          )
51
52          (?<factor> \s* (\d+)
53                          (?{
54                             say "factor -> NUM($^N)";
55                             push @stack, bless { 'val' => g(1) }, 'NUM';
56                          })
57                     | \s* \( (?&exp) \s* \)
58                          (?{ say "factor -> ( exp )" })
59          )
60      )
61  }xms;
62
63  my $input = <>;
64  chomp($input);
65  if ($input =~ $regexp) {
66    say "matches: $&";
67    my $ast = pop @stack;
68    say "AST:\n", Dumper $ast;
69
70    say $ast->translate;
71  }
72  else {
73    say "does not match";
74  }
\end{verbatim}

\parrafo{Las Clases representando a los AST}

Cada nodo del AST es un objeto. La clase del nodo nos dice que tipo de nodo es.
Así los nodos de la clase \verb|MULT| agrupan a los nódos de multiplicación y división.
Los nodos de la clase \verb|ADD| agrupan a los nódos de suma y resta.
El procedimiento general es asociar un método \verb|translate| con cada clase de nodo.
De esta forma se logra el polimorfismo necesario: cada clase de nodo sabe como traducirse
y el método \verb|translate| de cada clase puede escribirse como
\begin{itemize}
\item Obtener los resultados de llamar a \verb|$child->translate| para cada uno
de los nodos hijos \verb|$child|. Por ejemplo, si el nodo fuera un nodo \verb|IF_ELSE|
de un hipotético lenguaje de programación, se llamaría a los métodos \verb|translate| sobre sus tres hijos
\verb|boolexpr|, \verb|ifstatement| y \verb|elsestatement|.
\item Combinar los resultados para producir la traducción adecuada del nodo actual.
\end{itemize}
Es esta combinación la que mas puede cambiar según el tipo de nodo. Así, en el caso de 
el nodo \verb|IF_ELSE| el seudocódigo para la traducción sería algo parecido a esto:

\begin{verbatim}
my $self = shift;
my $etiqueta1 = generar_nueva_etiqueta;
my $etiqueta2 = generar_nueva_etiqueta;

my $boolexpr      = $self->boolexpr->translate;
my $ifstatement   = $self->ifstatement->translate,  
my $elsestatement = $self->elsestatement->translate, 
return << "ENDTRANS";
    $boolexpr
    JUMPZERO $etiqueta1:
    $ifstatement
    JUMP     $etiqueta2:
  $etiqueta1:
    $elsestatement
  $etiqueta2:
ENDTRANS
\end{verbatim}

Siguiendo estas observaciones el código de \verb|BinaryOp.pm| queda así:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n BinaryOp.pm
 1  package BinaryOp;
 2  use strict;
 3  use base qw(Class::Accessor);
 4
 5  BinaryOp->mk_accessors(qw{left right op});
 6
 7  sub translate {
 8    my $self = shift;
 9
10    return $self->left->translate." ".$self->right->translate." ".$self->op;
11  }
12
13  package ADD;
14  use base qw{BinaryOp};
15
16  package MULT;
17  use base qw{BinaryOp};
18
19  package NUM;
20
21  sub translate {
22    my $self = shift;
23
24    return $self->{val};
25  }
26
27  1;
\end{verbatim}

Véase también:
\begin{itemize}
\item \cpan{Class::Accessor}
\end{itemize}

\parrafo{Accediendo a los paréntesis lejanos: El módulo {\tt Regexp::Paren}}

En esta solución utilizamos 
las variables \verb|@-| y \verb|@+| para construir una función que nos 
permite acceder a lo que casó con 
los últimos paréntesis con memoria:
 
\begin{it}\begin{quotation}
Since Perl 5.6.1 the special variables \verb|@-| and \verb|@+| can functionally replace
\verb|$`|, \verb|$&| and \verb|$'|. These arrays contain pointers to the beginning and end of
each match (see \perldoc{perlvar} for the full story), so they give you essentially
the same information, but without the risk of excessive string copying.
\end{quotation}\end{it}

Véanse los párrafos en las páginas
\pageref{parrafo:fincas}, \pageref{parrafo:iniciocas}) y
\pageref{parrafo:lastpar} para mas información sobre \verb|@-| y \verb|@+|.

\verb|g(1)| nos retorna lo que casó con el último paréntesis,
\verb|g(2)| lo que casó con el penúltimo, etc.

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n Regexp/Paren.pm
 1  package Regexp::Paren;
 2  use strict;
 3
 4  use base qw{Exporter};
 5
 6  our @EXPORT_OK = qw{g};
 7
 8  sub g {
 9    die "Error in 'Regexp::Paren::g'. Not used inside (?{ code }) construct\n" unless defined($_);
10    my $ofs = - shift;
11
12    # Number of parenthesis that matched
13    my $np = @-;
14    die "Error. Illegal 'Regexp::Paren::g' ref inside (?{ code }) construct\n" unless ($np > - $ofs && $ofs < 0);
15    # $_ contains the string being matched
16    substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
17  }
18
19  1;
20
21  =head1 NAME
22
23  Regexp::Paren - Extends $^N inside (?{ ... }) constructs
24
25  =head1 SYNOPSIS
26
27    use Regexp::Paren qw{g};
28
29    'abcde' =~ qr{(.)(.)(.)
30                         (?{ print g(1)." ".g(2)." ".g(3)."\n" })                   # c b a
31                 (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)."\n" })          # d c b a
32                 (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n" }) # e d c b a
33                }x;
34
35    print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n"; # error!
36
37  =head1 DESCRIPTION
38
39  Inside a C<(?{ ... })> construct, C<g(1)> refers to what matched the last parenthesis
40  (like C<$^N>), C<g(2)> refers to the string that matched with the parenthesis before
41  the last, C<g(3)> refers to the string that matched with the parenthesis at distance 3,
42  etc.
43
44  =head1 SEE ALSO
45
46  =over 2
47
48  =item * L<perlre>
49
50  =item * L<perlretut>
51
52  =item * PerlMonks node I<Strange behavior o> C<@-> I<and> C<@+> I<in perl5.10 regexps> L<http://www.perlmonks.org/?node_id=794736>
53
54  =item * PerlMonks node I<Backreference variables in code embedded inside Perl 5.10 regexps> L<http://www.perlmonks.org/?node_id=794424>
55
56  =back
57
58  =head1 AUTHOR
59
60  Casiano Rodriguez-Leon (casiano@ull.es)
61
62  =head1 ACKNOWLEDGMENTS
63
64  This work has been supported by CEE (FEDER) and the Spanish Ministry of
65  I<Educacion y Ciencia> through I<Plan Nacional I+D+I> number TIN2005-08818-C04-04
66  (ULL::OPLINK project L<http://www.oplink.ull.es/>).
67  Support from Gobierno de Canarias was through GC02210601
68  (I<Grupos Consolidados>).
69  The University of La Laguna has also supported my work in many ways
70  and for many years.
71
72  =head1 LICENCE AND COPYRIGHT
73
74  Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
75
76  These modules are free software; you can redistribute it and/or
77  modify it under the same terms as Perl itself. See L<perlartistic>.
78
79  This program is distributed in the hope that it will be useful,
80  but WITHOUT ANY WARRANTY; without even the implied warranty of
81  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
\end{verbatim}

Al ejecutar \verb|perldoc Regexp::Paren| podemos ver la documentación
incluida (véase la documentación en \perldoc{perlpod} y \perldoc{perlpodspec}
así como la sección \gnereida{La Documentación en Perl} 
para mas detalles):

\begin{tabular}{|p{22cm}|}
\hline
\begin{verbatim}
NAME
    Regexp::Paren - Extends $^N inside (?{ ... }) constructs

SYNOPSIS
      use Regexp::Paren qw{g};

      'abcde' =~ qr{(.)(.)(.)
                           (?{ print g(1)." ".g(2)." ".g(3)."\n" })                   # c b a
                   (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)."\n" })          # d c b a
                   (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n" }) # e d c b a
                  }x;

      print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n"; # error!

DESCRIPTION
    Inside a "(?{ ... })" construct, g(1) refers to what matched the last
    parenthesis (like $^N), g(2) refers to the string that matched with the
    parenthesis before the last, g(3) refers to the string that matched with
    the parenthesis at distance 3, etc.

SEE ALSO
    * perlre
    * perlretut
    * PerlMonks node *Strange behavior o* "@-" *and* "@+" *in perl5.10
      regexps* <http://www.perlmonks.org/?node_id=794736>
    * PerlMonks node *Backreference variables in code embedded inside Perl
      5.10 regexps* <http://www.perlmonks.org/?node_id=794424>

AUTHOR
    Casiano Rodriguez-Leon (casiano@ull.es)

ACKNOWLEDGMENTS
    This work has been supported by CEE (FEDER) and the Spanish Ministry of
    *Educacion y Ciencia* through *Plan Nacional I+D+I* number
    TIN2005-08818-C04-04 (ULL::OPLINK project <http://www.oplink.ull.es/>).
    Support from Gobierno de Canarias was through GC02210601 (*Grupos
    Consolidados*). The University of La Laguna has also supported my work
    in many ways and for many years.

LICENCE AND COPYRIGHT
    Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights

\end{verbatim}\\
\hline
\end{tabular}

\sectionpractica{Traducción de {\tt invitation} a {\tt HTML}}

Esta práctica es continuación
de la práctica {\it un lenguaje para componer invitaciones}
especificada en la sección
\ref{practica:invitaciones}.

El objetivo es traducir la entrada escrita en el lenguaje de invitaciones
a HTML. La traducción del ejemplo anterior debería ser parecida a esta:
\begin{tabular}{|p{12cm}|p{12cm}|}
\hline
\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  <?xml version="1.0"?>
 2  <!DOCTYPE invitation SYSTEM "invitation.dtd">
 3  <invitation>
 4  <!-- ++++ The header part of the document ++++ -->
 5  <front>
 6  <to>Anna, Bernard, Didier, Johanna</to>
 7  <date>Next Friday Evening at 8 pm</date>
 8  <where>The Web Cafe</where>
 9  <why>My first XML baby</why>
10  </front>
11  <!-- +++++ The main part of the document +++++ -->
12  <body>
13  <par>
14  I would like to invite you all to celebrate
15  the birth of <emph>Invitation</emph>, my
16  first XML document child.
17  </par>
18  <par>
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  </par>
22  <par>
23  I <emph>really</emph> look forward to see you soon!
24  </par>
25  </body>
26  <!-- +++ The closing part of the document ++++ -->
27  <back>
28  <signature>Michel</signature>
29  </back>
30  </invitation>
\end{verbatim}
&
\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat invcss.html.save
<HTML>
<HEAD>
<TITLE> Invitation (sgmlpl/CSS formatting) </TITLE>
<LINK href="invit.css" rel="style-sheet" type="text/css">
<!-- 24 August 1998 mg -->
</HEAD>
<BODY>
<H1>INVITATION</H1>
<P><TABLE>
<TBODY>
<TR><TD class="front">To: </TD>
<TD>Anna, Bernard, Didier, Johanna</TD></TR>
<TR><TD class="front">When: </TD>
<TD>Next Friday Evening at 8 pm</TD></TR>
<TR><TD class="front">Venue: </TD>
<TD>The Web Cafe</TD></TR>
<TR><TD class="front">Occasion: </TD>
<TD>My first XML baby</TD></TR>
</TBODY>
</TABLE>
<P>
I would like to invite you all to celebrate
the birth of <EM>Invitation</EM>, my
first XML document child.
</P>
<P>
Please do your best to come and join me next Friday
evening. And, do not forget to bring your friends.
</P>
<P>
I <EM>really</EM> look forward to see you soon!
</P>
<P CLASS="signature">Michel</P>
</BODY>
</HTML>
\end{verbatim}\\
\hline
\end{tabular}
Para ver el resultado en su navegador visite el fichero
\htmladdnormallink{invitation.html}{invitation.html}

Su programa deberá producir un Abstract Syntax Tree.
Los nodos serán objetos. Cada clase (\verb|FRONT|, \verb|TO|, etc.)
deberá de disponer de un método \verb|translate|.

Para simplificar el proceso de traducción a \verb|HTML| se sugiere  utilizar una 
hoja de estilo parecida a la siguiente (tomada de la seción 7.4.4 del citado libro de Goosens):
\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invit.css
 1  /* CSS stylesheet for invitation1 in HTML */
 2  BODY {margin-top: 1em;     /* global page parameters */
 3        margin-bottom: 1em;
 4        margin-left: 1em;
 5        margin-right: 1em;
 6        font-family: serif;
 7        line-height: 1.1;
 8        color: black;
 9  }
10  H1   {text-align: center;  /* for global title   */
11        font-size: x-large;
12  }
13  P    {text-align: justify; /* paragraphs in body */
14        margin-top: 1em;
15  }
16  TABLE { border-width: 0pt }
17  TBODY { border-width: 0pt }
18  TD[class="front"] {        /* table data in front matter */
19        text-align: left;
20        font-weight: bold;
21  }
22  TD.front {        /* table data in front matter */
23        text-align: left;
24        font-weight: bold;
25  }
26  EM   {font-style: italic;  /* emphasis in body   */
27  }
28  P.signature {     /* signature          */
29        text-align: right;
30        font-weight: bold;
31  }
\end{verbatim}

Véase también:

\begin{itemize}
\item
\htmladdnormallink{The LaTex Web Companion}{http://books.google.es/books?id=B93uJGLZhAoC\&lpg=PP1\&ots=-JFhDfZPwN\&dq=The\%20LaTEX\%20web\%20companion\&hl=en\&pg=PP1\#v=onepage\&q=\&f=false}
\item
\htmladdnormallink{Examples from The LaTeX Web Companion}{http://www.ctan.org/tex-archive/info/examples/lwc/} (véanse los subdirectorios
correspondietnes a los capítulos 6 y 7)
\item
\htmladdnormallink{CSS Tutorial}{http://www.w3schools.com/css/}
\item
\htmladdnormallink{Edición extremadamente simple de HTML}{http://www.psicobyte.com/html/index.html}
\item
\htmladdnormallink{Perl-XML Frequently Asked Questions}{http://perl-xml.sourceforge.net/faq/}
\end{itemize}


\section{Análisis Sintáctico con {\tt Regexp::Grammars}}

El módulo \cpan{Regexp::Grammars} escrito por \wikip{Damian Conway}{Damian\_Conway} extiende
las expresiones regulares Perl con 
la capacidad de generar representaciones del árbol 
de análisis sintáctico abstracto y obviando la necesidad 
de explicitar los blancos. El módulo necesita para funcionar una versión de Perl superior
o igual a la 5.10. 

\subsection{Introducción}

\parrafo{El Problema}

La documentación de \regexpg{} establece cual es el problema que aborda 
el módulo:
\begin{it}\begin{quotation}
\ldots Perl5.10 makes possible to use regexes to recognize complex,
hierarchical--and even recursive--textual structures. The problem is that
Perl 5.10 doesn’t provide any support for extracting that
hierarchical data into nested data structures. In other words,
using Perl 5.10 you can match complex data, but not parse it into an internally useful form.

An additional problem when using Perl 5.10 regexes to match
complex data formats is that you have to make sure you remember
to insert whitespace- matching constructs (such as \verb"\s*") at every
possible position where the data might contain ignorable whitespace. This
reduces the readability of such patterns, and increases the chance of
errors (typically caused by overlooking a location where whitespace
might appear).

\parrafo{Una solución: {\tt Regexp::Grammars}}

The \regexpg{} module solves both those problems.

If you import the module into a particular lexical scope, it preprocesses
any regex in that scope, so as to implement a number of extensions to the
standard Perl 5.10 regex syntax. These extensions simplify the task of
defining and calling subrules within a grammar, and allow those subrule
calls to capture and retain the components of they match in a proper
hierarchical manner.

\end{quotation}\end{it}

\parrafo{La sintaxis de una expresión regular {\tt Regexp::Grammars}}

Las expresiones regulares \regexpg{} aumentan las regexp Perl 5.10. La sintáxis
se expande y se modifica:

\begin{it}\begin{quotation}
A \regexpg{} specification consists of a pattern (which may include both standard Perl 5.10 regex syntax, as well as special
\cpan{Regexp::Grammars} directives), followed by one or more rule or token definitions.
\end{quotation}\end{it}

Sigue un ejemplo:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n balanced_brackets.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        (<pp>)
    10
    11        <rule: pp>   \( (?: [^()]*+ | <escape> | <pp> )* \)
    12
    13        <token: escape> \\.
    14
    15      }xs;
    16  };
    17
    18  while (my $input = <>) {
    19      while ($input =~ m{$rbb}g) {
    20          say("matches: <$&>");
    21          say Dumper \%/;
    22      }
    23  }
\end{verbatim}

\begin{it}\begin{quote}
Note that there is no need to explicitly place \verb"\s*" 
subpatterns throughout the rules; that is taken care of automatically.

\ldots

The initial pattern (\verb|(<pp>)|) acts like the \emph{top} rule of the grammar, and must
be matched completely for the grammar to match.

The rules and tokens are declarations only and they are not directly
matched.  Instead, they act like subroutines, and are invoked by name
from the initial pattern (or from within a rule or token).

Each rule or token extends from the directive that introduces it up to
either the next rule or token directive, or (in the case of the final
rule or token) to the end of the grammar.  

\end{quote}\end{it}

\parrafo{El hash {\tt  \%/}: Una representación del AST}
Al ejecutar el programa anterior con entrada \verb|(2*(3+5))*4+(2-3)| produce:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 balanced_brackets.pl
(2*(3+5))*4+(2-3)
matches: <(2*(3+5))>
$VAR1 = {
          '' => '(2*(3+5))',
          'pp' => {
                    '' => '(2*(3+5))',
                    'pp' => '(3+5)'
                  }
        };

matches: <(2-3)>
$VAR1 = {
          '' => '(2-3)',
          'pp' => '(2-3)'
        };
\end{verbatim}


\begin{it}\begin{quotation}
Each rule calls the
subrules specified within it, and then return a hash containing whatever
result each of those subrules returned, with each result indexed by the
subrule’s name.

In this way, each level of the hierarchical regex can generate hashes
recording everything its own subrules matched, so when the entire pattern
matches, it produces a tree of nested hashes that represent the structured
data the pattern matched.

\ldots

In addition each result-hash has one extra key: the empty string. The
value for this key is whatever string the entire subrule call matched.
\end{quotation}\end{it}

\parrafo{Diferencias entre {\tt token} y {\tt rule}}

\begin{it}\begin{quotation}
The difference between a token and a rule is that a token treats any
whitespace within it exactly as a normal Perl regular expression would.
That is, a sequence of whitespace in a token is ignored if the \verb"/x"
modifier is in effect, or else matches the same literal sequence of
whitespace characters (if \verb"/x" is not in effect).

\end{quotation}\end{it}

En el ejemplo anterior el comportamiento es el mismo si se reescribe la regla 
para el token \verb|escape| como:
\begin{verbatim}
    13        <rule: escape> \\.
\end{verbatim}
En este otro ejemplo mostramos que la diferencia entre token y rule
es significativa:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsrule.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        <s>
    10
    11        <rule: s> <a> <c>
    12
    13        <rule: c>  c d
    14
    15        <token: a>  a b
    16
    17      }xs;
    18  };
    19
    20  while (my $input = <>) {
    21      if ($input =~ m{$rbb}) {
    22          say("matches: <$&>");
    23          say Dumper \%/;
    24      }
    25      else {
    26          say "Does not match";
    27      }
    28  }
\end{verbatim}

Al ejecutar este programa vemos la diferencia en la interpretación de los blancos:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 tokenvsrule.pl
ab c d
matches: <ab c d>
$VAR1 = {
          '' => 'ab c d',
          's' => {
                   '' => 'ab c d',
                   'c' => 'c d',
                   'a' => 'ab'
                 }
        };

a b c d
Does not match
ab cd
matches: <ab cd>
$VAR1 = {
          '' => 'ab cd',
          's' => {
                   '' => 'ab cd',
                   'c' => 'cd',
                   'a' => 'ab'
                 }
        };
\end{verbatim}
Obsérvese como la entrada \verb|a b c d| es rechazada mientras
que la entrada \verb|ab c d| es aceptada.

\parrafo{Redefinición de los espacios en blanco}

\begin{it}\begin{quotation}
In a rule, any sequence of whitespace (except those at the very start
and the very end of the rule) is treated as matching the implicit subrule
\verb"<.ws>", which is automatically predefined to match optional whitespace 
(i.e. \verb"\s*").

You can explicitly define a \verb"<ws>" token to change that default
behaviour. For example, you could alter the definition of whitespace
to include Perlish comments, by adding an explicit \verb"<token: ws>":

\begin{verbatim}
                      <token: ws>
                         (?: \s+ | #[^\n]* )*
\end{verbatim}

But be careful not to define \verb"<ws>" as a rule, as this will lead
to all kinds of infinitely recursive unpleasantness.
\end{quotation}\end{it}
El siguiente ejemplo ilustra como redefinir \verb|<ws>|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsruleandws.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      no warnings 'uninitialized';
 9      qr{
10        <s>
11
12        <token: ws> (?: \s+ | /\* .*? \*/)*+
13
14        <rule: s> <a> <c>
15
16        <rule: c>  c d
17
18        <token: a>  a b
19
20      }xs;
21  };
22
23  while (my $input = <>) {
24      if ($input =~ m{$rbb}) {
25          say Dumper \%/;
26      }
27      else {
28          say "Does not match";
29      }
30  }
\end{verbatim}
Ahora podemos introducir comentarios en la entrada:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 -w tokenvsruleandws.pl
ab /* 1 */ c d
$VAR1 = {
          '' => 'ab /* 1 */ c d',
          's' => {
                   '' => 'ab /* 1 */ c d',
                   'c' => 'c d',
                   'a' => 'ab'
                 }
        };

\end{verbatim}

\parrafo{Llamando a las subreglas}

\begin{it}\begin{quotation}
To invoke a rule to match at any point, just enclose the rule’s name
in angle brackets (like in \wikip{Perl 6}{Perl\_6}). There must be no space between the
opening bracket and the rulename. For example:

\begin{verbatim}
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               <name>            # Call <rule: name>
               <options>?        # Call <rule: options> (it's okay if it fails)

               <rule: name>
                   # etc.
           }x;
\end{verbatim}

If you need to match a literal pattern that would otherwise look like a subrule call, just backslash-escape the leading angle:

\begin{verbatim}
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               \<name>           # Match literal sequence '<' 'n' 'a' 'm' 'e' '>'
               <options>?        # Call <rule: options> (it's okay if it fails)

               <rule: name>
                   # etc.
           }x;
\end{verbatim}
\end{quotation}\end{it}

El siguiente programa ilustra algunos puntos discutidos en la cita anterior:
\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n badbracket.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        (<pp>)
10
11        <rule: pp>   \( (?: <b  > | \< | < escape> | <pp> )* \)
12
13        <token: b  > b
14
15        <token: escape> \\.
16
17      }xs;
18  };
19
20  while (my $input = <>) {
21      while ($input =~ m{$rbb}g) {
22          say("matches: <$&>");
23          say Dumper \%/;
24      }
25  }
\end{verbatim}

Obsérvense los blancos en \verb|< escape>| y en \verb|<token: b  > b|.
Pese a ello el programa funciona:

\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ perl5.10.1 badbracket.pl
(\(\))
matches: <(\(\))>
$VAR1 = {
          '' => '(\\(\\))',
          'pp' => {
                    '' => '(\\(\\))',
                    'escape' => '\\)'
                  }
        };

(b)
matches: <(b)>
$VAR1 = {
          '' => '(b)',
          'pp' => {
                    '' => '(b)',
                    'b' => 'b'
                  }
        };

(<)
matches: <(<)>
$VAR1 = {
          '' => '(<)',
          'pp' => '(<)'
        };

(c)

casiano@millo:
\end{verbatim}

\parrafo{Eliminación del anidamiento de ramas unarias en {\tt \%/}}

\begin{it}\begin{quotation}
\ldots Note, however, that if the result-hash at any level contains only the
empty-string key (i.e. the subrule did not call any sub-subrules or
save any of their nested result-hashes), then the hash is {\it unpacked}
and just the matched substring itself if returned.

For example, if \verb|<rule: sentence>| had been defined:

\begin{verbatim}
    <rule: sentence>
        I see dead people
\end{verbatim}

then a successful call to the rule would only add:

\begin{verbatim}
    sentence => 'I see dead people'
\end{verbatim}

to the current result-hash.

This is a useful feature because it prevents a series of nested subrule
calls from producing very unwieldy data structures. For example, without
this automatic unpacking, even the simple earlier example:

\begin{verbatim}
    <rule: sentence>
        <noun> <verb> <object>
\end{verbatim}

would produce something needlessly complex, such as:

\begin{verbatim}
    sentence => {
        ""     => 'I saw a dog',
        noun   => {
            "" => 'I',
        },
        verb   => {
            "" => 'saw',
        },
        object => {
            ""      => 'a dog',
            article => {
                "" => 'a',
            },
            noun    => {
                "" => 'dog',
            },
        },
    }
\end{verbatim}
\end{quotation}\end{it}

El siguiente ejemplo ilustra este punto:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n unaryproductions.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        <s>
10
11        <rule: s> <noun> <verb> <object>
12
13        <token: noun> he | she | Peter | Jane
14
15        <token: verb> saw | sees
16
17        <token: object> a\s+dog | a\s+cat
18
19      }x;
20  };
21
22  while (my $input = <>) {
23      while ($input =~ m{$rbb}g) {
24          say("matches: <$&>");
25          say Dumper \%/;
26      }
27  }
\end{verbatim}

Sigue una ejecución del programa anterior:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 unaryproductions.pl
he saw a dog
matches: <he saw a dog>
$VAR1 = {
          '' => 'he saw a dog',
          's' => {
                   '' => 'he saw a dog',
                   'object' => 'a dog',
                   'verb' => 'saw',
                   'noun' => 'he'
                 }
        };

Jane sees a cat
matches: <Jane sees a cat>
$VAR1 = {
          '' => 'Jane sees a cat',
          's' => {
                   '' => 'Jane sees a cat',
                   'object' => 'a cat',
                   'verb' => 'sees',
                   'noun' => 'Jane'
                 }
        };


\end{verbatim}

\parrafo{Ámbito de uso de {\tt Regexp::Grammars}}

Cuando se usa \cpan{Regexp::Grammars} como parte de 
un programa que utiliza otras regexes hay que evitar 
que \cpan{Regexp::Grammars} procese las mismas. \cpan{Regexp::Grammars}
reescribe las expresiones regulares durante la fase de preproceso. Esta por ello 
presenta las mismas limitaciones que cualquier otra forma de 
'source filtering' (véase \perldoc{perlfilter}). Por ello es una buena idea declarar
la gramática en un bloque \verb|do| restringiendo de esta forma el ámbito de 
acción del módulo.

\begin{verbatim}
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 .          ........
28      }xms
29  };
\end{verbatim}

\subsection{Objetos}

\begin{it}\begin{quotation}
When a grammar has parsed successfully, the \verb|%/| variable will contain
a series of nested hashes (and possibly arrays) representing the
hierarchical structure of the parsed data.

Typically, the next step is to walk that tree, extracting or converting
or otherwise processing that information. If the tree has nodes of many
different types, it can be difficult to build a recursive subroutine
that can navigate it easily.

A much cleaner solution is possible if the nodes of the tree are proper
objects. In that case, you just define a \verb|trasnlate()| method
for each of the classes, and have every node call that method on each
of its children.  The chain of \verb|translate()| calls would cascade down the
nodes of the tree, each one invoking the appropriate \verb|translate()| method
according to the type of node encountered.

The only problem is that, by default, \cpan{Regexp::Grammars} returns a tree
of plain-old hashes, not \verb|Class::Whatever| objects. Fortunately, it's
easy to request that the result hashes be automatically blessed into
the appropriate classes, using the \verb|<objrule:...>| and \verb|<objtoken:...>|
directives.

These directives are identical to the \verb|<rule:...>| and \verb|<token:...>|
directives (respectively), except that the rule or token they create will
also bless the hash it normally returns, converting it to an object of
a class whose name is the same as the rule or token itself.

For example:

\begin{verbatim}
    <objrule: Element>
        # ...Defines a rule that can be called as <Element>
        # ...and which returns a hash-based Element object
\end{verbatim}

The \verb|IDENTIFIER| of the rule or token may also be fully qualified. In
such cases, the rule or token is defined using only the final \emph{short
name}, but the result object is blessed using the fully qualified \emph{long
name}. For example:

\begin{verbatim}
    <objrule: LaTeX::Element> 
        # ...Defines a rule that can be called as <Element>
        # ...and which returns a hash-based LaTeX::Element object
\end{verbatim}

This can be useful to ensure that returned objects don't collide with
other namespaces in your program.

Note that you can freely mix object-returning and plain-old-hash-returning
rules and tokens within a single grammar, though you have to be careful
not to subsequently try to call a method on any of the unblessed nodes.

\end{quotation}\end{it}

\subsection{Renombrando los resultados de una subregla}

\parrafo{Nombre de la regla versus Nombre del Resultado}
 
No siempre el nombre de la regla es el mas apropiado
para ser el nombre del resultado:

\begin{it}\begin{quotation}
It is not always convenient to have subrule results stored under the same
name as the rule itself. Rule names should be optimized for understanding
the behaviour of the parser, whereas result names should be optimized
for understanding the structure of the data. Often those two goals are
identical, but not always; sometimes rule names need to describe what the
data looks like, while result names need to describe what the data means.
\end{quotation}\end{it}

\parrafo{Colisión de nombres de reglas}

\begin{it}\begin{quotation}
For example, sometimes you need to call the same rule twice, to match two
syntactically identical components whose positions give then semantically
distinct meanings:

\begin{verbatim}
    <rule: copy_cmd>
        copy <file> <file>
\end{verbatim}

The problem here is that, if the second call to \verb|<file>| succeeds, its
result-hash will be stored under the key \verb'file', clobbering the data
that was returned from the first call to \verb|<file>|.
\end{quotation}\end{it}

\parrafo{Aliasing}

\begin{it}\begin{quotation}
To avoid such problems, \cpan{Regexp::Grammars} allows you to alias any
subrule call, so that it is still invoked by the original name, but its
result-hash is stored under a different key. The syntax for that is:
\verb|<alias=rulename>|. For example:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file> <to=file>
\end{verbatim}

Here, \verb|<rule: file>| is called twice, with the first result-hash
being stored under the key \verb'from', and the second result-hash being
stored under the key \verb'to'.

Note, however, that the alias before the \verb|=| must be a proper identifier
(i.e. a letter or underscore, followed by letters, digits, and/or
underscores). Aliases that start with an underscore and aliases named
\verb|MATCH| have special meaning.
\end{quotation}\end{it}

\parrafo{Normalización de los resultados mediante aliasing}

\begin{it}\begin{quotation}
Aliases can also be useful for normalizing data that may appear in
different formats and sequences. For example:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file>        <to=file>
      | dup    <to=file>  as  <from=file>
      |      <from=file>  ->    <to=file>
      |        <to=file>  <-  <from=file>

\end{verbatim}

Here, regardless of which order the old and new files are specified,
the result-hash always gets:

\begin{verbatim}
    copy_cmd => {
        from => 'oldfile',
          to => 'newfile',
    }
\end{verbatim}
\end{quotation}\end{it}

\parrafo{Ejemplo}

El siguiente programa ilustra los comentarios de la documentación:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n copygrammar.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        <copy_cmd>
    10
    11        <rule: copy_cmd>
    12              copy <from=file> <to=file>
    13          |   <from=file> ->   <to=file>
    14          |   <to=file>   <- <from=file>
    15
    16        <token: file> [\w./\\]+
    17      }x;
    18  };
    19
    20  while (my $input = <>) {
    21      while ($input =~ m{$rbb}g) {
    22          say("matches: <$&>");
    23          say Dumper \%/;
    24      }
    25  }
\end{verbatim}
Cuando lo ejecutamos obtenemos:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 copygrammar.pl
copy a b
matches: <copy a b>
$VAR1 = {
          '' => 'copy a b',
          'copy_cmd' => {
                          '' => 'copy a b',
                          'to' => 'b',
                          'from' => 'a'
                        }
        };

b <- a
matches: <b <- a>
$VAR1 = {
          '' => 'b <- a',
          'copy_cmd' => {
                          '' => 'b <- a',
                          'to' => 'b',
                          'from' => 'a'
                        }
        };

a -> b
matches: <a -> b>
$VAR1 = {
          '' => 'a -> b',
          'copy_cmd' => {
                          '' => 'a -> b',
                          'to' => 'b',
                          'from' => 'a'
                        }
        };
\end{verbatim}

\subsection{Listas}


\parrafo{El operador de cierre positivo}

\begin{it}
\begin{quotation}
If a subrule call is quantified with a repetition specifier:

\begin{verbatim}
           <rule: file_sequence>
               <file>+
\end{verbatim}

then each repeated match overwrites the corresponding entry in the
surrounding rule’s result-hash, so only the result of the final
repetition will be
retained. That is, if the above example matched the string  \verb"foo.pl bar.py baz.php", 
then the result-hash would contain:

\begin{verbatim}
           file_sequence {
               ""   => 'foo.pl bar.py baz.php',
               file => 'baz.php',
           }
\end{verbatim}
\end{quotation}\end{it}

\parrafo{Operadores de listas y espacios en blanco}

Existe un caveat con el uso de los operadores de repetición
y el manejo de los blancos. Véase el siguiente programa:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers3.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        <numbers>
11
12        <rule: numbers>
13          (<number>)+
14
15        <token: number> \s*\d+
16      }xms;
17  };
18
19  while (my $input = <>) {
20      if ($input =~ m{$rbb}) {
21          say("matches: <$&>");
22          say Dumper \%/;
23      }
24  }
\end{verbatim}
Obsérvese el uso explícito 
de espacios \verb|\s*\d+| en la definición de \verb|number|.

Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers3.pl
1 2 3 4
matches: <1 2 3 4>
$VAR1 = {
          '' => '1 2 3 4',
          'numbers' => {
                         '' => '1 2 3 4',
                         'number' => ' 4'
                       }
        };
\end{verbatim}

Si se eliminan los blancos de la definición de 
\verb|number|: 
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        <numbers>
    11  
    12        <rule: numbers> 
    13          (<number>)+
    14  
    15        <token: number> \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = <>) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: <$&>");
    22          say Dumper \%/;
    23      }
    24  }
\end{verbatim}
se obtiene una conducta que puede sorprender:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers.pl 
12 34 56
matches: <12>
$VAR1 = {
          '' => '12',
          'numbers' => {
                         '' => '12',
                         'number' => '12'
                       }
        };
\end{verbatim}

La explicación está en la documentación: véase la sección \rgsec{Grammar Syntax}{Grammar\_syntax}:
\begin{it}\begin{quotation}
\verb|<rule: IDENTIFIER>|

    Define a rule whose name is specified by the supplied identifier.

Everything following the \verb|<rule:...>| directive (up to the next \verb|<rule:...>| or \verb|<token:...>| directive) 
is treated as part of the rule being defined.

\emph{Any whitespace in the rule is replaced by a call to the} \verb|<.ws>| subrule (which defaults to matching \verb|\s*|, but may be explicitly redefined).

\end{quotation}\end{it}
También podríamos haber resuelto el problema introduciendo un
blanco explícito dentro del cierre positivo:

\begin{verbatim}
      <rule: numbers>
        (<number> )+

      <token: number> \d+
\end{verbatim}

\parrafo{Una Solución al problema de recordar los resultados de una lista: El uso de brackets}

\begin{it}\begin{quotation}
Usually, that’s not the desired outcome, so \cpan{Regexp::Grammars} provides
another mechanism by which to call a subrule; one that saves all
repetitions of its results.

A regular subrule call consists of the rule’s name surrounded by angle
brackets. If, instead, you surround the rule’s name with  \verb"<[...]>"
(angle and square brackets) like so:

\begin{verbatim}
           <rule: file_sequence>
               <[file]>+
\end{verbatim}

then the rule is invoked in exactly the same way, but the result of that
submatch is pushed onto an array nested inside the appropriate result-hash
entry. In other words, if the above example matched the same  
\verb"foo.pl bar.py baz.php" string, the result-hash would contain:

\begin{verbatim}
           file_sequence {
               ""   => 'foo.pl bar.py baz.php',
               file => [ 'foo.pl', 'bar.py', 'baz.php' ],
           }
\end{verbatim}
\end{quotation}
\end{it}

Teniendo en cuenta lo dicho anteriormente sobre los blancos
dentro de los cuantificadores, es necesario introducir
blancos dentro del operador de repetición:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers4.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8
     9      qr{
    10        <numbers>
    11
    12        <rule: numbers>
    13          (?:  <[number]> )+
    14
    15        <token: number> \d+
    16      }xms;
    17  };
    18
    19  while (my $input = <>) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: <$&>");
    22          say Dumper \%/;
    23      }
    24  }
\end{verbatim}
Al ejecutar este programa obtenemos:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers4.pl
1 2 3 4
matches: <1 2 3 4
>
$VAR1 = {
          '' => '1 2 3 4
',
          'numbers' => {
                         '' => '1 2 3 4
',
                         'number' => [ '1', '2', '3', '4' ]
                       }
        };
\end{verbatim}

\parrafo{Otra forma de resolver las colisiones de nombres: salvarlos en una lista}

\begin{it}\begin{quotation}
This \emph{listifying subrule call} can also be useful for non-repeated
subrule calls, if the same subrule is invoked in several places in a
grammar. For example if a cmdline option could be given either one or
two values, you might parse it:

\begin{verbatim}
    <rule: size_option>   
        -size <[size]> (?: x <[size]> )?
\end{verbatim}

The result-hash entry for \verb'size' would then always contain an array,
with either one or two elements, depending on the input being parsed.
\end{quotation}\end{it}
Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n sizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        <command>
11
12        <rule: command> ls <size_option>
13
14        <rule: size_option>
15            -size <[size]> (?: x <[size]> )?
16
17        <token: size> \d+
18      }x;
19  };
20
21  while (my $input = <>) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: <$&>");
24          say Dumper \%/;
25      }
26  }
\end{verbatim}
Veamos su comportamiento con diferentes entradas:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 sizes.pl
ls -size 4
matches: <ls -size 4
>
$VAR1 = {
          '' => 'ls -size 4
',
          'command' => {
                         'size_option' => {
                                            '' => '-size 4
',
                                            'size' => [ '4' ]
                                          },
                         '' => 'ls -size 4
'
                       }
        };

ls -size 2x8
matches: <ls -size 2x8
>
$VAR1 = {
          '' => 'ls -size 2x8
',
          'command' => {
                         'size_option' => {
                                            '' => '-size 2x8
',
                                            'size' => [ '2', '8' ]
                                          },
                         '' => 'ls -size 2x8
'
                       }
        };
\end{verbatim}

\parrafo{Aliasing de listas}

\begin{it}\begin{quotation}
Listifying subrules can also be given aliases, just like ordinary
subrules. The alias is always specified inside the square brackets:

\begin{verbatim}
    <rule: size_option>   
        -size <[size=pos_integer]> (?: x <[size=pos_integer]> )?
\end{verbatim}

Here, the sizes are parsed using the \verb|pos_integer| rule, 
but saved in the result-hash in an array under the key \verb'size'.
\end{quotation}\end{it}

Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedsizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        <command>
11
12        <rule: command> ls <size_option>
13
14        <rule: size_option>
15            -size <[size=int]> (?: x <[size=int]> )?
16
17        <token: int> \d+
18      }x;
19  };
20
21  while (my $input = <>) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: <$&>");
24          say Dumper \%/;
25      }
26  }
\end{verbatim}
Veamos el resultado de una ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedsizes.pl
ls -size 2x4
matches: <ls -size 2x4
>
$VAR1 = {
          '' => 'ls -size 2x4
',
          'command' => {
                         'size_option' => {
                                            '' => '-size 2x4
',
                                            'size' => [
                                                        '2',
                                                        '4'
                                                      ]
                                          },
                         '' => 'ls -size 2x4
'
                       }
        };
\end{verbatim}

\parrafo{Caveat: Cierres y Warnings}

En este ejemplo aparece \verb|<number>+| sin 
corchetes ni paréntesis:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers5.pl 
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        <numbers>
    11  
    12        <rule: numbers> 
    13          <number>+
    14  
    15        <token: number> \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = <>) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: <$&>");
    22          say Dumper \%/;
    23      }
    24  }
\end{verbatim}
Este programa produce un mensaje de advertencia:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers5.pl 
  warn | Repeated subrule <number>+ will only capture its final match
       | (Did you mean <[number]>+ instead?)
       | 

\end{verbatim}

Si se quiere evitar el mensaje y se está dispuesto a asumir la pérdida
de los valores asociados con los elementos de la lista se deberán poner 
el operando entre paréntesis (con o sin memoria).

Esto es lo que dice la documentación sobre este warning:

\begin{it}\begin{quotation}
\verb|Repeated subrule <rule> will only capture its final match|

You specified a subrule call with a repetition qualifier, such as:

\begin{verbatim}
        <ListElem>*
\end{verbatim}

    or:

\begin{verbatim}
        <ListElem>+
\end{verbatim}

Because each subrule call saves its result in a hash entry of the
same name, each repeated match will overwrite the previous ones,
so only the last match will ultimately be saved. If you want to
save all the matches, you need to tell \cpan{Regexp::Grammars} to save the
sequence of results as a nested array within the hash entry, like so:

\begin{verbatim}
        <[ListElem]>*
\end{verbatim}

    or:

\begin{verbatim}
        <[ListElem]>+
\end{verbatim}

If you really did intend to throw away every result but the final
one, you can silence the warning by placing the subrule call inside
any kind of parentheses. For example:

\begin{verbatim}
        (<ListElem>)*
\end{verbatim}

    or:

\begin{verbatim}
        (?: <ListElem> )+
\end{verbatim}

\end{quotation}\end{it}


\subsection{Pseudo sub-reglas}

\parrafo{Subpatrones}

\begin{it}\begin{quotation}
Aliases can also be given to standard Perl subpatterns, as well as to
code blocks within a regex. The syntax for subpatterns is:

\begin{verbatim}
    <ALIAS= (SUBPATTERN) >
\end{verbatim}

In other words, the syntax is exactly like an aliased subrule call, except
that the rule name is replaced with a set of parentheses containing the
subpattern. Any parentheses--capturing or non-capturing--will do.

The effect of aliasing a standard subpattern is to cause whatever that
subpattern matches to be saved in the result-hash, using the alias as
its key. For example:

\begin{verbatim}
    <rule: file_command>

        <cmd=(mv|cp|ln)>  <from=file>  <to=file>
\end{verbatim}

Here, the \verb#<cmd=(mv|cp|ln)># is treated exactly like a regular \verb#(mv|cp|ln)#,
but whatever substring it matches is saved in the result-hash under the
key \verb|'cmd'|.
\end{quotation}\end{it}
Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n subpattern.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10          <file_command>
11
12          <rule: file_command>
13
14          <cmd=(mv|cp|ln)>  <from=([\w./]+)>  <to=([\w./]+)>
15
16      }x;
17  };
18
19  while (my $input = <>) {
20      while ($input =~ m{$rbb}g) {
21          say("matches: <$&>");
22          say Dumper \%/;
23      }
24  }
\end{verbatim}
y una ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 subpattern.pl
mv a b
matches: <mv a b>
$VAR1 = {
          '' => 'mv a b',
          'file_command' => {
                              '' => 'mv a b',
                              'to' => 'b',
                              'cmd' => 'mv',
                              'from' => 'a'
                            }
        };

cp c d
matches: <cp c d>
$VAR1 = {
          '' => 'cp c d',
          'file_command' => {
                              '' => 'cp c d',
                              'to' => 'd',
                              'cmd' => 'cp',
                              'from' => 'c'
                            }
        }
\end{verbatim}

\parrafo{Bloques de código}

\begin{it}\begin{quotation}
The syntax for aliasing code blocks is:

\begin{verbatim}
    <ALIAS= (?{ your($code->here) }) >
\end{verbatim}

Note, however, that the code block must be specified in the standard
Perl 5.10 regex notation: \verb|(?{...})|. A common mistake is to write:

\begin{verbatim}
    <ALIAS= { your($code->here } >
\end{verbatim}

instead, which will attempt to interpolate \verb|$code| before the
regex is even compiled, as such variables are only \emph{protected} from
interpolation inside a \verb|(?{...})|.

When correctly specified, this construct executes the code in the block
and saves the result of that execution in the result-hash, using the
alias as its key. Aliased code blocks are useful for adding semantic
information based on which branch of a rule is executed. For example,
consider the \verb|copy_cmd| alternatives shown earlier:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file>        <to=file>
      | dup    <to=file>  as  <from=file>
      |      <from=file>  ->    <to=file>
      |        <to=file>  <-  <from=file>
\end{verbatim}

Using aliased code blocks, you could add an extra field to the result-
hash to describe which form of the command was detected, like so:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file>        <to=file>  <type=(?{ 'std' })> 
      | dup    <to=file>  as  <from=file>  <type=(?{ 'rev' })> 
      |      <from=file>  ->    <to=file>  <type=(?{ 'fwd' })> 
      |        <to=file>  <-  <from=file>  <type=(?{ 'bwd' })> 
\end{verbatim}

Now, if the rule matched, the result-hash would contain something like:

\begin{verbatim}
    copy_cmd => {
        from => 'oldfile',
          to => 'newfile',
        type => 'fwd',
    }
\end{verbatim}
\end{quotation}\end{it}

El siguiente ejemplo ilustra lo dicho en la documentación.
En la línea 15 hemos introducido una regla para el control de 
errores\footnote{Versión de {\tt Grammar.pm} obtenida por email 
con las correcciones de Damian}:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedcodeblock2.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        <copy_cmd>
10
11        <rule: copy_cmd>
12              copy (<from=file>) (<to=file>) <type=(?{ 'std' })>
13          |   <from=file> ->   <to=file> <type=(?{ 'fwd' })>
14          |   <to=file>   <- <from=file> <type=(?{ 'bwd' })>
15          |   .+ (?{ die "Syntax error!\n" })
16
17        <token: file> [\w./\\]+
18      }x;
19  };
20
21  while (my $input = <>) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: <$&>");
24          say Dumper \%/;
25      }
26  }
\end{verbatim}

La ejecución muestra el comportamiento del programa con tres entradas válidas
y una errónea:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedcodeblock2.pl
copy a b
matches: <copy a b
>
$VAR1 = {
          '' => 'copy a b
',
          'copy_cmd' => {
                          '' => 'copy a b
',
                          'to' => 'b',
                          'from' => 'a',
                          'type' => 'std'
                        }
        };

b <- a
matches: <b <- a
>
$VAR1 = {
          '' => 'b <- a
',
          'copy_cmd' => {
                          '' => 'b <- a
',
                          'to' => 'b',
                          'from' => 'a',
                          'type' => 'bwd'
                        }
        };

a -> b
matches: <a -> b
>
$VAR1 = {
          '' => 'a -> b
',
          'copy_cmd' => {
                          '' => 'a -> b
',
                          'to' => 'b',
                          'from' => 'a',
                          'type' => 'fwd'
                        }
        };

cp a b
Syntax error!
\end{verbatim}

\parrafo{Pseudo subreglas y depuración}

\begin{it}\begin{quotation}
Note that, in addition to the semantics described above, aliased
subpatterns and code blocks also become visible to \cpan{Regexp::Grammars}
integrated debugger (see \rgsec{Debugging}{Debugging}).
\end{quotation}\end{it}

\subsection{Llamadas a subreglas desmemoriadas}

\begin{it}\begin{quotation}
By default, every subrule call saves its result into the result-hash,
either under its own name, or under an alias.

However, sometimes you may want to refactor some literal part of a rule
into one or more subrules, without having those submatches added to the
result-hash. The syntax for calling a subrule, but ignoring its return
value is:

\begin{verbatim}
    <.SUBRULE>
\end{verbatim}

(which is stolen directly from Perl 6).

For example, you may prefer to rewrite a rule such as:

\begin{verbatim}
    <rule: paren_pair> 

        \( 
            (?: <escape> | <paren_pair> | <brace_pair> | [^()] )*
        \)
\end{verbatim}

without any literal matching, like so:

\begin{verbatim}
    <rule: paren_pair> 

        <.left_paren>
            (?: <escape> | <paren_pair> | <brace_pair> | <.non_paren> )*
        <.right_paren>
    
    <token: left_paren>   \(
    <token: right_paren>  \)
    <token: non_paren>    [^()]
\end{verbatim}

Moreover, as the individual components inside the parentheses probably
aren't being captured for any useful purpose either, you could further
optimize that to:

\begin{verbatim}
    <rule: paren_pair> 

        <.left_paren>
            (?: <.escape> | <.paren_pair> | <.brace_pair> | <.non_paren> )*
        <.right_paren>
\end{verbatim}

Note that you can also use the dot modifier on an aliased subpattern:

\begin{verbatim}
    <.Alias= (SUBPATTERN) >
\end{verbatim}

This seemingly contradictory behaviour (of giving a subpattern a name,
then deliberately ignoring that name) actually does make sense in
one situation. Providing the alias makes the subpattern visible to the
debugger, while using the dot stops it from affecting the result-hash. See
\emph{Debugging non-grammars} for an example of this usage.
\end{quotation}\end{it}

\parrafo{Ejemplo: Números entre comas}

Por ejemplo, queremos reconocer listas de números separados por comas.
Supongamos también que queremos
darle un nombre a la expresión regular de separación.
Quizá, aunque no es el caso, porque la expresión
regular de separación sea suficientemente compleja.
Si no usamos la notación \emph{punto} la coma aparecerá en la estructura:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numberscomma.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        <numbers>
    12
    13        <objrule: numbers>
    14          <[number]> (<comma> <[number]>)*
    15
    16        <objtoken: number> \s*\d+
    17        <token: comma>  \s*,
    18      }xms;
    19  };
    20
    21  while (my $input = <>) {
    22      if ($input =~ m{$rbb}) {
    23          say("matches: <$&>");
    24          say Dumper \%/;
    25      }
    26  }
\end{verbatim}
En efecto, aparece la clave \verb|comma|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma.pl
2, 3, 4
matches: <2, 3, 4>
$VAR1 = {
  '' => '2, 3, 4',
  'numbers' => bless( {
    '' => '2, 3, 4',
    'number' => [
      bless( { '' => '2' }, 'number' ),
      bless( { '' => '3' }, 'number' ),
      bless( { '' => '4' }, 'number' )
    ],
    'comma' => ','
  }, 'numbers' )
};
\end{verbatim}
Si cambiamos la llamada a la regla \verb|<comma>| por 
\verb|<.comma>| 

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ diff numberscomma.pl numberscomma2.pl
14c14
<         <[number]> (<comma> <[number]>)*
---
>         <[number]> (<.comma> <[number]>)*
\end{verbatim}
eliminamos la aparición de la innecesaria clave:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma2.pl
2, 3, 4
matches: <2, 3, 4>
$VAR1 = {
  '' => '2, 3, 4',
  'numbers' => bless( {
    '' => '2, 3, 4',
    'number' => [
      bless( { '' => '2' }, 'number' ),
      bless( { '' => '3' }, 'number' ),
      bless( { '' => '4' }, 'number' )
    ]
  }, 'numbers' )
};

\end{verbatim}

\subsection{Destilación del resultado}

\parrafo{Destilación manual}

\begin{it}\begin{quotation}
\cpan{Regexp::Grammars} also offers full manual control over the distillation
process. If you use the reserved word \verb|MATCH| as the alias for a subrule
call:

\begin{verbatim}
    <MATCH=filename>
\end{verbatim}

or a subpattern match:

\begin{verbatim}
    <MATCH=( \w+ )>
\end{verbatim}

or a code block:

\begin{verbatim}
    <MATCH=(?{ 42 })>
\end{verbatim}

then the current rule will treat the return value of that subrule,
pattern, or code block as its complete result, and return that value
instead of the usual result-hash it constructs. This is the case even
if the result has other entries that would normally also be returned.

For example, in a rule like:

\begin{verbatim}
    <rule: term>
          <MATCH=literal>
        | <left_paren> <MATCH=expr> <right_paren>
\end{verbatim}

The use of \verb|MATCH| aliases causes the rule to return either whatever
\verb|<literal>| returns, or whatever \verb|<expr>| returns (provided it's between
left and right parentheses).

Note that, in this second case, even though \verb|<left_paren>| and \verb|<right_paren>|
are captured to the result-hash, they are not returned, because the
\verb|MATCH| alias overrides the normal \emph{return the result-hash} semantics and
returns only what its associated subrule (i.e. \verb|<expr>|) produces.
\end{quotation}\end{it}

El siguiente ejemplo ilustra el uso del alias \verb|MATCH|:

\begin{verbatim}
$ cat -n demo_calc.pl
 1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 8          <Answer>
 9
10          <rule: Answer>
11              <X=Mult> <Op=([+-])> <Y=Answer>
12            | <MATCH=Mult>
13
14          <rule: Mult>
15              <X=Pow> <Op=([*/%])> <Y=Mult>
16            | <MATCH=Pow>
17
18          <rule: Pow>
19              <X=Term> <Op=(\^)> <Y=Pow>
20            | <MATCH=Term>
21
22          <rule: Term>
23                 <MATCH=Literal>
24            | \( <MATCH=Answer> \)
25
26          <token: Literal>
27              <MATCH=( [+-]? \d++ (?: \. \d++ )?+ )>
28      }xms
29  };
30
31  while (my $input = <>) {
32      if ($input =~ $calculator) {
33          use Data::Dumper 'Dumper';
34          warn Dumper \%/;
35      }
36  }
\end{verbatim}

Veamos una ejecución:

\begin{verbatim}
$ ./demo_calc.pl
2+3*5
$VAR1 = {
          '' => '2+3*5',
          'Answer' => {
                        '' => '2+3*5',
                        'Op' => '+',
                        'X' => '2',
                        'Y' => {
                                 '' => '3*5',
                                 'Op' => '*',
                                 'X' => '3',
                                 'Y' => '5'
                               }
                      }
        };
4-5-2
$VAR1 = {
          '' => '4-5-2',
          'Answer' => {
                        '' => '4-5-2',
                        'Op' => '-',
                        'X' => '4',
                        'Y' => {
                                 '' => '5-2',
                                 'Op' => '-',
                                 'X' => '5',
                                 'Y' => '2'
                               }
                      }
        };
\end{verbatim}
Obsérvese como el árbol construido para la expresión \verb'4-5-2' 
se hunde a derechas dando lugar a una jerarquía errónea.
Para arreglar el problema sería necesario eliminar la 
recursividad por la izquierda en las reglas correspondientes.

\parrafo{Destilación en el programa}

\begin{it}\begin{quotation}
It's also possible to control what a rule returns from within a code
block. \cpan{Regexp::Grammars} provides a set of reserved variables that give
direct access to the result-hash.

The result-hash itself can be accessed as \verb|%MATCH| within any code block
inside a rule. For example:

\begin{verbatim}
    <rule: sum> 
        <X=product> \+ <Y=product>
            <MATCH=(?{ $MATCH{X} + $MATCH{Y} })>
\end{verbatim}

Here, the rule matches a product (aliased \verb|'X'| in the result-hash), then a
literal \verb|'+'|, then another product (aliased to \verb|'Y'| in the result-hash). The
rule then executes the code block, which accesses the two saved values
(as \verb|$MATCH{X}| and \verb|$MATCH{Y}|), adding them together. Because the block
is itself aliased to \verb|MATCH|, the sum produced by the block becomes the
(only) result of the rule.

It is also possible to set the rule result from within a code block
(instead of aliasing it). The special \emph{override} return value is
represented by the special variable \verb|$MATCH|. So the previous example
could be rewritten:

\begin{verbatim}
    <rule: sum> 
        <X=product> \+ <Y=product>
            (?{ $MATCH = $MATCH{X} + $MATCH{Y} })
\end{verbatim}
Both forms are identical in effect. Any assignment to \verb|$MATCH| overrides
the normal \emph{return all subrule results} behaviour.


Assigning to \verb|$MATCH| directly is particularly handy if the result may
not always be \emph{distillable}, for example:

\begin{verbatim}
    <rule: sum> 
        <X=product> \+ <Y=product>
            (?{ if (!ref $MATCH{X} && !ref $MATCH{Y}) {
                    # Reduce to sum, if both terms are simple scalars...
                    $MATCH = $MATCH{X} + $MATCH{Y};
                }
                else {
                    # Return full syntax tree for non-simple case...
                    $MATCH{op} = '+';
                }
            })
\end{verbatim}

Note that you can also partially override the subrule return
behaviour. Normally, the subrule returns the complete text it matched
under the \emph{empty key} of its result-hash. That is, of course, 
\verb|$MATCH{""}|,
so you can override just that behaviour by directly assigning to that
entry.

For example, if you have a rule that matches key/value pairs from a
configuration file, you might prefer that any trailing comments not
be included in the {\it matched text} entry of the rule's result-hash. You
could hide such comments like so:

\begin{verbatim}
    <rule: config_line>
        <key> : <value>  <comment>?
            (?{
                # Edit trailing comments out of "matched text" entry...
                $MATCH = "$MATCH{key} : $MATCH{value}";
            })
\end{verbatim}

Some more examples of the uses of \verb|$MATCH|:

\begin{verbatim}
    <rule: FuncDecl>
      # Keyword  Name               Keep return the name (as a string)...
        func     <Identifier> ;     (?{ $MATCH = $MATCH{'Identifier'} })


    <rule: NumList>
      # Numbers in square brackets...
        \[ 
            ( \d+ (?: , \d+)* )
        \]

      # Return only the numbers...
        (?{ $MATCH = $CAPTURE })


    <token: Cmd>
      # Match standard variants then standardize the keyword...
        (?: mv | move | rename )      (?{ $MATCH = 'mv'; })
\end{verbatim}

\verb|$CAPTURE| and \verb|$CONTEXT|
    are both aliases for the built-in read-only \verb|$^N |variable, 
which always contains the substring matched by 
the nearest preceding \verb|(...)| capture. 
\verb|$^N| still works perfectly well, but these are provided 
to improve the readability of code blocks and error messages respectively.
\end{quotation}\end{it}

El siguiente código implementa una calculadora
usando destilación en  el código:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_calc_inline.pl
 1  use v5.10;
 2  use warnings;
 3
 4  my $calculator = do{
 5      use Regexp::Grammars;
 6      qr{
 7          <Answer>
 8
 9          <rule: Answer>
10              <X=Mult> \+ <Y=Answer>
11                  (?{ $MATCH = $MATCH{X} + $MATCH{Y}; })
12            | <X=Mult> - <Y=Answer>
13                  (?{ $MATCH = $MATCH{X} - $MATCH{Y}; })
14            | <MATCH=Mult>
15
16          <rule: Mult>
17              <X=Pow> \* <Y=Mult>
18                  (?{ $MATCH = $MATCH{X} * $MATCH{Y}; })
19            | <X=Pow>  / <Y=Mult>
20                  (?{ $MATCH = $MATCH{X} / $MATCH{Y}; })
21            | <X=Pow>  % <Y=Mult>
22                  (?{ $MATCH = $MATCH{X} % $MATCH{Y}; })
23            | <MATCH=Pow>
24
25          <rule: Pow>
26              <X=Term> \^ <Y=Pow>
27                  (?{ $MATCH = $MATCH{X} ** $MATCH{Y}; })
28            | <MATCH=Term>
29
30          <rule: Term>
31                 <MATCH=Literal>
32            | \( <MATCH=Answer> \)
33
34          <token: Literal>
35              <MATCH=( [+-]? \d++ (?: \. \d++ )?+ )>
36      }xms
37  };
38
39  while (my $input = <>) {
40      if ($input =~ $calculator) {
41          say '--> ', $/{Answer};
42      }
43  }
\end{verbatim}

\begin{exercise}
Cual es la salida del programa anterior para las entradas:
\begin{itemize}
\item \verb|4-2-2|
\item \verb|8/4/2|
\item \verb|2^2^3|
\end{itemize}
\end{exercise}

\subsection{Llamadas privadas a subreglas y subreglas privadas}

\begin{it}\begin{quotation}
If a rule name (or an alias) begins with an underscore:

\begin{verbatim}
     <_RULENAME>       <_ALIAS=RULENAME>  
    <[_RULENAME]>     <[_ALIAS=RULENAME]>
\end{verbatim}

then matching proceeds as normal, and any result that is returned is
stored in the current result-hash in the usual way.

However, when any rule finishes (and just before it returns) it first
filters its result-hash, removing any entries whose keys begin with an
underscore. This means that any subrule with an underscored name (or with
an underscored alias) remembers its result, but only until the end of
the current rule. Its results are effectively private to the current rule.

This is especially useful in conjunction with result distillation.
\end{quotation}\end{it}

\subsection{Mas sobre listas}

\parrafo{Reconocimiento manual de listas}


\parrafo{Analizando listas manualmente}

El siguiente ejemplo muestra como construir un reconocedor de 
listas (posiblemente vacías) de números:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      <List>
     8
     9      <rule: List>
    10           <digit> <List>
    11         | # empty
    12
    13      <rule: digit>
    14          <MATCH=(\d+)>
    15
    16  }xms;
    17
    18  while (my $input = <>) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn "Does not match\n"
    26      }
    27  }
\end{verbatim}
Sigue una ejecución:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => {
                      '' => '2 3 4',
                      'digit' => '2'
                      'List' => {
                                  '' => '3 4',
                                  'digit' => '3'
                                  'List' => {
                                              '' => '4',
                                              'digit' => '4'
                                              'List' => '',
                                            },
                                },
                    }
        };
\end{verbatim}

\parrafo{Influencia del orden en el lenguaje reconocido}

Tenga en cuenta que el orden de las reglas
influye en el lenguaje reconocido. Véase lo que ocurre si cambiamos 
en el ejemplo anterior el orden de las reglas:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_empty_first.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      <List>
     8
     9      <rule: List>
    10           # empty
    11         | <digit> <List>
    12
    13      <rule: digit>
    14          <MATCH=(\d+)>
    15
    16  }xms;
    17
    18  while (my $input = <>) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn "Does not match\n"
    26      }
    27  }
\end{verbatim}
Al ejecutar se obtiene:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list_empty_first.pl
2 3 4
$VAR1 = {
          '' => '',
          'List' => ''
        };
\end{verbatim}

Por supuesto basta poner anclas en el patrón a buscar para forzar a que se reconozca
la lista completa:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ diff simple_list_empty_first.pl simple_list_empty_first_with_anchors.pl
7c7
<     <List>
---
>     ^<List>$
\end{verbatim}
En efecto, la nueva versión reconoce la lista:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_anchors.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => {
                      'List' => {
                                  'List' => {
                                              'List' => '',
                                              '' => '4',
                                              'digit' => '4'
                                            },
                                  '' => '3 4',
                                  'digit' => '3'
                                },
                      '' => '2 3 4',
                      'digit' => '2'
                    }
        };
\end{verbatim}

Si se quiere mantener la producción vacía en primer lugar 
pero forzar el reconocimiento de la lista completa, se puede
hacer uso de un lookahead negativo:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_empty_first_with_lookahead.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use strict;
     5  use Regexp::Grammars;
     6
     7  my $list = qr{
     8      <List>
     9
    10      <rule: List>
    11           (?! <digit> ) # still empty production
    12         | <digit> <List>
    13
    14      <rule: digit>
    15          <MATCH=(\d+)>
    16
    17  }xms;
    18
    19  while (my $input = <>) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn "Does not match\n"
    27      }
    28  }
\end{verbatim}
Así, sólo se reducirá por la regla vacía si el siguiente token no es un
número. Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_lookahead.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => {
                      'List' => {
                                  'List' => {
                                              'List' => '',
                                              '' => '4',
                                              'digit' => '4'
                                            },
                                  '' => '3 4',
                                  'digit' => '3'
                                },
                      '' => '2 3 4',
                      'digit' => '2'
                    }
        };

\end{verbatim}

\parrafo{Aplanamiento manual de listas}

¿Cómo podemos hacer que la estructura retornada por el reconocedor 
sea una lista?. Podemos añadir acciones como sigue:

\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_action.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      <List>
     8
     9      <rule: List>
    10           <digit> <X=List> <MATCH= (?{ unshift @{$MATCH{X}}, $MATCH{digit}; $MATCH{X} })>
    11         | # empty
    12           <MATCH= (?{ [] })>
    13
    14      <rule: digit>
    15          <MATCH=(\d+)>
    16
    17  }xms;
    18
    19  while (my $input = <>) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn "Does not match\n"
    27      }
    28  }
\end{verbatim}

Al ejecutarse este programa produce una salida como:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_action.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => [ '2', '3', '4' ]
        };
\end{verbatim}

\parrafo{Los operadores de repetición}

Los operadores de repetición como \verb|*|, \verb|+|, etc. 
permiten simplificar el análisis de lenguajes de listas:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_star.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list = qr{
 7      <List>
 8
 9      <rule: List>
10          (?: <[digit]>)*
11
12      <rule: digit>
13          <MATCH=(\d+)>
14
15  }xms;
16
17  while (my $input = <>) {
18      chomp $input;
19      if ($input =~ $list) {
20          use Data::Dumper 'Dumper';
21          warn Dumper \%/;
22      }
23      else {
24        warn "Does not match\n"
25      }
26  }
\end{verbatim}
Los corchetes alrededor de \verb|digit| hacen 
que el valor asociado con el patrón sea la lista de números.
Si no los ponemos el valor asociado sería el último valor de la lista.

\parrafo{Listas separadas por Algo}

\begin{it}\begin{quotation}
One of the commonest tasks in text parsing is to match a list of
unspecified length, in which items are separated by a fixed token. Things
like:

\begin{verbatim}
    1, 2, 3 , 4 ,13, 91        # Numbers separated by commas and spaces

    g-c-a-g-t-t-a-c-a          # Bases separated by dashes

    /usr/local/bin             # Names separated by directory markers

    /usr:/usr/local:bin        # Directories separated by colons
\end{verbatim}

The usual construct required to parse these kinds of structures is either:

\begin{verbatim}
    <rule: list>

        <item> <separator> <list               # recursive definition
      | <item>                                 # base case
\end{verbatim}

Or, more efficiently, but less prettily:

\begin{verbatim}
    <rule: list>

        <[item]> (?: <separator> <[item]> )*   # iterative definition
\end{verbatim}

Because this is such a common requirement, \cpan{Regexp::Grammars} provides a
cleaner way to specify the iterative version. The syntax is taken from
Perl 6:

\begin{verbatim}
    <rule: list>

        <[item]> ** <separator>                # iterative definition
\end{verbatim}

This is a repetition specifier on the first subrule (hence the use of \verb|**|
as the marker, to reflect the repetitive behaviour of \verb|*|). However, the
number of repetitions is controlled by the second subrule: the first
subrule will be repeatedly matched for as long as the second subrule
matches immediately after it.

So, for example, you can match a sequence of numbers separated by
commas with:

\begin{verbatim}
    <[number]> ** <comma>

    <token: number>  \d+
    <token: comma>   \s* , \s*
\end{verbatim}

Note that it's important to use the \verb|<[...]>| form for the items being
matched, so that all of them are saved in the result hash. You can also
save all the separators (if that's important):

\begin{verbatim}
    <[number]> ** <[comma]>
\end{verbatim}

The repeated item must be specified as a subrule call fo some kind,
but the separators may be specified either as a subrule or a bracketed
pattern. For example:

\begin{verbatim}
    <[number]> ** ( , )
\end{verbatim}

The separator must always be specified in matched delimiters of some kind:
either matching \verb|<...>| or matching \verb|(...)|. 
A common error is to write:

\begin{verbatim}
    <[number]> ** ,
\end{verbatim}

You can also use a pattern as the item matcher, but it must be aliased
into a subrule:

\begin{verbatim}
    <[item=(\d+)]> ** ( , )
\end{verbatim}
\end{quotation}\end{it}

\parrafo{Ejemplo: Listas de números separados por comas}

Veamos un ejemplo sencillo:

\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n demo_list.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list_nonempty = qr{
 7      <List>
 8
 9      <rule: List>
10          \(  <[Value]> ** (,)  \)
11
12      <token: Value>
13          \d+
14  }xms;
15
16  my $list_empty = qr{
17      <List>
18
19      <rule: List>
20          \(  (?: <[Value]> ** <_Sep=(,)> )?  \)
21
22      <token: Value>
23          \d+
24  }xms;
25
26  use Smart::Comments;
27
28
29  while (my $input = <>) {
30      my $input2 = $input;
31      if ($input =~ $list_nonempty) {
32          ### nonempty: $/{List}
33      }
34      if ($input2 =~ $list_empty) {
35          ### empty: $/{List}
36      }
37  }
\end{verbatim}
Sigue un ejemplo de ejecución:

\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ ./demo_list.pl
(3,4,5)

### nonempty: {
###             '' => '(3,4,5)',
###             Value => [
###                        '3',
###                        '4',
###                        '5'
###                      ]
###           }

### empty: {
###          '' => '(3,4,5)',
###          Value => [
###                     '3',
###                     '4',
###                     '5'
###                   ]
###        }
()

### empty: '()'
\end{verbatim}

\parrafo{Ejemplo: AST para las expresiones aritméticas}

Las expresiones aritméticas
puede definirse como una jerarquía de listas como
sigue:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n calcaslist.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5  $Data::Dumper::Indent = 1;
 6
 7  my $rbb = do {
 8      use Regexp::Grammars;
 9
10      qr{
11        \A<expr>\z
12
13        <objrule: expr>      <[operands=term]> ** <[operators=addop]>
14
15        <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
16
17        <objrule: uneg>      <[operators=minus]>* <[operands=power]>
18
19        <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
20
21        <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
22
23        <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
24                           | \( <MATCH=expr> \)
25
26        <token: addop>        [+-]
27
28        <token: mulop>        [*/]
29
30        <token: powerop>      \*\*|\^
31
32        <token: minus>        - <MATCH=(?{ 'NEG' })>
33
34      }x;
35  };
36
37  while (my $input = <>) {
38      chomp($input);
39      if ($input =~ m{$rbb}) {
40          my $tree = $/{expr};
41          say Dumper $tree;
42
43      }
44      else {
45          say("does not match");
46      }
47  }
\end{verbatim}

Obsérvese el árbol generado para la expresión \verb|4-2-2|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 calcaslist.pl
4-2-2
$VAR1 = bless( {
  'operands' => [
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '4', 'val' => '4' }, 'factor' )
                  ],
                  '' => '4'
                }, 'factorial' )
              ],
              '' => '4'
            }, 'power' )
          ],
          '' => '4'
        }, 'uneg' )
      ],
      '' => '4'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '2', 'val' => '2' }, 'factor' )
                  ],
                  '' => '2'
                }, 'factorial' )
              ],
              '' => '2'
            }, 'power' )
          ],
          '' => '2'
        }, 'uneg' )
      ],
      '' => '2'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '2', 'val' => '2' }, 'factor' )
                  ],
                  '' => '2'
                }, 'factorial' )
              ],
              '' => '2'
            }, 'power' )
          ],
          '' => '2'
        }, 'uneg' )
      ],
      '' => '2'
    }, 'term' )
  ],
  '' => '4-2-2',
  'operators' => [
    '-',
    '-'
  ]
}, 'expr' );
\end{verbatim}

\subsection{La directiva {\tt require}}

La directiva \verb|require| es similar 
en su funcionamiento al paréntesis 5.10 \verb|(??{ Código Perl })|
el cuál hace que el \verb|Código Perl| sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular con la que deberá
casarse.
(véase la sección \ref{subsection:tiempodematching}
para mas detalles).

La sintáxis de la directiva \verb|<require:>| es

\begin{it}\begin{quotation}
\begin{verbatim}
                        <require: (?{ CODE }) >
\end{verbatim}

The code block is executed and if its final value is true, matching
continues from the same position. If the block's final value is false,
the match fails at that point and starts backtracking.
\end{quotation}\end{it}

\begin{it}\begin{quotation}
The \verb|<require:...>| directive is useful for testing conditions that it's
not easy (or even possible) to check within the syntax of the the regex
itself. For example:

\begin{verbatim}
    <rule: IPV4_Octet_Decimal>
        # Up three digits...
        <MATCH= ( \d{1,3}+ )>
        
        # ...but less that 256...
        <require: (?{ $MATCH <= 255 })>
\end{verbatim}

A require expects a regex codeblock as its argument and succeeds if
the final value of that codeblock is true. If the final value is false,
the directive fails and the rule starts backtracking.

Note, in this example that the digits are matched with \verb|\d{1,3}+| . \emph{The
trailing} \verb|+| prevents the \verb|{1,3}| repetition from backtracking to a smaller
number of digits if the \verb|<require:...>| fails.
\end{quotation}\end{it}

El programa \verb|demo_IP4.pl| ilustra el uso de la directiva:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n ./demo_IP4.pl
 1  #!/usr//bin/env perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  use Regexp::Grammars;
 6
 7  my $grammar = qr{
 8      \A <IP4_addr> \Z
 9
10      <token: quad>
11          <MATCH=(\d{1,3})>
12          <require: (?{ $MATCH < 256 })>
13
14      <token: IP4_addr>
15          <[MATCH=quad]>**(\.)
16          <require: (?{ @$MATCH == 4 })>
17  }xms;
18
19  while (my $line = <>) {
20      if ($line =~ $grammar) {
21          use Data::Dumper 'Dumper';
22          say Dumper \%/;
23      }
24      else {
25          say 'Does not match'
26      }
27  }
\end{verbatim}
Las condiciones usadas en el \verb|require| obligan a que cada 
quad\footnote{
A quad (pronounced KWAHD ) is a unit in a set of something that comes
in four units. The term is sometimes used to describe each of the four
numbers that constitute an Internet Protocol ( IP ) address. Thus, an
Internet address in its numeric form (which is also sometimes called a
dot address ) consists of four quads separated by "dots" (periods). 

A quad also means \emph{a quarter} in some usages. (A quarter as a U.S. coin
or monetary unit means \emph{a quarter of a dollar,} and in slang is sometimes
called \emph{two bits.} However, this usage does not mean two binary bits as
used in computers.)
} sea menor que 256 y a que existan sólo cuatro quads.

Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123 . 145 . 105 . 252
Does not match
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123.145.105.252
$VAR1 = {
          '' => '123.145.105.252',
          'IP4_addr' => [
                          123,
                          145,
                          105,
                          252
                        ]
        };
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
148.257.128.128
Does not match
0.0.0.299
Does not match
pl@nereida:~/Lregexpgrammars/demo$  ./demo_IP4.pl
123.145.105.242.193
Does not match
\end{verbatim}
Obsérvese como no se aceptan blancos entre los puntos en esta versión.
¿Sabría explicar la causa?



\subsection{Casando con las claves de un hash}


\begin{it}\begin{quotation}
In some situations a grammar may need a rule that matches dozens,
hundreds, or even thousands of one-word alternatives. For example, when
matching command names, or valid userids, or English words. In such
cases it is often impractical (and always inefficient) to list all the
alternatives between \verb#|# alterators:

\begin{verbatim}
    <rule: shell_cmd>
        a2p | ac | apply | ar | automake | awk | ...
        # ...and 400 lines later
        ... | zdiff | zgrep | zip | zmore | zsh

    <rule: valid_word>
        a | aa | aal | aalii | aam | aardvark | aardwolf | aba | ...
        # ...and 40,000 lines later... 
        ... | zymotize | zymotoxic | zymurgy | zythem | zythum
\end{verbatim}

To simplify such cases, \cpan{Regexp::Grammars} provides a special construct
that allows you to specify all the alternatives as the keys of a normal
hash. The syntax for that construct is simply to put the hash name inside
angle brackets (with no space between the angles and the hash name).

Which means that the rules in the previous example could also be written:

\begin{verbatim}
    <rule: shell_cmd>
        <%cmds>

    <rule: valid_word>
        <%dict>
\end{verbatim}

provided that the two hashes (\verb|%cmds| and \verb|%dict|) 
are visible in the scope where the grammar is created.

Internally, the construct is converted to something equivalent to:

\begin{verbatim}
    <rule: shell_cmd>
        (<.hk>)  <require: exists $cmds{$CAPTURE}>

    <rule: valid_word>
        (<.hk>)  <require: exists $dict{$CAPTURE}>
\end{verbatim}

The special \verb|<hk>| rule is created automatically, and defaults to \verb|\S+|,
but you can also define it explicitly to handle other kinds of keys. For
example:

\begin{verbatim}
    <rule: hk>
        .+            # Key may be any number of chars on a single line

    <rule: hk>
        [ACGT]{10,}   # Key is a base sequence of at least 10 pairs
\end{verbatim}

Matching a hash key in this way is typically significantly faster than
matching a full set of alternations. Specifically, it is O(length of
longest potential key), instead of O(number of keys).
\end{quotation}\end{it}

\parrafo{Ejemplo de uso de la directiva hash}

Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n hash.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Data::Dumper;
 6  $Data::Dumper::Deparse = 1;
 7
 8  my %cmd = map { ($_ => undef ) } qw( uname pwd date );
 9
10  my $rbb = do {
11      use Regexp::Grammars;
12
13      qr{
14        ^<command>$
15
16        <rule: command>
17          <cmd=%cmd> (?: <[arg]> )*
18
19        <token: arg> [^\s<>`&]+
20      }xms;
21  };
22
23  while (my $input = <>) {
24      chomp($input);
25      if ($input =~ m{$rbb}) {
26          say("matches: <$&>");
27          say Dumper \%/;
28          system $/{''}
29      }
30      else {
31          say("does not match");
32      }
33  }
\end{verbatim}

Sigue un ejemplo de ejecución:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 hash.pl
a2p f1 f2
matches: <a2p f1 f2>
$VAR1 = {
          '' => 'a2p f1 f2',
          'command' => {
                         '' => 'a2p f1 f2',
                         'cmd' => 'a2p',
                         'arg' => [
                                    'f1',
                                    'f2'
                                  ]
                       }
        };

pocho 2 5
does not match

\end{verbatim}

\subsection{Depuración}

\begin{it}\begin{quotation}
\cpan{Regexp::Grammars} provides a number of features specifically designed to
help debug both grammars and the data they parse.

    All debugging messages are written to a log file (which, by default, is
    just \verb|STDERR|). However, you can specify a disk file explicitly by placing
    a \verb|"<logfile:...>"| directive \emph{at the start of your grammar}\footnote{no funcionará si no se pone al principio
    de la gramática}:

\begin{verbatim}
        $grammar = qr{

            <logfile: LaTeX_parser_log >

            \A <LaTeX_file> \Z    # Pattern to match

            <rule: LaTeX_file>
                # etc.
        }x;
\end{verbatim}

    You can also explicitly specify that messages go to the terminal:

\begin{verbatim}
            <logfile: - >
\end{verbatim}

\parrafo{Debugging grammar creation}

Whenever a log file has been directly specified, \cpan{Regexp::Grammars}
automatically does verbose static analysis of your grammar. That is,
whenever it compiles a grammar containing an explicit \verb|"<logfile:...>"|
directive it logs a series of messages explaining how it has interpreted
the various components of that grammar. For example, the following
grammar:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n log.pl
     1  #!/usr/bin/env perl5.10.1
     2  use strict;
     3  use warnings;
     4  use 5.010;
     5  use Data::Dumper;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        <logfile: ->
    12
    13        <numbers>
    14
    15        <rule: numbers>
    16          <number> ** <.comma>
    17
    18        <token: number> \d+
    19
    20        <token: comma>   ,
    21      }xms;
    22  };
    23
    24  while (my $input = <>) {
    25      if ($input =~ m{$rbb}) {
    26          say("matches: <$&>");
    27          say Dumper \%/;
    28      }
    29  }
\end{verbatim}

would produce the following analysis in the terminal:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./log.pl
  warn | Repeated subrule <number>* will only capture its final match
       | (Did you mean <[number]>* instead?)
       |
  info | Processing the main regex before any rule definitions
       |    |
       |    |...Treating <numbers> as:
       |    |      |  match the subrule <numbers>
       |    |       \ saving the match in $MATCH{'numbers'}
       |    |
       |     \___End of main regex
       |
       | Defining a rule: <numbers>
       |    |...Returns: a hash
       |    |
       |    |...Treating <number> as:
       |    |      |  match the subrule <number>
       |    |       \ saving the match in $MATCH{'number'}
       |    |
       |    |...Treating <.comma> as:
       |    |      |  match the subrule <comma>
       |    |       \ but don't save anything
       |    |
       |    |...Treating <number> ** <.comma> as:
       |    |      |  repeatedly match the subrule <number>
       |    |       \ as long as the matches are separated by matches of <.comma>
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: <number>
       |    |...Returns: a hash
       |    |
       |    |...Treating '\d' as:
       |    |       \ normal Perl regex syntax
       |    |
       |    |...Treating '+ ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: <comma>
       |    |...Returns: a hash
       |    |
       |    |...Treating ', ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
2, 3, 4
matches: <2, 3, 4>
$VAR1 = {
          '' => '2, 3, 4',
          'numbers' => {
                         '' => '2, 3, 4',
                         'number' => '4'
                       }
        };
\end{verbatim}

This kind of static analysis is a useful starting point in debugging a
\cei{miscreant grammar}\footnote{
miscreant - \it{One who has behaved badly, or illegally; One not restrained by
moral principles; an unscrupulous villain; One who holds an incorrect
religious belief; an unbeliever; Lacking in conscience or moral
principles; unscrupulous; Holding an incorrect religious belief.}
}, because it enables you to see what you actually
specified (as opposed to what you \emph{thought} you'd specified).

\parrafo{Debugging grammar execution}

\cpan{Regexp::Grammars} also provides a simple interactive debugger, with which
you can observe the process of parsing and the data being collected in
any result-hash.

To initiate debugging, place a \verb"<debug:...>" directive anywhere in your
grammar. When parsing reaches that directive the debugger will be
activated, and the command specified in the directive immediately
executed. The available commands are:

\begin{verbatim}
        <debug: on>    - Enable debugging, stop when entire grammar matches
        <debug: match> - Enable debugging, stope when a rule matches
        <debug: try>   - Enable debugging, stope when a rule is tried
        <debug: off>   - Disable debugging and continue parsing silently

        <debug: continue> - Synonym for <debug: on>
        <debug: run>      - Synonym for <debug: on>
        <debug: step>     - Synonym for <debug: try>
\end{verbatim}

    These directives can be placed anywhere within a grammar and take effect
    when that point is reached in the parsing. Hence, adding a
    \verb"<debug:step>" directive is very much like setting a breakpoint at that
    point in the grammar. Indeed, a common debugging strategy is to turn
    debugging on and off only around a suspect part of the grammar:

\begin{verbatim}
        <rule: tricky>   # This is where we think the problem is...
            <debug:step>
            <preamble> <text> <postscript>
            <debug:off>
\end{verbatim}

Once the debugger is active, it steps through the parse, reporting rules
that are tried, matches and failures, backtracking and restarts, and the
parser's location within both the grammar and the text being matched.
That report looks like this:

\begin{verbatim}
        ===============> Trying <grammar> from position 0
        > cp file1 file2 |...Trying <cmd>
                         |   |...Trying <cmd=(cp)>
                         |   |    \FAIL <cmd=(cp)>
                         |    \FAIL <cmd>
                          \FAIL <grammar>
        ===============> Trying <grammar> from position 1
         cp file1 file2  |...Trying <cmd>
                         |   |...Trying <cmd=(cp)>
         file1 file2     |   |    \_____<cmd=(cp)> matched 'cp'
        file1 file2      |   |...Trying <[file]>+
         file2           |   |    \_____<[file]>+ matched 'file1'
                         |   |...Trying <[file]>+
        [eos]            |   |    \_____<[file]>+ matched ' file2'
                         |   |...Trying <[file]>+
                         |   |    \FAIL <[file]>+
                         |   |...Trying <target>
                         |   |   |...Trying <file>
                         |   |   |    \FAIL <file>
                         |   |    \FAIL <target>
         <~~~~~~~~~~~~~~ |   |...Backtracking 5 chars and trying new match
        file2            |   |...Trying <target>
                         |   |   |...Trying <file>
                         |   |   |    \____ <file> matched 'file2'
        [eos]            |   |    \_____<target> matched 'file2'
                         |    \_____<cmd> matched ' cp file1 file2'
                          \_____<grammar> matched ' cp file1 file2'
\end{verbatim}

The first column indicates the point in the input at which the parser is
trying to match, as well as any backtracking or forward searching it may
need to do. The remainder of the columns track the parser's hierarchical
traversal of the grammar, indicating which rules are tried, which
succeed, and what they match.

Provided the logfile is a terminal (as it is by default), the debugger
also pauses at various points in the parsing process--before trying a
rule, after a rule succeeds, or at the end of the parse--according to
the most recent command issued. When it pauses, you can issue a new
command by entering a single letter:

\begin{verbatim}
        m       - to continue until the next subrule matches
        t or s  - to continue until the next subrule is tried
        r or c  - to continue to the end of the grammar
        o       - to switch off debugging
\end{verbatim}

Note that these are the first letters of the corresponding \verb"<debug:...>"
commands, listed earlier. Just hitting ENTER while the debugger is
paused repeats the previous command.

While the debugger is paused you can also type a \verb'd', which will display
the result-hash for the current rule. This can be useful for detecting
which rule isn't returning the data you expected.
\end{quotation}\end{it}

Veamos un ejemplo. El siguiente programa activa el depurador:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_debug.pl
     1  #!/usr/bin/env perl5.10.1
     2  use 5.010;
     3  use warnings;
     4
     5      use Regexp::Grammars;
     6
     7      my $balanced_brackets = qr{
     8          <debug:on>
     9
    10          <left_delim=(  \( )>
    11          (?:
    12              <[escape=(  \\ )]>
    13          |   <recurse=( (?R) )>
    14          |   <[simple=(  .  )]>
    15          )*
    16          <right_delim=( \) )>
    17      }xms;
    18
    19      while (<>) {
    20          if (/$balanced_brackets/) {
    21              say 'matched:';
    22              use Data::Dumper 'Dumper';
    23              warn Dumper \%/;
    24          }
    25      }
\end{verbatim}
Al ejecutar obtenemos
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
(a)
=====> Trying <grammar> from position 0
(a)\n  |...Trying <left_delim=(  \( )>
a)\n   |    \_____<left_delim=(  \( )> matched '('      c
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 1
a)\n   |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
)\n    |    \_____<[simple=(  .  )]> matched 'a'
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 2
)\n    |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
\n     |    \_____<[simple=(  .  )]> matched ')'
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 3
\n     |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
[eos]  |    \_____<[simple=(  .  )]> matched ''
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 4
[eos]  |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
       |    \FAIL <[simple=(  .  )]>
       |...Trying <right_delim=( \) )>
       |    \FAIL <right_delim=( \) )>
 <~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying <right_delim=( \) )>
       |    \FAIL <right_delim=( \) )>
 <~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying <right_delim=( \) )>
\n     |    \_____<right_delim=( \) )> matched ')'
        \_____<grammar> matched '(a)'   d
              :         {
              :           '' => '(a)',
              :           'left_delim' => '(',
              :           'simple' => [
              :                         'a'
              :                       ],
              :           'right_delim' => ')'
              :         };      o
matched:
$VAR1 = {
          '' => '(a)',
          'left_delim' => '(',
          'simple' => [
                        'a'
                      ],
          'right_delim' => ')'
        };
\end{verbatim}
\end{latexonly}

\begin{rawhtml}
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
<span class="lightblue">(a)</span>
=====&gt; Trying &lt;grammar&gt; from position 0
(a)\n  |...Trying &lt;left_delim=(  \( )&gt;

a)\n   |    \_____&lt;left_delim=(  \( )&gt; matched '('      <span class="lightblue">c</span>
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 1
a)\n   |   |...Trying &lt;left_delim=(  \( )&gt;

       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
)\n    |    \_____&lt;[simple=(  .  )]&gt; matched 'a'
       |...Trying &lt;[escape=(  \ )]&gt;

       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 2
)\n    |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;

        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
\n     |    \_____&lt;[simple=(  .  )]&gt; matched ')'
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;

       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 3
\n     |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;

       |...Trying &lt;[simple=(  .  )]&gt;
[eos]  |    \_____&lt;[simple=(  .  )]&gt; matched ''
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;

=====&gt; Trying &lt;grammar&gt; from position 4
[eos]  |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;

       |    \FAIL &lt;[simple=(  .  )]&gt;
       |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;
 &lt;~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;

 &lt;~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying &lt;right_delim=( \) )&gt;
\n     |    \_____&lt;right_delim=( \) )&gt; matched ')'
        \_____&lt;grammar&gt; matched '(a)'   <span class="lightblue">d</span>
              :         {
              :           '' =&gt; '(a)',
              :           'left_delim' =&gt; '(',
              :           'simple' =&gt; [
              :                         'a'
              :                       ],
              :           'right_delim' =&gt; ')'
              :         };      <span class="lightblue">o</span>
matched:
$VAR1 = {
          '' =&gt; '(a)',
          'left_delim' =&gt; '(',
          'simple' =&gt; [
                        'a'
                      ],
          'right_delim' =&gt; ')'
        };

</PRE>

\end{rawhtml}

\subsection{Mensajes de {\tt log} del usuario}

\begin{it}\begin{quotation}
    Both static and interactive debugging send a series of predefined log
    messages to whatever log file you have specified. It is also possible to
    send additional, user-defined messages to the log, using the \verb|"<log:...>"|
    directive.

    This directive expects either a simple text or a codeblock as its single
    argument. If the argument is a code block, that code is expected to
    return the text of the message; if the argument is anything else, that
    something else \emph{is} the literal message. For example:

\begin{verbatim}
        <rule: ListElem>

            <Elem=   ( [a-z]\d+) >
                <log: Checking for a suffix, too...>

            <Suffix= ( : \d+   ) >?
                <log: (?{ "ListElem: $MATCH{Elem} and $MATCH{Suffix}" })>
\end{verbatim}

    User-defined log messages implemented using a codeblock can also specify
    a severity level. If the codeblock of a \verb"<log:...>" directive returns
    two or more values, the first is treated as a log message severity
    indicator, and the remaining values as separate lines of text to be
    logged. For example:

\begin{verbatim}
        <rule: ListElem>
            <Elem=   ( [a-z]\d+) >
            <Suffix= ( : \d+   ) >?

                <log: (?{
                    warn => "Elem was: $MATCH{Elem}",
                            "Suffix was $MATCH{Suffix}",
                })>
\end{verbatim}

    When they are encountered, user-defined log messages are interspersed
    between any automatic log messages (i.e. from the debugger), at the
    correct level of nesting for the current rule.
\end{quotation}\end{it}


\subsection{Depuración de Regexps}

\begin{it}\begin{quotation}
    It is possible to use \cpan{Regexp::Grammars} without creating \emph{any} subrule
    definitions, simply to debug a recalcitrant regex. For example, if the
    following regex wasn't working as expected:

\begin{verbatim}
        my $balanced_brackets = qr{
            \(             # left delim
            (?:
                \\         # escape or
            |   (?R)       # recurse or
            |   .          # whatever
            )*
            \)             # right delim
        }xms;
\end{verbatim}

    you could instrument it with aliased subpatterns and then debug it
    step-by-step, using \cpan{Regexp::Grammars}:

\begin{verbatim}
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            <debug:step>

            <.left_delim=  (  \(  )>
            (?:
                <.escape=  (  \\  )>
            |   <.recurse= ( (?R) )>
            |   <.whatever=(  .   )>
            )*
            <.right_delim= (  \)  )>
        }xms;

        while (<>) {
            say 'matched' if /$balanced_brackets/;
        }
\end{verbatim}

    Note the use of amnesiac aliased subpatterns to avoid needlessly
    building a result-hash. Alternatively, you could use listifying aliases
    to preserve the matching structure as an additional debugging aid:

\begin{verbatim}
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            <debug:step>

            <[left_delim=  (  \(  )]>
            (?:
                <[escape=  (  \\  )]>
            |   <[recurse= ( (?R) )]>
            |   <[whatever=(  .   )]>
            )*
            <[right_delim= (  \)  )]>
        }xms;

        if ( '(a(bc)d)' =~ /$balanced_brackets/) {
            use Data::Dumper 'Dumper';
            warn Dumper \%/;
        }
\end{verbatim}
\end{quotation}\end{it}


\subsection{Manejo y recuperación de errores}

En este punto debo decir que no he podido reproducir el comportamiento
de las directivas \verb|<error:>| y \verb|<warning:>| tal y como las describe 
Conway en el manual de \regexpg{}. 

El siguiente ejemplo ilustra un conjunto de técnicas de gestión de errores
que son independientes del soprote dado por \regexpg{}.

Se trata de la misma calculadora explicada en la sección
\ref{subsection:recicla}.

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculatorwitherrmanagement.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Lingua::EN::Inflect qw(PL);
 6  use Scalar::Util qw{blessed};
 7
 8  my $rbb = do {
 9      my ($warnings, $errors);    # closure
10      sub warnings { $warnings }  # accessor
11      sub errors { $errors }      # accessor
12
13      use Regexp::Grammars;
14      qr{
15        (?{
16            $warnings = 0;
17            $errors = 0;
18        })
19        \A<expr>
20        (?:   \z
21             |
22               (.*) (?{
23                        # Accept the string but emit a warning
24                        $warnings++;
25                        local our $expr = \$MATCH{expr}{''};
26                        local our $endlegal = length($$expr) > 4? "... ".substr($$expr, -4) : $$expr;
27                        warn "Warning: Unexpected '". substr($^N, 0, 10)."' after '$endlegal'\n";
28                     })
29        )
30
31        <objrule: expr>      <[operands=term]> ** <[operators=addop]>
32
33        <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
34
35        <objrule: uneg>      <[operators=minus]>* <[operands=power]>
36
37        <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
38
39        <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
40
41        <objrule: factor>    (<val=([+-]?\d+(?:\.\d*)?)>)
42                           | \( <MATCH=expr> \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
46                                            $warnings++;
47                                            $errors++;
48                                        }) <MATCH=factor>
49
50        <token: addop>        [+-]
51
52        <token: mulop>        [*/]
53
54        <token: powerop>      \*\*|\^
55
56        <token: minus>        - <MATCH=(?{ 'NEG' })>
57
58      }x;
59  };
60
61  sub test_calc {
62    my $prompt = shift;
63
64    print $prompt;
65    while (my $input = <>) {
66        chomp($input);
67
68        local %/;
69        $input =~ m{$rbb};
70
71        say warnings." ".PL('warning',warnings) if warnings;
72        say errors." ".PL('error',errors)       if errors;
73
74        my $tree = $/{expr};
75        if (blessed($tree)) {
76            do "PostfixCalc.pm";
77            say "postfix: ".$tree->ceval;
78
79            do "EvalCalc.pm";
80            say "result: ".$tree->ceval;
81        }
82        print $prompt;
83    }
84    say "Bye!"
85  }
86
87  ########## main
88  test_calc(
89    'Parsing infix arithmetic expressions (CTRL-D to end in unix) ',
90  );
\end{verbatim}

Veamos algunas ejecuciones que incluyen entradas erróneas:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+3
postfix: 2 3 +
result: 5
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
Error: expecting a number or a open parenthesis, found: '#'
Error: expecting a number or a open parenthesis, found: ')'
Warning: Unexpected '*(3+#)' after '2'
4 warnings
3 errors
postfix: 2
result: 2
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+#*4
Error: expecting a number or a open parenthesis, found: '#*'
1 warning
1 error
postfix: 2 4 +
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
\end{verbatim}
Obsérvese los mensajes de error repetidos para la entrada 
\verb|2*(3+#)|. Ellos son debidos a los reiterados intentos de
casar \verb|<factor>| en la regla de recuperación de errores:
\begin{verbatim}
41        <objrule: factor>    (<val=([+-]?\d+(?:\.\d*)?)>)
42                           | \( <MATCH=expr> \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
46                                            $warnings++;
47                                            $errors++;
48                                        }) <MATCH=factor>
\end{verbatim}
en este caso resulta imposible encontrar un factor.
Se puede cambiar la conducta indicando un \verb|(* COMMIT)| antes de la
llamada a \verb|<MATCH=factor>|:
\begin{verbatim}
 41       <objrule: factor>    (<val=([+-]?\d+(?:\.\d*)?)>)
 42                          | \( <MATCH=expr> \)
 43                          | ([^-+(0-9]+) (?{
 44                                           # is + and not * to avoid infinite recursion
 45                                           warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
 46                                           $warnings++;
 47                                           $errors++;
 48                                       }) (*COMMIT) <MATCH=factor>
\end{verbatim}

en este caso la conducta es abandonar en el caso de que no se pueda encontrar un \verb|<factor>|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*3
postfix: 2 3 *
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) @
Error: expecting a number or a open parenthesis, found: '@'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
\end{verbatim}

\subsection{Mensajes de Warning}

\begin{it}\begin{quotation}
   Sometimes, you want to detect problems, but not invalidate the entire
   parse as a result. For those occasions, the module provides a \emph{less
   stringent} form of error reporting: the \verb"<warning:...>" directive.

   This directive is exactly the same as an \verb"<error:...>" in every respect
   except that it does not induce a failure to match at the point it
   appears.

   The directive is, therefore, useful for reporting \emph{non-fatal} problems
   in a parse. For example:

\begin{verbatim}
       qr{ \A            # ...Match only at start of input
           <ArithExpr>   # ...Match a valid arithmetic expression

           (?:
               # Should be at end of input...
               \s* \Z
             |
               # If not, report the fact but don't fail...
               <warning: Expected end-of-input>
               <warning: (?{ "Extra junk at index $INDEX: $CONTEXT" })>
           )

           # Rule definitions here...
       }xms;
\end{verbatim}

   Note that, because they do not induce failure, two or more
   \verb"<warning:...>" directives can be "stacked" in sequence, as in the
   previous example.

\end{quotation}\end{it}

\subsection{Simplificando el AST}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n exprdamian.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        \A<expr>\z
    12
    13        <objrule: expr>    <MATCH=term> (?! <addop> )                  # bypass
    14                         | <[operands=term]> ** <[operators=addop]>
    15
    16        <objrule: term>    <MATCH=factor> (?! <mulop> )                # bypass
    17                         | <[operands=factor]> ** <[operators=mulop]>
    18
    19        <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
    20                         | \( <MATCH=expr> \)
    21
    22        <token: addop> [+-]
    23
    24        <token: mulop> [*/]
    25
    26      }x;
    27  };
    28
    29  while (my $input = <>) {
    30      chomp($input);
    31      if ($input =~ m{$rbb}) {
    32          my $tree = $/{expr};
    33          say Dumper $tree;
    34          say $tree->ceval;
    35
    36      }
    37      else {
    38          say("does not match");
    39      }
    40  }
    41
    42  BEGIN {
    43
    44    package LeftBinaryOp;
    45    use strict;
    46    use base qw(Class::Accessor);
    47
    48    LeftBinaryOp->mk_accessors(qw{operators operands});
    49
    50    my %f = (
    51      '+' => sub { shift() + shift() },
    52      '-' => sub { shift() - shift() },
    53      '*' => sub { shift() * shift() },
    54      '/' => sub { shift() / shift() },
    55    );
    56
    57    sub ceval {
    58      my $self = shift;
    59
    60      # recursively evaluate the children first
    61      my @operands = map { $_->ceval } @{$self->operands};
    62
    63      # then combine them
    64      my $s = shift @operands;
    65      for (@{$self->operators}) {
    66        $s = $f{$_}->($s, shift @operands);
    67      }
    68      return $s;
    69    }
    70
    71    package term;
    72    use base qw{LeftBinaryOp};
    73
    74    package expr;
    75    use base qw{LeftBinaryOp};
    76
    77    package factor;
    78
    79    sub ceval {
    80      my $self = shift;
    81
    82      return $self->{val};
    83    }
    84
    85    1;
    86  }
\end{verbatim}

Ejecuciones:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 exprdamian.pl
4-2-2
$VAR1 = bless( {
  'operands' => [
    bless( {
      '' => '4',
      'val' => '4'
    }, 'factor' ),
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' ),
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' )
  ],
  '' => '4-2-2',
  'operators' => [
    '-',
    '-'
  ]
}, 'expr' );

0
8/4/2
$VAR1 = bless( {
  'operands' => [
    bless( {
      '' => '8',
      'val' => '8'
    }, 'factor' ),
    bless( {
      '' => '4',
      'val' => '4'
    }, 'factor' ),
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' )
  ],
  '' => '8/4/2',
  'operators' => [
    '/',
    '/'
  ]
}, 'term' );

1
3
$VAR1 = bless( {
  '' => '3',
  'val' => '3'
}, 'factor' );

3
2*(3+4)
$VAR1 = bless( {
  'operands' => [
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' ),
    bless( {
      'operands' => [
        bless( {
          '' => '3',
          'val' => '3'
        }, 'factor' ),
        bless( {
          '' => '4',
          'val' => '4'
        }, 'factor' )
      ],
      '' => '3+4',
      'operators' => [
        '+'
      ]
    }, 'expr' )
  ],
  '' => '2*(3+4)',
  'operators' => [
    '*'
  ]
}, 'term' );

14
\end{verbatim}


\subsection{Reciclando una {\tt Regexp::Grammar}}
\label{subsection:recicla}

\parrafo{Ejecución}

El siguiente programa \verb|calculator.pl|
recibe como entrada una expresión en infijo.

La ejecución consta de dos bucles.
En la primera parte se inyecta a la jerarquía de
clases de los AST generados para las expresiones en infijo
una semántica que permite 
evaluar la expresión:
\begin{verbatim}
    58  require EvalCalc;
    59
    60  test_calc(
    61    'Evaluating infix arithmetic expressions (CTRL-D to end in unix) ',
    62    sub { print &Data::Dumper::Dumper(shift()) },
    63  );
\end{verbatim}
En esta primera parte mostraremos además el AST
construido para la expresión infija de entrada.
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
8-4-2
$VAR1 = bless( {
  'operands' => [
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '8', 'val' => '8' }, 'factor' )
                  ],
                  '' => '8'
                }, 'factorial' )
              ],
              '' => '8'
            }, 'power' )
          ],
          '' => '8'
        }, 'uneg' )
      ],
      '' => '8'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '4', 'val' => '4' }, 'factor' )
                  ],
                  '' => '4'
                }, 'factorial' )
              ],
              '' => '4'
            }, 'power' )
          ],
          '' => '4'
        }, 'uneg' )
      ],
      '' => '4'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '2', 'val' => '2' }, 'factor' )
                  ],
                  '' => '2'
                }, 'factorial' )
              ],
              '' => '2'
            }, 'power' )
          ],
          '' => '2'
        }, 'uneg' )
      ],
      '' => '2'
    }, 'term' )
  ],
  '' => '8-4-2',
  'operators' => [
    '-',
    '-'
  ]
}, 'expr' );
2
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
<span class='lightblue'>8-4-2</span>
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '8', 'val' =&gt; '8' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '8'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '8'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '8'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '8'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '4', 'val' =&gt; '4' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '4'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '4'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '4'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '4'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '2', 'val' =&gt; '2' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '2'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '2'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '2'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '2'
    }, <span class='lightblue'>'term'</span> )
  ],
  '' =&gt; '8-4-2',
  <span class='red'>'operators' =&gt; [
    '-',
    '-'
  ]</span>
}, <span class='lightblue'>'expr'</span> );
2
</pre>
\end{rawhtml}
%}}}
Observamos que la asociatividad es la correcta.
El \verb|2| final es el resultado de la evaluación de
\verb|8-4-2|.

La estructura del árbol se corresponde con la de la gramática:
\begin{verbatim}
 8  my $rbb = do {
 9      use Regexp::Grammars;
10
11      qr{
12        \A<expr>\z
13
14        <objrule: expr>      <[operands=term]> ** <[operators=addop]>
15
16        <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
17
18        <objrule: uneg>      <[operators=minus]>* <[operands=power]>
19
20        <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
21
22        <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
23
24        <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
25                           | \( <MATCH=expr> \)
26
27        <token: addop>        [+-]
28
29        <token: mulop>        [*/]
30
31        <token: powerop>      \*\*|\^
32
33        <token: minus>        - <MATCH=(?{ 'NEG' })>
34
35      }x;
36  };
\end{verbatim}

Ahora, en una segunda parte sobreescribimos los métodos
\verb|sem| que describen la semántica para producir una traducción
de infijo a postfijo:
\begin{verbatim}
 66  require PostfixCalc;
 67  test_calc('Translating expressions to postfix (CTRL-D to end in unix) ');
\end{verbatim}
Ahora al proporcionar la entrada \verb|6--3!| obtenemos:
\begin{verbatim}
Translating expressions to postfix (CTRL-D to end in unix)
6--3!
6 3 ! ~ -
\end{verbatim}
Aquí \verb|~| es el operador de negación unaria y \verb|!| es el operador
factorial.

\parrafo{Estructura de la aplicación}

Estos son los ficheros que integran la aplicación:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ tree
.
|-- EvalCalc.pm            # Soporte para la evaluación de la expresión: sem
|-- Operator.pm            # Soporte a las clases nodo: recorridos
|-- PostfixCalc.pm         # Soporte para la traducción a postfijo: sem
`-- calculator.pl          # programa principal
\end{verbatim}

\parrafo{Programa principal}

En el programa principal definimos la gramática
y escribimos una subrutina \verb|test_calc|
que realiza el parsing. 

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
 1    #!/usr/bin/env perl5.10.1
 2    use strict;
 3    use warnings;
 4    use 5.010;
 5    use Data::Dumper;
 6    $Data::Dumper::Indent = 1;
 7  
 8    my $rbb = do {
 9        use Regexp::Grammars;
10  
11        qr{
12          \A<expr>\z
13  
14          <objrule: expr>      <[operands=term]> ** <[operators=addop]>
15  
16          <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
17  
18          <objrule: uneg>      <[operators=minus]>* <[operands=power]>
19  
20          <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
21  
22          <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
23  
24          <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
25                             | \( <MATCH=expr> \)
26  
27          <token: addop>        [+-]
28  
29          <token: mulop>        [*/]
30  
31          <token: powerop>      \*\*|\^
32  
33          <token: minus>        - <MATCH=(?{ 'NEG' })>
34  
35        }x;
36    };
37  
38    sub test_calc {
39      my $prompt = shift;
40      my $handler = shift;
41  
42      say $prompt;
43      while (my $input = <>) {
44          chomp($input);
45          if ($input =~ m{$rbb}) {
46              my $tree = $/{expr};
47              $handler->($tree) if $handler;
48  
49              say $tree->ceval;
50  
51          }
52          else {
53              say("does not match");
54          }
55      }
56    }
57  
58    require EvalCalc;
59  
60    test_calc(
61      'Evaluating infix arithmetic expressions (CTRL-D to end in unix) ',
62      sub { print &Data::Dumper::Dumper(shift()) },
63    );
64  
65  
66    require PostfixCalc;
67    test_calc('Translating expressions to postfix (CTRL-D to end in unix) ');
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/env perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use </span><span class="synConstant">5.010</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">use </span>Data::Dumper;
<span class="synLinenum">    6</span>   <span class="synIdentifier">$</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Indent</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rbb</span> = <span class="synStatement">do</span> {
<span class="synLinenum">    9</span>       <span class="synStatement">use </span>Regexp::Grammars;
<span class="synLinenum">   10</span> 
<span class="synLinenum">   11</span>       <span class="synConstant">qr{</span>
<span class="synLinenum">   12</span> <span class="synConstant">        </span><span class="synSpecial">\A</span><span class="synConstant">&lt;expr&gt;</span><span class="synSpecial">\z</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">        &lt;objrule: expr&gt;      &lt;</span><span class="synSpecial">[operands=term]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=addop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span> <span class="synConstant">        &lt;objrule: term&gt;      &lt;</span><span class="synSpecial">[operands=uneg]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=mulop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span> <span class="synConstant">        &lt;objrule: uneg&gt;      &lt;</span><span class="synSpecial">[operators=minus]</span><span class="synConstant">&gt;</span><span class="synSpecial">*</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operands=power]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">        &lt;objrule: power&gt;     &lt;</span><span class="synSpecial">[operands=factorial]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=powerop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synConstant">        &lt;objrule: factorial&gt; &lt;</span><span class="synSpecial">[operands=factor]</span><span class="synConstant">&gt;  &lt;</span><span class="synSpecial">[operators=(!)]</span><span class="synConstant">&gt;</span><span class="synSpecial">*</span>
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span> <span class="synConstant">        &lt;objrule: factor&gt;    &lt;val=</span><span class="synSpecial">([+-]?\d+(?:\.\d*)?)</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   25</span> <span class="synConstant">                           | </span><span class="synSpecial">\(</span><span class="synConstant"> &lt;MATCH=expr&gt; </span><span class="synSpecial">\)</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">        &lt;token: addop&gt;        </span><span class="synSpecial">[+-]</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        &lt;token: mulop&gt;        </span><span class="synSpecial">[*/]</span>
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span> <span class="synConstant">        &lt;token: powerop&gt;      </span><span class="synSpecial">\*\*</span><span class="synConstant">|</span><span class="synSpecial">\^</span>
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span> <span class="synConstant">        &lt;token: minus&gt;        - &lt;MATCH=</span><span class="synSpecial">(?</span><span class="synConstant">{ 'NEG' </span>}<span class="synSpecial">)</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span> <span class="synConstant">      }x</span>;
<span class="synLinenum">   36</span>   };
<span class="synLinenum">   37</span> 
<span class="synLinenum">   38</span>   <span class="synStatement">sub </span><span class="synIdentifier">test_calc </span>{
<span class="synLinenum">   39</span>     <span class="synStatement">my</span> <span class="synIdentifier">$prompt</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   40</span>     <span class="synStatement">my</span> <span class="synIdentifier">$handler</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>     <span class="synStatement">say</span> <span class="synIdentifier">$prompt</span>;
<span class="synLinenum">   43</span>     <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;) {
<span class="synLinenum">   44</span>         <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   45</span>         <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rbb</span><span class="synStatement">}</span>) {
<span class="synLinenum">   46</span>             <span class="synStatement">my</span> <span class="synIdentifier">$tree</span> = <span class="synIdentifier">$/</span>{expr};
<span class="synLinenum">   47</span>             <span class="synIdentifier">$handler</span>-&gt;(<span class="synIdentifier">$tree</span>) <span class="synStatement">if</span> <span class="synIdentifier">$handler</span>;
<span class="synLinenum">   48</span> 
<span class="synLinenum">   49</span>             <span class="synStatement">say</span> <span class="synIdentifier">$tree-&gt;ceval</span>;
<span class="synLinenum">   50</span> 
<span class="synLinenum">   51</span>         }
<span class="synLinenum">   52</span>         <span class="synStatement">else</span> {
<span class="synLinenum">   53</span>             <span class="synStatement">say</span>(<span class="synConstant">&quot;does not match&quot;</span>);
<span class="synLinenum">   54</span>         }
<span class="synLinenum">   55</span>     }
<span class="synLinenum">   56</span>   }
<span class="synLinenum">   57</span> 
<span class="synLinenum">   58</span>   <span class="synStatement">require</span> EvalCalc;
<span class="synLinenum">   59</span> 
<span class="synLinenum">   60</span>   test_calc(
<span class="synLinenum">   61</span>     <span class="synConstant">'Evaluating infix arithmetic expressions (CTRL-D to end in unix) '</span>,
<span class="synLinenum">   62</span>     <span class="synStatement">sub </span>{ <span class="synStatement">print</span> <span class="synIdentifier">&amp;</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Dumper</span>(<span class="synStatement">shift</span>()) },
<span class="synLinenum">   63</span>   );
<span class="synLinenum">   64</span> 
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>   <span class="synStatement">require</span> PostfixCalc;
<span class="synLinenum">   67</span>   test_calc(<span class="synConstant">'Translating expressions to postfix (CTRL-D to end in unix) '</span>);
</pre>

\end{rawhtml}
%}}}

Los nodos del AST poseen un método \verb|ceval| que se encarga de 
realizar la traducción del nodo.

\parrafo{Las Clases de nodos del AST}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n Operator.pm
   1  #   Class hierarchy diagram:
   2  #  $ vgg -t 'Operator(LeftBinaryOp(expr,term),RightBinaryOp(power),PreUnaryOp(uneg),PostUnaryOp(factorial))'
   3  #                           +--------+
   4  #                           |Operator|
   5  #                           +--------+
   6  #          .---------------.----^--------.-------------.
   7  #    +------------+ +-------------+ +----------+ +-----------+
   8  #    |LeftBinaryOp| |RightBinaryOp| |PreUnaryOp| |PostUnaryOp|
   9  #    +------------+ +-------------+ +----------+ +-----------+
  10  #      .---^--.        |              |               |
  11  #    +----+ +----+  +-----+         +----+       +---------+
  12  #    |expr| |term|  |power|         |uneg|       |factorial|
  13  #    +----+ +----+  +-----+         +----+       +---------+
  14  #
  15  #
  16  # NOTE: package "factor" actually implements numbers and is
  17  #       outside this hierarchy
  18  #
  19  package Operator;
  20  use strict;
  21  use Carp;
  22
  23  sub Operands {
  24    my $self = shift;
  25
  26    return () unless exists $self->{operands};
  27    return @{$self->{operands}};
  28  }
  29
  30  sub Operators {
  31    my $self = shift;
  32
  33    return () unless exists $self->{operators};
  34    return @{$self->{operators}};
  35  }
  36
  37  sub sem {
  38    confess "not defined sem";
  39  }
  40
  41  sub make_sem {
  42    my $class = shift;
  43    my %semdesc = @_;
  44
  45    for my $class (keys %semdesc) {
  46      my %sem = %{$semdesc{$class}};
  47
  48      # Install 'sem' method in $class
  49      no strict 'refs';
  50      no warnings 'redefine';
  51      *{$class."::sem"} = sub {
  52        my ($self, $op) = @_;
  53        $sem{$op}
  54      };
  55    }
  56  }
  57
  58  package LeftBinaryOp;
  59  use base qw{Operator};
  60
  61  sub ceval {
  62    my $self = shift;
  63
  64    # recursively evaluate the children first
  65    my @operands = map { $_->ceval } $self->Operands;
  66
  67    # then combine them
  68    my $s = shift @operands;
  69    for ($self->Operators) {
  70      $s = $self->sem($_)->($s, shift @operands);
  71    }
  72    return $s;
  73  }
  74
  75  package RightBinaryOp;
  76  use base qw{Operator};
  77
  78  sub ceval {
  79    my $self = shift;
  80
  81    # recursively evaluate the children first
  82    my @operands = map { $_->ceval } $self->Operands;
  83
  84    # then combine them
  85    my $s = pop @operands;
  86    for (reverse $self->Operators) {
  87      $s = $self->sem($_)->(pop @operands, $s);
  88    }
  89    return $s;
  90  }
  91
  92  package PreUnaryOp;
  93  use base qw{Operator};
  94
  95  sub ceval {
  96    my $self = shift;
  97
  98    # recursively evaluate the children first
  99    my @operands = map { $_->ceval } $self->Operands;
 100
 101    # then combine them
 102    my $s = shift @operands;
 103    for (reverse $self->Operators) {
 104      $s = $self->sem($_)->($s);
 105    }
 106    return $s;
 107  }
 108
 109  package PostUnaryOp;
 110  use base qw{Operator};
 111
 112  sub ceval {
 113    my $self = shift;
 114
 115    # recursively evaluate the children first
 116    my @operands = map { $_->ceval } $self->Operands;
 117
 118    # then combine them
 119    my $s = shift @operands;
 120    for ($self->Operators) {
 121      $s = $self->sem($_)->($s);
 122    }
 123    return $s;
 124  }
 125
 126  package term;
 127  use base qw{LeftBinaryOp};
 128
 129  package expr;
 130  use base qw{LeftBinaryOp};
 131
 132  package power;
 133  use base qw{RightBinaryOp};
 134
 135  package uneg;
 136  use base qw{PreUnaryOp};
 137
 138  package factorial;
 139  use base qw{PostUnaryOp};
 140
 141  package factor;
 142
 143  sub ceval {
 144    my $self = shift;
 145
 146    return $self->{val};
 147  }
 148
 149  1;
\end{verbatim}

\parrafo{Definiendo {\tt sem} para la evaluación de la expresión}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n EvalCalc.pm
 1  package EvalCalc;
 2  use strict;
 3  use Carp;
 4
 5  use Operator;
 6
 7  ####
 8  sub f {
 9    $_[0]>1?$_[0]*f($_[0]-1):1;
10  }
11
12  sub fac {
13    my $n = shift;
14
15    confess "Not valid number" unless $n =~ /^\d+$/;
16    f($n);
17  };
18
19  my $s = sub { shift() **  shift() };
20
21  Operator->make_sem(
22     expr => {
23        '+' => sub { shift()  +  shift() },
24        '-' => sub { shift()  -  shift() },
25     },
26     term => {
27       '*' => sub { shift()  *  shift() },
28       '/' => sub { shift()  /  shift() },
29     },
30     power => {
31        '^'  => $s,
32        '**' => $s,
33     },
34     uneg => {
35        'NEG' => sub { -shift() },
36     },
37     factorial => {
38        '!' => \&fac,
39     },
40  );
41
42  1;
\end{verbatim}

\parrafo{Definiendo {\tt sem} para la traducción a postfijo}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n PostfixCalc.pm
 1  package PostfixCalc;
 2  use strict;
 3
 4  use Operator;
 5
 6  # Modify semantics: now translate to postfix
 7  my $powers = sub { shift().' '.shift().' **' };
 8
 9  Operator->make_sem(
10     expr => {
11        '+' => sub { shift().' '.shift().' +'  },
12        '-' => sub { shift().' '.shift().' -' },
13      },
14      term => {
15        '*' => sub { shift().' '.shift().' *'  },
16        '/' => sub { shift().' '.shift().' /' },
17      },
18      power => {
19        '^'  => $powers,
20        '**' => $powers,
21      },
22      uneg => {
23         # use ~ for unary minus
24        'NEG' => sub { shift().' ~' },
25      },
26      factorial => {
27        '!' => sub { shift().' !'},
28      },
29  );
30
31  1;
\end{verbatim}


\begin{exercise}
\begin{itemize}
\item Explique el significado de la primera línea del programa principal
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n calculator.pl
   1  #!/usr/bin/env perl5.10.1
\end{verbatim}
\item Explique el significado de \verb|$handler| en \verb|test_calc|:
\begin{verbatim}
  42  sub test_calc {
  43    my $prompt = shift;
  44    my $handler = shift;
  45
  46    say $prompt;
  47    while (my $input = <>) {
  48        chomp($input);
  49        if ($input =~ m{$rbb}) {
  50            my $tree = $/{expr};
  51            $handler->($tree) if $handler;
  52
  53            say $tree->ceval;
  54
  55        }
  56        else {
  57            say("does not match");
  58        }
  59    }
  60  }
\end{verbatim}

\item Aisle las funciones relacionadas con la creación de semántica
como \verb|make_sem|, \verb|fac| y las llamadas a \verb|make_sem|
en un módulo \verb|Calculator::Semantics| aparte. 

\item Añada un traductor de infijo a prefijo al código presentado 
en esta sección. Una expresión como
\verb|2*3+4|  se traducirá como \verb|+ * 2 3 4|
\end{itemize}
\end{exercise}
  
\subsectionpractica{Calculadora con {\tt Regexp::Grammars}}

\begin{itemize}
\item Reforme la estructura del ejemplo para que tenga una jerarquía
de desarrollo de acuerdo a los estándares de Perl. Use \perldoc{h2xs} 
o bien \cpan{Module::Starter}. Use el espacio de nombres \verb|Calculator|.
Mueva el módulo \verb|Operator| a \verb|Calculator::Operator|.
Lea el capítulo \lhp{Modulos}{170} de los apuntes de LHP.

\item Defina el conjunto de pruebas que deberá pasar su traductor.
Añádalas como pruebas \verb|TODO|. Cuando la funcionalidad 
a comprobar esté operativa cambie su estatus.

\item Añada variables y la expresión de asignación:

\begin{verbatim}
b = a = 4*2
\end{verbatim}
que será traducida a postfijo como:

\begin{verbatim}
4 2 * a = b =
\end{verbatim}
El operador de asignación es asociativo a derechas.
El valor devuelto por una expresión de asignación es el valor asignado.

Use un hash para implantar la relación nombre-valor
en el caso de la evaluación

\item Introduzca la expresión bloque:

\begin{verbatim}
c = { a = 4; b = 2*a }
\end{verbatim}

Los bloques son listas entre llaves de expresiones separadas por punto y coma.
El valor retornado por una expresión bloque es el último evaluado 
en el bloque.

El símbolo de arranque de la gramática (esto es, el patrón regular
contra el que hay que casar) será la expresión bloque.

\item Introduzca las expresiones de comparación \verb|<|, \verb|>|, \verb|<=|, \verb|>=|, \verb|==| y \verb|!=|
con la prioridad adecuada. Tenga en cuenta que una expresión como:
\begin{verbatim}
a = b+2 > c*4
\end{verbatim}
deberá entenderse como
\begin{verbatim}
a = ((b+2) > (c*4))
\end{verbatim}
Esto es, se traducirá como:
\begin{verbatim}
b 2 + c 4 * > a =
\end{verbatim}

\item Introduzca la expresión \verb|if ... then ... else|. La parte del \verb|else|
será opcional:
\begin{verbatim}
c = if a > 0 then { a = a -1; 2*a } else { b + 2 };
d = if a > 0 then { a = b -1; 2*b }; 
\end{verbatim}
un \verb|else| casa con el \verb|if| mas cercano. 
La sentencia:
\begin{verbatim}
if (a > 0) then if (b > 0) then {5} else {6}
\end{verbatim}
se interpreta como:
\begin{verbatim}
if (a > 0) then (if (b > 0) then {5} else {6})
\end{verbatim}
y no como:
\begin{verbatim}
if (a > 0) then (if (b > 0) then {5}) else {6}
\end{verbatim}
Se traducirá como:
\begin{verbatim}
        a
        0
        >
        jz endif124
        b
        0
        >
        jz else125
        5
        j endif126
:else125
        6
:endif124
:endif125
        ...

\end{verbatim}
\item Escriba un intérprete de la máquina orientada a pila definida en los apartados anteriores.
El código generado debería poder ejecutarse correctamente en el intérprete.
\end{itemize}
%%% TEXEXPAND: END FILE ./chapter2/perlregexp.tex

\chapter{Análisis Sintáctico Descendente en JavaScript}

  %
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_descendente/calculadora.tex
\section{Ejemplo Simple de Intérprete: Una Calculadora}
\begin{enumerate}
\item 
\htmladdnormallink{How to write a simple interpreter in JavaScript}{http://www.codeproject.com/Articles/345888/How-to-write-a-simple-interpreter-in-JavaScript}
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter_descendente/calculadora.tex

  %
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_descendente/topdownprecedence.tex
\section{Análisis Top Down Usando Precedencia de Operadores}
\begin{enumerate}
\item Véase el libro \cite{wilson2008beautiful} \htmladdnormallink{Beautiful Code: Leading Programmers Explain How They Think}{http://books.google.es/books?id=gJrmszNHQV4C}, Capítulo 9.
\item 
\htmladdnormallink{Top Down Operator Precedence}{http://javascript.crockford.com/tdop/tdop.html} por Douglas Crockford
\item 
\htmladdnormallink{Top Down Operator Precedence demo}{http://javascript.crockford.com/tdop/} por Douglas Crockford
\item 
\htmladdnormallink{jslint}{http://www.jslint.com/lint.html}
\end{enumerate}

\subsection{Gramática de JavaScript}
\begin{enumerate}
\item 
\htmladdnormallink{Especificación de JavaScript}{http://hepunx.rl.ac.uk/~adye/jsspec11/jsrefspe.htm} 1997
\item 
\htmladdnormallink{NQLL(1) grammar (Not Quite LL(1)) for JavaScrip}{http://hepunx.rl.ac.uk/~adye/jsspec11/llr.htm} 1997
\item 
\htmladdnormallink{Postscript con la especificación de JavaScript}{http://hepunx.rl.ac.uk/~adye/jsspec11/jsspec.ps.gz} 1997
\item 
Mozilla \htmladdnormallink{JavaScript Language Resources}{https://developer.mozilla.org/en-US/docs/JavaScript/Language_Resources?redirectlocale=en-US&redirectslug=JavaScript_Language_Resources}
\item 
\htmladdnormallink{JavaScript 1.4 LR(1) Grammar}{http://www-archive.mozilla.org/js/language/grammar14.html} 1999.
\item 
\htmladdnormallink{Apple JavaScript Core Specifications}{http://www.opensource.apple.com/source/JavaScriptCore/}

\item 
\htmladdnormallink{Creating a JavaScript Parser}{http://cjihrig.com/blog/creating-a-javascript-parser/} Una implementación de ECAMScript 5.1 usando Jison 
disponible 
en GitHub
 en
\htmladdnormallink{https://github.com/cjihrig/jsparser}{https://github.com/cjihrig/jsparser}.
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter_descendente/topdownprecedence.tex

\chapter{Análisis Sintáctico Descendente en Perl}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_descendente/descendente_en_perl.tex
\label{chapter:introcomp}
Este capítulo tiene por objeto darte una visión global de la 
estructura de un compilador e introducirte en las técnicas básicas
de la construcción de compiladores usando Perl.

Puesto que no todos los alumnos que se incorporan en este capítulo 
han leído los anteriores y no necesariamente conocen Perl, en la sección
\ref{section:lasbases}
comenzamos haciendo un breve repaso a como construir un módulo en Perl.
Si quieres tener un conocimiento mas profundo
lee el capítulo sobre módulos en 
\eref{chapter:modulos}. 

La sección 
\ref{section:fases}
describe las fases en las que -al menos conceptualmente-
se divide un compilador.
A continuación la sección 
\ref{section:analisislexico}
presenta la primera de dichas fases, el análisis léxico.
En la sección 
\ref{section:conceptos}
repasamos conceptos de análisis sintáctico 
que deberían ser familiares a cualquiera que haya 
seguido un curso en teoría de autómatas 
y lenguajes formales.
Antes de comenzar a traducir es conveniente tener un \emph{esquema} o estrategia
de traducción para cada constructo sintáctico. 
La sección 
\ref{section:esquemas}
introduce el concepto de esquema de traducción.
La fase de análisis sintáctico consiste en la construcción
del \emph{árbol de análisis} a partir de la \emph{secuencia de unidades léxicas}. 
Existen diversas estrategias para resolver esta fase.
En la sección 
\ref{section:predictivo}
introducimos la que posiblemente sea la mas sencilla de todas: el análisis
descendente predictivo recursivo.
En la sección
\ref{section:recursionizquierda}
abordamos una estrategia para transformar ciertas
gramáticas para las que dicho método no funciona.

Un analizador sintáctico implícitamente construye 
el árbol de análisis concreto. En muchas ocasiones
resulta mas rentable trabajar con una forma simplificada
(\emph{abstracta}) del árbol que contiene la misma información 
que aquél. La sección 
\ref{section:aat} trata de la construcción de los 
árboles de análisis abstractos.

\section{Las Bases}
\label{section:lasbases}
Puesto que no todos los alumnos que están interesados en esta sección
tienen conocimientos previos de Perl, en esta sección
comenzamos haciendo un breve repaso a como construir un módulo en Perl
y al mismo tiempo repasamos las características usadas del lenguaje.
Si quieres tener un conocimiento mas profundo
de como construir un módulo, lee el capítulo
sobre módulos en \eref{chapter:modulos}.

\parrafo{Version}

El comportamiento de Perl puede variar ligeramente si la versión que tenemos instalada es 
antigua. Para ver la versión de Perl podemos hacer.

\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506$ perl -v

This is perl, v5.8.4 built for i386-linux-thread-multi

Copyright 1987-2004, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using `man perl' or `perldoc perl'.  If you have access to the
Internet, point your browser at http://www.perl.com/, the Perl Home Page.
\end{verbatim}

\parrafo{h2xs}

En primer lugar, construimos la estructura para nuestro proyecto de mini-lenguaje.
La mejor forma de comenzar a escribir un módulo es usando la herramienta Perl
\verb|h2xs|. Supongamos que queremos construir un módulo \verb|PL::Tutu|. 
Los nombres de los módulos siguen un esquema de identificadores separados
por una pareja de \verb|:|. Para saber más sobre el esquema de nombres 
de los módulos y la forma en la que estos se asigna a ficheros del sistema 
operativo, lea la sección 
sobre introducción a los módulos \eref{section:introamodulos}.

\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506$ h2xs -XA -n PL::Tutu
Defaulting to backwards compatibility with perl 5.8.4
If you intend this module to be compatible with earlier perl versions, please
specify a minimum perl version with the -b option.

Writing PL-Tutu/lib/PL/Tutu.pm
Writing PL-Tutu/Makefile.PL
Writing PL-Tutu/README
Writing PL-Tutu/t/PL-Tutu.t
Writing PL-Tutu/Changes
Writing PL-Tutu/MANIFEST
\end{verbatim}
La herramienta \verb|h2xs| fué concebida para ayudar en la transformación
de ficheros de cabecera de C en código Perl. La opción 
\verb|-X| hace que se omita la  creación de subrutinas externas (\verb|XS|)
La opción \verb|-A| implica que el módulo no hará uso del \verb|AutoLoader|.
La opción \verb|-n| proporciona el nombre del módulo.
La llamada a \verb|h2xs| crea la siguiente estructura de directorios y ficheros:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506$ tree
.
`-- PL-Tutu
    |-- Changes
    |-- MANIFEST
    |-- Makefile.PL
    |-- README
    |-- lib
    |   `-- PL
    |       `-- Tutu.pm
    `-- t
        `-- PL-Tutu.t

4 directories, 6 files
\end{verbatim}

\parrafo{Generación del Makefile}

Después de esto tenemos un módulo ''funcional'' que no hace nada.
Lo podríamos instalar como si lo hubieramos descargado desde CPAN
(Véase \eref{section:instalacionamano}).

Después cambiamos al directorio \verb|PL-Tutu/| y hacemos \verb|perl Makefile.PL|.
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506$ cd PL-Tutu/
lhp@nereida:~/Lperl/src/topdown/PL0506/PL-Tutu$ perl Makefile.PL
Checking if your kit is complete...
Looks good
Writing Makefile for PL::Tutu
\end{verbatim}
Esto crea el fichero \verb|Makefile| necesario para actualizar 
nuestra aplicación. Para saber más sobre \verb|perl Makefile.PL|
lea \eref{section:construccion}.

\parrafo{Documentación}

Pasamos ahora a trabajar en el módulo. Primero escribimos
la parte relativa a la documentación. Para ello 
editamos \verb|Tutu.pm|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/PL-Tutu/lib/PL$ pwd
/home/lhp/Lperl/src/topdown/PL0506/PL-Tutu/lib/PL
lhp@nereida:~/Lperl/src/topdown/PL0506/PL-Tutu/lib/PL$ ls -l
total 4
-rw-r--r--  1 lhp lhp 2343 2005-09-28 11:16 Tutu.pm
\end{verbatim}
y al final del mismo insertamos la documentación. Para saber más sobre el 
lenguajes de marcas de Perl (\emph{pod} por \emph{plain old documentation})
lea \eref{section:pod}. En este caso escribimos:
\begin{verbatim}
1;
__END__

=head1 NOMBRE

PL::Tutu - Compilador para un lenguaje sencillo denominado
          "Tutu" que usaremos en la asignatura PL

=head1 SINOPSIS

  use PL::Tutu;
  
  La subrutina PL::Tutu::compiler recibe dos argumentos: el 
  nombre del fichero de entrada (fuente.tutu) y el nombre del fichero de
  salida (código ensamblador para una especie de P-máquina).

=head1 DESCRIPCIÓN

Este módulo tiene dos objetivos: aprender a hacer un pequeño compilador
y aprender a programar modularmente en Perl, usando un buen número
de los recursos que este lenguaje ofrece.

El siguiente es un ejemplo de código fuente tutu:
 
  int a,b; 
  string c;
  a = 2+3;
  b = 3*4; 
  c = "hola"; 
  p c; 
  c = "mundo"; 
  p c; 
  p 9+2; 
  p a+1; 
  p b+1

supuesto que está guardado en el fichero "test2.tutu", podemos 
escribir un programa Perl "main.pl" para compilarlo: 

    $ cat main.pl
    #!/usr/bin/perl -w -I..
    #use PL::Tutu;
    use Tutu;

    PL::Tutu::compiler(@ARGV);

al ejecutar "main.pl":

    $ ./main.pl test2.tutu test2.ok

obtenemos el fichero "test2.ok" con el ensamblador: 
    $ cat test2.ok
    DATA holamundo
    PUSH 5
    PUSHADDR 0
    STORE_INT
    PUSH 12
    PUSHADDR 1
    STORE_INT
    PUSHSTR 0 4
    PUSHADDR 2
    STORE_STRING
    LOAD_STRING 2
    PRINT_STR
    PUSHSTR 4 5
    PUSHADDR 2
    STORE_STRING
    LOAD_STRING 2
    PRINT_STR
    PUSH 11
    PRINT_INT
    LOAD 0
    INC
    PRINT_INT
    LOAD 1
    INC
    PRINT_INT

Para mas información consulta la página de la asignatura.
¡Buena suerte!

=head2 EXPORT

No se exporta nada al espacio de nombres del cliente.


=head1 AUTOR

Casiano Rodríguez León, E<lt>casiano@ull.esE<gt>

=head1 VÉASE TAMBIÉN

L<perl>.

=cut
\end{verbatim}
La documentación puede ser mostrada utilizando el comando \verb|perldoc|.

\begin{latexonly}
Veáse la figura \ref{fig:perldoc}.

\begin{figure}[htb]
%\centerline{\epsfig{file=figures/perldoc.eps, height=14cm}}
\caption{El resultado de usar {\tt perldoc Tutu}}
\label{fig:perldoc}
\end{figure}
\end{latexonly}

\begin{rawhtml}
<center>
<img src="perldoc.jpg">
<p>
El resultado de usar <tt>perldoc Tutu</tt>
</center>
<hr>
<p>
\end{rawhtml}


La forma en la que se controla la calidad de un módulo es mediante 
el desarrollo de pruebas. Las pruebas son programas perl que se sitúan en el directorio
\verb|t/| y que tienen la extensión \verb|.t|. Para ejecutar las pruebas
se escribe:

\begin{verbatim}
make test
\end{verbatim}

Vease la sección \eref{subsection:laspruebas} de los apuntes de LHP para ams detalles.

\subsectionrepaso{Las Bases}
\label{repaso:lasbases}

Responda a las siguientes preguntas:

\begin{enumerate}
\item
¿Cómo puedo saber con que versión de Perl estoy trabajando?
\item
Cuando el intérprete Perl encuentra una sentencia 
\begin{verbatim}
use Este::Modulo;
\end{verbatim}
¿Donde busca el fichero \verb|Modulo.pm|?
\item
¿Con que opción debo usar Perl para ejecutar un programa en la línea de comandos?
\item
¿Cómo se llama el programa que me permite crear el esqueleto 
para una distribución de un módulo? ¿Con que opciones debo llamarlo?
\item
Cuando se crea con \verb|h2xs| el esqueleto para \verb|PL::Tutu|:
¿En que subdirectorio queda el fichero conteniendo el esqueleto del
módulo creado \verb|Tutu.pm|?
\item
¿Cuál es la función de \verb|MANIFEST|?
\item
¿Qué es \verb|Makefile.PL|? ¿Cuál es su función?
¿Que significa la frase \emph{looks good}?
\item
¿Con que comando se crea el \verb|Makefile| para trabajar en la plataforma
actual?
\item
¿Cómo se puede ver la documentación de un módulo?
\item 
¿Que hacen los siguientes comandos \verb|pod|?
Repase 
\eref{subsection:comandodeparrafo}
si tiene dudas.
\begin{verbatim}
=head1 cabecera 
=head2 cabecera 
=item texto
=over N
=back
=cut
=pod
=for X
=begin X
=end X
\end{verbatim}
\item
¿Que secuencia de comandos conocida como
\emph{mantra de instalación} es necesario ejecutar para 
instalar un módulo?
\item
¿Cual es la función del directorio \verb|t|?
\item
¿Que tipo deben tener los programas de prueba para que
\verb|make test| los reconozca como pruebas?

\end{enumerate}

\subsectionpractica{Crear y documentar el Módulo {\tt PL::Tutu}}
\label{practica:creacionydocdemodulo}
Reproduzca los pasos explicados en la sección 
\ref{section:lasbases} creando el módulo {\tt PL::Tutu}
y documentándolo. 
\begin{itemize}
\item
Compruebe que la documentación se muestra correctamente
\item
Compruebe que puede crear una distribución haciendo \verb|make dist|
\item
Compruebe que la distribución creada puede instalarse correctamente
siguiendo las instrucciones en 
\eref{section:instalacionamano}.
\end{itemize}

\section{Las Fases de un Compilador}
\label{section:fases}
La estructura del compilador, descompuesto en fases, queda explicitada 
en el código de la subrutina \verb|compile|:

\parrafo{Esquema del Compilador}

\begin{verbatim}
 1 package PL::Tutu;
 2 use 5.008004;   # Versión mínima de Perl 5.84
 3 use strict;     # Variables deben ser declaradas, etc.
 4 use warnings;   # Enviar warnings
 5 use IO::File;
 6 use Carp;       # Provee alternativas a "die" and "warn" 
 7 
 8 require Exporter;
 9 
10 our @ISA = qw(Exporter);   # Heredamos los métodos de la clase Exporter
11 our @EXPORT = qw( compile compile_from_file); # Estas funciones serán exportadas
12 our $VERSION = '0.01';     # Variable que define la versión del módulo
13 
14 our %symbol_table;         # La tabla de símbolos $symbol_table{x} contiene
15 our $data;                 # la información asociada con el objeto 'x'
16 our $target;               # tipo, dirección, etc.
17 our @tokens;               # La lista de terminales
18 our $errorflag;
19 our ($lookahead, $value);  # Token actual y su atributo
20 our $tree;                 # referencia al objeto que contiene
21 our $global_address;       # el árbol sintáctico
22 
23 # Lexical analyzer 
24 package Lexical::Analysis;
25 sub scanner {
26 }
27 
28 package Syntax::Analysis;
29 sub parser {
30 }
31 
32 package Machine::Independent::Optimization;
33 sub Optimize {
34 }
35 
36 package Code::Generation;
37 sub code_generator {
38 }
39   
40 package Peephole::Optimization;
41 sub transform {
42 }
43 
44 package PL::Tutu;
45 sub compile {
46   my ($input) = @_; # Observe el contexto!
47   local %symbol_table = (); 
48   local $data = ""; # Contiene todas las cadenas en el programa fuente
49   local $target = ""; # target code
50   local @tokens =();    # "local" salva el valor que serÃ¡ recuperado al finalizar
51   local $errorflag = 0; # el Ã¡mbito
52   local ($lookahead, $value) = ();
53   local $tree = undef; # Referencia al Ã¡rbol sintÃctico abstracto 
54   local $global_address = 0; # Usado para guardar la Ãltima direcciÃn ocupada
55   
56   ########lexical analysis
57   &Lexical::Analysis::scanner($input);
58 
59   ########syntax (and semantic) analysis
60   $tree = &Syntax::Analysis::parser;
61 
62   ########machine independent optimizations
63   &Machine::Independent::Optimization::Optimize;
64 
65   ########code generation
66   &Code::Generation::code_generator;
67 
68   ########peephole optimization
69   &Peephole::Optimization::transform($target);
70 
71   return \$target; #retornamos una referencia a $target
72 }
73 
74 sub compile_from_file {
75   my ($input_name, $output_name) = @_; # Nombres de ficheros
76   my $fhi;                             # de entrada y de salida
77   my $targetref;
78   
79   if (defined($input_name) and (-r $input_name)) {
80     $fhi = IO::File->new("< $input_name");
81   }
82   else { $fhi = 'STDIN'; }
83   my $input;
84   { # leer todo el fichero
85     local $/ = undef; # localizamos para evitar efectos laterales
86     $input = <$fhi>;
87   }
88   $targetref = compile($input);
89 
90   ########code output
91   my $fh = defined($output_name)? IO::File->new("> $output_name") : 'STDOUT';
92   $fh->print($$targetref);
93   $fh->close;
94   1; # El Ãºltimo valor evaluado es el valor retornado
95 }
96 
97 1;  # El 1 indica que la fase de carga termina con éxito
98 # Sigue la documentación ...
\end{verbatim}

\parrafo{Añadiendo Ejecutables}

Vamos a añadir un \emph{script} que use el módulo
\verb|PL::Tutu| para asi poder ejecutar nuestro compilador:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/$ mkdir scripts
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cd scripts/
\end{verbatim}
A continuación creamos dos versiones del compilador \verb|tutu.pl|
y \verb|tutu| y un programa de prueba \verb|test01.tutu|:

\begin{verbatim}
... # despues de crear los ficheros
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ ls
test01.tutu  tutu  tutu.pl
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ cat tutu.pl
#!/usr/bin/perl -w -I../lib/
use PL::Tutu;

PL::Tutu::compile_from_file(@ARGV);
\end{verbatim}

\parrafo{Búsqueda de Librerías en Tiempo de Desarrollo}

El programa \verb|tutu| ilustra otra forma de conseguir que el intérprete
Perl busque por la librería que está siendo desarrollada, mediante el
uso de \verb|use lib|:

\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ cat tutu
#!/usr/bin/perl -w
use lib ('../lib');
use PL::Tutu;

&PL::Tutu::compile_from_file(@ARGV);
\end{verbatim}

Una tercera forma (la que recomiendo):
\begin{verbatim}
$ export PERL5LIB=~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/lib
$ perl -MPL::Tutu -e 'PL::Tutu::compile_from_file("test01.tutu")'
\end{verbatim}

\parrafo{Añadiendo Los Ejecutables al {\tt MANIFEST}}

Ahora tenemos que añadir estos ficheros en \verb|MANIFEST| para que formen
parte del proyecto. En vez de eso lo que podemos hacer es crear un fichero
\verb|MANIFEST.SKIP|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cat MANIFEST.SKIP
\.o$
^\.cvsignore$
/\.cvsignore$
\.cvsignore$
CVS/[^/]+$
\.svn\b
^Makefile$
/Makefile$
^blib/
\.swp$
\.bak$
\.pdf$
\.ps$
\.sal$
pm_to_blib
\.pdf$
\.tar.gz$
\.tgz$
^META.yml$
\end{verbatim}
Ahora al hacer
\begin{verbatim}
make manifest
\end{verbatim}
se crea un fichero \verb|MANIFEST| que contiene los caminos 
relativos de todos los ficheros
en la jerarquía cuyos nombres no casan con una de las expresiones
regulares en \verb|MANIFEST.SKIP|.

Para saber mas sobre \verb|MANIFEST| léa 
\eref{subsection:MANIFEST}.

No recomiendo el uso de \verb|MANIFEST.SKIP|. Prefiero un control manual de los
ficheros que integran la aplicacion.

\parrafo{Indicando al Sistema de Distribución que los Ficheros son Ejecutables}

Es necesario indicarle a Perl que los ficheros añadidos son ejecutables.
Esto se hace mediante el par\'ametro \verb|EXE_FILES| de \verb|WriteMakefile|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cat Makefile.PL
use 5.008004;
use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    NAME              => 'PL::Tutu',
    VERSION_FROM      => 'lib/PL/Tutu.pm', # finds $VERSION
    PREREQ_PM         => {}, # e.g., Module::Name => 1.1
    EXE_FILES         => [ 'scripts/tutu.pl', 'scripts/tutu' ],
    ($] >= 5.005 ?     ## Add these new keywords supported since 5.005
      (ABSTRACT_FROM  => 'lib/PL/Tutu.pm', # retrieve abstract from module
       AUTHOR         => 'Lenguajes y Herramientas de Programacion <lhp@>') : ()),
);
\end{verbatim}
Perl utilizará esa información durante la fase de instalación
para instalar los ejecutables en el \emph{path} de búsqueda.

\parrafo{Reconstrucci\'on de la aplicación}
%\parrafo{Reconstrucci\'on de la aplicaciÃ³n}

A continuación hay que rehacer el \verb|Makefile|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ perl Makefile.PL
Writing Makefile for PL::Tutu
\end{verbatim}

Para crear una versión funcional hacemos \verb|make|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make
cp scripts/tutu blib/script/tutu
/usr/bin/perl "-MExtUtils::MY" -e "MY->fixin(shift)" blib/script/tutu
cp scripts/tutu.pl blib/script/tutu.pl
/usr/bin/perl "-MExtUtils::MY" -e "MY->fixin(shift)" blib/script/tutu.pl
Manifying blib/man3/PL::Tutu.3pm
\end{verbatim}

Para crear el \verb|MANIFEST| hacemos \verb|make manifest|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make manifest
/usr/bin/perl "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
Added to MANIFEST: scripts/tutu
\end{verbatim}

Comprobemos que el test de prueba generado automáticamente por
\verb|h2xs| se pasa correctamente:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make test
PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
t/PL-Tutu....ok
All tests successful.
Files=1, Tests=1,  0 wallclock secs ( 0.08 cusr +  0.00 csys =  0.08 CPU)
\end{verbatim}

\parrafo{Ejecución}

Podemos ahora ejecutar los guiones:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ cd scripts/
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ ls -l
total 12
-rw-r--r--  1 lhp lhp 15 2005-09-29 12:56 test01.tutu
-rwxr-xr-x  1 lhp lhp 92 2005-09-29 13:29 tutu
-rwxr-xr-x  1 lhp lhp 80 2005-09-29 12:58 tutu.pl
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ tutu test01.tutu test01.sal
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ ls -l
total 12
-rw-r--r--  1 lhp lhp  0 2005-09-29 13:53 test01.sal
-rw-r--r--  1 lhp lhp 15 2005-09-29 12:56 test01.tutu
-rwxr-xr-x  1 lhp lhp 92 2005-09-29 13:29 tutu
-rwxr-xr-x  1 lhp lhp 80 2005-09-29 12:58 tutu.pl
\end{verbatim}

Veamos los contenidos del programa fuente \verb|test01.tutu|
que usaremos para hacer una prueba:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu/scripts$ cat test01.tutu
int a,b;
a = 4
\end{verbatim}

\parrafo{Construcción de una Distribución}

Para hacer una distribución instalable hacemos \verb|make dist|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ make dist
rm -rf PL-Tutu-0.01
/usr/bin/perl "-MExtUtils::Manifest=manicopy,maniread" \
        -e "manicopy(maniread(),'PL-Tutu-0.01', 'best');"
mkdir PL-Tutu-0.01
mkdir PL-Tutu-0.01/scripts
mkdir PL-Tutu-0.01/lib
mkdir PL-Tutu-0.01/lib/PL
mkdir PL-Tutu-0.01/t
tar cvf PL-Tutu-0.01.tar PL-Tutu-0.01
PL-Tutu-0.01/
PL-Tutu-0.01/scripts/
PL-Tutu-0.01/scripts/test01.tutu
PL-Tutu-0.01/scripts/tutu
PL-Tutu-0.01/scripts/tutu.pl
PL-Tutu-0.01/META.yml
PL-Tutu-0.01/Changes
PL-Tutu-0.01/MANIFEST
PL-Tutu-0.01/lib/
PL-Tutu-0.01/lib/PL/
PL-Tutu-0.01/lib/PL/Tutu.pm
PL-Tutu-0.01/MANIFEST.SKIP
PL-Tutu-0.01/t/
PL-Tutu-0.01/t/PL-Tutu.t
PL-Tutu-0.01/Makefile.PL
PL-Tutu-0.01/README
rm -rf PL-Tutu-0.01
gzip --best PL-Tutu-0.01.tar
\end{verbatim}
Después de esto tenemos en el directorio de trabajo
el fichero  \verb|PL-Tutu-0.01.tar.gz| con la distribución:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/02fases/PL-Tutu$ ls -ltr
total 72
drwxr-xr-x  2 lhp lhp  4096 2005-09-29 12:01 t
-rw-r--r--  1 lhp lhp  1196 2005-09-29 12:01 README
drwxr-xr-x  3 lhp lhp  4096 2005-09-29 12:01 lib
-rw-r--r--  1 lhp lhp   152 2005-09-29 12:01 Changes
-rw-r--r--  1 lhp lhp   167 2005-09-29 13:23 MANIFEST.SKIP
-rw-r--r--  1 lhp lhp     0 2005-09-29 13:23 pm_to_blib
drwxr-xr-x  6 lhp lhp  4096 2005-09-29 13:23 blib
-rw-r--r--  1 lhp lhp   113 2005-09-29 13:23 MANIFEST.bak
drwxr-xr-x  2 lhp lhp  4096 2005-09-29 13:29 scripts
-rw-r--r--  1 lhp lhp   616 2005-09-29 13:49 Makefile.PL
-rw-r--r--  1 lhp lhp 20509 2005-09-29 13:51 Makefile
-rw-r--r--  1 lhp lhp  3654 2005-09-29 16:34 PL-Tutu-0.01.tar.gz
-rw-r--r--  1 lhp lhp   298 2005-09-29 16:34 META.yml
-rw-r--r--  1 lhp lhp   205 2005-09-29 16:34 MANIFEST
\end{verbatim}

\subsectionrepaso{Fases de un Compilador}
\label{repaso:fases}
\begin{enumerate}
\item
¿Que hace la declaración 
\verb|package nombredepaquete|?
\item
¿Cual es la función de la declaración \verb|use 5.008004|?
\item
¿Cuál es la función de la declaración \verb|use strict|?
\item
¿Cuál es la función de la declaración \verb|use warnings|?
\item
¿Que diferencia hay entre \verb|use warnings| y \verb|perl -w|?
\item
¿Cuál es la función de la declaración \verb|use Carp|?
¿Que diferencia hay entre \verb|croak| y \verb|die|?
\item
¿Qué hace la declaración \verb|our|? 
\item
¿Qué es una variable de paquete?
\item
¿Cuál es el nombre completo de una variable de paquete?
\item
¿En que variable especial se situán los argumentos pasados a una subrutina?
\item
¿Que hace la declaración \verb|local|?
\item
¿Cómo se declara una variable léxica?
\item
¿Cuál es el prefijo para los hashes?
\item
¿Cómo se hace referencia a un elemento de un hash \verb|%h| de clave \verb|k|?
\item
¿Cómo se hace referencia a un elemento de un array \verb|@a| de índice \verb|7|?
¿Que lugar ocupa ese elemento en el array?
\item
¿Cuál es el significado de \verb|undef|?
\item
¿Cuál es el prefijo para las subrutinas?
\item
Señale la diferencia entre
\begin{verbatim}
my ($input) = @_;
\end{verbatim}
y
\begin{verbatim}
my $input = @_;
\end{verbatim}
Repase 
\eref{section:referencias}.
\item
Toda referencia es un escalar: ¿Cierto o falso?
\item
Toda referencia es verdadera ¿Cierto o falso?
\item
¿Que diferencia hay entre \verb|use| y \verb|require|?
¿La línea \verb|require Exporter| se ejecuta en tiempo de compilación 
o en tiempo de ejecución?
\item
¿Que hace la línea 
\verb|our @ISA = qw(Exporter)|?. Repáse 
\eref{section:herencia}.

\item
¿Que hace la línea
\verb|our @EXPORT = qw( compile compile_from_file)|?
\item
¿Que diferencia hay entre \verb|EXPORT| y \verb|EXPORT_OK|?.
Repase \eref{section:exportacion}.
\item
¿Que hace la línea
\verb|our $VERSION = '0.01|?
\item
¿Que valor tiene una variable no incializada? ¿y si es un array?
\item
¿Que es un array anónimo? 
(Repase \eref{section:anonimos})
\item
¿Que es un hash anónimo?
(Repase \eref{section:anonimos})
\item
¿Que hace el operador \verb|=>|?.
Repase 
\eref{subsection:flechagrande}.
\item
¿En que lugar se dejan los ejecutables asociados con una distribución?
¿Cómo se informa a Perl que se trata de ejecutables?
\item
¿Cuál es la función de \verb|MANIFEST.SKIP|?
¿Que hace \verb|make manifest|?
\item
¿Que hace la opción \verb|-I|?
¿Porqué la primera línea de \verb|tutu.pl| comienza:\\
\verb|#!/usr/bin/perl -w -I../lib/|?
\item
¿Cómo puedo saber lo que hace el módulo \verb|lib|?
¿Qué hace la línea \verb|use lib ('../lib')| en el programa \verb|tutu|?
\item
¿Que contiene la variable \verb|PERL5LIB|?
\item
¿Cómo se crea una distribución?
\item
¿Que devuelve \verb|-r $input_name| en la línea 79?
Repase 
\eref{subsection:filetests}.
\item
¿Cuál es la función de la variable mágica \verb|$/|?
¿Que se leerá en la línea 86
\begin{verbatim}
85   local $/ = undef;
86   my $input = <$fhi>;
\end{verbatim}
\item
¿Que hace el operador \verb|\|? ¿Que relación hay entre \verb|\$target| y \verb|$target|?.
\item
Si \verb|$targetref| es una referencia a la cadena que va a contener el
código objeto, ¿Cómo se denota a la cadena referenciada por \verb|$targetref|?
Explique la línea 
\begin{verbatim}
92   $fh->print($$targetref);
\end{verbatim}
\end{enumerate}

\subsectionpractica{Fases de un Compilador}
\label{practica:fases}
Reproduzca los pasos explicados en la sección
\ref{section:fases} extendiendo el módulo \verb|PL::Tutu|
con las funciones de compilación y los correspondientes
guiones de compilación.

Mejore el script \verb|tutu| para que acepte opciones desde la línea de comandos.
Debera soportar al menos las siguientes opciones:
\begin{itemize}
\item \verb|--usage| 

Muestra de forma concisa el comando de uso
\item \verb|--help| 

Un resumen de cada opción disponible

\item \verb|--version|

Muestra la versión del programa

\item \verb|--man| 

Muestra la documentación
\end{itemize}

Use para ello el módulo \tei{Getopt::Long}.
Este módulo provee la función \tei{GetOptions} la cual
se atiene a los estándares de especificación
de opciones en la línea de comandos POSIX y GNU.
Esta función soporta el uso del guión doble \verb|--|
y el simple así como admitir el prefijo mas corto
que deshace la ambiguedad entre las diferentes opciones.

La llamada a 
\tei{GetOptions} analiza la l\'inea de comandos en
\verb|ARGV|
inicializa la variable asociada de manera adecuada. Retorna un valor verdadero
si la l\'inea de comandos pudo ser procesada con
En caso contrario emitir\'a
un mensaje de error y devolver\'a falso. Recuerde hacer
\verb|perldoc Getopt::Long|
para obtener informaci\'on mas detallada

El siguiente ejemplo ilustra el uso de \verb|Getopt::Long|.
Se hace uso también del módulo (función \tei{pod2usage} en la línea 63)
\verb|Pod::Usage| el cual permite la documentación empotrada.

\begin{verbatim}
nereida:~/LEyapp/examples> cat -n treereg
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Parse::Eyapp::YATW;
 4  use Parse::Eyapp::Node;
 5  use Parse::Eyapp::Treeregexp;
 6  use Carp;
 7  use Getopt::Long;
 8  use Pod::Usage;
 9
10  my $infile;
11  my $outfile;
12  my $packagename;
13  my $prefix = '';
14  my $syntax = 1;
15  my $numbers = 1;
16  my $severity = 0; # 0 = Don't  check arity. 1 = Check arity. 
17                    # 2 = Check arity and give a warning 3 = ... and croak
18  GetOptions(
19    'in=s'       => \$infile,
20    'out=s'      => \$outfile,
21    'mod=s'      => \$packagename,
22    'prefix=s'   => \$prefix,
23    'severity=i' => \$severity,
24    'syntax!'    => \$syntax,
25    'numbers!'   => \$numbers,
26    'version'    => \&version,
27    'usage'      => \&usage,
28    'help'       => \&man,
29  ) or croak usage();
30
31  # If an argument remains is the inputfile 
32  ($infile) = @ARGV unless defined($infile);
33  die usage() unless defined($infile);
34
35  my $treeparser = Parse::Eyapp::Treeregexp->new(
36                      INFILE   => $infile,
37                      OUTFILE  => $outfile,
38                      PACKAGE  => $packagename,
39                      PREFIX   => $prefix,
40                      SYNTAX   => $syntax,
41                      NUMBERS  => $numbers,
42                      SEVERITY => $severity
43                    );
44
45  $treeparser->generate();
46
47  sub version {
48    print "Version $Parse::Eyapp::Treeregexp::VERSION\n";
49    exit;
50  }
51
52  sub usage {
53    print <<"END_ERR";
54  Supply the name of a file containing a tree grammar (.trg)
55  Usage is:
56  treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
57          [-p treeprefix] [-o outputfile] -i filename[.trg]
58  END_ERR
59    exit;
60  }
61
62  sub man {
63    pod2usage(
64      -exitval => 1,
65      -verbose => 2
66    );
67  }
68  __END__
69
70  =head1 SYNOPSIS
71
72    treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
73            [-p treeprefix] [-o outputfile] -i filename[.trg]
74    treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
75            [-p treeprefix] [-o outputfile] filename[.trg]
76 ... # Follows the documentation bla, bla, bla
\end{verbatim}

Ahora podemos ejecutar el guión de múltiples formas:
\begin{verbatim}
nereida:~/LEyapp/examples> treereg -nos -nonu -se 3 -m Tutu Foldonly1.trg 
nereida:~/LEyapp/examples> treereg -nos -nonu -s 3 -m Tutu Foldonly1.trg  
Option s is ambiguous (severity, syntax)
nereida:~/LEyapp/examples> treereg -nos -bla -nonu -m Tutu Foldonly1.trg
Unknown option: bla
nereida:~/LEyapp/examples> 
\end{verbatim}

La librería estandar de Perl incluye el módulo \verb|Getopt::Long|. 
No es el caso de \verb|Pod::Usage|. Descarge el módulo e instalelo
en un directorio local en el que tenga permisos. Si es preciso repase las secciones
\eref{section:instalacionamano} y \eref{section:CPAN}  de los apuntes de 
introducción a Perl.

\section{Análisis Léxico}
\label{section:analisislexico}
Comenzaremos con la parte mas sencilla del compilador: el analizador 
léxico. 
Habitualmente el término ``análisis léxico'' se refiere al tratamiento
de la entrada que produce como salida
la lista de \emph{tokens}. Un \emph{token} hace alusión 
a las unidades mas simples que tiene significado. Habitualmente 
un \emph{token} o lexema queda descrito por una expresión regular.
Léxico viene del griego \emph{lexis}, que significa ``palabra''.
Perl es, sobra decirlo, una herramienta eficaz para encontrar en que lugar 
de la cadena se produce un emparejamiento.
Sin embargo, en el análisis léxico, el problema es encontrar la subcadena
a partir de la última posición en la que se produjo un emparejamiento
y que es aceptada por una de las expresiones
regulares que definen los lexemas del lenguaje dado.

La estructura general del analizador léxico consiste en un bucle en el que se va
recorriendo la entrada, buscando por un emparejamiento con 
uno de los patrones/lexemas especificados y, cuando se encuentra, se retorna esa información
al analziador sintáctico. Como no tenemos escrito el analaizador sintáctico 
simplemente iremos añadiéndo los terminales al final de una lista.

Una iteración del bucle tiene la forma de una secuencia de condicionales
en las que se va comprobando si la entrada casa con cada una de las expresiones regulares
que definen los terminales del lenguaje. Las condiciones tienen un aspecto similar a este:

\begin{verbatim}
     ...
     if (m{\G\s*(\d+)}gc) {
       push @tokens, 'NUM', $1;
     } 
     elsif (m{\G\s*([a-z_]\w*)\b}igc) {
       push @tokens, 'ID', $1;
     } 
     ...
\end{verbatim}

Una expresión como \verb#m{\G\s*(\d+)}gc# es una expresión regular.
Es conveniente que en este punto repase la introducción a las 
expresiones regulares en 
\eref{section:introregexp}. 

\parrafo{El Operador de Binding}

Nótese que, puesto que no se menciona sobre que variable
se hace el \emph{binding} (no se usa ninguno de los operadores
de \emph{binding} \verb|=~| y \verb|!~|): se entiende que 
es sobre la variable por defecto \verb|$_| sobre la que se 
hace el matching.

\parrafo{Casando a partir del Ültimo Emparejamiento}

El ancla \verb|\G| 
casa con el punto en la cadena en el que terminó el último emparejamiento.

La expresión regular describiendo el patrón de interés se pone
entre paréntesis para usar la estrategia de los paréntesis
con memoria (véanse 
\ref{section:variablesmagicasereg}
y
\ref{section:dolar1}). 

Las opciones \verb|c| y \verb|g| son especialmente 
útiles para la construcción del analizador.

\parrafo{La opción {\tt g}}

\emph{
Como lo usamos en un contexto escalar, la opción {\tt g} itera sobre la cadena, devolviendo
cierto cada vez que casa, y falso cuando deja de casar.} 
Se puede averiguar la posicion del emparejamiento
utilizando la función \verb|pos|. 
(véase la sección \ref{section:g} para mas información sobre la opción \verb|g|).

\parrafo{La opción {\tt c}}

La opción
\verb|/c| afecta a las operaciones de emparejamiento
con \verb|/g| en un contexto escalar. Normalmente, \emph{cuando una
búsqueda global escalar tiene lugar y no ocurre casamiento,
la posici\'on de comienzo de búsqueda es reestablecida} al comienzo de
la cadena.
La opci\'on \verb|/c| hace que la posici\'on inicial de 
emparejamiento permanezca donde la dej\'o el \'ultimo
emparejamiento con \'exito y no se vaya al comienzo. 
Al combinar esto con el ancla \verb|\G|, la cuál
casa con el final del último emparejamiento, obtenemos que la combinación

\begin{verbatim}
                            m{\G\s*(...)}gc 
\end{verbatim}

logra el efecto deseado: Si la primera expresión regular
en la cadena \verb|elsif| fracasa, la posición de búsqueda no es inicializada
de nuevo gracias a la opción \verb|c| y el ancla \verb|\G| sigue recordando
donde terminó el ultimo casamiento.

\parrafo{La opción {\tt i}}


Por último, la opción \verb|i| permite ignorar el tipo de letra (mayúsculas 
o minúsculas).

Repase la sección
\ref{section:opciones}
para ver algunas de las opciones mas usadas.

\parrafo{Código del Analizador Léxico}

Este es el código completo de la subrutina \verb|scanner| que se encarga
del análisis léxico:

\begin{verbatim}
 1 package Lexical::Analysis;
 2 sub scanner {
 3   local $_ = shift;
 4   { # Con el redo del final hacemos un bucle "infinito"
 5     if (m{\G\s*(\d+)}gc) {
 6       push @tokens, 'NUM', $1;
 7     } 
 8     elsif (m{\G\s*int\b}igc) {
 9       push @tokens, 'INT', 'INT';
10     } 
11     elsif (m{\G\s*string\b}igc) {
12       push @tokens, 'STRING', 'STRING';
13     } 
14     elsif (m{\G\s*p\b}igc) {
15       push @tokens, 'P', 'P'; # P para imprimir
16     } 
17     elsif (m{\G\s*([a-z_]\w*)\b}igc) {
18       push @tokens, 'ID', $1;
19     } 
20     elsif (m{\G\s*\"([^"]*)\"}igc) {
21       push @tokens, 'STR', $1;
22     } 
23     elsif (m{\G\s*([+*()=;,])}gc) {
24       push @tokens, 'PUN', $1;
25     }
26     elsif (m{\G\s*(\S)}gc) { # Hay un caracter "no blanco"
27       Error::fatal "Caracter invalido: $1\n";
28     }
29     else {
30       last;
31     }
32     redo;
33   }
34 }
\end{verbatim}

\parrafo{Relación de corutina con el Analizador Sintáctico}

Si decidieramos establecer una relación de corutina con el analizador léxico los 
condicionales se pueden programar siguiendo secuencias con esta estructura:

\begin{verbatim}
      return ('INT', 'INT') if (m{\G\s*int\b}igc);
\end{verbatim}
     
\parrafo{Manejo de Errores}

Para completar el analizador solo quedan declarar 
las variables usadas y las subrutinas de manejo de errores:

\begin{verbatim}
######## global scope variables
our @tokens = ();
our $errorflag = 0;

package Error;

sub error($) {
  my $msg = shift;
  if (!$errorflag) {
    warn "Error: $msg\n";
    $errorflag = 1;
  }
}

sub fatal($) {
  my $msg = shift;
  die "Error: $msg\n";
}
\end{verbatim}

El uso de \verb|our| es necesario porque hemos 
declarado al comienzo del módulo \verb|use strict|.
El pragma {\tt use strict} le indica al compilador Perl 
que debe considerar como obligatorias un conjunto de reglas de
buen estilo de programación. Entre otras restricciones, el uso del
pragma implica que
todas las variables (no-mágicas) 
deben ser declaradas explícitamente (uso de \verb|my|, \verb|our|, etc.)
La declaración \verb|our| se describe en \eref{subsection:our}.

\subsectionejercicio{La opción {\tt g}}

Explique cada una de las líneas que siguen:
\begin{verbatim}
$ perl -wde 0
main::(-e:1):   0
  DB<1> $x = "ababab"
  DB<2> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 2
  DB<3> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 4
  DB<4> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 6
  DB<5> print "falso" unless $x =~ m{b}g
falso
\end{verbatim}

\subsectionejercicio{Opciones {\tt g} y {\tt c} en Expresiones Regulares}

Explique cada una de las conductas que siguen
\begin{itemize}
\item
¿Porqué en la línea 18 se casa con la primera \verb|b|?
\begin{verbatim}
  DB<5> $x = "bbabab"
  DB<6> $x =~ m{a}g; print "match= ".$&." pos = ".pos($x)
match= a pos = 3
  DB<7> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 4
  DB<8> $x =~ m{c}g; print "match= ".$&." pos = ".pos($x)
Use of uninitialized value in concatenation (.) 
  DB<18> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 1
\end{verbatim}

\item
¿Porqué en la línea 27 se casa con la última \verb|b|?
\begin{verbatim}
  DB<23> $x = "bbabab"
  DB<24> $x =~ m{a}g; print "match= ".$&." pos = ".pos($x)
match= a pos = 3
  DB<25> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 4
  DB<26> $x =~ m{c}gc
  DB<27> $x =~ m{b}g; print "match= ".$&." pos = ".pos($x)
match= b pos = 6
\end{verbatim}

\item
¿Porqué en la línea 5 se produce casamiento y en la línea 8 no?
\begin{verbatim}
  DB<3> $x = "bcbabab"
  DB<4> $x =~ m{b}gc; print "match= ".$&." pos = ".pos($x)
match= b pos = 1
  DB<5> $x =~ m{a}gc; print "match= ".$&." pos = ".pos($x)
match= a pos = 4

  DB<6> $x = "bcbabab"
  DB<7> $x =~ m{b}gc; print "match= ".$&." pos = ".pos($x)
match= b pos = 1
  DB<8> $x =~ m{\Ga}gc; print "match= ".$&." pos = ".pos($x)
Use of uninitialized value in concatenation 
match=  pos = 1
\end{verbatim}
\end{itemize}

\subsectionejercicio{El orden de las expresiones regulares}
¿Que ocurriría en la subrutina \verb|scanner| si el código en las líneas
17-19 que reconoce los identificadores se adelanta a la línea 8? 
¿Que ocurriría con el reconocimiento de las palabras reservadas como
\verb|INT|? ¿Seguiría funcionando correctamente 
el analizador?

\subsectionejercicio{Regexp para cadenas}
En la rutina \verb|scanner|. ¿Es legal que una cadena correspondiente
al terminal \verb|STR| contenga retornos de carro entre las comillas dobles?

\subsectionejercicio{El {\tt or} es vago}
Explique el resultado de la siguiente sesión con el depurador:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL/Lexical$ perl -de 0
  DB<1> 'bb' =~ m{b|bb}; print $&
  b
  DB<2> 'bb' =~ m{bb|b}; print $&
  bb
\end{verbatim}
Perl convierte la expresión regular en un NFA. A diferencia de lo 
que ocurre en otras herramientas, el NFA no es convertido en un DFA.
El NFA es entonces simulado. ¿Que está ocurriendo en la simulación? 


\subsectionpractica{Números de Línea, Errores, Cadenas y Comentarios}
\label{practica:lineasyerrores}
Extienda el analizador léxico para que:
\begin{itemize}
\item
Reescriba la expresión regular para las cadenas de manera que acepte comillas dobles 
escapadas \verb|\"| en el interior de una cadena.
Por ejemplo en \verb|"esta \"palabra\" va entre comillas"|.

Analice esta solución ¿Es correcta?:
\begin{verbatim}
 DB<1> $stringre = qr{"(\\.|[^\\"])*"}
 DB<2> print $& if '"esta \"palabra\" va entre comillas"' =~ $stringre
 "esta \"palabra\" va entre comillas"
\end{verbatim}

\item Consuma comentarios a la Perl: 
cualesquiera caracteres después de una almohadilla hasta el final 
de la línea (\verb|# ...|).
\item
Consuma comentarios no anidados a la \emph{C} (\verb|/* ... */|.).
Repase las secciones sobre expresiones regulares no ``greedy'' (p. ej. sección
\ref{section:nogreedy}) y la sección \ref{section:x}.
Recuerde que, en una expresión regular, 
la opción \verb|/s| hace que el punto \verb|'.'| empareje con un 
retorno de carro \verb|\n|.  Esto es, el punto ``casa'' con cualquier carácter.

Observe el siguiente ejemplo:
\begin{verbatim}
pl@nereida:~/src/perl/testing$ cat -n ccomments.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  sub showmatches {
 5   my ($x, $re) = @_;
 6
 7    for (my $i = 0; $x =~ /$re/gsx; $i++) {
 8      print "matching $i: $1\n";
 9      $i++;
10    }
11  }
12
13  my $x = <<'EOC';
14  if (x) {
15    /* a comment */ return x + 1; /* another comment */
16  }
17  else {
18    return x + 2; /* a last comment */
19  }
20  EOC
21
22  print "\n************************\n";
23
24  my $greedy = q{ (
25           /\*  # Abrir comentario
26           .*   # Consumir caracteres (greedy)
27           \*/  # Cerrar comentario
28           )
29  };
30  print "Greedy:\n";
31  showmatches($x, $greedy);
32
33  print "\n************************\n";
34
35  my $lazy = q{ (
36           /\*  # Abrir comentario
37           .*?  # Consumir caracteres (lazy)
38           \*/  # Cerrar comentario
39           )
40  };
41  print "Lazy:\n";
42  showmatches($x, $lazy);
\end{verbatim}
Cuando se ejecuta produce:
\begin{verbatim}
pl@nereida:~/src/perl/testing$ ccomments.pl

************************
Greedy:
matching 0: /* a comment */ return x + 1; /* another comment */
}
else {
  return x + 2; /* a last comment */

************************
Lazy:
matching 0: /* a comment */
matching 2: /* another comment */
matching 4: /* a last comment */
\end{verbatim}

Explique la conducta.

%Muestre un ejemplo en el que no funcione la expresión regular: 
%
%\begin{verbatim}
% $program =~ m{
%   /\*  # Abrir comentario
%   .*   # Consumir caracteres
%   \*/  # Cerrar comentario
%}gsx
%\end{verbatim}

\item
Números en punto flotante (como \verb|-1.32e-04| o \verb|.91|).
El siguiente ejemplo intenta ayudarle en la búsqueda de la solución:
\begin{verbatim}
lhp@nereida:~$ perl -de 0
  DB<1> print "Si" if  ('.5' =~ m{\d+})
Si
  DB<2> print "Si" if  ('.5' =~ m{^\d+})

  DB<3> print "Si" if  '0.7' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}
Si
  DB<4> print "Si" if  '.7' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}

  DB<5> print "Si" if  '1e2' =~ m{^\d+(\.\d+)?(e[+-]?\d+)?$}
Si
  DB<6> print "Si " while  'ababa' =~ m{a}g
Si Si Si
  DB<7> print "@a" if @a = 'ababa' =~ m{(a)}g
a a a
\end{verbatim}
¿Sabría decir porque la respuesta al primer comando del depurador es
\verb|si|?.

\item
Tenga presente el posible conflicto entre los terminales \verb|INT| y \verb|FLOAT|.
Si la entrada contiene \verb|3.5| el terminal debería ser \verb|(FLOAT, '3.5')|
y no \verb|(INT, 3), ('.', '.'), (INT, 5)|.

\item
En esta práctica si lo desea puede instalar y usar 
\htmladdnormallink{el módulo}{http://search.cpan.org/~abigail/Regexp-Common-2.120/lib/Regexp/Common.pm}
\tei{Regexp::Common}
\htmladdnormallink{mantenido por}{http://search.cpan.org/~abigail/} 
\cei{Abigail} el cual provee expresiones regulares para las situaciones mas comunes: números, 
teléfonos, IP, códigos postales, listas, etc. Puede incluso usarlo para encontrar 
soluciones a las cuestiones planteadas en esta práctica:

\begin{verbatim}
nereida:~/doc/casiano/PLBOOK/PLBOOK> perl -MRegexp::Common -e 'print "$RE{num}{int}\n"'
(?:(?:[+-]?)(?:[0123456789]+))
\end{verbatim}
Podemos hacer uso directo del hash \verb|%RE| directamente 
en las expresiones regulares aprovechando que estas interpolan
las variables en su interior:
 \begin{verbatim}
nereida:/tmp> cat -n prueba.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Regexp::Common;
     4
     5  my $input = <>;
     6
     7  print "$&\n" if $input =~ /^$RE{num}{real}$/;
nereida:/tmp> ./prueba.pl
23.45
23.45
nereida:/tmp> ./prueba.pl
jshdf
nereida:/tmp> 
\end{verbatim}
\item
Para mejorar la calidad de los mensajes de error extienda el par \verb|(terminal, valor)|
devuelto por el \verb|scanner| a un par \verb|(terminal, [valor, número de línea ])| cuya
segunda componente es un array anónimo conteniendo 
el valor y el número de línea en el que aparece el terminal.

El siguiente extracto de un analizador léxico muestra como hacerlo:

\begin{verbatim}
sub _Lexer {

  return('', undef) unless defined($input);

  #Skip blanks
      $input=~m{\G((?:
              \s+       # any white space char
          |   \#[^\n]*  # Perl like comments
          )+)}xsgc
    and do {
        my($blanks)=$1;

        #Maybe At EOF
            pos($input) >= length($input)
        and return('', undef);
        $tokenend += $blanks =~ tr/\n//;
    };
    
    $tokenbegin = $tokenend;

      $input=~/\G(and)/gc
    and return($1, [$1, $tokenbegin]);

      $input=~/\G(?:[A-Za-z_][A-Za-z0-9_]*::)*([A-Za-z_][A-Za-z0-9_]*)/gc
    and do {
      return('IDENT', [$1, $tokenbegin]);
    };

    ....................

        $input=~/\G{/gc
    and do {
        my($level,$from,$code);

        $from=pos($input);

        $level=1;
        while($input=~/([{}])/gc) {
                substr($input,pos($input)-1,1) eq '\\' #Quoted
            and next;
                $level += ($1 eq '{' ? 1 : -1)
            or last;
        }
            $level
        and  _SyntaxError("Not closed open curly bracket { at $tokenbegin");
        $code = substr($input,$from,pos($input)-$from-1);
        $tokenend+= $code=~tr/\n//;
        return('CODE', [$code, $tokenbegin]);
    };


    #Always return something
      $input=~/\G(.)/sg
    and do {
      $1 eq "\n" and ++$tokenend;
      return ($1, [$1, $tokenbegin]);
    };
    #At EOF
    return('', undef);
}
\end{verbatim}
El operador \verb|tr| ha sido utilizado para contar los retornos de carro
(descrito en la sección 
\ref{section:tr}). El operador, ademas de reemplazar
devuelve el número de carácteres reeemplazados
o suprimidos: 
\begin{verbatim}
$cuenta = $cielo =~ tr/*/*/; # cuenta el numero de estrellas en cielo
\end{verbatim}
Para aprender soluciones alternativas consulte 
\verb|perldoc -q 'substring'|.
\item
Mejore sus mensajes de error ahora que lleva la cuenta de los números
de línea. En vez de usar las rutinas \verb|error| y \verb|fatal|
introducidas en la sección anterior escriba una sola rutina
que recibe el nivel de severidad del error (parámetro \verb|$level|
en el siguiente ejemplo)
y ejecuta la acción apropiada. El código de \verb|_SyntaxError|
ilustra como hacerlo:
\begin{verbatim}
sub _SyntaxError {
  my($level,$message,$lineno)=@_;

  $message= "*".
      [ 'Warning', 'Error', 'Fatal' ]->[$level].
      "* $message, at ".
      ($lineno < 0 ? "eof" : "line $lineno")." at file $filename\n";

      $level > 1
  and die $message;

  warn $message;

  $level > 0 and ++$nberr;

      $nberr == $max_errors
  and die "*Fatal* Too many errors detected.\n"
}
\end{verbatim}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pruebas para el Analizador Léxico}
\label{section:lexicomodular}
Queremos separar/aislar las diferentes fases
del compilador en diferentes módulos. 

\parrafo{Módulo {\tt PL::Error}}

Para ello comenzamos creando un módulo 
conteniendo las rutinas de tratamiento de errores:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ pwd
/home/lhp/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ cat -n Error.pm
   1  package Error;
   2  use strict;
   3  use warnings;
   4  use Carp;
   5
   6  require Exporter;
   7
   8  our @ISA = qw(Exporter);
   9  our @EXPORT = qw( error fatal);
  10  our $VERSION = '0.01';
  11
  12  sub error {
  13    my $msg = join " ", @_;
  14    if (!$PL::Tutu::errorflag) {
  15      carp("Error: $msg\n");
  16      $PL::Tutu::errorflag = 1;
  17    }
  18  }
  19
  20  sub fatal {
  21    my $msg = join " ", @_;
  22    croak("Error: $msg\n");
  23  }
\end{verbatim}
Observa como accedemos a la variable \verb|errorflag| del paquete 
\verb|PL::Tutu|.
Para usar este módulo desde \verb|PL::Tutu|, tenemos que declarar su uso:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ cat -n Tutu.pm | head -8
     1  package PL::Tutu;
     2
     3  use 5.008004;
     4  use strict;
     5  use warnings;
     6  use IO::File;
     7  use Carp;
     8  use PL::Error;
\end{verbatim}
En la línea 8 hacemos \verb|use PL::Error| y no \verb|use Error| ya que el módulo
lo hemos puesto en el directorio \verb|PL|.
No olvides hacer \verb|make manifest| para actualizar el fichero \verb|MANIFEST|.

\parrafo{Módulo {\tt PL::Lexical::Analysis}}

Supongamos que además de modularizar el grupo de rutinas de tratamiento de errores
queremos hacer lo mismo con la parte del análisis léxico. Parece lógico que el 
fichero lo pongamos en un subdirectorio de \verb|PL/| por lo que cambiamos 
el nombre del módulo a \verb|PL::Lexical::Analysis| quedando la jerarquía de ficheros
asi:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL$ tree
.
|-- Error.pm
|-- Lexical
|   `-- Analysis.pm
`-- Tutu.pm
\end{verbatim}

Por supuesto debemos modificar las correspondientes líneas en \verb|Tutu.pm|:

\begin{verbatim}
 1 package PL::Tutu;
 2 
 3 use 5.008004;
 4 use strict;
 5 use warnings;
 6 use IO::File;
 7 use Carp;
 8 use PL::Error;
 9 use PL::Lexical::Analysis;
10 ...
11 
12 sub compile {
13   my ($input) = @_;
14   local %symbol_table = ();
15   local $data = ""; # Contiene todas las cadenas en el programa fuente
16   local $target = ""; # target code
17   my @tokens = ();
18   local $errorflag = 0;
19   local ($lookahead, $value) = ();
20   local $tree = undef; # abstract syntax tree
21   local $global_address = 0;
22 
23   
24   ########lexical analysis
25   @tokens = &PL::Lexical::Analysis::scanner($input);
26   print "@tokens\n";
27 
28   ...
29 
30   return \$target;
31 }
\end{verbatim}
Observe que ahora \verb|PL::Lexical::Analysis::scanner| devuelve 
ahora la
lista con los terminales y que \verb|@tokens| se ha ocultado en 
\verb|compile| como una variable léxica (línea 17).
En la línea 26 mostramos el contenido de la lista de terminales.

Sigue el listado del módulo conteniendo el analizador léxico.
Obsérve las líneas 6, 16 y 44.
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/lib/PL/Lexical$ cat -n Analysis.pm
     1  # Lexical analyzer
     2  package PL::Lexical::Analysis;
     3  use strict;
     4  use warnings;
     5  use Carp;
     6  use PL::Error;
     7
     8  require Exporter;
     9
    10  our @ISA = qw(Exporter);
    11  our @EXPORT = qw( scanner );
    12  our $VERSION = '0.01';
    13
    14  sub scanner {
    15    local $_ = shift;
    16    my @tokens;
    17
    18    { # Con el redo del final hacemos un bucle "infinito"
    19      if (m{\G\s*(\d+)}gc) {
    20        push @tokens, 'NUM', $1;
    21      }
    ..      ...
    37      elsif (m{\G\s*([+*()=;,])}gc) {
    38        push @tokens, 'PUN', $1;
    39      }
    40      elsif (m{\G\s*(\S)}gc) {
    41        Error::fatal "Caracter invalido: $1\n";
    42      }
    43      else {
    44        return @tokens;
    45      }
    46      redo;
    47    }
    48  }
\end{verbatim}

\parrafo{El Programa Cliente}

Puesto que en el paquete \verb|PL::Lexical::Analysis|
exportamos \verb|scanner| no es necesario llamar la rutina por el nombre 
completo desde \verb|compile|. Podemos simplificar la línea en la
que se llama a \verb|scanner| que queda así:
\begin{verbatim}
########lexical analysis
@tokens = &scanner($input);
print "@tokens\n";
\end{verbatim}
De la misma forma, dado que \verb|PL::Tutu| exporta la función \verb|compile_from_file|,
no es necesario llamarla por su nombre completo desde el guión \verb|tutu|. Reescribimos
la línea de llamada:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/scripts$ cat tutu
#!/usr/bin/perl -w
use lib ('../lib');
use PL::Tutu;

&compile_from_file(@ARGV);
\end{verbatim}

\parrafo{Actualización del MANIFEST}

Como siempre que se añaden o suprimen archivos es necesario actualizar 
\verb|MANIFEST|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ make manifest
/usr/bin/perl "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
Added to MANIFEST: lib/PL/Lexical/Analysis.pm
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ cat -n MANIFEST
     1  Changes
     2  lib/PL/Error.pm
     3  lib/PL/Lexical/Analysis.pm
     4  lib/PL/Tutu.pm
     5  Makefile.PL
     6  MANIFEST
     7  MANIFEST.SKIP
     8  README
     9  scripts/test01.tutu
    10  scripts/tutu
    11  scripts/tutu.pl
    12  t/PL-Tutu.t
\end{verbatim}

\subsection{Comprobando el Analizador Léxico}
\label{subsection:tests}
Queremos comprobar si nuestro código funciona. ¿Cómo hacerlo?.
Lo adecuado es llevar una aproximación sistemática que permita validar
el código. 
%Esa es la función del programa \verb|test.pl| que se generó
%automáticamente con \verb|h2xs|.

\parrafo{Principios Básicos del Desarrollo de Pruebas}

En general, la filosofía aconsejable para realizar un banco
de pruebas de nuestro módulo es la que se articula en la metodología denominada
\cei{Extreme Programming}, descrita en múltiples textos, en concreto en el 
libro de Scott \cite{scott}:
\begin{itemize}
\item
Todas las pruebas deben automatizarse
\item
Todos los fallos que se detecten deberían quedar traducidos en pruebas
\item
La aplicación debería pasar todas las pruebas después de cualquier modificación
importante y también al final del día
\item
El desarrollo de las pruebas debe preceder el desarrollo 
del código
\item
Todos los requerimientos deben ser expresados en forma de pruebas
\end{itemize}

\parrafo{La Jerarquía de Una Aplicación}

Pueden haber algunas diferencias entre el esquema que se describe aqui y su versión de Perl.
Lea detenidamente el capítulo 
\htmladdnormallink{Test Now, test Forever}{http://nereida.deioc.ull.es/~pl/cgi-bin/test_now_test_forever.pdf}
 del libro de Scott \cite{scott} y el libro \cite{perltesting} de Ian Langworth y chromatic.

Si usas una versión de Perl posterior  la 5.8.0, entonces tu versión del programa
\verb|h2xs| 
creará un subdirectorio \verb|/t| en el que guardar los ficheros de prueba
Estos ficheros deberán 
ser programas Perl de prueba con el tipo \verb|.t|. La utilidad
\verb|h2xs| incluso deja un programa de prueba \verb|PL-Tutu.t| en ese directorio.
La jerarquía de ficheros con la que trabajamos actualmente es:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ make veryclean
rm -f blib/script/tutu blib/script/tutu.pl
rm -rf ./blib Makefile.aperl ...
mv Makefile Makefile.old > /dev/null 2>&1
rm -rf blib/lib/auto/PL/Tutu blib/arch/auto/PL/Tutu
rm -rf PL-Tutu-0.01
rm -f  blib/lib/PL/.Tutu.pm.swp ...
rm -f *~ *.orig */*~ */*.orig
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ tree
.
|-- .svn                # use siempre un sistema de control de versiones
|-- Changes             # la historia de cambios
|-- MANIFEST            # lista de ficheros que componen la distribución
|-- MANIFEST.SKIP       # regexps para determinar que ficheros no pertenecen
|-- META.yml            # YML no es XML
|-- Makefile.PL         # generador del Makefle independiente de la plataforma
|-- PL-Tutu-0.01.tar.gz
|-- README              # instrucciones de instalacion
|-- lib
|   `-- PL
|       |-- Error.pm            # rutinas de manejo de errores
|       |-- Lexical
|       |   `-- Analysis.pm     # modulo con el analizador lexico
|       `-- Tutu.pm             # modulo principal
|-- scripts
|   |-- test01.sal   # salida del programa de prueba
|   |-- test01.tutu  # programa de prueba
|   |-- tutu         # compilador
|   `-- tutu.pl      # compilador
`-- t
    `-- 01Lexical.t  # prueba consolidada
\end{verbatim}

\parrafo{Un Ejemplo de Programa de Prueba}

Estos son los contenidos de nuestro primer test:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ cd t
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ ls -l
total 4
-rw-r--r--  1 lhp lhp 767 2005-10-10 11:27 01Lexical.t
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ cat -n 01Lexical.t
 1  # Before `make install' is performed this script should be runnable with
 2  # `make test'. After `make install' it should work as `perl PL-Tutu.t'
 3
 4  #########################
 5
 6  # change 'tests => 1' to 'tests => last_test_to_print';
 7
 8  use Test::More tests => 5;
 9  use Test::Exception;
10
11  BEGIN { use_ok('PL::Lexical::Analysis') };
12  BEGIN { use_ok('PL::Tutu') };
13
14  #########################
15
16  # Insert your test code below, the Test::More module is use()ed here so read
17  # its man page ( perldoc Test::More ) for help writing this test script.
18
19  can_ok('PL::Lexical::Analysis', 'scanner');
20
21  # Test result of call
22  my $a = 'int a,b; string c; c = "hello"; a = 4; b = a +1; p b';
23  my @tokens = scanner($a);
24  my @expected_tokens = qw{
25  INT INT
26  ID a
27  PUN ,
28  ID b
29  PUN ;
30  STRING STRING
31  ID c
32  PUN ;
33  ID c
34  PUN =
35  STR "hello"
36  PUN ;
37  ID a
38  PUN =
39  NUM 4
40  PUN ;
41  ID b
42  PUN =
43  ID a
44  PUN +
45  NUM 1
46  PUN ;
47  P P
48  ID b
49  };
50  is(@tokens, @expected_tokens, "lexical analysis");
51
52  # test a lexically  erroneous program
53  $a = 'int a,b; string c[2]; c = "hello"; a = 4; b = a +1; p b';
54  throws_ok { scanner($a) } qr{Error: Caracter invalido:}, 'erroneous program';
\end{verbatim}

El nombre del fichero de prueba debe cumplir que:
\begin{itemize}
\item
Sea significativo del tipo de prueba
\item
Que los prefijos de los nombres \verb|01|, \verb|02|, \ldots nos garanticen
el orden de ejecución
\end{itemize}

\parrafo{Ejecución de Las Pruebas}

Ahora ejecutamos las pruebas:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu$ make test
PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
t/01Lexical....ok 1/5Possible attempt to separate words with commas at t/01Lexical.t line 49.
t/01Lexical....ok
All tests successful.
Files=1, Tests=5,  0 wallclock secs ( 0.08 cusr +  0.00 csys =  0.08 CPU)
\end{verbatim}
O bien usamos \verb|prove|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ prove -I../lib 01Lexical.t
01Lexical....ok
All tests successful.
Files=1, Tests=2,  0 wallclock secs ( 0.03 cusr +  0.01 csys =  0.04 CPU)
\end{verbatim}
También podemos añadir la opción \verb|verbose| a \verb|prove|:
\begin{verbatim}
lhp@nereida:~/Lperl/src/topdown/PL0506/03lexico/PL-Tutu/t$ prove -v 01Lexical.t
01Lexical....1..5
ok 1 - use PL::Lexical::Analysis;
ok 2 - use PL::Tutu;
ok 3 - PL::Lexical::Analysis->can('scanner')
ok 4 - lexical analysis
ok 5 - erroneous program
ok
All tests successful.
Files=1, Tests=5,  0 wallclock secs ( 0.07 cusr +  0.01 csys =  0.08 CPU)
\end{verbatim}

Repáse 
\eref{subsection:laspruebas} para un mejor conocimiento
de la metodología de pruebas en Perl.

\subsubsection{Versiones anteriores a la 5.8}
En esta sección he usado la versión 5.6.1 de Perl.  
Creeemos un subdirectorio \verb|tutu_src/| y en él un programa de prueba
\verb|pruebalex.pl|:
\begin{verbatim}
$ pwd
/home/lhp/projects/perl/src/tmp/PL/Tutu/tutu_src
$ cat pruebalex.pl
#!/usr/bin/perl -w -I..
#use PL::Tutu;
use Tutu;

my $a = 'int a,b; string c; c = "hello"; a = 4; b = a +1; p b';
Lexical::Analysis::scanner($a);
print "prog = $a\ntokens = @PL::Tutu::tokens\n";
\end{verbatim}
Observa como la opción \verb|-I..| hace que se busque por las librerías en el directorio
padre del actual.
Cuando ejecutamos \verb|pruebalex.pl| obtenemos la lista de terminales:
\begin{verbatim}
$ ./pruebalex.pl
prog = int a,b; string c; c = "hello"; a = 4; b = a +1; p b
tokens = INT INT ID a PUN , ID b PUN ; STRING STRING ID c PUN ; 
ID c PUN = STR hello PUN ; ID a PUN = NUM 4 PUN ; ID b PUN = 
ID a PUN + NUM 1 PUN ; P P ID b
\end{verbatim}
La última línea ha sido partida por razones de legibilidad, pero consituye 
una sóla línea.
Editemos el fichero \verb|test.pl| en el directorio del módulo.
Sus contenidos son como sigue:
\begin{verbatim}
$ cat -n test.pl
 1  # Before `make install' is performed this script should be runnable with
 2  # `make test'. After `make install' it should work as `perl test.pl'
 3
 4  #########################
 5
 6  # change 'tests => 1' to 'tests => last_test_to_print';
 7
 8  use Test;
 9  BEGIN { plan tests => 1 };
10  use PL::Tutu;
11  ok(1); # If we made it this far, we're ok.
12
13  #########################
14
15  # Insert your test code below, the Test module is use()ed here so read
16  # its man page ( perldoc Test ) for help writing this test script.
17
\end{verbatim}
En la línea 9 se establece el número de pruebas a realizar. 
La primera prueba aparece en la línea 11. Puede parecer que no es una prueba,
¡pero lo es!. Si se ha alcanzado la línea 11 es que se pudo cargar
el módulo \verb|PL::Tutu| y eso ¡tiene algún mérito!.

Seguiremos el consejo de la línea 15 y escribiremos nuestra segunda
prueba al final del fichero \verb|test.pl|:
\begin{verbatim}
$ cat -n test.pl | tail -7
16  # its man page ( perldoc Test ) for help writing this test script.
17
18  my $a = 'int a,b; string c; c = "hello"; a = 4; b = a +1; p b';
19  local @PL::Tutu::tokens = ();
20  Lexical::Analysis::scanner($a);
21  ok("@PL::Tutu::tokens" eq
22  'INT INT ID a PUN , ID b PUN ; STRING STRING ID c PUN ; ID c 
     PUN = STR hello PUN ; ID a PUN = NUM 4 PUN ; ID b PUN = 
     ID a PUN + NUM 1 PUN ; P P ID b');

\end{verbatim}
La línea 22 ha sido partida por razones de legibilidad, pero constituye 
una sóla línea.
Ahora podemos ejecutar \verb|make test| y comprobar que las dos
pruebas funcionan:
\begin{verbatim}
$ make test
PERL_DL_NONLAZY=1 /usr/bin/perl -Iblib/arch -Iblib/lib -I/usr/lib/perl/5.6.1 \
                                -I/usr/share/perl/5.6.1 test.pl
1..2
ok 1
ok 2
\end{verbatim}
¿Recordaste cambiar la línea 9 de \verb|test.pl|?
¿Añadiste los nuevos ficheros a la lista en \verb|MANIFEST|?

\subsectionpractica{Pruebas en el Análisis Léxico}
\label{practica:pruebaslexico}
Extienda su compilador para modularizar el analizador léxico
tal y como se explicó en la sección
\ref{section:lexicomodular}.
\begin{enumerate}
\item
Lea  los siguientes documentos
\begin{itemize}
\item
\tei{Test::Tutorial} 
(\htmladdnormallink{Test::Tutorial - A tutorial about writing really basic tests}
{http://search.cpan.org/~nwclark/perl-5.8.8/lib/Test/Tutorial.pod})
por Michael Schwern. 

\item
\htmladdnormallink{Test Now, test Forever}
{http://nereida.deioc.ull.es/~pl/cgi-bin/test_now_test_forever.pdf}
'' del libro de Scott \cite{scott}.

%\item
%\htmladdnormallink{Testing Files and Test Modules}
%{http://www.perl.com/lpt/a/966}
%por Phil Crow. 

\item
\htmladdnormallink{Perl Testing Reference Card}
{perl_test_refcard.pdf}
por Ian Langworth. 

\item
\htmladdnormallink{Chapter 4: Distributing Your Tests (and Code)}
{http://www.oreilly.com/catalog/perltestingadn/chapter/ch04.pdf}
del libro 
\htmladdnormallink{Perl Testing: A Developer's Notebook}
{http://www.oreilly.com/catalog/perltestingadn/index.html}

\end{itemize}

\item
Incluya la estrategia de pruebas de no regresión explicada en las secciones previas.
Dado que ahora la estructura del terminal es una estructura de datos mas compleja
\verb|(token, [value, line_number])| no podrá usar \verb|is|, ya que este último sólo 
comprueba la igualdad entre escalares.
Use \verb|is_deeply| para comprobar que la estructura de datos devuelta por el
analizador léxico es igual a la esperada. Sigue un ejemplo:

\begin{verbatim}
nereida:~/src/perl/YappWithDefaultAction/t> cat -n  15treeregswith2arrays.t
 1  #!/usr/bin/perl -w
 2  use strict;
 3  #use Test::More qw(no_plan);
 4  use Test::More tests => 3;
 5  use_ok qw(Parse::Eyapp) or exit;

..  ..... etc., etc.

84  my $expected_tree = bless( {
85    'children' => [
86      bless( { 'children' => [
87          bless( { 'children' => [], 'attr' => 'a', 'token' => 'a' }, 'TERMINAL' )
88        ]
89      }, 'A' ),
90      bless( { 'children' => [
91          bless( { 'children' => [], 'attr' => 'c', 'token' => 'c' }, 'TERMINAL' )
92        ]
93      }, 'C' )
94    ]
95  }, 'ABC' );
96  is_deeply($t, $expected_tree, "deleting node between arrays");
\end{verbatim}

\item
Extienda los tests con una prueba en la que la entrada contenga un carácter ilegal.
Obsérve que, tal y como esta escrito la rutina \verb|scanner|,
si la entrada tiene un carácter ilegal se ejecutarán las líneas 
\begin{verbatim}
26     elsif (/\G\s*(.)/gc) {
27       Error::fatal "Caracter invalido: $1\n";
28     }
\end{verbatim}
lo que causa la parada del programa 
de prueba,
al ejecutarse \verb|fatal| el cuál llama a \verb|croak|.
\begin{verbatim}
  sub fatal {
    my $msg = join " ", @_;
    croak("Error: $msg\n");
  }
\end{verbatim}
El objetivo es lograr que el programa de pruebas continúe ejecutando las subsiguientes 
pruebas.

Para ello puede usar \verb|Test::Exception| 
o bien \verb|eval| y la variable especial \verb|$@| para controlar que el
programa \verb|.t| no termine prematuramente.
\begin{htmlonly}
Repase la sección \eref{subsection:controldeerrores},
el capítulo 
\externalref{section:knappruebas} y mas específicamente la sección
\externalref{subsection:laspruebas} del capítulo sobre construcción de módulos.
\end{htmlonly}
\begin{latexonly}
Repase las secciones sobre pruebas en \cite{CasianoIntroAPerl}.
\end{latexonly}

\item
Pruebe a dar como entrada un fichero vacío
\item
Pruebe a dar como entrada un fichero que no existe
\item
Pruebe a dar como entrada un fichero binario
\item
Si tiene sentido en su caso, llame a las subrutinas con mas argumentos (y también con menos) de los que esperan.
\item
Si tiene sentido en su caso, llame a las subrutinas con argumentos cuyo tipo no es el que se espera.

No use prototipos para lograrlo. No es una buena idea. Los prototipos en Perl
a menudo producen un preprocesado del parámetro. Escriba código que controle que 
la naturaleza del parámetro es la que se espera. Por ejemplo:

\begin{verbatim}
sub tutu {
  my $refhash = shift;
  croak "Error" unless UNIVERSAL::isa($refhash, 'HASH');
  ...
}
\end{verbatim}
\item
Cambie los argumentos de orden (si es que se aplica a su código)
\item
Comentarios: pruebe con \verb|/* * */ a = 4; /* * / */|. Tambien con
comentarios anidados (debería producirse un error)
\item
Flotantes: compruebe su expresión regular con 0.0 0e0 .0 0 1.e-5 1.0e2 -2.0  . (un punto sólo)
\item
Cadenas. Pruebe con las cadenas
\begin{verbatim}
"" 
"h\"a\"h" 
"\"" 
\end{verbatim}
Pruebe también con una cadena con varias líneas y
otra que contenga un carácter de control en su interior.
\item
Convierta los fallos (bugs) que encontró durante el desarrollo en pruebas
\item
Compruebe la documentación usando el módulo
\htmladdnormallink{Test::Pod}
{http://search.cpan.org/~petdance/Test-Pod-1.26/Pod.pm}
de Andy Lester. Instálelo si es necesario.

\item
Utilice el módulo 
\htmladdnormallink{Test::Warn}
{http://search.cpan.org/~bigj/Test-Warn-0.08/Warn.pm}
para comprobar que los mensajes de warning (uso de \verb|warn| and \verb|carp|)
se muestran correctamente.

\item
Una prueba \tei{SKIP} declara un bloque de pruebas
que - bajo ciertas circustancias - puede saltarse.
Puede ser que sepamos que ciertas pruebas 
sólo funcionan en ciertos sistemas operativos 
o que la prueba requiera que ciertos paquetes están instalados 
o que la máquina
disponga de ciertos recursos (por ejemplo, acceso a internet).
En tal caso queremos que los tests se consideren si se dan las circustancias
favorables pero que en otro caso se descarten sin protestas.
Consulte la documentación de los módulos \verb|Test::More| y \verb|Test::Harness|
sobre pruebas tipo {\tt SKIP}. El ejemplo que sigue
declara un bloque de pruebas que pueden saltarse.
La llamada a \verb|skip| indica cuantos tests hay,
bajo que condición saltarselos.
\begin{verbatim}
 1  SKIP: {
 2      eval { require HTML::Lint };
 3 
 4      skip "HTML::Lint not installed", 2 if $@;
 5 
 6      my $lint = new HTML::Lint;
 7      isa_ok( $lint, "HTML::Lint" );
 8 
 9      $lint->parse( $html );
10      is( $lint->errors, 0, "No errors found in HTML" );
11  }
\end{verbatim}
Si el usuario no dispone del módulo \verb|HTML::Lint| 
el bloque no será ejecutado.
El módulo \verb|Test::More| producirá \verb|ok|s que serán
interpretados por  \verb|Test::Harness| como tests \emph{skipped}
pero \verb|ok|.

Otra razón para usar una prueba \verb|SKIP| es disponer de la posibilidad
de saltarse ciertos grupos de pruebas. Por ejemplo, aquellas que llevan
demasiado tiempo de ejecución y no son tan significativas que no se 
pueda prescindir de ellas cuando se introducen pequeños cambios en el código.
El siguiente código muestra como usando una variable de entorno \verb|TEST_FAST|
podemos controlar que pruebas se ejecutan. 
\begin{verbatim}
nereida:~/src/perl/YappWithDefaultAction/t> cat 02Cparser.t | head -n 56 -
#!/usr/bin/perl -w
use strict;
#use Test::More qw(no_plan);
use Test::More tests => 6;

use_ok qw(Parse::Eyapp) or exit;

SKIP: {
  skip "You decided to skip C grammar test (env var TEST_FAST)", 5 if $ENV{TEST_FAST} ;
  my ($grammar, $parser);
  $grammar=join('',<DATA>);
  $parser=new Parse::Eyapp(input => $grammar, inputfile => 'DATA', firstline => 52);

  #is($@, undef, "Grammar module created");

  # Does not work. May I have done s.t. wrong?
  #is(keys(%{$parser->{GRAMMAR}{NULLABLE}}), 43, "43 nullable productions");

  is(keys(%{$parser->{GRAMMAR}{NTERM}}), 233, "233 syntactic variables");

  is(scalar(@{$parser->{GRAMMAR}{UUTERM}}), 3, "3 UUTERM");

  is(scalar(keys(%{$parser->{GRAMMAR}{TERM}})), 108, "108 terminals");

  is(scalar(@{$parser->{GRAMMAR}{RULES}}), 825, "825 rules");

  is(scalar(@{$parser->{STATES}}), 1611, "1611 states");
}

__DATA__
/*
   This grammar is a stripped form of the original C++ grammar
   from the GNU CC compiler :

   YACC parser for C++ syntax.
   Copyright (C) 1988, 89, 93-98, 1999 Free Software Foundation, Inc.
   Hacked by Michael Tiemann (tiemann@cygnus.com)

   The full gcc compiler an the original grammar file are freely
   available under the GPL license at :

   ftp://ftp.gnu.org/gnu/gcc/
   ...................... etc. etc.
*/
nereida:~/src/perl/YappWithDefaultAction> echo $TEST_FAST
1
nereida:~/src/perl/YappWithDefaultAction> make test
PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
t/01calc....................................ok
t/02Cparser.................................ok
        5/6 skipped: various reasons
t/03newgrammar..............................ok
t/04foldandzero.............................ok
t/05treewithvars............................ok
t/06meta....................................ok
t/07translationschemetype...................ok
t/08tschemetypestar.........................ok
t/09ts_with_defaultaction...................ok
t/10ts_with_treereg.........................ok

etc., etc...................................ok

t/28unshifttwoitems.........................ok
t/29foldinglistsofexpressions...............ok
t/30complextreereg..........................ok
t/32deletenodewithwarn......................ok
t/33moveinvariantoutofloop..................ok
t/34moveinvariantoutofloopcomplexformula....ok
All tests successful, 5 subtests skipped.
Files=33, Tests=113,  5 wallclock secs ( 4.52 cusr +  0.30 csys =  4.82 CPU)
\end{verbatim}
Introduzca una prueba \verb|SKIP| similar a la anterior y otra que 
si el módulo
\verb|Test::Pod| esta instalado comprueba
que la documentación esta bien escrita.
Estudie la documentación del módulo \verb|Test::Pod|.

\item
Introduzca pruebas 
\verb|TODO| (que, por tanto, deben fallar) para las funciones que están por escribir
(\verb|parser|, \verb|Optimize|, \verb|code_generator|, \verb|transform|).
Repáse \eref{subsection:laspruebas}. Sigue un ejemplo:

\begin{verbatim}
42 TODO: {
43   local $TODO = "Randomly generated problem";
44   can_ok('Algorithm::Knap01DP', 'GenKnap'); # sub GenKnap no ha sido escrita aún
45 }
\end{verbatim}

\item
Cuando compruebe el funcionamiento de su módulo 
\emph{nunca descarte que el error pueda estar en
el código de la prueba}. En palabras de Schwern

\begin{verse}
\begin{quote}
Code has bugs. Tests are code. Ergo, tests have bugs.\\

\flushright{Michael Schwern}
\end{quote}
\end{verse}

\item
Instale el módulo 
\htmladdnormallink{Devel::Cover}{http://search.cpan.org/~pjcj/Devel-Cover-0.59/lib/Devel/Cover.pm}.
El módulo  \tei{Devel::Cover} ha sido
escrito por
\htmladdnormallink{Paul Johnson}{http://search.cpan.org/~pjcj/} y proporciona 
estadísticas del cubrimiento alcanzado por una ejecución.
Para usarlo siga estos pasos:
\begin{verbatim}
pl@nereida:~/src/perl/YappWithDefaultAction$ cover -delete
Deleting database /home/pl/src/perl/YappWithDefaultAction/cover_db
pl@nereida:~/src/perl/YappWithDefaultAction$ HARNESS_PERL_SWITCHES=-MDevel::Cover make test
PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
t/01calc....................................ok 
t/01calc....................................ok
t/02Cparser.................................ok
        5/6 skipped: various reasons
t/03newgrammar..............................ok 
t/03newgrammar..............................ok
t/04foldandzero.............................ok
etc., etc. .................................ok
t/34moveinvariantoutofloopcomplexformula....ok
All tests successful, 5 subtests skipped.
Files=33, Tests=113, 181 wallclock secs (177.95 cusr +  2.94 csys = 180.89 CPU)
\end{verbatim}
La ejecución toma ahora mucho mas tiempo: ¡181 segundos frente a los 5 que toma la ejecución sin \tei{cover}!.
Al ejecutar \verb|cover| de nuevo obtenemos una tabla con las estadísticas
de cubrimiento:

\begin{verbatim}
pl@nereida:~/src/perl/YappWithDefaultAction$ cover
Reading database from /home/pl/src/perl/YappWithDefaultAction/cover_db

---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
blib/lib/Parse/Eyapp.pm       100.0    n/a    n/a  100.0    n/a    0.2  100.0
...lib/Parse/Eyapp/Driver.pm   72.4   63.2   50.0   64.3    0.0   21.3   64.4
...ib/Parse/Eyapp/Grammar.pm   90.9   77.8   66.7  100.0    0.0   16.6   84.3
blib/lib/Parse/Eyapp/Lalr.pm   91.4   72.6   78.6  100.0    0.0   48.3   85.6
blib/lib/Parse/Eyapp/Node.pm   74.4   58.3   29.2   88.2    0.0    1.6   64.7
...ib/Parse/Eyapp/Options.pm   86.4   50.0    n/a  100.0    0.0    2.7   72.8
...lib/Parse/Eyapp/Output.pm   82.3   47.4   60.0   70.6    0.0    3.7   70.0
.../lib/Parse/Eyapp/Parse.pm  100.0    n/a    n/a  100.0    n/a    0.2  100.0
...Parse/Eyapp/Treeregexp.pm  100.0    n/a    n/a  100.0    n/a    0.1  100.0
blib/lib/Parse/Eyapp/YATW.pm   89.4   63.9   66.7   85.7    0.0    4.8   77.6
...app/_TreeregexpSupport.pm   73.1   33.3   50.0  100.0    0.0    0.4   60.8
main.pm                        52.2    0.0    n/a   80.0    0.0    0.0   45.7
Total                          83.8   64.7   60.0   84.5    0.0  100.0   75.5
---------------------------- ------ ------ ------ ------ ------ ------ ------

Writing HTML output to /home/pl/src/perl/YappWithDefaultAction/cover_db/coverage.html ...
pl@nereida:~/src/perl/YappWithDefaultAction$          
\end{verbatim}
El 
\htmladdnormallink{HTML generado}{cover_db/coverage.html}
nos permite tener una visión mas detallada de los niveles
de cubrimiento.

Para mejorar el cubrimiento de tu código comienza por el informe de
cubrimiento de subrutinas. Cualquier subrutina marcada como
no probada es un candidato a contener errores o incluso a ser {\it código
muerto}.

Para poder hacer el cubrimiento del código usando Devel::Cover, si se usa una \verb|csh| 
o \verb|tcsh| se debe escribir:

\begin{verbatim}
nereida:~/src/perl/YappWithDefaultAction> setenv HARNESS_PERL_SWITCHES -MDevel::Cover
nereida:~/src/perl/YappWithDefaultAction> make test
PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t
t/01calc....................................ok 
t/01calc....................................ok
t/02Cparser.................................ok
        5/6 skipped: various reasons
t/03newgrammar..............................ok 
t/03newgrammar..............................ok
t/04foldandzero.............................ok
t/05treewithvars............................ok
t/06meta....................................ok 
t/06meta....................................ok
t/07translationschemetype...................ok
............................................ok
t/38tspostfix_resultisarray.................ok
t/39tspostfix...............................ok 
All tests successful, 5 subtests skipped.
Files=38, Tests=135, 210 wallclock secs (206.28 cusr +  3.27 csys = 209.55 CPU)
nereida:~/src/perl/YappWithDefaultAction>
\end{verbatim}
Aún mas robusto - más independiente de la shell que usemos - es pasar las opciones en
\verb|HARNESS_PERL_SWITCHES| como parámetro a \verb|make|:
\begin{verbatim}
make HARNESS_PERL_SWITCHES=-MDevel::Cover test
\end{verbatim}

Añade el informe de cubrimiento al \verb|MANIFEST| para que se incluya en la distribución 
que subas. Si lo consideras conveniente añade un directorio informes en los que vayan los informes asociados
a esta práctica. Incluye en el \verb|README| o en la documentación una breve descripción
de donde están los informes.

\item
Se conoce con el nombre de \cei{perfilado} o \cei{profiling} de
un programa al estudio de su rendimiento mediante un programa
(conocido como \cei{profiler}) que monitoriza la ejecución del mismo
mediante una técnica que interrumpe cada cierto tiempo el programa
para comprobar en que punto de la ejecución se encuentra.
Las estadísticas acumuladas se vuelcan al final de la ejecución 
en un fichero que puede ser visualizado mediante la aplicación apropiada.

En Perl hay dos módulos que permiten realizar profiling. El mas antiguo es
\tei{Devel::DProf}. La aplicación para visualizar los resultados
se llama \tei{dprofpp}.
Sigue un ejemplo de uso:

\begin{verbatim}
nereida:~/src/perl/YappWithDefaultAction/t> perl -d:DProf 02Cparser.t
1..6
ok 1 - use Parse::Eyapp;
ok 2 - 233 syntactic variables
ok 3 - 3 UUTERM
ok 4 - 108 terminals
ok 5 - 825 rules
ok 6 - 1611 states
nereida:~/src/perl/YappWithDefaultAction/t> dprofpp tmon.out
Total Elapsed Time = 3.028396 Seconds
  User+System Time = 3.008396 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 31.4   0.945  1.473   1611   0.0006 0.0009  Parse::Eyapp::Lalr::_Transitions
 17.5   0.528  0.528   1611   0.0003 0.0003  Parse::Eyapp::Lalr::_Closures
 16.1   0.486  0.892      1   0.4861 0.8918  Parse::Eyapp::Lalr::_ComputeFollows
 8.04   0.242  0.391      1   0.2419 0.3906  Parse::Yapp::Driver::_Parse
 8.04   0.242  0.242  11111   0.0000 0.0000  Parse::Eyapp::Lalr::__ANON__
 4.59   0.138  0.138   8104   0.0000 0.0000  Parse::Eyapp::Lalr::_Preds
 2.66   0.080  0.080      1   0.0800 0.0800  Parse::Eyapp::Lalr::_SetDefaults
 2.66   0.080  0.972      1   0.0800 0.9718  Parse::Eyapp::Lalr::_ComputeLA
 2.46   0.074  0.074   3741   0.0000 0.0000  Parse::Eyapp::Parse::_Lexer
 1.89   0.057  0.074   8310   0.0000 0.0000  Parse::Eyapp::Parse::__ANON__
 0.96   0.029  0.028      1   0.0288 0.0276  Parse::Eyapp::Lalr::_SolveConflict
                                             s
 0.66   0.020  0.050      6   0.0033 0.0083  Parse::Eyapp::Output::BEGIN
 0.60   0.018  1.500      1   0.0176 1.4997  Parse::Eyapp::Lalr::_LR0
 0.53   0.016  0.259      3   0.0054 0.0863  Parse::Eyapp::Lalr::_Digraph
 0.33   0.010  0.010      1   0.0100 0.0100  Parse::Eyapp::Grammar::_SetNullable
\end{verbatim}         

Tambien es posible usar el módulo \tei{-MDevel::Profiler}:
\begin{verbatim}
nereida:~/src/perl/YappWithDefaultAction/examples> perl -MDevel::Profiler eyapp 02Cparser.yp
Unused terminals:

        END_OF_LINE, declared line 128
        ALL, declared line 119
        PRE_PARSED_CLASS_DECL, declared line 120

27 shift/reduce conflicts and 22 reduce/reduce conflicts
nereida:~/src/perl/YappWithDefaultAction/examples> dprofpp tmon.out
Total Elapsed Time = 3.914144 Seconds
  User+System Time = 3.917144 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 22.3   0.877  1.577   1611   0.0005 0.0010  Parse::Eyapp::Lalr::_Transitions
 17.8   0.700  0.700   1611   0.0004 0.0004  Parse::Eyapp::Lalr::_Closures
 15.6   0.614  1.185      1   0.6142 1.1854  Parse::Eyapp::Lalr::_ComputeFollow
                                             s
 9.60   0.376  0.545      1   0.3758 0.5453  Parse::Yapp::Driver::_Parse
 7.99   0.313  0.313   8104   0.0000 0.0000  Parse::Eyapp::Lalr::_Preds
 5.85   0.229  0.229      3   0.0763 0.0763  Parse::Eyapp::Lalr::_Digraph
 4.06   0.159  0.159   3741   0.0000 0.0000  Parse::Eyapp::Parse::_Lexer
 3.32   0.130  0.130      1   0.1300 0.1300  Parse::Eyapp::Lalr::DfaTable
 2.27   0.089  0.089      1   0.0890 0.0890  Parse::Eyapp::Lalr::_SetDefaults
 2.04   0.080  1.265      1   0.0800 1.2654  Parse::Eyapp::Lalr::_ComputeLA
 1.17   0.046  0.057      1   0.0464 0.0567  Parse::Eyapp::Grammar::Rules
 1.02   0.040  1.617      1   0.0397 1.6169  Parse::Eyapp::Lalr::_LR0
 0.77   0.030  0.030   1185   0.0000 0.0000  Parse::Eyapp::Lalr::_FirstSfx
 0.71   0.028  0.039      1   0.0284 0.0387  Parse::Eyapp::Grammar::RulesTable
 0.54   0.021  0.021   1650   0.0000 0.0000  Parse::Eyapp::Grammar::classname
\end{verbatim}

Presente un informe del perfil de su compilador. 
Añade el informe del perfil al \verb|MANIFEST| para que se incluya en la distribución 
que subas.

\item
El módulo \tei{Devel::Size} proporciona la posibilidad de
conocer cuanto ocupa una estructura de datos. Considere el siguiente
ejemplo:
\begin{verbatim}
 71 .................................... codigo omitido
 72
 73 use Devel::Size qw(size total_size);
 74 use Perl6::Form;
 75
 76 sub sizes {
 77   my $d = shift;
 78   my ($ps, $ts) = (size($d), total_size($d));
 79   my $ds = $ts-$ps;
 80   return ($ps, $ds, $ts);
 81 }
 82
 83 print form(
 84 ' ==============================================================',
 85 '| VARIABLE | SOLO ESTRUCTURA |     SOLO DATOS |          TOTAL |',
 86 '|----------+-----------------+----------------+----------------|',
 87 '| $parser  | {>>>>>>} bytes  | {>>>>>>} bytes | {>>>>>>} bytes |', sizes($parser),
 88 '| $t       | {>>>>>>} bytes  | {>>>>>>} bytes | {>>>>>>} bytes |', sizes($t),
 89 ' ==============================================================',
 90 );
\end{verbatim}
Al ejecutarlo se obtiene esta salida:

\begin{verbatim}
 ....... salida previa omitida

 ==============================================================
| VARIABLE | SOLO ESTRUCTURA |     SOLO DATOS |          TOTAL |
|----------+-----------------+----------------+----------------|
| $parser  |      748 bytes  |      991 bytes |     1739 bytes |
| $t       |       60 bytes  |     1237 bytes |     1297 bytes |
 ==============================================================
\end{verbatim}
Elabore un informe con el consumo de memoria de las variables mas importantes
de su programa.
Añadelo el informe al \verb|MANIFEST| para que se incluya en la distribución 
que subas. Explica en el \verb|README| o en la documentación el significado 
de los ficheros de informe.


\end{enumerate}

\subsectionrepaso{Pruebas en el Análisis Léxico}
\begin{enumerate}
\item
¿Cuál es la diferencia entre los operadores \verb|==| y \verb|eq|?
\item
¿Cuáles son los parámetros de la función \verb|ok|?
\item
¿Cuáles son los parámetros de la función \verb|is|?
\item
¿Porqué es conveniente nombrar las pruebas con un nombre que empiece por
un número?
\item
¿Como puedo ejecutar los tests en modo \emph{verbose}?
\item
¿Como puedo probar un código que produce la detención del programa?
\item
¿Que contiene la variable \verb|$@|?
\item
¿Que hace la función \verb|like|?
\item
¿Que contiene la variable \verb|$#-|? ¿Y \verb|$+|?
(Consulte \ref{section:variablesmagicasereg})
\item
¿Porqué la función \verb|use_ok| es llamada dentro de un \verb|BEGIN|?
\item
¿Que es una prueba \verb|SKIP|?
\item
¿Que es una prueba \verb|TODO|?
\item
¿Que hace la función \verb|pod_file_ok|?
¿A que módulo pertenece?
\item
¿Que hace el operador \verb|tr|?
\item
¿Qué devuelve el operador \verb|tr|?
\item
¿Que hace la opción \verb|d| de \verb|tr|?
(consulte \ref{section:tr})
\item
Explique la conducta de la siguiente sesión con el depurador:
\begin{verbatim}
  DB<1> $a = '"Focho \"mucha\" chufa"'
  DB<2> print $a
"Focho \"mucha\" chufa"
  DB<3> print $& if $a =~ m{^"([^"]|\\")*"}
"Focho \"
  DB<4> print $& if $a =~ m{^"(\\"||[^"])*"}
"Focho \"mucha\" chufa"
\end{verbatim}
\item
Supuesto que tuvieramos el operador menos en nuestro lenguaje y
dada la entrada \verb|a = 2-3|, ¿Que devolverá su analizador léxico? 
¿Devuelve \verb|ID PUN NUM NUM| o bien \verb|ID PUN NUM PUN NUM|?
(hemos simplificado el flujo eliminando los atributos).
\item
¿Que hace la llamada
\verb|use Test::More qw(no_plan);|?
\item
¿Que hace la función \verb|can_ok|? ¿Qué argumentos tiene?
\item
Explique las causas de la siguiente conducta del depurador:
\begin{verbatim}
  DB<1> $a='4+5'
  DB<2> print "($&) " while ($a =~ m/(\G\d+)/gc) or ($a =~ m/(\G\+)/gc);
(4) (+) (5)
  DB<3> $a='4+5' # inicializamos la posición de búsqueda
  DB<4> print "($&) " while ($a =~ m/(\G\d+)/g) or ($a =~ m/(\G\+)/g);
(4)
  DB<5> $a='4+5'
  DB<6> print "($&) " while ($a =~ m/\G\d+|\G\+/g)
(4) (+) (5)
\end{verbatim}
\item
¿Que diferencia hay entre \verb|is_deeply| e \verb|is|?

\item
¿Que argumentos recibe la función \verb|throws_ok|?
¿En que módulo se encuentra?

\item
¿Que hace el comando
\verb|HARNESS_PERL_SWITCHES=-MDevel::Cover make test|?

\item
¿Cómo se interpreta el cubrimiento de las sentencias? ¿y de las subrutinas?
¿y de las ramas? ¿y las condiciones lógicas?
¿En cual de estos factores es realista y deseable lograr un cubrimiento
del \%100 con nuestras pruebas?

\item
¿Que pasa si después de haber desarrollado un número de pruebas
cambio la interfaz de mi API?

\item
¿Que hace el comando \verb|perl -d:DProf programa|? ¿Para que sirve?
\end{enumerate}

\section{Conceptos Básicos para el Análisis Sintáctico}
\label{section:conceptos}
Suponemos que el lector de esta sección ha realizado con éxito
un curso en teoría de autómatas y lenguajes formales.
Las siguientes definiciones repasan los conceptos mas importantes.

\begin{definition}
Dado un conjunto $A$, se define $A^*$ el cierre de Kleene de $A$ como:
\begin{math}
A^* = \cup_{n=0}^{\infty} A^n
\end{math}

Se admite que $A^0 = \{ \epsilon \}$, donde $\epsilon$ denota la palabra vacía, esto es
la palabra que tiene longitud cero, formada por cero símbolos del conjunto base $A$.
\end{definition}

\begin{definition}
Una gramática $G$ es una cuaterna $G =(\Sigma,V,P,S)$. 
$\Sigma$ es el conjunto de terminales. $V$ es un conjunto (disjunto de $\Sigma$)
que se denomina conjunto de \emph{variables sintácticas} o \emph{categorías gramáticales},
P es un conjunto de pares de $V \times (V \cup \Sigma )^*$. En vez de escribir
un par usando la notación $(A, \alpha) \in P$ se escribe $A \rightarrow \alpha$.
Un elemento de $P$ se denomina producción. Por último, $S$ es un símbolo del conjunto
$V$ que se denomina símbolo de arranque.
\end{definition}

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y $\mu = \alpha A \beta \in (V \cup \Sigma)^*$
una frase formada por variables y terminales y $A \rightarrow \gamma$ una producción de 
$P$, decimos que  $\mu$ deriva en un paso en  $\alpha \gamma \beta$. Esto es, derivar 
una cadena $\alpha A \beta$ es sustituir 
una variable sintáctica $A$ de $V$ por la parte derecha $\gamma$ de una de sus reglas de producción.
Se dice que $\mu$ deriva en $n$ pasos en $\delta$ si deriva en $n-1$ pasos en una cadena
$\alpha A \beta$ la cual deriva en un paso en $\delta$. Se escribe entonces
que $\mu  \stackrel{*}{\Longrightarrow}  \delta$. Una cadena deriva en 0 pasos en si misma.

\end{definition}

\begin{definition}
\label{definition:lenguajegenerado}
Dada una gramática $G=(\Sigma,V,P,S)$ se denota por $L(G)$ o lenguaje
generado por $G$ al lenguaje:

\begin{center}
$L(G) = \{ x \in \Sigma^* : S \stackrel{*}{\Longrightarrow} x \}$
\end{center}

Esto es, el lenguaje generado por la gramática $G$ esta formado por las cadenas
de terminales que pueden ser derivados desde el símbolo de arranque.
\end{definition}

\begin{definition}
Una derivación que comienza en el símbolo de arranque y termina en una secuencia
formada por sólo terminales de $\Sigma$ se dice \emph{completa}.

Una derivación $\mu  \stackrel{*}{\Longrightarrow}  \delta$ 
en la cual en cada paso $\alpha A x$ la regla de producción aplicada $A \rightarrow \gamma$
se aplica en la variable sintáctica mas a la derecha se dice \emph{una derivación a derechas}

Una derivación $\mu  \stackrel{*}{\Longrightarrow}  \delta$ 
en la cual en cada paso $x A \alpha$ la regla de producción aplicada $A \rightarrow \gamma$
se aplica en la variable sintáctica mas a la izquierda se dice \emph{una derivación a izquierdas}
\end{definition}

\begin{definition}
Observe que una derivación puede ser representada como un árbol cuyos nodos
están etiquetados en $V \cup \Sigma$. La aplicación de la regla de 
producción $A \rightarrow \gamma$ se traduce en asignar como hijos del nodo etiquetado con $A$
a los nodos etiquetados con los símbolos $X_1 \ldots X_n$ que constituyen
la frase $\gamma = X_1 \ldots X_n$.  
Este árbol se llama \cei{árbol sintáctico concreto} asociado 
con la derivación.
\end{definition}

\begin{definition}
\label{definition:arbolconcreto}
Observe que, dada una frase $x \in L(G)$ una derivación desde el
símbolo de arranque da lugar a  un árbol. Ese árbol tiene como raíz el 
símbolo de arranque y como hojas los terminales 
$x_1 \ldots x_n$ que forman $x$. Dicho árbol se denomina \emph{árbol
de análisis sintáctico concreto} de $x$. Una derivación determina
una forma de recorrido del árbol de análisis sintáctico concreto.
\end{definition}

\begin{definition}
Una gramática $G$ se dice ambigua si existe alguna frase $x \in L(G)$
con al menos dos árboles sintácticos. 
Es claro que esta definición es equivalente a afirmar que existe 
alguna frase $x \in L(G)$ para la cual existen dos derivaciones a 
izquierda (derecha) distintas.
\end{definition}

\subsection{Ejercicio}
\label{ejercicio:tutugrammar}
Dada la gramática con producciones:

\vspace{0.5cm}
\begin{tabular}{l}
program      $\rightarrow$  declarations  statements         $|$ statements\\
declarations $\rightarrow$ declaration  ';'  declarations    $|$ declaration ';'\\
declaration  $\rightarrow$ INT  idlist                       $|$ STRING   idlist\\
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM $|$ STR\\
idlist       $\rightarrow$ ID ',' idlist $|$ ID
\end{tabular}
\vspace{0.25cm}

En esta gramática, $\Sigma$ esta formado por los caracteres entre comillas simples y 
los símbolos cuyos identificadores están en mayúsculas. Los restantes identificadores
corresponden a elementos de $V$. El símbolo de arranque es $S =$ program.

Conteste a las siguientes cuestiones:

\begin{enumerate}
\item
Describa con palabras el lenguaje generado.
\item
\label{ejer:arbol}
Construya el árbol de análisis sintáctico
concreto para cuatro frases del lenguaje.
\item
Señale a que recorridos del árbol corresponden las respectivas
derivaciones a izquierda y a derecha en el apartado \ref{ejer:arbol}.
\item
¿Es ambigua esta gramática?. Justifique su respuesta.
\end{enumerate}

\section{Análisis Sintáctico Predictivo Recursivo}
\label{section:predictivo}
La siguiente fase en la construcción del analizador es la fase de 
análisis sintáctico. Esta toma como entrada el flujo de terminales
y construye como salida el árbol de análisis sintáctico abstracto.

El árbol de análisis sintáctico abstracto es una representación  compactada del árbol 
de análisis sintáctico concreto que contiene la misma información que éste.

Existen diferentes métodos de análisis sintáctico. La mayoría caen en una de dos categorías:
ascendentes y descendentes. Los ascendentes construyen el árbol desde las hojas
hacia la raíz. Los descendentes lo hacen en modo inverso. El que describiremos
aqui es uno de los mas sencillos: se denomina método de análisis predictivo descendente 
recursivo.

\subsection{Introducción}
\label{subsection:introduccion}
En este método se asocia una subrutina con cada variable sintáctica $A \in V$. Dicha subrutina 
(que llamaremos \verb|A|) reconocerá el lenguaje generado desde la variable $A$:

\begin{center}
$L_A(G) = \{ x \in \Sigma^* : A \stackrel{*}{\Longrightarrow} x \}$
\end{center}

En este método se escribe una rutina \verb|A| por variable sintáctica $A \in V$. 
Se le da a la rutina asociada el mismo nombre que a la variable sintáctica
asociada. La función de la rutina \verb|A| asociada con la variable
$A \in V$ es reconocer el lenguaje $L(A)$ generado por $A$.
La estrategia general que sigue la rutina \verb|A| para reconocer
$L(A)$ es decidir en términos del terminal $a$ en la entrada
que regla de producción concreta $A \rightarrow \alpha$ se aplica para
a continuación comprobar que la entrada que sigue pertenece al lenguaje generado por 
$\alpha$. 
En un analizador predictivo descendente recursivo (APDR) se asume que el símbolo que actualmente 
esta siendo observado (denotado \verb|lookahead|) permite determinar unívocamente
que producción de $A$ hay que aplicar. 
Una vez que se ha determinado que la regla por la que continuar la derivación
es $A \rightarrow \alpha$ se procede a reconocer $L_{\alpha}(G)$,
el lenguaje generado por $\alpha$. Si $\alpha = X_1 \ldots X_n$,
las apariciones de terminales $X_i$ en $\alpha$ son emparejadas
con los terminales en la entrada mientras que las apariciones de variables $X_i = B$
en $\alpha$ se traducen en llamadas a la correspondiente subrutina asociada con \verb|B|.

Para ilustrar el método,
simplificaremos la gramática presentada en el ejercicio
\ref{ejercicio:tutugrammar} eliminando las declaraciones:


\vspace{0.25cm}
\begin{tabular}{l}
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM
\end{tabular}
\vspace{0.25cm}

La secuencia de llamadas cuando se procesa la entrada mediante 
el siguiente programa construye ``implícitamente'' el árbol 
de análisis sintáctico concreto.

Dado que estamos usando \verb|strict| se requiere prototipar las funciones
al comienzo del fichero:
\begin{verbatim}
sub parse();
sub statements();
sub statement();
sub expression();
sub term();
sub factor();
sub idlist();
sub declaration();
sub declarations();
\end{verbatim}

Para saber mas sobre prototipos consulte \eref{section:prototipos}.

\begin{program}
\label{program:adrp}
\begin{verbatim}
 1 sub match {
 2   my $t = shift;
 3 
 4   if ($lookahead eq $t) {
 5     ($lookahead, $value) = splice @tokens,0,2; 
 6     if (defined($lookahead)) { 
 7       $lookahead = $value if ($lookahead eq 'PUN');
 8     } else { $lookahead = 'EOI'; }
 9   }
10   else { error("Se esperaba $t y se encontro $lookahead\n"); }
11 }
12 
13 sub statement {
14   if ($lookahead eq 'ID') { match('ID'); match('='); expression; }
15   elsif ($lookahead eq 'P') { match('P'); expression; }
16   else { error('Se esperaba un identificador'); }
17 }
18 
19 sub term() {
20   factor;
21   if ($lookahead eq '*') { match('*'); term; }
22 }
23 
24 sub expression() {
25   term;
26   if ($lookahead eq '+') { match('+'); expression; }
27 }
28 
29 sub factor() {
30   if ($lookahead eq 'NUM') { match('NUM'); }
31   elsif ($lookahead eq 'ID') { match('ID'); }
32   elsif ($lookahead eq '(') { match('('); expression; match(')'); }
33   else { error("Se esperaba (, NUM o ID"); }
34 }
35 
36 sub statements {
37   statement;
38   if ($lookahead eq ';') { match(';'); statements; }
39 }
40 
41 sub parser {
42   ($lookahead, $value) = splice @tokens,0,2; 
43   statements; match('EOI');
44 }
\end{verbatim}
\end{program}

Como vemos en el ejemplo, el análisis predictivo confía en que, si estamos
ejecutando la entrada del procedimiento \verb|A|,
el cuál está asociado con la variable $A \in V$, el símbolo terminal
que esta en la entrada $a$  determine de manera unívoca la regla
de producción $A \rightarrow a \alpha$ que debe ser procesada.

Si se piensa, esta condición requiere que todas las partes derechas $\alpha$ de
las reglas $A \rightarrow \alpha$ de $A$ ``comiencen'' por diferentes símbolos.
Para formalizar esta idea, introduciremos el concepto de
conjunto $FIRST(\alpha)$:

\begin{definition}
Dada una gramática 
$G=(\Sigma,V,P,S)$ y un símbolo $\alpha \in (V \cup \Sigma)^*$ se define el conjunto 
$FIRST(\alpha)$ como:

$FIRST(\alpha) = \left \{ b \in \Sigma :  \alpha  \stackrel{*}{\Longrightarrow}  b \beta \right \}
\cup N(\alpha)$ 

\noindent donde:

$N(\alpha) = \left \{ \begin{array}{ll}
                         \left \{ \epsilon \right \}& \mbox{si $\alpha \stackrel{*}{\Longrightarrow} \epsilon$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}


Podemos reformular ahora nuestra afirmación anterior en estos términos:
Si $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$ y los conjuntos $FIRST(\gamma_i)$ son 
disjuntos podemos construir el procedimiento para la variable $A$ siguiendo
este seudocódigo:

\begin{verbatim}
sub A {
  if ($lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  elsif ($lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else ($lookahead in FIRST(gamma_n)) { imitar gamma_n }
}
\end{verbatim}

Donde si $\gamma_j$ es $X_1 \ldots X_k$ el código \verb|gamma_j| consiste
en una secuencia $i = 1 \ldots k$ de llamadas de uno de estos dos tipos:
\begin{itemize}
\item
Llamar a la subrutina \verb|X_i| si $X_i$ es una variable sintáctica
\item
Hacer una llamada a \verb|match(X_i)| si $X_i$ es un terminal
\end{itemize}

\subsectionejercicio{Recorrido del árbol en un ADPR}
¿En que forma es recorrido el árbol de análisis sintáctico concreto en un 
analizador descendente predictivo recursivo? ¿En que orden son visitados los nodos?

\subsectionejercicio{Factores Comunes}
En el programa \ref{program:adrp} el reconocimiento de las categorías gramáticales
statements, expression y term (líneas 19-27) difiere del resto. Observe las reglas:

\vspace{0.25cm}
\begin{tabular}{l}
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
\end{tabular}
\vspace{0.25cm}

¿Son disjuntos los conjuntos $FIRST(\gamma_i)$ para las partes derechas de las reglas
de statements?
¿Son disjuntos los conjuntos $FIRST(\gamma_i)$ para las partes derechas de las reglas
de expression?
¿Son disjuntos los conjuntos $FIRST(\gamma_i)$ para las partes derechas de las reglas
de term?

Si se tiene una variable con producciones:

\begin{tabular}{l}
$A   \rightarrow \alpha \beta \mid \alpha \gamma$
\end{tabular}

Las dos producciones tienen un \cei{máximo factor común} en la izquierda
de su parte derecha $\alpha$. Asumimos que $FIRST(\beta) \cap FIRST(\gamma) = \emptyset$.
\begin{enumerate}
\item
¿Cómo puede modificarse la gramática para obtener una nueva gramática que cumpla la condición de que las partes derechas tienen conjuntos $FIRST(\gamma_i)$ disjuntos?
\item
¿Puede modificarse la técnica APDR para que funcione sobre gramáticas con este tipo 
de producciones?. Observe el código asociado con statements, expression  y term.
¿Cómo sería el esquema general?
\end{enumerate}

\subsection{Derivaciones a vacío}
Surge un problema cuando $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$
y la palabra vacía está en alguno de los conjuntos
$FIRST(\gamma_i)$. ¿Que hacer entonces? 

Nótese que si $A \rightarrow \gamma$ y $\epsilon \in FIRST(\gamma)$ es porque existe una derivación
$\gamma \stackrel{*}{\Longrightarrow} \epsilon$. ¿Que terminales podemos 
legalmente encontrarnos cuando estamos en la subrutina \verb|A|?
Consideremos una derivación desde el símbolo de arranque en la que se 
use la producción $A \rightarrow \gamma$. Dicha derivación forzosamente
tendrá la forma:

\begin{center}
$S \stackrel{*}{\Longrightarrow} \beta A\ a \mu \Longrightarrow \beta \gamma\ a \mu \stackrel{*}{\Longrightarrow} \beta\ a \mu$.
\end{center}

Cualquier terminal $a \in \Sigma$ que pueda aparecer en una derivación desde 
el símbolo de arranque inmediatamente a continuación  de la variable $A$ 
es susceptible de ser visto
cuando se esta analizando $A$ y se aplicó 
$A \rightarrow \gamma$ con $\gamma \stackrel{*}{\Longrightarrow} \epsilon$.
Esto nos lleva a la definición del conjunto $FOLLOW(A)$ como conjunto
de terminales que pueden aparecer a continuación de $A$ en una derivación 
desde el símbolo de arranque:

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y una variable $A \in V$ 
se define el conjunto $FOLLOW(A)$ como: 

$FOLLOW(A) = \left \{ b \in \Sigma :  \exists\ S  \stackrel{*}{\Longrightarrow}  \alpha A b \beta \right \} \cup E(A)$

\noindent donde

$E(A) = \left \{ \begin{array}{ll}
                         \{ \$  \}& \mbox{si $S \stackrel{*}{\Longrightarrow} \alpha A$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}
Aqui $\$$ denota el final de la entrada (que se corresponde en el código Perl anterior 
con el terminal \verb|EOI|).

Si $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$ dado que los conjuntos $FIRST(\gamma_i)$ 
han de ser disjuntos para que un analizador predictivo APDR funcione, sólo una parte derecha
puede contener la palabra vacía en su $FIRST$. Supongamos que es $\gamma_n$.
Podemos reformular la construcción del procedimiento para la variable $A$ siguiendo
este seudocódigo:

\begin{verbatim}
sub A {
  if ($lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  elsif ($lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else ($lookahead in FIRST(gamma_n) or $lookahead in FOLLOW(A)) { imitar gamma_n }
}
\end{verbatim}

Un caso particular de $\gamma_n \stackrel{*}{\Longrightarrow} \epsilon$ 
es que $\gamma_n = \epsilon$. En tal caso, y como
es obvio, el significado de \verb|imitar gamma_n| 
es equivalente a ejecutar una sentencia vacía.

\subsection{Construcción de los conjuntos de Primeros y Siguientes}

\begin{algorithm} Construcción de los conjuntos $FIRST(X)$

Repita el siguiente conjunto de reglas hasta que no se puedan añadir mas símbolos terminales o  a ningún conjunto $FIRST(X)$:
\begin{enumerate}
\item
$Si\ X \in \Sigma\ entonces\ FIRST(X) = {X}$
\item
$Si\ X \rightarrow \epsilon\ entonces\ FIRST(X) =  FIRST(X) \cup \{ \epsilon \}$
\item
$Si X \in V \ y\ X \rightarrow Y_1 Y_2 \cdots Y_k \in P\ entonces$
\begin{eqnarray}
&&i = 1; \nonumber\\
&&hacer \nonumber\\
&&\ \ FIRST(X) = FIRST(X) \cup FIRST^*(Y_i); \nonumber\\
&&\ \ i++; \nonumber\\
&&mientras\ (i \leq k\ y\ \epsilon \in FIRST(Y_i)) \nonumber 
\end{eqnarray}
\item
Añadir $\epsilon$ a $FIRST(X)$ si $i \geq k$ y $\epsilon \in FIRST(Y_k)$
\end{enumerate}
\end{algorithm}
Aqui $FIRST^*(Y)$ denota al conjunto $FIRST(Y) - \{ \epsilon \}$.

Este algoritmo puede ser extendido para calcular 
$FIRST(\alpha)$ para $\alpha = X_1 X_2 \cdots X_n \in (V \cup \Sigma)^*$.
El esquema es anólogo al de un símbolo individual.

\begin{algorithm} Construcción del conjunto $FIRST(\alpha)$ 

Repita siguiente conjunto de reglas hasta que no se puedan añadir mas
símbolos terminales o  a ningún conjunto $FIRST(\alpha)$:
\begin{eqnarray}
&&i = 1; \nonumber\\
&&FIRST(\alpha) = \emptyset; \nonumber\\
&&hacer \nonumber\\
&&\ \ FIRST(\alpha) = FIRST(\alpha) \cup FIRST^*(X_i); \nonumber\\
&&\ \ i++; \nonumber\\
&&mientras\ (i \leq n\ y\ \epsilon \in FIRST(X_i)) \nonumber 
\end{eqnarray}
\end{algorithm} 

\begin{algorithm} Construcción de los conjuntos $FOLLOW(A)\ \forall A \in V$: 

Repetir los siguientes pasos hasta que ninguno de los conjuntos $FOLLOW$ cambie:
\begin{enumerate} 
\item 
$FOLLOW(S) = \{\$\} $  ($\$$ representa el final de la entrada)
\item
$Si\ A \rightarrow \alpha B \beta\ entonces$
\[ FOLLOW(B) =  FOLLOW(B) \cup (FIRST(\beta) - \{\epsilon\})\]
\item
$Si\ A \rightarrow \alpha B\ o\ A \rightarrow \alpha B \beta\ y\ \epsilon \in FIRST(\beta)\  entonces$
\[ FOLLOW(B) = FOLLOW(B) \cup FOLLOW(A)\]
\end{enumerate}
\end{algorithm}

\subsectionejercicio{Construir los $FIRST$}
Construya los conjuntos $FIRST$ de las partes derechas de las reglas de 
producción de la gramática presentada en el ejercicio \ref{ejercicio:tutugrammar}.

\subsectionejercicio{Calcular los $FOLLOW$}
Modificamos la gramática de la sección 
\ref{subsection:introduccion}
para que admita la sentencia vacía:

\vspace{0.25cm}
\begin{tabular}{l}
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression $|\ \epsilon$\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM
\end{tabular}
\vspace{0.25cm}

Calcule los conjuntos $FOLLOW$. ¿Es la nueva gramática susceptible
de ser analizada por un analizador predictivo descendente recursivo?
¿Cómo sería el código para la subrutina \verb|statements|?. Escríbalo.

\subsectionpractica{Construcción de los FIRST y los FOLLOW}
\label{practica:firstandfollow}
He escrito un módulo llamado 
\htmladdnormallink{Grammar}{Grammar-0.02.tar.gz} 
que provee la función
\verb|Grammar::Parse| la cual recibe una cadena conteniendo la
gramática en formato \verb|yacc| o \verb|eyapp| y devuelve una referencia a un
hash conteniendo la información pertinente para el tratamiento de 
la gramática. 
Para instalar el módulo tenga en cuenta que depende del módulo \verb|Parse::Yapp|.

Para ilustrar el uso vea los ejemplos en el directorio \verb|scripts|.
En concreto veamos el programa \verb|grammar.pl|.
\begin{verbatim}
Grammar/scripts$ cat -n grammar.pl
 1  #!/usr/bin/perl -w -I../lib
 2  use strict;
 3  use Grammar;
 4  use Data::Dumper;
 5
 6  sub usage {
 7    print <<"EOI";
 8  usage:
 9  $0 input_grammar
10  EOI
11    die "\n";
12  }
13
14  usage() unless @ARGV;
15  my $filename = shift;
16
17  local $/ = undef;
18  open my $FILE, "$filename";
19  my $grammar = <$FILE>;
20  my $x = Grammar::Parse($grammar);
21
22  print Dumper($x);
\end{verbatim}
Vamos a darle como entrada la gramática en el fichero \verb|aSb.yp|
conteniendo una gramática:
\begin{verbatim}
Grammar/scripts$ cat -n aSb.yp
 1  %%
 2  S:
 3      |   'a' S 'b'
 4  ;
 5  %%
\end{verbatim}

Las gramáticas aceptadas por \verb|Grammar::Parse| se adaptan a la sintáxis de
las gramáticas reconocidas por \verb|Parse::Yapp|.
Una gramática (normalmente con tipo  \verb|.yp|) consta de tres partes: la cabeza, el cuerpo
y la cola. Cada una de las partes va separada de las otras por el
símbolo \verb|%%| en una línea aparte. Así, el \verb|%%| de la línea 1
separa la cabeza del cuerpo. En la cabecera se colocan 
las declaraciones de terminales (directiva \verb|%token|), 
cual es el símbolo de arranque (directiva \verb|%start|), etc.
El cuerpo contiene las reglas de la gramática y
las acciones asociadas. Por último, la cola  en nuestro caso no es
usada y es vacía. En general, la cola 
contiene las rutinas de soporte al código que aparece en las acciones 
asi como, posiblemente, rutinas para el análisis léxico 
y el tratamiento de errores. 

La salida de \verb|Grammar::Parse| es una referencia a un hash cuyas entradas
vienen explicadas por los comentarios.
\begin{verbatim}
Grammar/scripts$ grammar.pl aSb.yp
$VAR1 = {
    'SYMS' => { 'S' => 2, '"b"' => 3, '"a"' => 3 }, # Símbolo => línea
    'NULL' => { 'S' => 1 }, # símbolos que se anulan
    'RULES' => [
                 [ 'S', [] ], # S produce vacío
                 [ 'S', [ '"a"', 'S', '"b"' ] ] # S -> aSb
               ],
    'START' => 'S', # Símbolo de arranque
    'TERM' => [ '"b"', '"a"' ], # terminales /tokens
    'NTERM' => { 'S' => [ 0, 1 ] }  # índices de las reglas de las variables sintácticas
  };
\end{verbatim}
Usando la estructura devuelta por la función \verb|Grammar::Parse| escriba un módulo
que provea funciones para computar los \verb|FIRST| y los \verb|FOLLOW| de las variables
sintácticas de la gramática. No olvide escribir la documentación. 
Incluya una prueba por cada una de las gramáticas que figuran en el directorio \verb|scripts|
del módulo \verb|Grammar|.

Puede encontrar la práctica \emph{casi hecha} en
\htmladdnormallink{PL::FirstFollow}{PL-FirstFollow-0.02.tar.gz}.
Asegúrese de entender el algoritmo usado.
Aumente el número de pruebas y haga un análisis de cubrimiento.

\subsection{Gramáticas LL(1)}
Una gramática $G = (\Sigma, V, P, S)$ cuyo lenguaje generado 
$L(G)$ puede ser analizado por un 
analizador sintáctico descendente recursivo predictivo
se denomina \cei{LL(1)}. Una gramática es LL(1) si y sólo si 
para cualesquiera dos
producciones $A \rightarrow \alpha$ y $A \rightarrow \beta$ de
$G$ se cumple:
\begin{enumerate}
\item
$FIRST(\alpha) \cap FIRST(\beta) = \emptyset$
\item
Si $\epsilon \in FIRST(\alpha)$, entonces $FIRST(\alpha) \cap FOLLOW(A) = \emptyset$
\end{enumerate}

¿De donde viene el nombre LL(1)? La primera L hace alusión al hecho de que 
el flujo de terminales se lee de izquierda a derecha, accediendo a la entrada
por su izquierda (\emph{Left}). La segunda L se refiere a que el método
de análisis predictivo construye una derivación a izquierdas. El número
entre paréntesis indica el número de terminales que debemos consultar para
decidir que regla de producción se aplica. Asi, en una gramática LL(2) la decisión 
final de que producción elegir se hace consultando los dos terminales a la entrada.

\subsectionejercicio{Caracterización de una gramática LL(1) }
Cuando se dice que una gramática es LL(1) si, y sólo si:
\begin{enumerate}
\item
$FIRST(\alpha) \cap FIRST(\beta) = \emptyset$
\item
Si $\epsilon \in FIRST(\alpha)$, entonces $FIRST(\alpha) \cap FOLLOW(A) = \emptyset$
\end{enumerate}
se asume que los conjuntos $FIRST(\alpha)$ no son vacíos.
\begin{itemize}
\item
¿Que se puede decir de la regla  $A \rightarrow \alpha$ si
$FIRST(\alpha) = \emptyset$?
\item
¿Que se puede decir de la variable $A$ si $FOLLOW(A) = \emptyset$?
\end{itemize}

\subsectionejercicio{Ambiguedad y LL(1)}
¿Puede una gramática LL(1) ser ambigua?.
Razone su respuesta.

\subsectionpractica{Un analizador APDR}
\label{practica:APDR}

Siguiendo con la construcción del compilador para el lenguaje Tutu, escriba un 
analizador APDR para la siguiente gramática. Reutilice el código de las
prácticas de las secciones anteriores 
(\ref{section:analisislexico}
y
\ref{section:lexicomodular}).

\vspace{0.5cm}
\begin{tabular}{l}
program      $\rightarrow$  declarations  statements         $|$ statements\\
declarations $\rightarrow$ declaration  ';'  declarations    $|$ declaration ';'\\
declaration  $\rightarrow$ INT  idlist                       $|$ STRING   idlist\\
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression $|\ \epsilon$\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM $|$ STR\\
idlist       $\rightarrow$ ID ',' idlist $|$ ID
\end{tabular}
\vspace{0.25cm}

\subsectionpractica{Generación Automática de Analizadores Predictivos}
\label{practica:GAP}

\paragraph{Objetivo}
Escriba un módulo \verb|GAP.pm| que provea una subrutina \verb|gap| para
la generación automática de un APDR supuesto que la gramática de entrada es 
LL(1). 

La subrutina \verb|gap| recibe como entrada la gramática según la estructura de
datos generada  por la función \verb|Grammar::Parse| de la versión 0.3 del módulo
\htmladdnormallink{Grammar}{Grammar-0.03.tar.gz}. 

\paragraph{El Módulo {\tt Grammar}}

La estructura de datos generada  por la función \verb|Grammar::Parse|
se explicó en la práctica  
\ref{practica:firstandfollow}.
La estructura ha sido extendida
en esta versión para incluir el código que se sitúe en la zona de cola.
Por ejemplo, dada la gramática de entrada:

\begin{verbatim}
  Grammar/03/scripts$ cat -n aSb.yp
       1  %%
       2  S:
       3      |   'a' S 'b'
       4  ;
       5  %%
       6
       7  sub Lex {
       8    local $_ = shift; # input
       9    my @tokens;
      10
      11
      12    while ($_) {
      13      s/^\s*//; # fuera blancos
      14      push @tokens, $1, $1 if s/^(.)//s
      15    }
      16    @tokens;
      17  }
      18
      19  sub main {
      20    my $filename = shift;
      21    my $input;
      22
      23    if (defined($filename)) {
      24      local $/ = undef;
      25      open my $FILE, $filename or die "No se pudo abrir $filename\n";
      26      $input = <$FILE>;
      27      close($FILE);
      28    }
      29    else { $input = <STDIN> }
      30
      31    my @tokens = Lex($input);
      32    Parse(@tokens); # Llamada al analizador generado
      33    print "Sintácticamente correcto\n";
      34  }
\end{verbatim}
se genera la siguiente estructura de datos:
\begin{verbatim}
{
  'SYMS' => { 'S' => 2, 'b' => 3, 'a' => 3 },  # Símbolo => línea de aparición
  'NULL' => { 'S' => 1 }, # Símbolos que se anulan
  'RULES' => [ # Reglas 
               [ 'S', [] ], # S produce vacío
               [ 'S', [ 'a', 'S', 'b' ] ] # S-> a S b
             ],
  'START' => 'S', # Símbolo de arranque
  'TERM' => [ 'b', 'a' ], # Terminales
  'NTERM' => { 'S' => [ 0, 1 ] } # Variables sintácticas e índices de las reglas de esa variable
  'TAIL' => [ # [ 'Código de cola', línea en la que está el segundo %% ]
  '

  sub Lex {
    local $_ = shift; # input
    my @tokens;


    while ($_) {
      s/^\\s*//; # fuera blancos
      push @tokens, $1, $1 if s/^(.)//s
    }
    @tokens;
  }

  sub main {
    my $filename = shift;
    my $input;

    if (defined($filename)) {
      local $/ = undef;
      open my $FILE, $filename or die "No se pudo abrir $filename\\n";
      $input = <$FILE>;
      close($FILE);
    }
    else { $input = <STDIN> }

    my @tokens = Lex($input);
    my $ok = Parse(@tokens); # Llamada al analizador generado
    print "Sintácticamente correcto\\n" if $ok;
  }

  ', 5 ], # línea en la que está el segundo %%
 };
\end{verbatim}

Asi pues la entrada con clave \verb|TAIL| contiene el código auxiliar de
cola. Este código debe ser incluido por su programa dentro del texto del
paquete generado por \verb|gap|.

\paragraph{Descripción del objetivo: La función {\tt gap}}

La función \verb|gap| también recibe como entrada el nombre 
del package:
\begin{verbatim}
$package_text = &gap($grammar, 'Package_name');
\end{verbatim}
La función \verb|gap| retorna
una cadena conteniendo el \verb|package| en el que estan las subrutinas del
analizador sintáctico. 

La idea es que dicha cadena se salvará en un fichero
con nombre \verb|Package_name.pm| que podrá posteriormente ser usado 
(\verb|use Package_name|) por un programa que necesite analizar entradas
que se conforman de acuerdo a la especificación de la gramática.

\paragraph{Descripción del objetivo: La función {\tt parser}}
La rutina principal del paquete generado se ha de llamar
\verb|parser| (esto es, su nombre completo es: \verb|Package_name::parser|. 
Evidentemente \verb|Package_name| debe ser un nombre Perl válido).
Ninguna subrutina deberá ser exportada sino que deberán ser llamadas
por su nombre completo.

La subrutina \verb|parser| recibe como argumento el array de 
terminales, obtiene el primer terminal y llama a la subrutina
asociada con el símbolo de arranque. Los terminales están representados
como parejas $(terminal, atributo)$.

Observe que, una vez que la cadena \verb|$package_text| conteniendo el paquete ha sido 
generada y salvada en un fichero con nombre \verb|Package_name.pm|, podemos escribir
un programa cliente:

\begin{verbatim}
use strict;
use Package_name;

&Package_name::main;
\end{verbatim}

Este programa espera una entrada desde fichero o \verb|STDIN| e
informa si dicha entrada es sintácticamente correcta o no
para la gramática en cuestión.

\paragraph{Cálculo de los First y los Follow con {\tt PL::FirstFollow}}

Para facilitar la escritura de \verb|GAP.pm| pueden hacer uso 
del módulo \htmladdnormallink{PL::FirstFollow}{PL-FirstFollow-0.02.tar.gz}
el cual calcula los $FIRST$ y los $FOLLOW$. El módulo \tei{PL::FirstFollow}
depende de 
\htmladdnormallink{Set::Scalar}{http://search.cpan.org/~jhi/Set-Scalar-1.20/lib/Set/Scalar.pm}
escrito por 
\htmladdnormallink{Jarkko Hietaniemi}{http://search.cpan.org/~jhi/}: instálelo primero.

Deberá familiarizarse con {\tt PL::FirstFollow}, rellenar la
documentación de todas las subrutinas (apariciones de \verb|????| en el texto)
y escribir la documentación siguiendo el template que se provee. 
\emph{Rellene los fragmentos de código que se han sustituido por 
signos de interrogación}.
Haga un estudio de cubrimiento
y añada pruebas para mejorar el actual. El actual cubrimiento es:
\begin{verbatim}
---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...ammar-0.03/lib/Grammar.pm  100.0    n/a    n/a  100.0    0.0   75.3   97.2
blib/lib/PL/FirstFollow.pm    100.0   92.9   50.0  100.0    0.0   24.7   95.1
Total                         100.0   92.9   50.0  100.0    0.0  100.0   95.5
---------------------------- ------ ------ ------ ------ ------ ------ ------
\end{verbatim}
Si observa un fallo en \tei{PL::FirstFollow} háganoslo saber y
además de resolverlo escriba una prueba para detectar el fallo.

Haga un estudio de profiling de su aplicación.
\paragraph{Uso de Templates}

Un módulo que puede facilitar la escritura de esta práctica 
es 
\htmladdnormallink{Text::Template}{http://search.cpan.org/~mjd/Text-Template-1.44/lib/Text/Template.pm}
debido a 
\htmladdnormallink{Mark Jason Dominus}{http://search.cpan.org/~mjd/}.
El siguiente ejemplo de uso es un fragmento de  un traductor - que nunca acabo de terminar
- que toma con fuente 
un fichero en el formato que usa Moodle para los cuestionarios (conocido como 
formato GIFT) y lo convierte en un cuestionario \LaTeX{}:


\begin{verbatim}
lhp@nereida:~/projects/Gift2LaTeX/Gift2LaTeX/lib$ cat -n Gift2LaTeX.pm
   1  package Gift2LaTeX;
   2
   3  use strict;
   4  use warnings;
   5  use Gift;
   6  use Text::Template;
   7  use HTML::Latex;
  ..    ......................................................
  49  package Gift::TRUEFALSE; # True-false questions belong to this class
  50
  51  { # closure
  52
  53    die "Can't find $TEMPLATE_DIR/TRUEFALSE_question.tep\n"
  54          unless -e "$TEMPLATE_DIR/TRUEFALSE_question.tep";
  55    my $tfq_tmpl = Text::Template->new( #tfq = true-false question
  56      DELIMITERS => ['%<', '%>'];
  57      SOURCE => "$TEMPLATE_DIR/TRUEFALSE_question.tep",
  58    );
  ..    ......................................................
  67    sub gen_latex {
  68      my $self = shift;
  69
  70      ########## Generate latex for question
  71      my $prefix  = $self->PREFIX;
  72
  73      my $sufix = $self->POSTSTATE;
  74
  75      $self->Error("Only HTML and PLAIN formats are supported\n")
  76          unless (!$self->FORMAT or ($self->FORMAT =~ m{html|plain}i));
  77
  78      my ($prefix_tex, $sufix_tex);
  79      if (defined($self->FORMAT) and $self->FORMAT =~ m{plain}i) {
  80        $prefix_tex = $prefix;
  81        $sufix_tex  = $sufix;
  82      }
  83      else { # HTML by default
  ..    ......................................................
  86      }
  87      my $params = {
  88        prefix  => $prefix_tex,
  89        sufix   => $sufix_tex,
  90        separator => $separator,
  91        label   => $label_prefix.$question_number,
  92        question_number => $question_number
  93      };
  94      my $question_tex = $tfq_tmpl->fill_in(HASH => $params);
  96      ########## Generate latex for answer
 ...      ....................................
 101    }
 102  }
\end{verbatim}
En la línea 55 se crea el template. El template se lee desde el fichero
\verb|"$TEMPLATE_DIR/TRUEFALSE_question.tep"| cuyo contenido es una mezcla
de texto (en este caso texto \LaTeX{} y HTML) con código Perl:
El código Perl aparece acotado entre los delimitadores \verb|'%<'|
y \verb|'%>'|.

\begin{verbatim}
lhp@nereida:~/projects/Gift2LaTeX/Gift2LaTeX/etc/en$ cat -n TRUEFALSE_question.tep
 1  \ begin{latexonly}
 2    %<$separator%>
 3    \ label{question:%<$label%>}
 4    %<$prefix%>
 5
 6    \ begin{center}
 7      \ begin{tabular}{llll}
 8          $\ bigcirc$ & TRUE & $\ bigcirc$ & FALSE
 9      \ end{tabular}
10
11      \noindent %<$sufix%>
12    \ end{center}
13  \ end{latexonly}
14
15  \ begin{htmlonly}
16  %<$separator%>
17  \ label{question:%<$label%>}
18  %<$prefix%>
19
20  \ begin{center}
21    \ begin{tabular}{llll}
22        \ htmlref{$\bigcirc$}{answer:%<$label%>} & TRUE &
23        \ htmlref{$\bigcirc$}{answer:%<$label%>} & FALSE
24    \ end{tabular}
25
26    \ noindent %<$sufix%>
27  \ end{center}
28  \ end{htmlonly}
\end{verbatim}

El template se rellena en las líneas 87-94. En esa llamada
se ejecuta el código Perl incrustado en el esqueleto
y su resultado se inserta en la posición que ocupa en el texto.

\paragraph{Concatenación y Documentos {\tt HERE}}
Cuando concatene sangre adecuadamente las concatenaciones:
\begin{verbatim}
my $usage = "Usage: $0 <file> [-full] [-o] [-beans]\n"
            . "Options:\n"
            . "    -full  : produce a full dump\n"
            . "    -o     : dump in octal\n"
            . "    -beans : source is Java\n"
            ;
\end{verbatim}
ponga el punto al principio de la siguiente línea, no al final.

Pero cuando el número de líneas es grande 
es mejor
usar un \cei{here document}
o \cei{documento aqui}. Veamos un ejemplo:
\begin{verbatim}
print <<"EOI";
El programa se deberá ejecutar con:

$0 numfiles $opciones initialvalue
EOI
\end{verbatim}
Para definir un ``documento aqui'' 
se escribe la etiqueta entrecomillada y precedida de \verb|<<| y 
sigue el texto que consituye el \emph{here document}
que se delimita por una línea en blanco que empieza por la etiqueta.
Al documento aquí se le trata como una cadena de doble comilla si
la etiqueta aparece en doble comilla y como de comilla simple
si la etiqueta esta  entre comillas simples.
Observe que el punto y coma se escribe despues 
de la primera aparición 
de la etiqueta.

Un problema con el uso de los heredoc es que rompen la estructura normal
del sangrado:
\begin{verbatim}
if ($usage_error) {
    warn <<'END_USAGE';
Usage: qdump <file> [-full] [-o] [-beans]
Options:
    -full  : produce a full dump
    -o     : dump in octal
    -beans : source is Java
END_USAGE
}
\end{verbatim}
Es mejor que cada heredoc se aisle en una subrutina y se parametrice con
las variables que van a ser interpoladas:
\begin{verbatim}
sub build_usage {
    my ($prog_name, $file_name) = @_;

    return <<"END_USAGE";
Usage: $prog_name $file_name [-full] [-o] [-beans]
Options:
    -full  : produce a full dump
    -o     : dump in octal
    -beans : source is Java
END_USAGE
}
\end{verbatim}

que mas tarde puede ser llamado con los valores de interpolación adecuados:

\begin{verbatim}
if ($usage_error) {
    warn build_usage($PROGRAM_NAME, $requested_file);
}
\end{verbatim}
Véase  el libro de Conway  Perl Best Practices
\cite{bestpractices}
para mas detalles sobre buenas prácticas de programación con heredocs.

\paragraph{Descarga de los Módulos Necesarios}
\begin{itemize}
\item
El módulo \tei{Grammar}: 
\htmladdnormallink
{http://nereida.deioc.ull.es/\~{}pl/perlexamples/Grammar-0.03.tar.gz}
{http://nereida.deioc.ull.es/~pl/perlexamples/Grammar-0.03.tar.gz}

\item
El módulo \tei{PL::FirstFollow}:
\htmladdnormallink
{http://nereida.deioc.ull.es/\~{}pl/perlexamples/PL-FirstFollow-0.02.tar.gz}
{http://nereida.deioc.ull.es/~pl/perlexamples/PL-FirstFollow-0.02.tar.gz}
\end{itemize}

\section{Esquemas de Traducción}
\label{section:esquemas}
\begin{definition}
Un \cei{esquema de traducción} es una gramática independiente del contexto
en la cual se han insertado fragmentos de código en las partes derechas
de sus reglas de producción. Los fragmentos de código asi insertados 
se denominan \cei{acciones semánticas}. Dichos fragmentos actúan, calculan
y modifican los atributos asociados con los nodos del árbol sintáctico. 
El orden en que se evalúan los fragmentos
es el de un recorrido primero-profundo del árbol de análisis sintáctico.
\end{definition}
Obsérvese que, en general, para poder aplicar un esquema de traducción hay 
que construir el árbol sintáctico y después aplicar las acciones empotradas
en las reglas en el orden de recorrido primero-profundo. Por supuesto, si 
la gramática es ambigua una frase podría tener dos árboles y la ejecución de las
acciones para ellos podría dar lugar a diferentes resultados. Si se quiere
evitar la multiplicidad de resultados (interpretaciones semánticas)
es necesario precisar de que árbol sintáctico concreto se esta hablando.

Por ejemplo, si en la regla $A \rightarrow \alpha \beta $
insertamos un fragmento de código:

\begin{center}
$A \rightarrow \alpha \{ action \} \beta $
\end{center}

La acción $\{ action \}$ se ejecutará después de todas las acciones
asociadas con el recorrido del subárbol de $\alpha$ y antes que todas
las acciones asociadas con el recorrido del subárbol $\beta$.

El siguiente esquema de traducción recibe como entrada una expresión en infijo
y produce como salida su traducción a postfijo para expresiones aritmeticas con sólo 
restas de números:

\vspace{0.5cm}
\begin{tabular}{ll}
$expr   \rightarrow expr_1  -  NUM$  & \verb|{ $expr{TRA} = $expr[1]{TRA}." ".$NUM{VAL}." - "}| \\
$expr   \rightarrow NUM$             & \verb|{ $expr{TRA} = $NUM{VAL} }|
\end{tabular}
\vspace{0.5cm}

Las apariciones de variables sintácticas en una regla de producción se indexan
como se ve en el ejemplo, para distinguir de que nodo del árbol de análisis estamos
hablando. Cuando hablemos del atributo de un nodo utilizaremos una indexación tipo
\emph{hash}. Aquí \verb|VAL| es un atributo de los nodos de tipo $NUM$ denotando
su valor numérico y para accederlo escribiremos \verb|$NUM{VAL}|.
Análogamente \verb|$expr{TRA}| denota el atributo ``traducción'' de
los nodos de tipo $expr$.

\begin{exercise}
Muestre la secuencia de acciones a la
que da lugar el esquema de traducción anterior 
para la frase 7 -5 -4.
\end{exercise}

En este ejemplo, el cómputo del atributo \verb|$expr{TRA}| depende de los atributos
en los nodos hijos, o lo que es lo mismo, depende de los atributos de los símbolos
en la parte derecha de la regla de producción. Esto ocurre a menudo y motiva la siguiente
definición:

\begin{definition}
Un atributo tal que su valor en un nodo
puede ser computado en términos de los atributos de los hijos del nodo se dice
que es un \cei{atributo sintetizado}.
\end{definition}

\begin{example}
\label{example:typesandts}
Un ejemplo de atributo heredado es el tipo de las variables en las declaraciones:

\vspace{0.5cm}
\begin{tabular}{ll}
$decl   \rightarrow type$ \verb|{ $list{T} = $type{T} }| $list$\\
$type   \rightarrow INT$ \verb|{ $type{T} = $int }|\\
$type   \rightarrow STRING$ \verb|{ $type{T} = $string }|\\
$list   \rightarrow ID$ , \verb|{ $ID{T} = $list{T}; $list_1{T} = $list{T} }| $list_1$\\
$list   \rightarrow ID$ \verb|{ $ID{T} = $list{T} }|
\end{tabular}
\vspace{0.5cm}
\end{example}

\begin{definition}
Un \cei{atributo heredado} es aquel cuyo valor se computa a partir de los
valores de sus hermanos y de su padre.
\end{definition}

\begin{exercise}
Escriba un esquema de traducción que convierta expresiones en infijo con los 
operadores \verb|+-*/()| y números en expresiones en postfijo. Explique el significado
de los atributos elegidos.
\end{exercise}

% %%%%%%%%%%%%%%%%TODO: COMENTAR
% \section{Esquemas de Traducción con {\tt Parse::Eyapp}}
% 
% La distribución \tei{Parse::Eyapp} debida al autor de estos apuntes (i.e. Casiano Rodriguez-Leon)
% permite la escritura de esquemas de traducción. El módulo no esta aún disponible
% en CPAN: estoy a la espera de completar las pruebas y la documentación.
% 
% El ejemplo simple que sigue ilustra como construir un esquema de traducción. 
% El código completo puede encontrarlo en la página
% \pageref{apendice:transschemesimple}.
% Un ejemplo de ejecución del programa se encuentra en la página 
% \ref{apendice:ejecuciondetrans_scheme_simple}.
% 
% Comencemos por el principio:
% \label{codigo:trans_scheme_simple2}
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> head -n79 trans_scheme_simple2.pl | cat -n
%  1  #!/usr/bin/perl -w
%  2  use strict;
%  3  use Data::Dumper;
%  4  use Parse::Eyapp;
%  5  use IO::Interactive qw(is_interactive);
%  6
%  7  my $translationscheme = q{
%  8  %{
%  9  # head code is available at tree construction time
% 10  use Data::Dumper;
% 11
% 12  our %sym; # symbol table
% 13  %}
% 14
% 15  %metatree
% 16
% 17  %right   '='
% 18  %left   '-' '+'
% 19  %left   '*' '/'
% 20
% 21  %%
% 22  line:       %name EXP
% 23                exp <+ ';'> /* Expressions separated by semicolons */
% 24                  { $lhs->{n} = [ map { $_->{n}} $_[1]->Children() ]; }
% 25  ;
% 26
% 27  exp:
% 28              %name PLUS
% 29                exp.left '+'  exp.right
% 30                  { $lhs->{n} = $left->{n} + $right->{n} }
% 31          |   %name MINUS
% 32                exp.left '-' exp.right
% 33                  { $lhs->{n} = $left->{n} - $right->{n} }
% 34          |   %name TIMES
% 35                exp.left '*' exp.right
% 36                  { $lhs->{n} = $left->{n} * $right->{n} }
% 37          |   %name DIV
% 38                exp.left '/' exp.right
% 39                  { $lhs->{n} = $left->{n} / $right->{n} }
% 40          |   %name NUM   $NUM
% 41                  { $lhs->{n} = $NUM->{attr} }
% 42          |   '(' $exp ')'  %begin { $exp }
% 43          |   %name VAR
% 44                $VAR
% 45                  { $lhs->{n} = $sym{$VAR->{attr}}->{n} }
% 46          |   %name ASSIGN
% 47                $VAR '=' $exp
% 48                  { $lhs->{n} = $sym{$VAR->{attr}}->{n} = $exp->{n} }
% 49
% 50  ;
% 51
% 52  %%
% 53  # tail code is available at tree construction time
% 54  sub _Error {
% 55    my($token)=$_[0]->YYCurval;
% 56    my($what)= $token ? "input: '$token'" : "end of input";
% 57
% 58    die "Syntax error near $what.\n";
% 59  }
% 60
% 61  sub _Lexer {
% 62      my($parser)=shift;
% 63
% 64      for ($parser->YYData->{INPUT}) {
% 65          $_ or  return('',undef);
% 66
% 67          s/^\s*//;
% 68          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
% 69          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
% 70          s/^(.)// and return($1,$1);
% 71          s/^\s*//;
% 72      }
% 73  }
% 74
% 75  sub Run {
% 76      my($self)=shift;
% 77      return $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
% 78  }
% 79  }; # end translation scheme
% \end{verbatim}
% 
% Las líneas 7-79 no hacen otra cosa que iniciar una cadena conteniendo el esquema de
% traducción. También podríamos haberlo escrito en un fichero y compilarlo con 
% \tei{eyapp}. 
% 
% \paragraph{Partes de un programa {\tt eyapp}}
% 
% Un programa \verb|eyapp| es similar en muchos aspectos a 
% un programa \tei{yapp}/\tei{yacc} y se divide en tres partes:
% la cabeza, el cuerpo
% y la cola. Cada una de las partes va separada de las otras por el
% símbolo \verb|%%| en una línea aparte. Así, el \verb|%%| de la línea 21
% separa la cabeza del cuerpo. En la cabecera se colocan el
% código de inicialización, las declaraciones de terminales, las reglas
% de precedencia, etc.  El cuerpo contiene las reglas de la gramática y
% las acciones asociadas. Por último, la cola de un program \verb|eyapp|
% se separa del cuerpo por otro \verb|%%| en una línea aparte.
% La cola contiene las rutinas de soporte al código que aparece en las acciones 
% asi como, posiblemente, rutinas para el análisis léxico  (subrutina \verb|_Lexer|
% en la línea 58)
% y el tratamiento de errores (subrutina \verb|_Error| en la línea 54).
% Puede encontrar una descripción de la gramática de \verb|eyapp| 
% usando su propia notación en la página
% \pageref{apendice:eyappgrammar}.
% 
% \paragraph{Esquemas de Traducción con {\tt \%metatree}}
% Por defecto \verb|Parse::Eyapp| se comporta de manera similar a \verb|yapp|
% y \verb|yacc| generando un analizador sintáctico LALR(1) y ejecutando 
% las acciones empotradas según una antiderivación a derechas, esto es en un
% recorrido del árbol de análisis sintáctico 
% de abajo hacia arriba y de izquierda a derecha. 
% 
% Mediante la directiva \tei{\%metatree} en la línea 15 
% le indicamos a \verb|Parse::Eyapp| que debe generar un 
% esquema de traducción. En tal caso, al llamar al analizador
% el código empotrado no es ejecutado sino que se genera un árbol
% de análisis sintáctico con los correspondientes nodos de código
% colgando del árbol en las posiciones que les corresponden.
% 
% \paragraph{Las reglas}
% 
% Las reglas de producción de la gramática están entre 
% las líneas 21 y 52. Cada entrada comienza con el nombre de la variable sintáctica
% y va seguida de las partes derechas de sus reglas de producción separadas por barras
% verticales. Opcionalmente se le puede dar un nombre a la regla de producción
% usando la directiva \tei{\%name}. El efecto que tiene esta directiva 
% es bendecir - durante la fase tree construction time - 
% el nodo del árbol sintáctico en una clase con nombre el
% argumento de \verb|%name| (los nodos del árbol sintáctico son objetos).
% El código - entre llaves - puede ocupar cualquier lugar en el lado
% derecho. 
% 
% \paragraph{Nombres de los atributos}
% 
% En las acciones los atributos de los nodos pueden ser accedidos usando 
% el array mágico \verb|@_|. De hecho, los códigos insertados en el árbol
% sintáctico son convertidos en subrutinas anónimas. 
% Así \verb|$_[0]| es una referencia al nodo 
% padre asociado con el lado izquierdo, \verb|$_[1]| el asociado
% con el primer símbolo de la parte derecha, etc. {\it Esta \cei{notación posicional}
% es confusa e induce a error: si el programador cambia la regla posteriormente insertando
% acciones o símbolos en la parte derecha, ¡todas las apariciones de índices en
% el código que se refieran a nodos a la derecha del insertado
% deben ser modificadas!}. Algo similar ocurre si decide suprimir una acción o un 
% símbolo. Por ello \verb|Parse::Eyapp| 
% proporciona mediante la \cei{notación punto} la posibilidad de
% hacer una copia automática con nombre del atributo: la notación
% \verb|exp.left| indica que la variable léxica \verb|$left|
% guardará una referencia al nodo que corresponde a esta instanciación de la variable
% sintáctica \verb|exp|. Además \verb|Parse::Eyapp| provee la variable
% léxica especial \verb|$|\tei{lhs} donde se guarda una referencia al nodo padre.
% Así la regla:
% 
% \begin{verbatim}
%                 exp.left '-' exp.right
%                   { $lhs->{n} = $left->{n} - $right->{n} }
% \end{verbatim}
% equivale al siguiente código:
% \begin{verbatim}
%                  exp '-' exp
%                   { 
%                     my $lhs = shift; 
%                     my ($left, $right) = @_[1, 3];
%                     $lhs->{n} = $left->{n} - $right->{n} 
%                   }
% \end{verbatim}
% Si se desea usar el propio nombre de la variable sintáctica como 
% nombre del atributo se usa la \cei{notación dolar}. Asi la notación
% \verb|$exp| puede considerarse una abreviación a la notación \verb|exp.exp|. 
% El código:
% \begin{verbatim}
%                 $VAR '=' $exp
%                   { $lhs->{n} = $sym{$VAR->{attr}}->{n} = $exp->{n} }
% \end{verbatim}
% equivale a este otro:
% \begin{verbatim}
%                   VAR '=' exp
%                   { 
%                     my $lhs = shift;
%                     my ($VAR, $exp) = @_[1, 3];
%                     $lhs->{n} = $sym{$VAR->{attr}}->{n} = $exp->{n} 
%                   }
% \end{verbatim}
% 
% \paragraph{Fases de un Esquema de Traducción}
% 
% La ejecución de un esquema de traducción por \verb|Parse::Eyapp| 
% ocurre en tres tiempos. 
% 
% \paragraph{Class Construction Time}
% 
% En una primera parte - que denominaremos
% \cei{Class Construction Time} - se analiza la gramática y se crea 
% la clase que contendrá el analizador sintáctico. 
% Esto se hace llamando al método de clase \tei{new\_grammar}
% el cual devuelve una cadena conteniendo información
% sobre las ambiguedades, conflictos y errores
% que pueda tener la gramática:
% 
% \begin{verbatim}
% 84  my $warnings = Parse::Eyapp->new_grammar(
% 85    input=>$translationscheme,
% 86    classname=>'main',
% 87    firstline => 6,
% 88    outputfile => 'main.pm');
% 89  die "$warnings\nSolve Ambiguities. See file main.output\n"  if $warnings;
% \end{verbatim}
% 
% El nombre de la clase  o package en el que se crea el analizador
% se especifica mediante el argumento \tei{classname}.
% 
% El argumento \tei{firstline} facilita la emisión de errores 
% y warnings indicando la línea en que comienza la cadena que contiene
% el esquema de traducción.
% 
% Si se especifica el argumento \tei{outputfile}\verb| => filename| los resultados
% del análisis se volcarán en los ficheros \verb|filename.pm| y \verb|filename.output|
% los cuales contienen respectivamente el código del analizador e información
% pormenorizada sobre las tablas usadas por el analizador y los conflictos
% y ambiguedades encontradas durante el estudio de la gramática.
% 
% Una vez creada la clase es posible instanciar objetos del tipo analizador
% llamando al constructor \verb|new| de la clase creada:
% 
% \begin{verbatim}
% 90  my $parser = main->new();
% \end{verbatim}
% 
% \paragraph{Tree Construction Time}
% 
% En una segunda parte - que denominaremos 
% \cei{Tree Construction Time} - se toma la entrada (usando para ello el analizador 
% léxico y las rutinas de error proveídas por el programador) 
% y se procede a la construcción del árbol. 
% \emph{Las acciones
% especificadas por el programador en el esquema no son ejecutadas} sino
% que se añaden al árbol como referencias a subrutinas (nodos de tipo \verb|CODE|). 
% 
% El programador
% puede influir en la construcción del árbol por medio de diversas directivas.
% De estas explicaremos tres:
% 
% \paragraph{La directiva {\tt \%name class}}
% Como se ha dicho, la directiva \verb|%name class| hace que el nodo asociado con la 
% instanciación  de la regla de producción se bendiga en la clase dada por la cadena
% \verb|class|. 
% 
% \paragraph{La directiva {\tt \%begin}}
% 
% La directiva \tei{\%begin} \verb|{ ... code ...}| usada en la línea 42 hace que el
% código usado como argumento \verb|{ ... code ...}| se ejecute en {\it Tree Construction Time}.
% \begin{verbatim}
% 27  exp:
% 28              %name PLUS
% 29                exp.left '+'  exp.right
% 30                  { $lhs->{n} = $left->{n} + $right->{n} }
% 31          |   %name MINUS
% ..          .   ............................................
% 42          |   '(' $exp ')'  %begin { $exp }
% \end{verbatim}
% 
% En el ejemplo la directiva \verb|%begin { $exp }| hace que nos saltemos
% el nodo asociado con el paréntesis enlazando directamente la raíz del árbol
% referenciado por \verb|$exp| con el padre de la regla actual.
% Si no se hubiera insertado esta directiva el árbol construido para
% la entrada \verb|2*(3+4)| sería similar a este:
% \begin{verbatim}
% TIMES
%   |-- NUM -- TERMINAL( attr => 2 )
%   |-- '*'
%   `-- E_7
%        |-- '('
%        |-- PLUS
%        |    |-- NUM -- TERMINAL( attr => 3 )
%        |    |-- '+'
%        |    `-- NUM -- TERMINAL( attr => 4 )
%        `--  ')'
% 
% \end{verbatim}
% El efecto de la directiva \verb|%begin { $exp }| es retornar la referencia
% a la expresión parentizada dando lugar al siguiente árbol:
% \begin{verbatim}
% TIMES
%   |-- NUM -- TERMINAL( attr => 2 )
%   |-- '*'
%   `-- PLUS
%        |-- NUM -- TERMINAL( attr => 3 )
%        |-- '+'
%        `-- NUM -- TERMINAL( attr => 4 )
% \end{verbatim}
% 
% En general, 
% las acciones asociadas con directivas \verb|%begin| 
% modifican la construcción del árbol sintáctico
% concreto para dar lugar a un árbol de análisis sintáctico abstracto adecuado
% a los requerimientos de las fases posteriores. 
% 
% Las acciones en Tree Construction Time insertadas mediante \verb|%begin|
% se ejecutan colaborativamente con las acciones de construcción del árbol 
% en el orden 
% usual de los analizadores LR: según una antiderivación a derechas, 
% esto es, en un
% recorrido del árbol de análisis sintáctico 
% de abajo hacia arriba (de las hojas hacia la raíz) y de izquierda a derecha. 
% 
% Las acciones en Tree Construction Time
% reciben como argumentos en \verb|$_[1]|, \verb|$_[2]|, etc. las referencias a los
% nodos del árbol asociadas con los elementos de la parte derecha. 
% {\it En Tree Construction Time el argumento \verb|$_[0]|
% es una referencia al objeto analizador sintáctico}.
% 
% La segunda fase en nuestro ejemplo ocurre en las líneas 90-92
% en las que leemos la entrada y llamamos al método 
% \verb|Run| el cual construye el árbol:
% 
% \begin{verbatim}
% 90  print "Write a sequence of arithmetic expressions: " if is_interactive();
% 91  $parser->YYData->{INPUT} = <>;
% 92  my $t = $parser->Run() or die "Syntax Error analyzing input";
% \end{verbatim}
% 
% El método \verb|Run| se limita a llamar al método \verb|YYParse| que es quien 
% realiza el análisis:
% 
% \begin{verbatim}
% 74  sub Run {
% 75      my($self)=shift;
% 76      return $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
% 77  }
% \end{verbatim}
% 
% Cuando el método \verb|YYParse| proveido por \verb|Parse::Eyapp| es llamado
% es necesario que hayan sido especificadas las correspondientes 
% referencias a las rutinas de análisis léxico
% (argumento con clave \verb|yylex|) 
% y de tratamiento de errores (argumento con clave \verb|yyerror|).
% 
% Despues de esta fase tenemos el árbol de análisis extendido con los
% nodos de tipo \verb|CODE|.
% 
% \paragraph{Execution Time} 
% 
% En una tercera parte - que denominaremos \cei{Execution Time} - el árbol es recorrido
% en orden primero-profundo y los nodos de la clase \verb|CODE| son ejecutados. El
% árbol será modificado y decorado como consecuencia de las acciones
% y podremos examinar los resultados:
% \begin{verbatim}
% 93  $t->translation_scheme;
% 94  my $treestring = Dumper($t);
% 95  our %sym;
% 96  my $symboltable = Dumper(\%sym);
% 97  print <<"EOR";
% 98  ***********Tree*************
% 99  $treestring
% 100  ******Symbol table**********
% 101  $symboltable
% 102  ************Result**********
% 103  $t->{n}
% 104
% 105  EOR
% \end{verbatim}
% 
% El método \verb|translation_scheme| tiene una estructura simple
% y tiene un código similar a este:
% 
% \begin{verbatim}
% sub translation_scheme {
%   my $self = shift; # root of the subtree
%   my @children = $self->children();
%   for (@children) {
%     if (ref($_) eq 'CODE') {
%       $_->($self, @children);
%     }
%     elsif (defined($_)) {
%       translation_scheme($_);
%     }
%   }
% }
% \end{verbatim}
% Como se ve en el código de \verb|translation_scheme| la subrutina
% asociada se le pasan como argumentos referencias al nodo y a los hijos del nodo.
% 
% \paragraph{Los Terminales}
% Durante la fase de construcción del árbol sintáctico
% los nodos que corresponden a terminales o tokens de la gramática 
% son -por defecto - bendecidos en la clase \verb|"${PREFIX}|\tei{TERMINAL}\verb|"|.
% Si el programador no ha indicado lo contrario en la llamada al analizador,
% \verb|$PREFIX| es la cadena vacía. 
% (Véase el párrafo en la página \ref{paragraph:prefix} sobre el argumento \verb|yyprefix|
% del método constructor del analizador).
% 
% Los nodos de la clase \verb|TERMINAL| poseen 
% al menos dos atributos \verb'token' y \verb|attr|. El atributo 
% \verb'token' indica que clase de terminal es (\verb|NUM|, \verb|IDENTIFIER|, etc.).
% El atributo \verb|attr| nos da el valor semántico del terminal tal y como
% fué recibido del analizador léxico.
% 
% \paragraph{Listas y Opcionales}
% El fragmento del esquema de traducción entre las líneas 26 y 30:
% 
% \begin{verbatim}
% 26  line: %name PROG
% 27         exp <%name EXP + ';'>
% 28           { @{$lhs->{t}} = map { $_->{t}} ($lhs->child(0)->Children()); }
% 29
% 30  ;
% \end{verbatim}
% 
% expresa que el lenguaje generado por el no terminal \verb|line| esta formado por
% secuencias no vacías de frases generadas a partir de \verb|exp| separadas por
% puntos y comas. En concreto, el analizador generado por \verb|eyapp| transforma
% la regla \verb|line: exp <%name EXP + ';'>| en:
% \begin{verbatim}
% line:       %name EXP
%               PLUS-1
% ;
% PLUS-1:     %name _PLUS_LIST
%               PLUS-1 ';'  exp
%         |     exp      
% ;
% \end{verbatim}
% 
% La expresión \verb|exp <+ ';'>| es tratada como un único elemento de la parte 
% derecha y su atributo es un nodo de la clase \tei{\_PLUS\_LIST} cuyos
% hijos son los elementos de la lista. Por ejemplo, para la entrada
% \verb|a=2; b = 2*a| el analizador construye un árbol similar a este:
% \begin{verbatim}
% bless( {
%   'children' => [
%     bless( {              # _PLUS_LIST
%     | 'children' => [
%     |   bless( {          # ASSIGN a = 2
%     |   | 'children' => [
%     |   |   bless( { 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   bless( { 'attr' => '=', 'token' => '=' }, 'TERMINAL' ),
%     |   |   bless( {      # NUM 2
%     |   |     'children' => [
%     |   |       bless( { 'attr' => '2', 'token' => 'NUM' }, 'TERMINAL' ),
%     |   |       sub { my $lhs = $_[0]; my $NUM = $_[1];  $lhs->{n} = $NUM->{attr}  }
%     |   |     ]
%     |   |   }, 'NUM' ),
%     |   |   sub { my ($lhs, $exp, $VAR) = ($_[0], $_[3], $_[1]);  
%     |   |         $lhs->{n} = $sym{$VAR->{attr}}->{n} = $exp->{n}  }
%     |   | ]
%     |   }, 'ASSIGN' ),
%     |   bless( {         # ASSIGN b = 2*a
%     |   | 'children' => [
%     |   |   bless( { 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   bless( { 'attr' => '=', 'token' => '=' }, 'TERMINAL' ),
%     |   |   bless( {     # TIMES 2*a
%     |   |     'children' => [
%     |   |       bless( { .... }, 'NUM' ),
%     |   |       bless( { 'attr' => '*', 'token' => '*' }, 'TERMINAL' ),
%     |   |       bless( { .... }, 'VAR' ),
%     |   |       sub { ... }
%     |   |     ]
%     |   |   }, 'TIMES' ),
%     |   |   sub { ... }
%     |   | ]
%     |   }, 'ASSIGN' )
%     | ]
%     }, '_PLUS_LIST' ),
%     sub { ... }
%   ]
% }, 'EXP' )
% \end{verbatim}
% 
% \emph{Observe que, por defecto, los nodos punto y coma ({\tt ;}) son eliminados del nodo
% lista de hijos del nodo} \verb|_PLUS_LIST|. Por defecto, en los
% nodos creados por \verb|Parse::Eyapp| desde listas 
% declaradas mediante operadores de brackets (por ejemplo \verb|St <+ ';'>|
% o \verb|ID <* ','>|) se 
% elimina el separador si este fué definido mediante una cadena (uso de apostrofes).
% 
% Diremos que un terminal es un \cei{terminal sintáctico} o
% \cei{syntax token} si fue definido en el programa \verb|eyapp|
% mediante una cadena delimitada por
% apóstrofes.
% 
% Si queremos cambiar el estatus de un syntax token, por ejemplo
% si queremos 
% que el separador \verb|';'| del ejemplo forme parte de la lista deberemos añadir a la cabecera
% la declaración \verb|%semantic token ';'|. 
% 
% Si creamos una nueva versión
% de nuestro programa \verb|trans_scheme_simple3.pl| añadiendo esta declaración:
% 
% \begin{verbatim}
% %semantic token ';'
% %right   '='
% ....
% \end{verbatim}
% Las listas contendran los puntos y comas. 
% En tal caso, la línea 24 dará lugar a un 
% error\footnote{
% El código de la línea 24
% 
% \begin{alltt}
% 24\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \$lhs->\{n\}\ =\ [\ map\ \{\ \$\_->\{n\}\}\ \$\_[1]->Children()\ ];\ \}
% \end{alltt}
% 
% funciona como sigue:
% obtiene la lista de hijos verdaderos (aquellos que no son
% referencias a subrutinas) mediante el método {\tt Children}.
% La aplicación posterior de {\tt map} crea una lista con los atributos {\tt n}
% de esos nodos. Por último la inclusión entre corchetes 
% crea una lista anónima con dichos números. La referencia
% resultante es asignada al atributo {\tt n} del lado
% izquierdo
% }
% ya que los nodos 
% punto y coma carecen del atributo \verb|n|:
% \begin{verbatim}
% 24                  { $lhs->{n} = [ map { $_->{n}} $_[1]->Children() ]; }
% \end{verbatim}
% 
% En efecto:
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> trans_scheme_simple3.pl > salida
% a=2*3; b = a+1; c = a-b
% Use of uninitialized value in join or string at trans_scheme_simple3.pl line 99, <> line 1.
% Use of uninitialized value in join or string at trans_scheme_simple3.pl line 99, <> line 1.
% \end{verbatim}
% Al usar la declaración \tei{\%semantic token} la nueva estructura del árbol es:
% \begin{verbatim}
% less( {
%   'n' => [ 6, undef, 7, undef, -1 ],
%   'children' => [
%     bless( {
%       'children' => [
%         bless( { 'n' => 6, ................  ] }, 'ASSIGN' ),
%         bless( { 'children' => [], 'attr' => ';', 'token' => ';' }, 'TERMINAL' ),
%         bless( { 'n' => 7, ................  }, 'ASSIGN' ),
%         bless( { 'children' => [], 'attr' => ';', 'token' => ';' }, 'TERMINAL' ),
%         bless( { 'n' => -1, ................  }, 'ASSIGN' )
%       ]
%     }, '_PLUS_LIST' ),
%     sub { "DUMMY" }
%   ]
% }, 'EXP' )
% \end{verbatim}
% \verb|Parse::Eyapp| extiende \tei{Parse::Yapp} con listas vacías y no vacías
% usando los operadores \verb|*|, \verb|+|:
% 
% \noindent La regla:
% \begin{verbatim}
%                           A : B C * 'd' 
% \end{verbatim}
% \noindent es equivalente a:
% 
% \begin{verbatim}
%                           A : B L 'd' 
%                           L : /* vacío */
%                             | P
%                           P : C P
%                             | C
% \end{verbatim}
% 
% \noindent Es posible especificar la presencia de símbolos
% opcionales usando \verb|?|. 
% 
% Observe que el operador de concatenación tiene menor prioridad que 
% los operadores de listas, esto es la expresión \verb|AB*| es interpretada
% como \verb|A(B*)|.
% 
% Una secuencia de 
% símbolos en la parte derecha de una regla de producción
% puede ser agrupada mediante el uso de paréntesis.
% Al agrupar una secuencia se crea una variable sintáctica intermedia
% que produce dicha secuencia. Por ejemplo, la regla:
% 
% \begin{verbatim}
%                     A : B (C { dosomething(@_) })? D 
% \end{verbatim}
% 
% \noindent es equivalente a:
% \begin{verbatim}
%                     A  : B T1 D 
%                     T1 :  /* vacío */
%                        | T2
%                     T2 : C { dosomething(@_) }
% \end{verbatim}
% 
% \paragraph{Ambiguedades}
% 
% Hay numerosas ambiguedades en la gramática asociada con el
% esquema de traducción presentado en la página 
% \pageref{codigo:trans_scheme_simple2}.
% Las ambiguedades se resuelven exactamente igual
% que en \verb|yacc| usando directivas en la \cei{cabecera} o
% primera parte que indiquen como resolverlas. 
% 
% Entre las ambiguedades presentes en la gramática del ejemplo
% estan las siguientes:
% 
% \begin{itemize}
% \item
% ¿Como debo interpretar la expresión \verb|e - e - e|?
% ¿Como \verb|(e - e) - e|? ¿o bien \verb|e - (e - e)|?
% La respuesta la da la asignación de asociatividad a los operadores
% que hicimos en la cabecera.
% Al declarar como asociativo a izquierdas al terminal \verb|-| 
% hemos resuelto este tipo de ambiguedad. Lo que estamos haciendo es
% indicarle al analizador que a la hora de elegir entre 
% los árboles abstractos elija siempre el árbol que se hunde a izquierdas.
% \item
% ¿Como debo interpretar la expresión \verb|e - e * e|?
% ¿Como \verb|(e - e) * e|? ¿o bien \verb|e - (e * e)|?
% 
% En \verb|eyapp| los terminales declarados mediante directivas
% \verb|%left|, \verb|%right| y \verb|%nonassoc|
% tienen asociada \underline{una prioridad}. \emph{Esa prioridad es 
% mayor cuanto mas abajo en el texto está la línea 
% de su declaración}. 
% Un terminal puede ser también declarado con la directiva \verb|%token| en
% cuyo caso no se le asocia prioridad.
% 
% Al declarar que el operador \verb|*| tiene mayor prioridad que el operador \verb|-| 
% estamos resolviendo esta otra fuente de ambiguedad. Esto es así pues
% el operador \verb|*| fué declarado después que el operador \verb|-|.
% Le indicamos así al analizador que construya el árbol asociado con
% la interpretación \verb|e - (e * e)|.
% 
% 
% \emph{En {\tt eyapp} La prioridad asociada con una regla de producción
% es la del \underline{último terminal} que aparece en dicha regla}.
% 
% Una regla de producción puede ir seguida de una directiva
% \tei{\%prec} la cual le da una prioridad explícita.  
% Esto puede ser de gran ayuda en ciertos casos de 
% ambiguedad.
% Por ejemplo, si quisieramos introducir el uso el menos unario en
% la gramática surgiría una ambiguedad:
% 
% \begin{verbatim}
%   39         |   %name UMINUS
%   40               '-' $exp %prec NEG
%   41                 { $lhs->{n} = -$exp->{n} }
% \end{verbatim}
% ¿Cual es la ambiguedad que surge con esta regla? 
% Una de las ambiguedades de esta regla 
% esta relacionada con el doble significado
% del menos como operador unario y binario: hay frases
% como \verb|-e-e| que tiene dos posibles interpretaciones:
% Podemos verla como \verb|(-e)-e| o bien como \verb|-(e-e)|.
% Hay dos árboles posibles. El analizador, cuando este analizando
% la entrada \verb|-e-e| y vea el
% segundo \verb|-| deberá escoger uno de los dos árboles. 
% ¿Cuál?. 
% 
% El conflicto puede verse como una ``lucha'' entre
% la regla \verb|exp: '-' exp| la cual interpreta la frase como
% \verb|(-e)-e| y la segunda aparición del terminal \verb|-| 
% el cuál ``quiere entrar'' para que gane la regla \verb|exp: exp '-' exp|
% y dar lugar a la interpretación \verb|-(e-e)|.
% 
% En este caso, si atendemos a la norma enunciada de que
% la prioridad asociada con una regla de producción
% es la del \underline{último terminal} que aparece en dicha regla,
% las dos reglas 
% $E \rightarrow - E$ y $E \rightarrow E - E$ tienen
% la prioridad del terminal \verb|-|.
% 
% Lo que hace la declaración \verb|%prec NEG| de la línea
% 40 es modificar la prioridad de la regla $E \rightarrow - E$
% para que tenga la 
% del terminal \verb|NEG|. El terminal \verb|NEG| lo declaramos
% en la cabecera del programa, dándole la prioridad adecuada:
% \begin{verbatim}
% 17  %right   '='
% 18  %left   '-' '+'
% 19  %left   '*' '/'
% 20  $right NEG
% 21  %%
% \end{verbatim}
% 
% \begin{exercise}
% ¿Cómo se hubiera interpretado la expresion \verb|- e - e| si no
% se hubiese introducido el terminal de desempate \verb|NEG|?
% \end{exercise}
% 
% \begin{exercise}
% ¿Cómo se interpretará una expresion como \verb|e = e - e|?
% \end{exercise}
% 
% \item
% Tenga en cuenta que algunas funcionalidades proveídas por \verb|Parse::Eyapp|
% (por ejemplo las listas) suponen la inserción de reglas dentro de la gramática
% de entrada y por tanto pueden dar lugar a ambiguedades.
% 
% \item
% Una fuente de ambiguedad puede aparecer como consecuencia de la aparición de acciones
% semánticas. Cuando se  inserta una acción $\left \{ action_1\right \}$
% en medio de una regla $A \rightarrow \alpha \beta$ :
% \begin{center}
% $A \rightarrow \alpha \left \{ action_1 \right \} \beta \left \{ action_2\right \}$ 
% \end{center}
% \verb|eyapp| crea una variable sintáctica temporal $T$ e introduce una nueva regla:
% 
% \begin{center}
% \begin{enumerate}
% \item
% $A \rightarrow \alpha T \beta \left \{ action_2\right \}$ 
% \item
% $T \rightarrow \epsilon \left \{ action_1 \right \}$ 
% \end{enumerate}
% \end{center}
% 
% esta modificación puede dar lugar a conflictos.
% 
% \end{itemize}
% 
% \paragraph{La rutina de Tratamiento de Errores}
% Recuerde que la fase de análisis sintáctico y léxico de 
% la entrada ocurre en Tree Construction Time.
% En consecuencia el primer argumento que recibe el método \verb|_Error| 
% (líneas 53-59) cuando es llamado
% por el analizador sintáctico es una referencia al objeto analizador 
% sintáctico. Dicho objeto dispone de un conjunto de métodos, muchos de los cuales
% ya existían en \verb|Parse::Yapp|. Entre estos últimos se encuentra  el método
% \tei{YYCurval} que es llamado en la línea 55 y que devuelve
% el terminal/token que estaba siendo analizado en el momento en el que 
% se produjo el error. Si dicho token no está definido es que hemos alcanzado el
% final del fichero (línea 56).
% 
% \begin{verbatim}
% 54  sub _Error {
% 55    my($token)=$_[0]->YYCurval;
% 56    my($what)= $token ? "input: '$token'" : "end of input";
% 57
% 58    die "Syntax error near $what.\n";
% 59  }
% \end{verbatim}
% 
% Otros métodos que pueden ser de ayuda en el diagnóstico de 
% errores son \tei{YYCurval} que devuelve el atributo del 
% token actual y \tei{YYExpect} que devuelve una lista
% con los terminales esperados en el momento en el que se produjo
% el error.
% 
% \paragraph{El Analizador Léxico}
% El analizador léxico esta tomado de los ejemplos 
% que acompañan a \verb|Parse::Yapp|. Se supone que la entrada
% se ha dejado dentro del objeto analizador en \verb|$parser->YYData->{INPUT}|.
% Recuerde que el análisis léxico de la entrada ocurre en Tree Construction Time.
% En consecuencia el primer argumento que recibe \verb|_Lexer| cuando es llamado
% por el analizador sintáctico es la referencia al objeto analizador 
% sintáctico. De ahí que lo primero que se hace, en la línea 59, sea 
% crear en \verb|$parser| una variable léxica que referencia dicho objeto.
% 
% \begin{verbatim}
% 58  sub _Lexer {
% 59      my($parser)=shift;
% 60
% 61          $parser->YYData->{INPUT}
% 62      or  return('',undef);
% 63
% 64      $parser->YYData->{INPUT}=~s/^\s*//;
% 65
% 66      for ($parser->YYData->{INPUT}) {
% 67          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
% 68          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
% 69          s/^(.)// and return($1,$1);
% 70          s/^\s*//;
% 71      }
% 72  }
% \end{verbatim}
% 
% \begin{exercise}
% ¿Cuantos elementos tiene la lista sobre la que se hace el bucle 
% \verb|for| de la línea 66?
% \end{exercise}
% 
% Obsérvese el \cei{falso bucle {\tt for}} en la línea 66. 
% Es un truco que constituye una de esas frases hechas o \cei{idioms}
% que aunque la primera vez resultan extrañas,
% a fuerza de verlas repetidas se convierten en familiares.
% 
% El bucle de hecho se ejecutará una sóla vez en cada llamada 
% a \verb|_Lexer|. El objetivo es evitar las costosas indirecciones
% a las que obliga almacenar la entrada en \verb|$parser->YYData->{INPUT}|.
% Para ello se aprovecha la capacidad del bucle \verb|for| sin índice
% \emph{de crear en} \verb|$_| \emph{un alias del elemento visitado en la iteración}.
% 
% \begin{exercise}
% \ 
% \begin{enumerate}
% \item
% ¿Puedo cambiar el binding de la línea 64 por uno sobre
% \verb|$_| dentro del falso \verb|for|? ¿Ganamos algo con ello?
% 
% \item
% ¿Puedo cambiar la comprobación en las líneas 61-62
% por una primera línea dentro del falso \verb|for| que diga
% \verb|$_ or return('',undef);|?
% 
% \item
% ¿Cuántas veces se ejecuta el falso bucle si \verb|$parser->YYData->{INPUT}|
% contiene la cadena vacía?
% 
% %Las líneas 61-62 contienen un sutil error ¿Cual es?.
% %
% \item
% ¿Que ocurrirá en las líneas 61-62 
% si \verb|$parser->YYData->{INPUT}| contiene sólamente la cadena '0'?
% \end{enumerate}
% 
% \end{exercise}
% 
% \paragraph{Acciones por Defecto}
% 
% En el ejemplo anterior la acción es asociada con los nodos
% \verb|PLUS|, \verb|MINUS|, \verb|TIMES| y \verb|DIV| es similar.
% \verb|Parse::Eyapp| proporciona una directiva \verb|%|\tei{defaultaction}
% la cual permite especificar la acción por defecto. Esta acción es asociada
% con las reglas que no tienen una acción asociada explícita. El siguiente
% ejemplo muestra su uso:
% 
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> cat -n trans_scheme_default_action.pl
%  1  #!/usr/bin/perl
%  2  use strict;
%  3  use warnings;
%  4  use Data::Dumper;
%  5  use Parse::Eyapp;
%  6  use IO::Interactive qw(interactive);
%  7
%  8  my $translationscheme = q{
%  9    %{
% 10    # head code is available at tree construction time
% 11    use Data::Dumper;
% 12
% 13    our %sym; # symbol table
% 14    %}
% 15
% 16    %defaultaction { $lhs->{n} = eval " $left->{n} $_[2]->{attr} $right->{n} " }
% 17
% 18    %metatree
% 19
% 20    %right   '='
% 21    %left   '-' '+'
% 22    %left   '*' '/'
% 23
% 24    %%
% 25    line:       %name EXP
% 26                  exp <+ ';'> /* Expressions separated by semicolons */
% 27                    { $lhs->{n} = $_[1]->Last_child->{n} }
% 28    ;
% 29
% 30    exp:
% 31                %name PLUS
% 32                  exp.left '+' exp.right
% 33            |   %name MINUS
% 34                  exp.left '-' exp.right
% 35            |   %name TIMES
% 36                  exp.left '*' exp.right
% 37            |   %name DIV
% 38                  exp.left '/' exp.right
% 39            |   %name NUM   $NUM
% 40                    { $lhs->{n} = $NUM->{attr} }
% 41            |   '(' $exp ')'  %begin { $exp }
% 42            |   %name VAR
% 43                  $VAR
% 44                    { $lhs->{n} = $sym{$VAR->{attr}}->{n} }
% 45            |   %name ASSIGN
% 46                  $VAR '=' $exp
% 47                    { $lhs->{n} = $sym{$VAR->{attr}}->{n} = $exp->{n} }
% 48
% 49    ;
% 50
% 51    %%
% 52    sub Error {
% 53      die "Syntax error near ".($_[0]->YYCurval?$_[0]->YYCurval:"end of file")."\n";
% 54    }
% 55
% 56    sub Lexer {
% 57      my($parser)=shift;
% 58
% 59      for ($parser->YYData->{INPUT}) {
% 60        s/^\s*//;
% 61        $_ eq '' and  return('',undef);
% 62        s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
% 63        s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
% 64        s/^(.)// and return($1,$1);
% 65      }
% 66    }
% 67  }; # end translation scheme
% 68
% 69  $Data::Dumper::Indent = 1;
% 70  $Data::Dumper::Terse = 1;
% 71  $Data::Dumper::Deepcopy  = 1;
% 72  my $warnings = Parse::Eyapp->new_grammar(
% 73    input=>$translationscheme,
% 74    classname=>'Calc',
% 75    firstline => 6,
% 76    outputfile => 'Calc.pm');
% 77  die "$warnings\nSolve Ambiguities. See file main.output\n"  if $warnings;
% 78  my $parser = Calc->new();
% 79  print {interactive} "Write a sequence of arithmetic expressions: ";
% 80  $parser->YYData->{INPUT} = <>;
% 81  my $t = $parser->YYParse( yylex => \&Calc::Lexer, yyerror => \&Calc::Error );
% 82  $t->translation_scheme;
% 83  my $treestring = Dumper($t);
% 84  my $symboltable;
% 85  {
% 86    no warnings;
% 87    $symboltable = Dumper(\%Calc::sym);
% 88  }
% 89  print <<"EOR";
% 90  ***********Tree*************
% 91  $treestring
% 92  ******Symbol table**********
% 93  $symboltable
% 94  ************Result**********
% 95  $t->{n}
% 96
% 97  EOR
% \end{verbatim}
% 
% El método \tei{Last\_child} usado en la línea 27 devuelve una referencia al
% último hijo no código del nodo.
% Al ser \verb|$_[1]| un nodo de tipo \tei{'\_PLUS\_LIST'} queda garantizado que
% el último hijo no es una referencia a una subrutina asi que podría haberse 
% usado el método \tei{last\_child} el cual devuelve el último hijo 
% del nodo, sea este código o no.
% 
% La línea 86 tiene por efecto desactivar los avisos. De otra manera se produciría 
% un \tei{warning} con respecto al uso único de la variable \verb|%Calc::sym|:
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> echo "a=2*3; b=a+1" | trans_scheme_default_action.pl
% Name "Calc::sym" used only once: possible typo at trans_scheme_default_action.pl line 85.
% ***********Tree*************
% bless( {
%   'n' => 7,
%   'children' => [
%     ............
%   ]
% }, 'EXP' )
% 
% ******Symbol table**********
% {
%   'a' => { 'n' => 6 },
%   'b' => { 'n' => 7 }
% }
% 
% ************Result**********
% 7
% \end{verbatim}
% 
% \paragraph{Un Esquema  de Traducción para las Declaraciones de Variables}
% En el siguiente ejemplo se muestra la implementación en \verb|eyapp| del ejemplo
% \ref{example:typesandts}. El código es similar salvo por la presencia 
% de flechas de referenciado:
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n trans_scheme_simple_decls2.pl
%  1  #!/usr/bin/perl -w
%  2  use strict;
%  3  use Data::Dumper;
%  4  use Parse::Eyapp;
%  5  our %s; # symbol table
%  6
%  7  my $ts = q{
%  8    %token FLOAT INTEGER NAME
%  9
% 10    %{
% 11    our %s;
% 12    %}
% 13
% 14    %metatree
% 15
% 16    %%
% 17    Dl:  D <* ';'>
% 18    ;
% 19
% 20    D : $T { $L->{t} = $T->{t} } $L
% 21    ;
% 22
% 23    T : FLOAT    { $lhs->{t} = "FLOAT" }
% 24      | INTEGER  { $lhs->{t} = "INTEGER" }
% 25    ;
% 26
% 27    L : $NAME
% 28          { $NAME->{t} = $lhs->{t}; $s{$NAME->{attr}} = $NAME }
% 29      | $NAME { $NAME->{t} = $lhs->{t}; $L->{t} = $lhs->{t} } ',' $L
% 30          { $s{$NAME->{attr}} = $NAME }
% 31    ;
% 32    %%
% 33  };
% 34
% 35  sub Error { die "Error sintáctico\n"; }
% 36
% 37  { # Closure of $input, %reserved_words and $validchars
% 38    my $input = "";
% 39    my %reserved_words = ();
% 40    my $validchars = "";
% 41
% 42    sub parametrize__scanner {
% 43      $input = shift;
% 44      %reserved_words = %{shift()};
% 45      $validchars = shift;
% 46    }
% 47
% 48    sub scanner {
% 49      $input =~ m{\G\s+}gc;                     # skip whites
% 50      if ($input =~ m{\G([a-z_A_Z]\w*)\b}gc) {
% 51        my $w = uc($1);                 # upper case the word
% 52        return ($w, $w) if exists $reserved_words{$w};
% 53        return ('NAME', $1);            # not a reserved word
% 54      }
% 55      return ($1, $1) if ($input =~ m/\G([$validchars])/gc);
% 56      die "Caracter invalido: $1\n" if ($input =~ m/\G(\S)/gc);
% 57      return ('', undef); # end of file
% 58    }
% 59  } # end closure
% 60
% 61  Parse::Eyapp->new_grammar(input=>$ts, classname=>'main', outputfile=>'Types.pm');
% 62  my $parser = main->new(yylex => \&scanner, yyerror => \&Error); # Create the parser
% 63
% 64  parametrize__scanner(
% 65    "float x,y;\ninteger a,b\n",
% 66    { INTEGER => 'INTEGER', FLOAT => 'FLOAT'},
% 67    ",;"
% 68  );
% 69
% 70  my $t = $parser->YYParse() or die "Syntax Error analyzing input";
% 71
% 72  $t->translation_scheme;
% 73
% 74  $Data::Dumper::Indent = 1;
% 75  $Data::Dumper::Terse = 1;
% 76  $Data::Dumper::Deepcopy  = 1;
% 77  $Data::Dumper::Deparse = 1;
% 78  print Dumper($t);
% 79  print Dumper(\%s);
% \end{verbatim}
% Al ejecutarlo con la entrada \verb|"float x,y;\ninteger a,b\n"|
% los contenidos finales del arbol son:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> trans_scheme_simple_decls2.pl
% bless({'children'=>[
%    bless({'children'=>[
%    |   bless({'children'=>[
%    |   |   bless({'children'=>[
%    |   |   |   bless({'children'=>[],'attr'=>'FLOAT','token'=>'FLOAT'},'TERMINAL'),
%    |   |   |   sub {use strict 'refs'; my $lhs=$_[0]; $$lhs{'t'}='FLOAT'; }
%    |   |   | ],
%    |   |   | 't'=>'FLOAT'
%    |   |   },'T_8'),       # T -> FLOAT
%    |   |   sub { ... },
%    |   |   bless({'children'=>[
%    |   |   |   bless({'children'=>[],'attr'=>'x','token'=>'NAME','t'=>'FLOAT'},'TERMINAL'),
%    |   |   |   sub{ ... },
%    |   |   |   bless({'children'=>[],'attr'=>',','token'=>','},'TERMINAL'),
%    |   |   |   bless({'children'=>[
%    |   |   |   |   bless({'children'=>[],'attr'=>'y','token'=>'NAME','t'=>'FLOAT'},
%    |   |   |   |         'TERMINAL'),
%    |   |   |   |   sub{ ... }
%    |   |   |   | ],
%    |   |   |   | 't'=>'FLOAT'
%    |   |   |   },'L_10'), # L -> NAME
%    |   |   |   sub{ ... }
%    |   |   | ],
%    |   |   | 't'=>'FLOAT'
%    |   |   },'L_11'),     # L -> NAME ',' L 
%    |   |   undef
%    |   | ]
%    |   },'D_6'),          # D -> T L
%    |   bless({ 
%    |    ... # tree for integer a, b
%    |   },'D_6')           # D -> T L
%    | ]
%    },'_STAR_LIST_1'),
%  ]
% },'Dl_5')   # Dl : D <* ';'> equivale a: Dl : /* empty */ | S_2; S_2: S_1; S_1: S_1 ';' D | D 
% \end{verbatim}
% Los contenidos de la tabla de símbolos \verb|%s| quedan como sigue:
% \begin{verbatim}
% {
%  'y'=>bless({'children'=>[],'attr'=>'y','token'=>'NAME','t'=>'FLOAT'},'TERMINAL'),
%  'a'=>bless({'children'=>[],'attr'=>'a','token'=>'NAME','t'=>'INTEGER'},'TERMINAL'),
%  'b'=>bless({'children'=>[],'attr'=>'b','token'=>'NAME','t'=>'INTEGER'},'TERMINAL'),
%  'x'=>bless({'children'=>[],'attr'=>'x','token'=>'NAME','t'=>'FLOAT'},'TERMINAL')
% }
% \end{verbatim}
% 
% \paragraph{Prefijos}
% \label{paragraph:prefix}
% Como se ha mencionado, durante la fase \emph{Tree Construction}
% los nodos son bendecidos en el nombre de la regla
% de producción. \cei{El nombre de una regla de producción} es, por defecto,
% la concatenación de la variable en el lado izquierdo
% (\cei{LHS}) con el número de orden de la regla. 
% Es  posible modificar el nombre por defecto usando
% la directiva \tei{\%name}. 
% 
% {\it Si se desean evitar posibles colisiones con clases existentes
% es posible prefijar todos los nombres de las clases
% con un prefijo dado usando el parámetro \tei{yyprefix} en la llamada
% al constructor del analizador}:
% 
% \begin{verbatim}
% my $warnings = Parse::Eyapp->new_grammar(
%   input=>$translationscheme,
%   classname=>'main',
%   firstline => 6,
%   outputfile => 'main.pm');
% die "$warnings\nSolve Ambiguities. See file main.output\n"  if $warnings;
% 
% # Prefix all the classes with 'Calc::'
% my $parser = main->new(yyprefix => 'Calc::');
% \end{verbatim}
% El resultado de esta llamada a \verb|new| es que las clases de los nodos 
% quedan prefijadas con \verb|Calc::|. Por ejemplo el árbol creado
% para la frase \verb|a=1| será:
% \begin{verbatim}
% bless( { 'children' => [
%     bless( { 'children' => [
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'Calc::TERMINAL' ),
%             bless( { 'children' => [], 'attr' => '=', 'token' => '=' }, 'Calc::TERMINAL' ),
%             bless( { 'children' => [
%                 bless( { 'children' => [], 'attr' => '1', 'token' => 'NUM' }, 'Calc::TERMINAL' ),
%               ]
%             }, 'Calc::NUM' ),
%           ]
%         }, 'Calc::ASSIGN' )
%       ]
%     }, 'Calc::_PLUS_LIST' ),
%   ]
% }, 'Calc::EXP' )
% \end{verbatim}
% 
% \paragraph{Modo Standalone}
% Es mas eficiente aislar el código del esquema de traducción en un fichero 
% (se asume por defecto el tipo \verb|.eyp|) y generar el módulo que contiene
% el código del analizador usando el guión \tei{eyapp}.
% 
% El siguiente ejemplo muestra un ejemplo de compilación separada.
% El esquema de traducción convierte expresiones
% en infijo a postfijo. De un lado tenemos el fichero \verb|TSPostfix2.eyp|
% conteniendo el esquema:
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n TSPostfix2.eyp
%  1  # File TSPostfix2.eyp
%  2  %right  '='
%  3  %left   '-' '+'
%  4  %left   '*' '/'
%  5  %left   NEG
%  6
%  7  %{
%  8    use Data::Dumper;
%  9    $Data::Dumper::Indent = 1;
% 10    $Data::Dumper::Deepcopy = 1;
% 11    #$Data::Dumper::Deparse = 1;
% 12    use IO::Interactive qw(interactive);
% 13  %}
% 14
% 15  %metatree
% 16
% 17  %defaultaction {
% 18    if (@_==4) { # binary operations: 4 = lhs, left, operand, right
% 19      $lhs->{t} = "$_[1]->{t} $_[3]->{t} $_[2]->{attr}";
% 20      return
% 21    }
% 22    die "Fatal Error. Unexpected input\n".Dumper(@_);
% 23  }
% 24
% 25  %%
% 26  line: %name PROG
% 27         exp <%name EXP + ';'>
% 28           { @{$lhs->{t}} = map { $_->{t}} ($lhs->child(0)->Children()); }
% 29
% 30  ;
% 31
% 32  exp:        NUM         { $lhs->{t} = $_[1]->{attr}; }
% 33          |   VAR         { $lhs->{t} = $_[1]->{attr}; }
% 34          |   VAR '=' exp { $lhs->{t} = "$_[1]->{attr} $_[3]->{t} =" }
% 35          |   exp '+' exp
% 36          |   exp '-' exp
% 37          |   exp '*' exp
% 38          |   exp '/' exp
% 39          |   '-' exp %prec NEG { $_[0]->{t} = "$_[2]->{t} NEG" }
% 40          |   '(' exp ')' %begin { $_[2] }
% 41  ;
% 42
% 43  %%
% 44
% 45  sub _Error {
% 46      my($token)=$_[0]->YYCurval;
% 47
% 48      my($what)= $token ? "input: '$token'" : "end of input";
% 49      die "Syntax error near $what.\n";
% 50  }
% 51
% 52  my $x; # Used for input
% 53
% 54  sub _Lexer {
% 55      my($parser)=shift;
% 56
% 57      $x =~ s/^\s+//;
% 58      return('',undef) if $x eq '';
% 59
% 60
% 61      $x =~ s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
% 62      $x =~ s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
% 63      $x =~ s/^(.)//s                    and return($1,$1);
% 64  }
% 65
% 66  sub Run {
% 67      my($self)=shift;
% 68      $x = <>;
% 69      my $tree = $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error,
% 70        #yydebug => 0xFF
% 71      );
% 72
% 73      print Dumper($tree);
% 74      $tree->translation_scheme();
% 75      print Dumper($tree);
% 76      {
% 77        local $" = ";";
% 78        print "Translation:\n@{$tree->{t}}\n";
% 79      }
% 80  }
% 81
% \end{verbatim}
% Observe el uso del método \tei{Children} - con {\tt C} mayúscula -
% en la línea 28: 
% \emph{devuelve los hijos del nodo no incluyendo las referencias
% a subrutinas}.
% A diferencia de su homólogo con {\tt c}  minúscula  \tei{children} 
% el cual devuelve todos los hijos del nodo, 
% incluyendo las referencias al código empotrado.
% 
% Compilamos con \verb|eyapp|:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> eyapp TSPostfix2
% nereida:~/src/perl/YappWithDefaultAction/examples> ls -ltr | tail -2
% -rw-r-----  1 pl users   1781 2006-10-30 13:08 TSPostfix2.eyp
% -rw-r--r--  1 pl users   7611 2006-10-30 13:12 TSPostfix2.pm
% \end{verbatim}
% 
% De otro lado tenemos el programa cliente 
% el cual  se limita a cargar el módulo y llamar
% al método \verb|Run|:
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n usetspostfix2.pl
%      1  #!/usr/bin/perl -w
%      2  use strict;
%      3  use TSPostfix2;
%      4
%      5  my $parser = new TSPostfix2();
%      6  $parser->Run;
% \end{verbatim}
% Al ejecutar el programa se produce una salida similar a esta
% (la salida ha sido editada para darle mayor claridad):
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> usetspostfix2.pl
%  1  a=2
%  2  ...
%  3  $VAR1 = bless( { 'children' => [
%  4      bless( { 'children' => [
%  5      |   bless( { 'children' => [
%  6      |   |   bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%  7      |   |   bless( { 'children' => [], 'attr' => '=', 'token' => '=' }, 'TERMINAL' ),
%  8      |   |   bless( { 'children' => [
%  9      |   |       bless( { 'children' => [], 'attr' => '2', 'token' => 'NUM' }, 'TERMINAL' ),
% 10      |   |       sub { "DUMMY" }
% 11      |   |     ],
% 12      |   |     't' => '2'
% 13      |   |   }, 'exp_4' ),
% 14      |   |   sub { "DUMMY" }
% 15      |   | ],
% 16      |   | 't' => 'a 2 ='
% 17      |   }, 'exp_6' )
% 18      | ]
% 19      }, 'EXP' ),
% 20      sub { "DUMMY" }
% 21    ],
% 22    't' => [ 'a 2 =' ]
% 23  }, 'PROG' );
% 24  Translation:
% 25  a 2 =
% \end{verbatim}
% 
% Como puede verse en la salida, cuando no se especifica el nombre del nodo asociado
% con la regla de producción se genera un \cei{nombre por defecto} que consiste en la concatenación
% del nombre de la variable sintáctica en el lado izquierdo y el número de orden 
% de la regla de producción. Así el nodo descrito en las líneas 5-17 tiene por nombre 
% \verb|exp_6| indicando que corresponde a la sexta regla de producción de \verb|exp|.
% 
% El nodo en las líneas 4-19 tiene por nombre \verb|EXP|. Su nombre
% le fué dado mediante la directiva \verb|%name| en la línea
% \begin{verbatim}
% 27         exp <%name EXP + ';'>
% \end{verbatim}
% Es posible insertar una directiva \tei{\%name en una lista} usando esta
% sintáxis.
% 
% Nótese también que si hubieramos usado la opción \tei{Data::Dumper::Deparse} (línea 11) podríamos
% hacer que \verb|Data::Dumper| nos informe no sólo de la presencia de código
% sino que nos muestre el código fuente que ocupa esa posición.
% 
% \section{Manipulación del Árbol Sintáctico}
% El
% módulo \verb|Parse::Eyapp::Treeregexp| permite la transformación de
% árboles mediante el uso de \cei{Expresiones Regulares Arbol}.
% Las expresiones regulares árbol serán introducidas en mas detalle en la 
% sección 
% \ref{section:aat}.
% 
% \paragraph{Optimización del Traductor de Infijo a Postfijo}
% 
% El siguiente ejemplo modifica el anterior esquema de traducción
% de infijo a postfijo para producir un código de postfijo
% mas eficiente. Para ello se transforma el árbol generado 
% durante la fase  {\it Tree Construction Time} y antes de la fase 
% {\it Execution Time}. El código \cei{Treeregexp} 
% que define el conjunto de transformaciones
% se encuentra en las líneas 74-103.
% 
% Las transformaciones consisten en
% \begin{enumerate}
% \item
% Compactar los árboles \verb|UMINUS| a un número negativo
% \item
% Realizar \cei{plegado de constantes}: sustituir 
% los árboles de constantes por su evaluación
% \item
% Sustituir los árboles producto en los que uno de los factores es cero
% por el número cero.
% \end{enumerate}
% 
% Después de ello se realiza la traducción quedando la misma
% como el atributo \verb|t| del 
% nodo raíz (línea 120). 
% 
% A partir de este momento, 
% si el traductor tuviera un mayor número de fases
% de posterior tratamiento del árbol, 
% los nodos de tipo código y los nodos hoja cuya funcionalidad es
% puramente sintáctica como los terminales \verb|=|, \verb|*| etc.
% pueden ser eliminados. Es por eso que los suprimimos en las
% líneas 122-123.
% 
% Veamos primero el código y luego lo discutiremos en mas detalle:
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n TSwithtreetransformations.eyp
%    1  # File TSwithtreetransformations.eyp
%    2  %right  '='
%    3  %left   '-' '+'
%    4  %left   '*' '/'
%    5  %left   NEG
%    6
%    7  %{
%    8    # Treeregexp is the engine for tree transformations
%    9    use Parse::Eyapp::Treeregexp;
%   10    use Data::Dumper;
%   11    $Data::Dumper::Indent = 1;
%   12    $Data::Dumper::Deepcopy = 1;
%   13    $Data::Dumper::Deparse = 1;
%   14  %}
%   15
%   16  %metatree
%   17
%   18  %defaultaction {
%   19    if (@_==4) { # binary operations: 4 = lhs, left, operand, right
%   20      $lhs->{t} = "$_[1]->{t} $_[3]->{t} $_[2]->{attr}";
%   21      return
%   22    }
%   23    die "Fatal Error. Unexpected input\n".Dumper(@_);
%   24  }
%   25
%   26  %%
%   27  line: %name PROG
%   28         exp <%name EXP + ';'>
%   29           { @{$lhs->{t}} = map { $_->{t}} ($lhs->child(0)->Children()); }
%   30
%   31  ;
%   32
%   33  exp:      %name NUM     NUM         { $lhs->{t} = $_[1]->{attr}; }
%   34          | %name VAR     VAR         { $lhs->{t} = $_[1]->{attr}; }
%   35          | %name ASSIGN  VAR '=' exp { $lhs->{t} = "$_[1]->{attr} $_[3]->{t} =" }
%   36          | %name PLUS    exp '+' exp
%   37          | %name MINUS   exp '-' exp
%   38          | %name TIMES   exp '*' exp
%   39          | %name DIV     exp '/' exp
%   40          | %name UMINUS  '-' exp %prec NEG { $_[0]->{t} = "$_[2]->{t} NEG" }
%   41          |               '(' exp ')' %begin { $_[2] } /* skip parenthesis */
%   42  ;
%   43
%   44  %%
%   45
%   46  # subroutines  _Error and _Lexer
%   ..  ................................
%   66
%   67  sub Run {
%   68      my($self)=shift;
%   69      print "input: "; $x = <>;
%   70      my $tree = $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error,
%   71        #yydebug => 0xFF
%   72      );
%   73
%   74      my $transform = Parse::Eyapp::Treeregexp->new( STRING => q{
%   75
%   76        delete_code : CODE => { $delete_code->delete() }
%   77
%   78        {
%   79          sub not_semantic {
%   80            my $self = shift;
%   81            return  1 if $self->{token} eq $self->{attr};
%   82            return 0;
%   83          }
%   84        }
%   85
%   86        delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => { $delete_tokens->delete() }
%   87
%   88        delete = delete_code delete_tokens;
%   89
%   90        uminus: UMINUS(., NUM($x), .) => { $x->{attr} = -$x->{attr}; $_[0] = $NUM }
%   91
%   92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
%   93           => {
%   94          $x->{attr} = eval  "$x->{attr} $W->{attr} $y->{attr}";
%   95          $_[0] = $NUM[0];
%   96        }
%   97
%   98        zero_times: TIMES(NUM($x), ., .) and { $x->{attr} == 0 } => { $_[0] = $NUM }
%   99        times_zero: TIMES(., ., NUM($x)) and { $x->{attr} == 0 } => { $_[0] = $NUM }
%  100
%  101        algebraic_transformations = constantfold zero_times times_zero;
%  102
%  103      },
%  104      PACKAGE => 'TSwithtreetransformations',
%  105      OUTPUTFILE => 'main.pm',
%  106      SEVERITY => 0,
%  107      NUMBERS => 0,
%  108      );
%  109
%  110      # Create the transformer
%  111      $transform->generate();
%  112      # Get the AST
%  113
%  114      our ($uminus);
%  115      $uminus->s($tree);
%  116
%  117      our (@algebraic_transformations);
%  118      $tree->s(@algebraic_transformations);
%  119
%  120      $tree->translation_scheme();
%  121
%  122      our (@delete);
%  123      $tree->s(@delete);
%  124      print Dumper($tree);
%  125  }
% \end{verbatim}
% 
% \paragraph{La Estructura de un Programa {\tt Treeregexp}}
% 
% La estructura de un programa \tei{Treeregexp} es sencilla. Consiste en la repetición
% de tres tipos de expresiones regulares árbol: las \cei{treeregexp} propiamente
% dichas, \cei{código auxiliar para las transformaciones} y 
% \cei{definiciones de familias de transformaciones}.
% 
% \begin{verbatim}
% treeregexplist:  
%     treeregexp* 
% ;
% 
% treeregexp: 
%     IDENT ':' treereg ('=>' CODE)?  # Treeregexp 
%   | CODE                            # Código auxiliar
%   | IDENT '=' IDENT + ';'           # Familia de transformaciones
% ;
% \end{verbatim}
% 
% Las expresiones regulares árbol propiamente dichas siguen la regla 
% 
% \begin{verbatim}
%                   IDENT ':' treereg ('=>' CODE)?
% \end{verbatim}
% 
% Podemos ver ejemplos de instancias de esta regla en las líneas 
% 76, 86, 90, 92-96, 98 y 99. El identificador \verb|IDENT| da el nombre
% a la regla. Actualmente (2006) existen estos tipos de \tei{treereg}:
% 
% \begin{verbatim}
% treereg: 
%       /* patrones con hijos */
%     IDENT '(' childlist ')' ('and' CODE)? 
%   | REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)? 
%   | SCALAR '(' childlist ')' ('and' CODE)?  
%   | '.' '(' childlist ')' ('and' CODE)? 
%         /* hojas */
%   | IDENT ('and' CODE)? 
%   | REGEXP (':' IDENT)? ('and' CODE)? 
%   | '.' ('and' CODE)? 
%   | SCALAR ('and' CODE)? 
%   | ARRAY 
%   | '*' 
% \end{verbatim}
% 
% \paragraph{Las Reglas Treeregexp}
% 
% Una regla como
% \begin{verbatim}
%             zero_times: TIMES(NUM($x), ., .) and { $x->{attr} == 0 } => { $_[0] = $NUM }
% \end{verbatim}
% crea un objeto transformación (concretamente un objeto de la clase \tei{Parse::Eyapp:YATW})
% que puede ser referido a través de la variable escalar \verb|$zero_times|.
% La primera parte de la regla \verb|zero_times| indica que 
% para que se produzca el emparejamiento es necesario que el nodo visitado sea
% del tipo \verb|TIMES| y su primer
% hijo es de tipo \verb|NUM|. Una referencia al nodo hijo de \verb|NUM| será automáticamente
% guardada en la variable \underline{léxica} \verb|$x|. 
% 
% \paragraph{Escalares}
% 
% El efecto de un escalar en una treeregexp 
% es casar con cualquier nodo y almacenar su referencia en la variable.
% 
% La aparición de \verb|$x| en la treeregexp anterior 
% casará con cualquier nodo. La referencia al nodo que ha casado queda en \verb|$x|.
% Asi \verb|$x| podrá ser usado en el \cei{patrón árbol semántico} 
% o \cei{condición semántica}(esto es,
% en el código opcional que va precedido de la palabra reservada \verb|and|) 
% y en la \cei{acción de transformación árbol} (el código opcional que va precedido de la 
% flecha gorda \verb|=>|).
% 
% \paragraph{El Punto}
% 
% Un punto también casa con cualquier nodo. Puede verse como una abreviación de 
% la expresión regular árbol escalar. Una referencia al nodo que casa
% queda almacenada en la variable
% léxica especial \tei{\$W}. Si la expresión regular árbol tiene
% varios puntos sus referencias quedan almacenadas en la variable array \verb|@W|.
% Es un error usar el identificador \verb|W| en una expresión regular escalar 
% escalar. Por ejemplo, una treeregexp como:
% 
% \begin{verbatim}
% constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($W), ., NUM($y))
% \end{verbatim}
% 
% da lugar al error:
% 
% \begin{verbatim}
% *Error* Can't use $W to identify an scalar treeregexp at line 100.
% \end{verbatim}
% 
% \paragraph{Condiciones Semánticas}
% 
% \emph{La segunda parte de la regla} es opcional y comienza con la palabra reservada \verb|and|
% seguida de un código que \emph{explicita las condiciones semánticas que debe cumplir el nodo
% para que se produzca el casamiento}. En el ejemplo se explicita que el attributo del nodo 
% (forzosamente del tipo \verb|TERMINAL| en este caso) referenciado por \verb|$x| debe ser cero.
% 
% \paragraph{Referenciado de los Nodos del Arbol}
% 
% Es posible dentro de las partes de código referirse a los nodos del árbol.
% Cuando la rutina de transformación generada por el compilador para una 
% treeregexp es llamada, el primer argumento \verb|$_[0]| contiene la referencia al nodo 
% que esta siendo visitado. 
% 
% \verb|Parse::Eyapp::Treeregexp| crea variables léxicas con nombres
% los tipos de los nodos a los que referencian. 
% Así la subrutina generada para la transformación \verb|zero_times| 
% 
% \begin{verbatim}
%      zero_times: TIMES(NUM($x), ., .) and { $x->{attr} == 0 } => { $_[0] = $NUM }
% \end{verbatim}
% 
% guarda en la variable lexica \verb|$TIMES| una copia de \verb|$_[0]| y en 
% la variable léxica \verb|$NUM| una referencia al nodo \verb|$TIMES->child(0)| .
% 
% Si un tipo de nodo se repite en la treeregexp la variable léxica
% asociada con dicho tipo se autodeclara como un array. Este es el caso de 
% la transformación \verb|constantfold|
% en la cual aparecen dos nodos de tipo \verb|NUM|:
% \begin{verbatim}
% 92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
% 93           => {
% 94          $x->{attr} = eval  "$x->{attr} $W->{attr} $y->{attr}";
% 95          $_[0] = $NUM[0];
% 96        }
% \end{verbatim}
% La variable \verb|@NUM| es automáticamente declarada: \verb|$NUM[0]| es una
% referencia al primer nodo \verb|NUM| y \verb|$NUM[1]| es una referencia
% al segundo.
% 
% \paragraph{Código de Transformación}
% 
% \emph{La tercera parte de la regla} es también opcional y viene precedida de la \cei{flecha gorda}.
% Habitualmente {contiene el código que transforma el árbol}.
% Para lograr la modificación del nodo del árbol visitado el programador
% \verb|Treeregexp| deberá usar \verb|$_[0]|. Recuerde que
% los elementos en \verb|@_| son alias de los argumentos. Si el código 
% de la tercera parte fuera reescrito como:
% \begin{verbatim}
%                             { $TIMES = $NUM }
% \end{verbatim}
% no funcionaría ya que estaríamos modificando la variable léxica que referencia al
% nodo raíz del subarbol que ha casado.
% 
% \paragraph{Expresiones Regulares}
% Es posible usar una expresión regular clásica lineal (\cei{regexp}) para 
% explicitar el tipo de un nodo como indica la regla de producción:
% 
% \begin{verbatim}
%       treereg: REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)? 
% \end{verbatim}
% 
% La treeregexp para el plegado de constantes constituye un ejemplo:
% 
% \begin{verbatim}
%   92        constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
%   93           => {
%   94                $x->{attr} = eval  "$x->{attr} $W->{attr} $y->{attr}";
%   95                $_[0] = $NUM[0];
%   96              }
% \end{verbatim}
% 
% La expresión regular deberá especificarse entre barras de división (\verb|/|)
% y es posible especificar opciones después del segundo slash (\verb|e|, \verb|i|, etc.).
% El identificador opcional después de la regexp indica el nombre para la
% variable léxica que almacenará una copia de la referencia al nodo del árbol.
% En el ejemplo \verb|$bin| podría usarse para referenciar al nodo apuntado por \verb|$_[0]|.
% Si no se especifica identificador quedará almacenado en la variable léxica
% especial \verb|$W|.  Si la expresión regular árbol tiene
% varias regexp (y/o puntos) sus referencias quedan almacenadas en la variable array \verb|@W|.
% 
% \paragraph{Familias de Transformaciones}
% Las transformaciones creadas por \verb|Parse::Eyapp::Treeregexp| pueden agruparse por familias.
% Esta es la función de la regla de producción:
% \begin{verbatim}
%                     treeregexp: IDENT '=' IDENT + ';' 
% \end{verbatim}
% En el ejemplo creamos una nueva familia denominada \verb|algebraic_transformations|
% mediante la asignación de la línea 101:
% \begin{verbatim}
% algebraic_transformations = constantfold zero_times times_zero;
% \end{verbatim}
% Las transformaciones en esa familia pueden ser accedidas posteriormente
% para su aplicación mediante la
% variable de paquete \verb|@algebraic_transformations| (véanse las líneas 
% 117-118).
% 
% \paragraph{Codigo de Apoyo}
% En medio de la definición de cualquier regla treeregexp es posible insertar 
% código de apoyo siempre que se sitúe entre llaves:
% 
% \begin{verbatim}
%   78        {
%   79          sub not_semantic {
%   80            my $self = shift;
%   81            return  1 if $self->{token} eq $self->{attr};
%   82            return 0;
%   83          }
%   84        }
%   85
%   86        delete_tokens : TERMINAL and { not_semantic($TERMINAL) } => { $delete_tokens->delete() }
% \end{verbatim}
% 
% \paragraph{El método {\tt delete} de los objetos {\tt YATW}}
% 
% Los objetos de la clase \tei{Parse::Eyapp::YATW} como \verb|$delete_tokens| disponen
% de un método \tei{delete} que permite eliminar con seguridad un hijo de la raíz del 
% subárbol que ha casado. En este caso los nodos que casan son los de la clase \verb|TERMINAL| 
% en los que el valor de la clave \verb|token| coincide con el valor de la clave \verb|attr|.
% 
% \paragraph{Fases en la Ejecución de un Programa {\tt Treeregexp}}
% Un programa {\tt Treeregexp} puede - como en el ejemplo - proporcionarse como una
% cadena de entrada al método \verb|new| de la clase \verb|Parse::Eyapp::Treeregexp|
% o bien escribirse en un fichero separado (la extensión \verb|.trg| es usada por
% defecto) y compilado con el script \tei{treereg} que acompaña a la distribución de
% \verb|Parse::Eyapp|.
% 
% La primera fase en la ejecución de un programa \tei{Treeregexp}
% es la \cei{fase de creación del paquete {\tt Treeregexp}}
% que contendrá las subrutinas
% de reconocimiento de los patrones árbol definidos en el programa {\tt Treeregexp}.
% En el ejemplo esta fase tiene lugar en las líneas
% 74-111 con las llamadas a \verb|new| (que crea el objeto programa {\tt Treeregexp})
% y \tei{generate} (que crea el paquete conteniendo las subrutinas reconocedoras).
% \begin{verbatim}
%   74      my $transform = Parse::Eyapp::Treeregexp->new( STRING => q{
%   75
%   76        delete_code : CODE => { $delete_code->delete() }
%  ...        ................................................
%  103      },
%  104      PACKAGE => 'TSwithtreetransformations',
%  105      OUTPUTFILE => 'main.pm',
%  106      SEVERITY => 0,
%  107      NUMBERS => 0,
%  108      );
%  109
%  110      # Create the transformer
%  111      $transform->generate();
% \end{verbatim}
% 
% Durante esta fase se crea un \cei{objeto transformación} i(perteneciente a la clase \tei{Parse::Eyapp::YATW})
% por cada expresión regular árbol que aparece en el programa {\tt Treeregexp}.
% Las variables contenedor de cada uno de esos objetos tienen por nombre el que se
% les dió a las correspondientes expresiones regulares árbol. En nuestro ejemplo, y después
% de esta fase habrán sido creadas variables escalares de paquete 
% \verb|$delete_tokens|, \verb|$delete|, \verb|$uminus|, \verb|$constantfold|, \verb|$zero_times| 
% y \verb|$times_zero|
% asociadas con cada una de las expresiones regulares árbol definidas.
% También se crearán variables array para cada una de las
% familias de transformaciones especificadas: Asi  la variable
% \verb|@delete| contiene \verb|($delete_tokens, $delete)| y la variable
% \verb|@algebraic_transformations|
% es igual a \verb|($constantfold, $zero_times, $times_zero)|. La variable de paquete especial
% \verb|@all| es un array que contiene todas las transformaciones definidas en el programa.
% 
% Una vez creados los objetos transformación y las familias de transformaciones
% \verb|Parse::Eyapp::YATW| podemos proceder a transformar el árbol
% mediante su uso.
% Esto puede hacerse mediante el método \tei{s} el cual procede 
% a modificar el árbol pasado como parámetro.
% \begin{verbatim}
%  114      our ($uminus);
%  115      $uminus->s($tree);
% \end{verbatim}
% En el ejemplo la llamada \verb|$uminus->s($tree)| da lugar al 
% recorrido  primero-profundo de \verb|$tree|. Cada vez que un nodo 
% casa con la regla:
% \begin{verbatim}
% UMINUS(., NUM($x), .) # first child is '-', second the number and third the code
% \end{verbatim}
% se le aplica la transformación:
% \begin{verbatim}
% { $x->{attr} = -$x->{attr}; $_[0] = $NUM }
% \end{verbatim}
% Esta transformación hace que el nodo \verb|UMINUS| visitado sea sustituido 
% por un nodo de tipo \verb|NUM| cuyo atributo sea el número de su hijo
% \verb|NUM| cambiado de signo.
% 
% Las líneas 117-118 nos muestran como someter un árbol a un conjunto 
% de transformaciones:
% \begin{verbatim}
%  117      our (@algebraic_transformations);
%  118      $tree->s(@algebraic_transformations);
% \end{verbatim}
% Los objetos nodo (esto es, los que pertenecen a la clase \tei{Parse::Eyapp::Node})
% disponen del método \tei{s} que recibe como argumentos una familia de 
% transformaciones. La familia de transformaciones es aplicada iterativamente
% al árbol hasta que este no cambia. 
% 
% Nótese que consecuencia de esta definición es que es posible escribir transformaciones
% que dan lugar a bucles infinitos. Por ejemplo si en \verb|@algebraic_transformations|
% incluimos una transformación que aplique las propiedades conmutativas de la 
% suma:
% \begin{verbatim}
%  commutative_add: PLUS($x, ., $y, .)
%         => { my $t = $x; $_[0]->child(0, $y); $_[0]->child(2, $t)}
% \end{verbatim}
% el programa podría caer en un bucle infinito ya que la transformación es
% susceptible de ser aplicada indefinidamente. Sin embargo no se produce bucle infinito
% si llamamos al código asociado a la transformación:
% \begin{verbatim}
% $commutative_add->($tree);
% \end{verbatim}
% 
% ya que en este caso se produce un sólo recursivo descendente aplicando la transformación
% \verb|$commutative_add|.
% 
% El uso de transformaciones conmutativas no tiene porque dar lugar a 
% la no finalización del programa. La parada del programa se puede
% garantizar si \emph{podemos asegurar que la aplicación reiterada
% del patrón implica la desaparición del mismo}. Por ejemplo,
% la transformación \verb|comasocfold| puede ser añadida
% a la familia \verb|algebraic_transformations| sin introducir
% problemas de parada:
% \begin{verbatim}
% comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
%    => {
%   $x->{attr} = $x->{attr} * $y->{attr};
%   $_[0] = $DIV;
% }
% 
% algebraic_transformations = constantfold zero_times times_zero comasocfold;
% \end{verbatim}
% La introducción de esta transformación permite el plegado de entradas como \verb|a=2;b=2/a*3|:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> usetswithtreetransformations3.pl
% a=2;b=2/a*3
% $VAR1 = bless( { 'children' => [
%     bless( { 'children' => [
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%             bless( { 'children' => [
%                 bless( { 'children' => [], 'attr' => 2, 'token' => 'NUM' }, 'TERMINAL' ) ],
%               't' => 2
%             }, 'NUM' )
%           ],
%           't' => 'a 2 ='
%         }, 'ASSIGN' ),
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' ),
%             bless( { 'children' => [
%                 bless( { 'children' => [
%                     bless( { 'children' => [], 'attr' => 6, 'token' => 'NUM' }, 'TERMINAL' )
%                   ],
%                   't' => 6
%                 }, 'NUM' ),
%                 bless( { 'children' => [
%                     bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' )
%                   ],
%                   't' => 'a'
%                 }, 'VAR' )
%               ],
%               't' => '6 a /'
%             }, 'DIV' )
%           ],
%           't' => 'b 6 a / ='
%         }, 'ASSIGN' )
%       ]
%     }, 'EXP' )
%   ],
%   't' => [ 'a 2 =', 'b 6 a / =' ]
% }, 'PROG' );
% \end{verbatim}
% 
% \paragraph{Ejecución del Ejemplo}
% 
% Una vez compilado el analizador, escribimos 
% el programa que usa el módulo generado:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n usetswithtreetransformations.pl
%      1  #!/usr/bin/perl -w
%      2  use strict;
%      3  use TSwithtreetransformations;
%      4  use Parse::Eyapp::Treeregexp;
%      5
%      6  my $parser = TSwithtreetransformations->new();
%      7  $parser->Run;
% \end{verbatim}
% Al ejecutarlo obtenemos la siguiente salida:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> eyapp TSwithtreetransformations.eyp ; \\
%                                                    usetswithtreetransformations.pl
% input: a=2*-3;b=a*(2-1-1);c=a+b
% $VAR1 = bless( { 'children' => [
%     bless( { 'children' => [
%     |   bless( { 'children' => [
%     |   |   bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   bless( { 'children' => [
%     |   |   |   bless( { 'children' => [], 'attr' => -6, 'token' => 'NUM' }, 'TERMINAL' )
%     |   |   | ],
%     |   |   | 't' => -6
%     |   |   }, 'NUM' )
%     |   | ],
%     |   | 't' => 'a -6 ='
%     |   }, 'ASSIGN' ),
%     |   bless( { 'children' => [
%     |   |   bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   bless( { 'children' => [
%     |   |   |   bless( { 'children' => [], 'attr' => 0, 'token' => 'NUM' }, 'TERMINAL' )
%     |   |   | ],
%     |   |   | 't' => 0
%     |   |   }, 'NUM' )
%     |   | ],
%     |   | 't' => 'b 0 ='
%     |   }, 'ASSIGN' ),
%     |   bless( { 'children' => [
%     |   |   bless( { 'children' => [], 'attr' => 'c', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   bless( { 'children' => [
%     |   |   |   bless( { 'children' => [
%     |   |   |       bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' )
%     |   |   |     ],
%     |   |   |     't' => 'a'
%     |   |   |   }, 'VAR' ),
%     |   |   |   bless( { 'children' => [
%     |   |   |       bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' )
%     |   |   |     ],
%     |   |   |     't' => 'b'
%     |   |   |   }, 'VAR' )
%     |   |   | ],
%     |   |   | 't' => 'a b +'
%     |   |   }, 'PLUS' )
%     |   | ],
%     |   | 't' => 'c a b + ='
%     |   }, 'ASSIGN' )
%     | ]
%     }, 'EXP' )
%   ],
%   't' => [ 'a -6 =', 'b 0 =', 'c a b + =' ]
% }, 'PROG' );
% \end{verbatim}
% Como puede verse la traducción de la frase de
% entrada \verb|a=2*-3;b=a*(2-1-1);c=a+b| 
% queda como atributo \verb|t| del nodo raíz \verb|PROG|.
% 
% \paragraph{Expresiones Regulares Arbol Array}
% Una expresión regular árbol array se escribe insertando un array Perl
% en la expresión regular árbol, por ejemplo \verb|@a|. 
% Una \cei{expresión regular árbol array} \verb|@a| casa con la secuencia mas corta de hijos del nodo
% tal que la siguiente expresión regular árbol (\underline{no array}) casa. 
% La lista de nodos
% que han casado con la expresión regular árbol array quedará en la variable
% léxica \verb|@a|. 
% Por ejemplo, despúes de un casamiento de un árbol \verb|$t| con la expresión regular árbol 
% \verb|BLOCK(@a, ASSIGN($x, $e), @b)|, la variable léxica  
% \verb|@a| contendrá la lista de nodos hijos de  \verb|$t| 
% que precede a la primera aparición de \verb|ASSIGN($x, $e)|.
% Si no 
% existe expresión regular árbol siguiente - el caso de \verb|@b| en el ejemplo -
% la expresión regular
% array casará con todos los nodos hijo a partir del último casamiento (\underline{no array}). 
% Asi \verb|@b| contendrá la lista de referencias a los nodos hijos
% de \verb|$t| posteriores al nodo \verb|ASSIGN($x, $e)|.
% 
% Es \underline{ilegal} escribir dos expresiones regulares arbol array
% seguidas (por ejemplo \verb|A(@a, @b)|).
% 
% El siguiente ejemplo muestra como usar las expresiones árbol array 
% para mover las asignaciones invariantes de un bucle fuera
% del mismo (líneas 104-116):
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/t> cat -n 34moveinvariantoutofloopcomplexformula.t
%   1  #!/usr/bin/perl -w
%   2  use strict;
%   5  use Parse::Eyapp;
%   6  use Data::Dumper;
%   7  use Parse::Eyapp::Treeregexp;
%   8
%   9  my $grammar = q{
%  10  %{
%  11  use Data::Dumper;
%  12  %}
%  13  %right  '='
%  14  %left   '-' '+'
%  15  %left   '*' '/'
%  16  %left   NEG
%  17  %tree
%  18
%  19  %%
%  20  block:  exp <%name BLOCK + ';'> { $_[1] }
%  21  ;
%  22
%  23  exp:      %name NUM
%  24              NUM
%  25          | %name WHILE
%  26              'while'   exp  '{' block '}'
%  27          | %name VAR
%  28              VAR
%  29          | %name ASSIGN
%  30              VAR '=' exp
%  31          | %name PLUS
%  32              exp '+' exp
%  33          | %name MINUS
%  34              exp '-' exp
%  35          | %name TIMES
%  36              exp '*' exp
%  37          | %name DIV
%  38              exp '/' exp
%  39          | %name UMINUS
%  40              '-' exp %prec NEG
%  41          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
%  42  ;
%  43
%  44  %%
%  ..  .......................................................................
%  87  }; # end grammar
%  88
%  ..    ..................
%  99  $parser->YYData->{INPUT} = "a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n";
% 100  my $t = $parser->Run;
% 101  print "\n***** Before ******\n";
% 102  print Dumper($t);
% 104  my $p = Parse::Eyapp::Treeregexp->new( STRING => q{
% 105    moveinvariant: 
% 106      BLOCK(@prests, WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)), @possts )
% 107        and { is_invariant($ASSIGN, $WHILE) } /* Check if ASSIGN is invariant relative */
% 108      => {                                    /* to the while loop                     */
% 109           my $assign = $ASSIGN;   
% 110           $BLOCK[1]->delete($ASSIGN);
% 111           $BLOCK[0]->insert_before($WHILE, $assign);
% 112         }
% 113    },
% 114    #outputfile => 'main.pm',
% 115    firstline => 104,
% 116  );
% \end{verbatim}
% Al ejecutar el programa con la entrada
% \verb|"a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n"|
% obtenemos el árbol modificado:
% \begin{verbatim}
% bless( { 'children' => [
%     bless( { 'children' => [ # a = 1000
%     |   bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   bless( { 'children' => [
%     |       bless( { 'children' => [], 'attr' => '1000', 'token' => 'NUM' }, 'TERMINAL' )
%     |     ]
%     |   }, 'NUM' )
%     | ]
%     }, 'ASSIGN' ),
%     bless( { 'children' => [ # c = 1
%     |   bless( { 'children' => [], 'attr' => 'c', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   bless( { 'children' => [ bless( { 'children' => [], 'attr' => '1', 'token' => 'NUM' }, 'TERMINAL' )
%     |     ]
%     |   }, 'NUM' )
%     | ]
%     }, 'ASSIGN' ),
%     bless( { 'children' => [ # b = 5 moved out of loop
%     |   bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   bless( { 'children' => [ bless( { 'children' => [], 'attr' => '5', 'token' => 'NUM' }, 'TERMINAL' )
%     |     ]
%     |   }, 'NUM' )
%     | ]
%     }, 'ASSIGN' ),
%     bless( { 'children' => [ # while
%     |   bless( { 'children' => [ #   ( a )
%     |       bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' )
%     |     ]
%     |   }, 'VAR' ),
%     |   bless( { 'children' => [ # BLOCK {}
%     |   |   bless( { 'children' => [ # c = c * a
%     |   |   |   bless( { 'children' => [], 'attr' => 'c', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   |   bless( { 'children' => [
%     |   |   |       bless( { 'children' => [
%     |   |   |           bless( { 'children' => [], 'attr' => 'c', 'token' => 'VAR' }, 'TERMINAL' )
%     |   |   |         ]
%     |   |   |       }, 'VAR' ),
%     |   |   |       bless( { 'children' => [
%     |   |   |           bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' )
%     |   |   |         ]
%     |   |   |       }, 'VAR' )
%     |   |   |     ]
%     |   |   |   }, 'TIMES' )
%     |   |   | ]
%     |   |   }, 'ASSIGN' ),
%     |   |   bless( { 'children' => [ # a = a - 1
%     |   |   |   bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     |   |   |   bless( { 'children' => [
%     |   |   |       bless( { 'children' => [
%     |   |   |           bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' )
%     |   |   |         ]
%     |   |   |       }, 'VAR' ),
%     |   |   |       bless( { 'children' => [
%     |   |   |           bless( { 'children' => [], 'attr' => '1', 'token' => 'NUM' }, 'TERMINAL' )
%     |   |   |         ]
%     |   |   |       }, 'NUM' )
%     |   |   |     ]
%     |   |   |   }, 'MINUS' )
%     |   |   | ]
%     |   |   }, 'ASSIGN' )
%     |   | ]
%     |   }, 'BLOCK' )
%     | ]
%     }, 'WHILE' )
%   ]
% }, 'BLOCK' );
% \end{verbatim}
% 
% \paragraph{Expresión regular árbol estrella}
% Una \cei{expresión regular árbol estrella} casa con la secuencia mas corta de hijos del nodos
% tal que la siguiente expresión regular árbol casa. Si no
% existe expresión regular árbol siguiente - esto es, la expresión regular
% estrella es la última de la lista como en \verb|A(B(C,.), *)|- la expresión regular
% estrella casará con todos los nodos hijo a partir del último casamiento.
% Una expresión regular árbol array se escribe insertando el símbolo \verb|*|
% en la expresión regular árbol. Las listas de nodos
% que han casado con la expresiones regulares árbol estrella quedaran en las variables
% léxicas \verb|@W_0|, \verb|@W_1|, \verb|@W_2|, etc.
% En este sentido una expresión regular árbol estrella no es mas que
% una abreviación para la expresión regular árbol \verb|@W_#| 
% siendo \verb|#| el número de orden de aparición.
% 
% \paragraph{Parámetros Pasados a una Subrutina de Transformación Árbol}
% Como se ha mencionado anteriormente el compilador de expresiones
% regulares árbol traduce cada transformación árbol en una subrutina Perl.
% Con mayor precisión: se crea un objeto \verb|Parse::Eyapp:YATW| que es el
% encargado de gestionar la transformación. Para que una subrutina pueda
% ser convertida en un objeto YATW deben ajustarse al \cei{Protocolo YATW de LLamada}. 
% Actualmente (2006) la subrutina asociada con un objeto YATW es llamada como sigue:
% 
% \begin{verbatim}
%   pattern_sub(
%         $_[0],  # Node being visited
%         $_[1],  # Father of this node
%         $index, # Index of this node in @Father->children
%         $self,  # The YATW pattern object
%  );
% \end{verbatim}
% 
% Los cuatro argumentos tienen el siguiente significado:
% 
% \begin{enumerate}
% \item
% El nódo del árbol que esta siendo visitado
% \item
% El padre de dicho nodo
% \item
% El índice del nodo (\verb|$_[0]|) en la lista de nodos del padre
% \item
% Una referencia al objeto YATW
% \end{enumerate}
% 
% La subrutina debe devolver cierto (TRUE) si se produce matching
% y falso en otro caso. Recuerde que el método \verb|s| de los nodos (no así 
% el de los objetos YATW) permancerá aplicando las transformaciones
% hasta que no se produzcan emparejamientos. Por tanto es importante 
% asegurarse cuando se usa la forma \verb|$node->s(@transformations)|
% que la aplicación reiterada de las transformaciones conduce
% a situaciones en las que eventualmente las subrutinas retornan
% el valor falso.
% 
% Es posible que el protocolo de llamada YATW cambie en un futuro próximo.
% 
% %TODO: examples que figuran en el tutorial en MANIFEST
% %TODO: las opciones de new
% 
% \section{Árbol Sintáctico Abstracto con {\tt Parse::Eyapp}}
% 
% \paragraph{La directiva {\tt \%tree}}
% La directiva \tei{\%tree} permite que {\tt Parse::Eyapp}
% genere al árbol sintáctico. Haciendo uso de las directivas
% adecuadas podemos controlar la forma del árbol. La directiva
% \verb|%tree| es una alternativa a la directiva \verb|%metatree|
% y es incompatible con esta última. El objetivo es lograr
% una representación adecuada del árbol sintáctico y dejar
% para fases posteriores la decoración del mismo.
% 
% \label{code:rule6}
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n Rule6.yp
%  1  %{
%  2  use Data::Dumper;
%  3  %}
%  4  %right  '='
%  5  %left   '-' '+'
%  6  %left   '*' '/'
%  7  %left   NEG
%  8  %tree
%  9
% 10  %%
% 11  line: exp  { $_[1] }
% 12  ;
% 13
% 14  exp:      %name NUM
% 15              NUM
% 16          | %name VAR
% 17            VAR
% 18          | %name ASSIGN
% 19            VAR '=' exp
% 20          | %name PLUS
% 21            exp '+' exp
% 22          | %name MINUS
% 23            exp '-' exp
% 24          | %name TIMES
% 25            exp '*' exp
% 26          | %name DIV
% 27            exp '/' exp
% 28          | %name UMINUS
% 29            '-' exp %prec NEG
% 30          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
% 31  ;
% 32
% 33  %%
% 34
% 35  sub _Error {
% ..    ..........
% 43  }
% 44
% 45  sub _Lexer {
% ..    ..........
% 62  }
% 63
% 64  sub Run {
% 65      my($self)=shift;
% 66      $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error,
% 67                      #yyprefix => "Rule6::",
% 68                      #yydebug =>0xFF
% 69                    );
% 70  }
% \end{verbatim}
% 
% \paragraph{Compilación Separada}
% Para compilar un programa separado \tei{Parse::Eyapp} usamos el guión \tei{eyapp}:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Rule6
% nereida:~/src/perl/YappWithDefaultAction/examples> ls -ltr | tail -1
% -rw-rw----  1 pl users   5475 2006-11-06 13:53 Rule6.pm
% \end{verbatim}
% 
% \paragraph{Terminales sintácticos y Terminales Semánticos}
% A diferencia de lo que ocurre cuando se usa la directiva \tei{\%metatree}
% la construcción del árbol solicitado mediante la directiva \tei{\%tree}
% implícitamente considera token sintácticos aquellos terminales que aparecen en 
% definidos en el programa \verb|eyapp| mediante el uso de apóstrofes.
% Los token sintácticos no forman parte del árbol construido.
% Asi pues -en el ejemplo que nos ocupa - los terminales \verb|'='|,
% \verb|'-'|,
% \verb|'+'|,
% \verb|'*'| y
% \verb|'/'|
% serán -por defecto - eliminados del árbol sintáctico. 
% Por ejemplo, para la entrada \verb|a=b*32| el siguiente árbol es construido:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> useruleandshift.pl
% a=b*32
% $VAR1 = bless( { 'children' => [
%     bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     bless( { 'children' => [
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' )
%           ]
%         }, 'VAR' ),
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => '32', 'token' => 'NUM' }, 'TERMINAL' )
%           ]
%         }, 'NUM' )
%       ]
%     }, 'TIMES' )
%   ]
% }, 'ASSIGN' );
% \end{verbatim}
% Esta conducta puede cambiarse usando la directiva \tei{\%semantic token}
% la cual declara una lista de terminales como semánticos. En tal caso 
% dichos terminales formarán parte del árbol construido. Si por el contrario
% lo que queremos es cambiar el estatus de un terminal
% - por ejemplo \verb|NUM| o \verb|ID| - a sintáctico usaremos
% la directiva \tei{\%syntactic token}.
% 
% \paragraph{Compilación Separada de Transformaciones Arbol}
% Como se mencionó en la sección anterior es también posible 
% aislar el programa de transformaciones árbol en un fichero
% separado. El tipo \verb|.trg| se asume por defecto.
% El ejemplo que sigue sustituye nodos producto por un número potencia de
% dos por nodos unarios de desplazamiento a izquierda. De este modo
% facilitamos la tarea de la generación de un código mas eficiente:
% 
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n Shift.trg
%  1  # File: Shift.trg
%  2  {
%  3    sub log2 {
%  4      my $n = shift;
%  5      return log($n)/log(2);
%  6    }
%  7
%  8    my $power;
%  9  }
% 10  mult2shift: TIMES($e, NUM($m)) and { $power = log2($m->{attr}); (1 << $power) == $m->{attr} }
% 11    => {
% 12      $_[0]->delete(1);
% 13      $_[0]->{shift} = $power;
% 14      bless $_[0], 'SHIFTLEFT';
% 15    }
% \end{verbatim}
% Obsérvese que la variable léxica \verb|$power| es visible en la definición
% de la transformación \verb|mult2shift|.
% Compilamos el programa de transformaciones usando el guión \tei{treereg}:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> treereg Shift
% nereida:~/src/perl/YappWithDefaultAction/examples> ls -ltr | tail -1
% -rw-rw----  1 pl users   1405 2006-11-06 14:09 Shift.pm
% \end{verbatim}
% Como se ve, la compilación produce un módulo que \verb|Shift.pm|
% que contiene el código de los
% analizadores.
% El código generado por la versión 0.2 de \tei{treereg} es el siguiente:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n Shift.pm
%  1  package Shift;
%  2
%  3  # This module has been generated using Parse::Eyapp::Treereg
%  4  # from file Shift.trg. Don't modify it.
%  5  # Change Shift.trg instead.
%  6  # Copyright (c) Casiano Rodriguez-Leon 2006. Universidad de La Laguna.
%  7  # You may use it and distribute it under the terms of either
%  8  # the GNU General Public License or the Artistic License,
%  9  # as specified in the Perl README file.
% 10
% 11  use strict;
% 12  use warnings;
% 13  use Carp;
% 14  use Parse::Eyapp::_TreeregexpSupport qw(until_first_match checknumchildren);
% 15
% 16  our @all = ( our $mult2shift, ) = Parse::Eyapp::YATW->buildpatterns(\&mult2shift, );
% 17
% 18  #line 2 "Shift.trg"
% 19
% 20    sub log2 {
% 21      my $n = shift;
% 22      return log($n)/log(2);
% 23    }
% 24
% 25    my $power;
% 26
% 27    sub mult2shift {
% 28      my $mult2shift = $_[3]; # reference to the YATW pattern object
% 29      my $e;
% 30      my $NUM;
% 31      my $TIMES;
% 32      my $m;
% 33
% 34      {
% 35        my $child_index = 0;
% 36
% 37        return 0 unless (ref($TIMES = $_[$child_index]) eq 'TIMES');
% 38        return 0 unless defined($e = $TIMES->child(0+$child_index));
% 39        return 0 unless (ref($NUM = $TIMES->child(1+$child_index)) eq 'NUM');
% 40        return 0 unless defined($m = $NUM->child(0+$child_index));
% 41        return 0 unless do
% 42  #line 10 "Shift.trg"
% 43        { $power = log2($m->{attr}); (1 << $power) == $m->{attr} };
% 44
% 45      } # end block of child_index
% 46  #line 11 "Shift.trg"
% 47      {
% 48        $_[0]->delete(1);
% 49        $_[0]->{shift} = $power;
% 50        bless $_[0], 'SHIFTLEFT';
% 51      }
% 52    } # end of mult2shift
% 53
% 54  1;
% \end{verbatim}
% 
% \paragraph{Uso de los Módulos Generados}
% El programa de análisis se limita a cargar los dos módulos generados,
% crear el analizador (línea 8), llamar al método \verb|Run| 
% para crear el árbol y proceder a las sustituciones (línea 12):
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n useruleandshift.pl
%  1  #!/usr/bin/perl -w
%  2  use strict;
%  3  use Rule6;
%  4  use Data::Dumper;
%  5  use Shift;
%  6
%  7  $Data::Dumper::Indent = 1;
%  8  my $parser = new Rule6();
%  9  my $t = $parser->Run;
% 10  print Dumper($t);
% 11  print "\n***********\n";
% 12  $t->s(@Shift::all);
% 13  print Dumper($t);
% \end{verbatim}
% Cuando alimentamos el programa con la entrada \verb|a=b*32| obtenemos la
% siguiente salida:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> useruleandshift.pl
% a=b*32
% $VAR1 = bless( { 'children' => [
%     bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     bless( { 'children' => [
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' )
%           ]
%         }, 'VAR' ),
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => '32', 'token' => 'NUM' }, 'TERMINAL' )
%           ]
%         }, 'NUM' )
%       ]
%     }, 'TIMES' )
%   ]
% }, 'ASSIGN' );
% 
% ***********
% $VAR1 = bless( {
%   'children' => [
%     bless( { 'children' => [], 'attr' => 'a', 'token' => 'VAR' }, 'TERMINAL' ),
%     bless( {
%       'shift' => 5,
%       'children' => [
%         bless( { 'children' => [
%             bless( { 'children' => [], 'attr' => 'b', 'token' => 'VAR' }, 'TERMINAL' )
%           ]
%         }, 'VAR' )
%       ]
%     }, 'SHIFTLEFT' )
%   ]
% }, 'ASSIGN' );
% \end{verbatim}
% 
% \section{La opción {\tt SEVERITY}}
% La opción \tei{SEVERITY} del constructor \tei{Parse::Eyapp::Treeregexp::new}
% controla la forma en la que se interpreta el éxito de un casamiento
% en lo que se refiere al número de hijos del nodo.
% Para ilustrar su uso consideremos el siguiente ejemplo que 
% hace uso de \verb|Rule6| la gramática que fue introducida 
% en la sección \ref{code:rule6} (página \pageref{code:rule6}).
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> cat -n numchildren.pl
%  1  #!/usr/bin/perl -w
%  2  use strict;
%  3  use Rule6;
%  4  use Data::Dumper;
%  5  use Parse::Eyapp::Treeregexp;
%  6  use Parse::Eyapp::Node;
%  7
%  8  our @all;
%  9  my $severity = shift || 0;
% 10
% 11  my $transform = Parse::Eyapp::Treeregexp->new( STRING => q{
% 12    zero_times_whatever: TIMES(NUM($x)) and { $x->{attr} == 0 } => { $_[0] = $NUM }
% 13  },
% 14  SEVERITY => $severity,
% 15  );
% 16
% 17  $transform->generate;
% 18  $Data::Dumper::Indent = 1;
% 19  my $parser = new Rule6();
% 20  my $t = $parser->Run;
% 21  $t->s(@all);
% 22  print Dumper($t);
% \end{verbatim}
% Este programa obtiene el nivel de severidad a usar desde la línea de comandos
% (línea 9). Nótese que la especificación de \verb|TIMES| 
% en la transformación \verb|zero_times_whatever| este aparece con un único hijo.
% Existen varias interpretaciones de la expresión que se corresponden con los
% niveles de \tei{SEVERITY}: 
% \begin{itemize}
% \item
% Quiero decir que tiene al menos un hijo. No me importa si tiene mas
% \item
% Para que case tiene que tener exactamente un hijo
% \item
% Para que case tiene que tener exactamente un hijo. Si aparece un nodo 
% \verb|TIMES| con un número de hijos diferente quiero ser avisado
% \item
% Para que case tiene que tener exactamente un hijo. Si aparece un nodo 
% \verb|TIMES| con un número de hijos diferente 
% quiero que se considere un error 
% (mis nodos tiene aridad fija)
% \end{itemize}
% En la siguiente ejecución
% el nivel especificado es cero. La expresión \verb|0*2| casa y es modificada.
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> numchildren.pl 0
% 0*2
% $VAR1 = bless( {
%   'children' => [
%     bless( {
%       'children' => [],
%       'attr' => 0,
%       'token' => 'NUM'
%     }, 'TERMINAL' )
%   ]
% }, 'NUM' );
% \end{verbatim}
% En la siguiente ejecución el nivel especificado es uno.
% La expresión \verb|0*2| no casa pero no se avisa ni se considera un 
% error la presencia de un nodo \verb|TIMES| con una aridad distinta.
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> numchildren.pl 1
% 0*2
% $VAR1 = bless( {
%   'children' => [
%     bless( {
%       'children' => [
%         bless( {
%           'children' => [],
%           'attr' => '0',
%           'token' => 'NUM'
%         }, 'TERMINAL' )
%       ]
%     }, 'NUM' ),
%     bless( {
%       'children' => [
%         bless( {
%           'children' => [],
%           'attr' => '2',
%           'token' => 'NUM'
%         }, 'TERMINAL' )
%       ]
%     }, 'NUM' )
%   ]
% }, 'TIMES' );
% \end{verbatim}
% En la siguiente ejecución el nivel especificado es dos.
% La expresión \verb|0*2| no casa y se avisa 
% de la presencia de un nodo \verb|TIMES| con una aridad distinta:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> numchildren.pl 2
% 0*2
% Warning! found node TIMES with 2 children.
% Expected 1 children (see line 12 of numchildren.pl)"
% $VAR1 = bless( {
%   'children' => [
%     bless( {
%       'children' => [
%         bless( {
%           'children' => [],
%           'attr' => '0',
%           'token' => 'NUM'
%         }, 'TERMINAL' )
%       ]
%     }, 'NUM' ),
%     bless( {
%       'children' => [
%         bless( {
%           'children' => [],
%           'attr' => '2',
%           'token' => 'NUM'
%         }, 'TERMINAL' )
%       ]
%     }, 'NUM' )
%   ]
% }, 'TIMES' );
% \end{verbatim}
% En la última ejecución el nivel especificado es tres.
% El programa se detiene ante
% la presencia de un nodo \verb|TIMES| con una aridad distinta:
% \begin{verbatim}
% nereida:~/src/perl/YappWithDefaultAction/examples> numchildren.pl 3
% 0*2
% Error! found node TIMES with 2 children.
% Expected 1 children (see line 12 of numchildren.pl)"
%  at (eval 3) line 28
% \end{verbatim}
% 
% \subsectionpractica{Esquema de Traducción para un Lenguaje Simple}
% \label{practica:esquemadetradsimple}
% Utilice 
% \htmladdnormallink{Parse::Eyapp}{Parse-Eyapp.tar.gz}
% para construir un árbol de análisis sintáctico abstracto 
% para la siguiente gramática:
% 
% \vspace{0.5cm}
% \begin{tabular}{lll}
% program      &$\rightarrow$& definitions \{ definitions \}\\
% definitions  &$\rightarrow$& datadefinition $|$ functiondefinition\\
% datadefinition   &$\rightarrow$& basictype declarator \{ ',' declarator \} ';'\\
% declarator  &$\rightarrow$& ID \{ '$[$' constantexp '$]$' \}\\
% functiondefinition &$\rightarrow$& $[$ basictype $]$ functionheader functionbody\\
% basictype    &$\rightarrow$& INT  $|$ CHAR\\
% functionheader &$\rightarrow$& ID '(' $[$ parameters $]$ ')'\\
% parameters &$\rightarrow$& basictype declarator \{ ',' basictype declarator \} \\
% functionbody &$\rightarrow$& '\{' \{ datadefinition \} \{ statement \} '\}'\\
% statement &$\rightarrow$& $[$ exp $]$ ';'\\
%           &&$|$ '\{' \{ datadefinition \} \{ statement \} '\}'\\
%           &&$|$  IF '(' exp ')' statement $[$ ELSE statement $]$\\
%           &&$|$  WHILE '(' exp ')' statement\\
%           &&$|$  RETURN $[$ exp $]$ ';'\\
% constantexp  &$\rightarrow$& exp \\
% exp       &$\rightarrow$& lvalue '=' exp $|$ lvalue '+=' exp \\
%           &&$|$ exp '\&\&' exp $|$ exp '$||$' exp  $|$\\
%           &&$|$ exp '==' exp $|$ exp '!=' exp  $|$\\
%           &&$|$ exp '$<$' exp $|$ exp '$>$' exp  $|$ exp '$<=$' exp $|$ exp '$>=$' exp  $|$\\
%           &&$|$ exp '+' exp $|$ exp '-' exp  $|$\\
%           &&$|$ exp '*' exp $|$ exp '/' exp $|$\\
%           &&$|$ unary\\
% unary     &$\rightarrow$& '$++$' lvalue  $|$ '$--$' lvalue $|$ primary\\
% primary   &$\rightarrow$& '(' exp ')' $|$ ID '(' $[$ argumentlist $]$ ')' $|$ lvalue\\
%           &             & $|$ NUM $|$ CHARACTER $|$ STRING\\
% lvalue   &$\rightarrow$& ID  \{ '$[$' exp '$]$' \}\\
% argumentlist &$\rightarrow$& exp \{ ',' exp \}
% \end{tabular}
% \vspace{0.25cm}
% 
% La descripción utiliza una notación tipo BNF: las llaves indican 
% 0 o mas repeticiones y los corchetes opcionalidad.
% Su analizador, además de seguir los consejos explícitados en la 
% sección \ref{section:consejosyapp},
% deberá cumplir las siguientes especificaciones:
% 
% \begin{enumerate}
% \item
% Comienze trabajando en el cuerpo de la gramática.
% \item
% Olvídese del 
% analizador léxico por ahora. Su objetivo es tener una gramática limpia
% de conflictos y que reconozca el lenguaje dado. 
% \item
% Sustituya las repeticiones
% BNF por listas usando los operadores \verb|eyapp| \verb|+|, \verb|*| y sus variantes con separadores. 
% Si una variable describe una lista de \verb|cosas| pongale un adjetivo adecuado como
% \verb|cosaslist|. 
% \underline{Ponga nombres significativos a las variables y terminales}. 
% No los llame \verb|d1|, \verb|d2|, etc.
% \item
% Si tiene un elemento opcional en la BNF, por ejemplo, en la regla: 
% 
% functiondefinition $\rightarrow$ $[$ basictype $]$ functionheader functionbody
% 
% use el operador \verb|?|.
% \item
% Cada par de reglas que introduzca vuelva a recompilar con \verb|eyapp| la gramática
% para ver si se introducido ambiguedad. Cuando estoy editando la gramática
% suelo escribir a menudo la orden 
% 
% \verb|:!eyapp %| 
% 
% para recompilar:
% 
% \vspace{0.5cm}
% \begin{tabular}{|p{14.5cm}|}
% \hline
% \begin{verbatim}
%      15
%      16 declaratorlist: declarator +
%      17 ;
%      18 functiondefinition: 
%      19    basictype functionheader functionbody
%      20  | functionheader functionbody
%      21 ;
%      22
%      23 %%
% ~
% ~
% ~
% ~
% ~
% ~
% ~
% ~
% ~
% ~
% :!eyapp %
% \end{verbatim}\\
% \hline
% \end{tabular}
% \vspace{0.5cm}
% 
% Esto llama a \verb|eyapp| con el fichero bajo edición. Si hay errores o conflictos (esto es,
% hemos introducido ambiguedad) los detectarémos enseguida.
% Procure detectar la aparición de un conflicto lo antes posible.
% Observe el sangrado del ejemplo. Es el que le recomiendo.
% \item
% Cuando esté en el proceso de construcción de la gramática y aún le queden
% por rellenar variables sintácticas, declárelas como terminales mediante
% \verb|%token| como en el código que aparece encima. De esta manera
% evitará las quejas de \verb|eyapp|.
% 
% \item {\bf Resolución de Ambiguedades y Conflictos}
% 
% Las operaciones de asignación tienen la prioridad mas baja,
% seguidas  de las lógicas, los test de igualdad y después 
% de los de comparación, a continuación las aditivas, multiplicativas y por 
% último los \verb|unary| y \verb|primary|. Exprese la asociatividad natural y la
% prioridad especificada usando
% los mecanismos que \verb|eyapp| provee al efecto: \verb|%left|, \verb|%right|,
% \verb|%nonassoc| y \verb|%prec|.
% 
% \item
% La gramática es ambigua, ya que para una sentencia como 
% 
% \begin{center}
% if $E_1$ then if $E_2$ then $S_1$ else $S_2$
% \end{center}
% 
% existen dos árboles posibles: uno que asocia el ``else'' con el primer ``if'' y otra
% que lo asocia con el segundo. Los dos árboles corresponden a las
% dos posibles parentizaciones:
% 
% \begin{center}
% if $E_1$ then (if $E_2$ then $S_1$ else $S_2$)
% \end{center}
% 
% Esta es la regla de prioridad usada en la mayor parte de los lenguajes:
% un ``else'' casa con el ``if'' mas cercano. La otra posible parentización
% es:
% 
% \begin{center}
% if $E_1$ then (if $E_2$ then $S_1$) else $S_2$
% \end{center}
% 
% \emph{La conducta por defecto de {\tt eyapp} es parentizar a derechas}.
% El generador  {\tt eyapp}  nos informará del conflicto pero si no se le indica 
% como resolverlo parentizará a derechas.
% Resuelva este conflicto.
% 
% \item {\bf Analizador Léxico}
% 
% Además del tipo de terminal y su valor el analizador
% léxico deberá devolver el número de línea.
% El analizador léxico deberá aceptar comentarios C.
% En la gramática, el terminal \verb|CHARACTER| se refiere a 
% caracteres entre comillas simples (por ejemplo \verb|'a'|).
% El terminal \verb|STRING| se refiere a 
% caracteres entre comillas dobles (por ejemplo \verb|"hola"|).
% 
% Se aconseja que las palabras reservadas del lenguaje
% no se traten con expresiones regulares específicas sino que se
% capturen en el patrón de identificador \verb|[a-z_]\w+|. 
% Se mantiene para ello un hash con las palabras reservadas 
% que es inicializado al comienzo del programa. Cuando 
% el analizador léxico encuentra un identificador
% mira en primer lugar en dicho hash 
% para ver si es una palabra reservada y,
% si lo es, devuelve el terminal correspondiente.
% En caso contrario se trata de un identificador.
% 
% \item {\it ¿Que clase de árbol debe producir el analizador?}
% La respuesta es que sea lo mas abstracto posible.
% Debe 
% \begin{itemize}
% \item
% Contener toda la información necesaria para el manejo eficiente
% de las fases subsiguientes: Análisis de ámbito, Comprobación de tipos,
% Optimización independiente de la máquina, etc.
% \item 
% Ser uniforme
% \item
% Legible (human-friendly)
% \item
% No contener nodos que no portan información. 
% \end{itemize}
% 
% El siguiente ejemplo muestra una versión aceptable de árbol abstracto.
% Cuando se le proporciona el programa de entrada:
% 
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> cat -n prueba5.c
%      1  int f(int a)
%      2  {
%      3    if (a>0)
%      4      a = f(a-1);
%      5  }
% \end{verbatim}
% 
% el analizador produce un árbol parecido a este (se ha simplificado 
% por razones de espacio):
% 
% \begin{small}
% \begin{verbatim}
% $VAR1=bless({ 'children'=>[
%     bless({ 'children'=>[ # TYPEDFUNC
%     |   bless({ 'children'=>[
%     |       bless({'attr'=>['INT',1],'token'=>'INT'},'TERMINAL')
%     |     ]
%     |   },'INT'),
%     |   bless({ 'children'=>[ # FUNCTION
%     |   |   bless({'attr'=>['f',1],'token'=>'ID'},'TERMINAL'),
%     |   |   bless({ 'children'=>[ # PARAMS
%     |   |       bless({ 'children'=>[ # PARAM
%     |   |           bless({ 'children'=>[
%     |   |               bless({'attr'=>['INT',1],'token'=>'INT'},'TERMINAL')
%     |   |             ]
%     |   |           },'INT'),
%     |   |           bless({'attr'=>['a',1],'token'=>'ID'},'TERMINAL'),
%     |   |           bless({'children'=>[]},'ARRAYSPEC')
%     |   |         ]
%     |   |       },'PARAM')
%     |   |     ]
%     |   |   },'PARAMS'),
%     |   |   bless({ 'children'=>[
%     |   |       bless({'children'=>[]},'DECLARATIONS'),
%     |   |       bless({ 'children'=>[
%     |   |       |   bless({ # IF
%     |   |       |     'children'=>[
%     |   |       |       bless({ # GT
%     |   |       |         'children'=>[
%     |   |       |           bless({ # VAR
%     |   |       |             'children'=>[
%     |   |       |               bless({'attr'=>['a',3],'token'=>'ID'},'TERMINAL')
%     |   |       |             ]
%     |   |       |           },'VAR'),
%     |   |       |           bless({ 'children'=>[
%     |   |       |               bless({'attr'=>['0',3],'token'=>'INUM'},'TERMINAL')
%     |   |       |             ]
%     |   |       |           },'INUM')
%     |   |       |         ]
%     |   |       |       },'GT'),
%     |   |       |       bless({ # ASSIGN
%     |   |       |         'children'=>[
%     |   |       |           bless({ # VAR
%     |   |       |             'children'=>[
%     |   |       |               bless({'attr'=>['a',4],'token'=>'ID'},'TERMINAL')
%     |   |       |             ]
%     |   |       |           },'VAR'),
%     |   |       |           bless({ # FUNCTIONCALL
%     |   |       |           | 'children'=>[
%     |   |       |           |   bless({'attr'=>['f',4],'token'=>'ID'},'TERMINAL'),
%     |   |       |           |   bless({ # ARGLIST
%     |   |       |           |     'children'=>[
%     |   |       |           |       bless({ # MINUS
%     |   |       |           |         'children'=>[
%     |   |       |           |           bless({ 'children'=>[
%     |   |       |           |               bless({'attr'=>['a',4],'token'=>'ID'},'TERMINAL')
%     |   |       |           |             ]
%     |   |       |           |           },'VAR'),
%     |   |       |           |           bless({ 'children'=>[
%     |   |       |           |               bless({'attr'=>['1',4],'token'=>'INUM'},'TERMINAL')
%     |   |       |           |             ]
%     |   |       |           |           },'INUM')
%     |   |       |           |         ]
%     |   |       |           |       },'MINUS')
%     |   |       |           |     ]
%     |   |       |           |   },'ARGLIST')
%     |   |       |           | ]
%     |   |       |           },'FUNCTIONCALL')
%     |   |       |         ]
%     |   |       |       },'ASSIGN')
%     |   |       |     ]
%     |   |       |   },'IF')
%     |   |       | ]
%     |   |       },'STATEMENTS')
%     |   |     ]
%     |   |   },'BLOCK')
%     |   | ]
%     |   },'FUNCTION')
%     | ]
%     },'TYPEDFUNC')
%   ]
% },'PROGRAM');
% \end{verbatim}
% \end{small}
% 
% Es deseable  darle una estructura uniforme al árbol. Por ejemplo, como consecuencia 
% de que la gramática admite funciones con declaración implícita del tipo retornado cuando este es entero
% 
% \begin{verbatim}
%  1  definition:
%  2      funcDef { $_[1]->type("INTFUNC"); $_[1] }
%  3    | %name TYPEDFUNC
%  4      basictype funcDef
%  5    | declaration { $_[1] }
%  6  ;
% \end{verbatim}
% \end{enumerate}
% 
% se producen dos tipos de árboles. Es conveniente
% convertir las definiciones de función con declaración 
% implícita en el mismo árbol que se obtiene con 
% declaración explícita. Para ello puede usar una expresión regular
% árbol.
% 
% \section{Análisis de Ámbito}
% Los lenguajes de programación suelen permitir el uso del mismo 
% \cei{nombre}\footnote{Usamos el término nombre y no identificador ya que este último
% tiene una connotación mas precisa}
% para denotar distintos objetos de un programa. Es por ello que es necesario
% determinar que definición o declaración se aplica a una determinada
% ocurrencia de un objeto.
% 
% \begin{definition}
% Una \cei{declaración} es un constructo sintáctico que define y provee información 
% sobre un nombre.
% \end{definition}
% 
% \begin{definition}
% Las \cei{reglas de ámbito} de un lenguaje determinan que declaración
% del nombre es la que se \emph{aplica} cuando el nombre es usado.
% \end{definition}
% 
% En la definición anterior la frase final \emph{cuando el nombre es usado}
% puede referirse al texto del programa a su uso durante la ejecución
% del programa. Se habla de \cei{static binding} o \cei{reglas de ámbito estático} 
% cuando las reglas de ámbito se refieren al uso en el texto y determinan 
% consiguientemente su uso en ejecución. Las aplicaciones de las reglas de ámbito estático
% pueden ser calculadas en tiempo de compilación.
% 
% Por contrario cuando se usa \cei{dynamic binding} o \cei{reglas de ámbito dinámico}
% el acceso a una determinada variable puede suceder en términos de una regla 
% establecida en tiempo de ejecución y el ámbito de la regla puede no tener 
% una asignación clara a una zona léxica de texto. Un ejemplo: la declaración \tei{local}
% de Perl modifica el ámbito de una variable de paquete, de manera que el valor
% visible a través del nombre será el último dado. Cuando el ámbito (estático) de 
% la declaración de \verb|local| termina se podrá acceder al antiguo valor de la variable.
% 
% \begin{definition}
% Cuando se usa \emph{static binding},
% la parte del texto del programa al cual se aplica la declaración de un 
% nombre se denomina \cei{ámbito de la declaración}
% \end{definition}
% 
% 
% \begin{definition}
% La tarea de asignar las ocurrencias de las declaraciones de nombres a las 
% ocurrencias de uso  de los nombres de acuerdo a las reglas de ámbito
% del lenguaje se denomina \cei{identificación de los nombres}
% \end{definition}
% 
% \begin{definition}
% Una ocurrencia de un nombre se dice \cei{local} si está en el ámbito 
% de una declaración que no se aplica desde el comienzo de la declaración 
% hasta el final del texto del programa. Tal declaración
% es una \cei{declaración local}.
% \end{definition}
% 
% \begin{definition}
% Si, por el contrario, una ocurrencia de un nombre está en el ámbito
% de una declaración que no se aplica desde el comienzo de la declaración 
% hasta el final del texto del programa se dice que la declaración
% es una \cei{declaración global}.
% \end{definition}
% 
% \begin{definition}
% Aunque la definición anterior establece el \cei{atributo ámbito}
% como un atributo de la declaración es usual y conveniente
% hablar del 
% \begin{quote}
% "\emph{ámbito del nombre {\tt x}}" 
% \end{quote}
% como una abreviación
% de 
% \begin{quote}
% "\emph{el ámbito de la declaración del nombre {\tt x}
% que se aplica a esta ocurrencia de {\tt x}}"
% \end{quote}
% \end{definition}
% 
% Como ya sabemos, es falso que en el ámbito de una declaración que define a \verb|x| 
% dicha declaración se aplique a todas las ocurrencias de \verb|x| en su ámbito.
% En un ámbito estático, una declaración local a la anterior puede \cei{ocultar la visibilidad} de 
% la declaración anterior de \verb|x|.
% 
% \begin{definition}
% Las \cei{reglas de visibilidad} de un lenguaje especifican como se relacionan los nombres
% con las declaraciones que se les aplican.
% \end{definition}
% Por ejemplo en Pascal es posible hacer visible el nombre de un campo de un registro
% extendiéndolo con el nombre del registro. En Perl es posible acceder a una variable de paquete
% ocultada por una léxica usando su nombre completo.
% 
% También es posible hacer visible un nombre escondido -sin necesidad como en el ejemplo anterior
% de extender el identificador - mediante alguna directiva
% que lo haga visible: Son ejemplos la declaración \verb|with| the Pascal y la declaración
% \tei{our} de Perl (via uso del módulo y exportación del símbolo).
% 
% En el ejemplo del lenguaje Simple introducido en la práctica 
% \ref{practica:esquemadetradsimple}
% hay una única declaración que se aplica a cada 
% ocurrencia correcta de un nombre en un programa.
% Esto no tiene porque ser siempre así: en ciertos lenguajes 
% una redeclaración de un cierto nombre \verb|x| puede que sólo oculte 
% a otra declaración previa de \verb|x| si las dos declaraciones
% asignan el mismo tipo a \verb|x|. Esta idea suele conocerse
% como \cei{sobrecarga de identificadores}. De todos modos, sigue 
% siendo cierto que para que el programa
% sea considerado correcto es necesario que sea posible determinar
% para cada ocurrencia de un identificador que definición se
% aplica. Así una llamada  a una cierta función
% \verb|min(x,y)| llamaría a diferentes 
% funciones \verb|min| según fueran los tipos de \verb|x| e \verb|y|.
% En Perl tenemos que es 
% legal tener variables \verb|$x|, \verb|@x|, \verb|%x|, \verb|&x|, \verb|*x|,
% etc. ya que corresponden a tipos distintos. Si bien el ejemplo 
% de sobrecarga de identificadores en Perl 
% podría considerarse un poco forzado ya 
% que encaja también con la idea de hacer visible
% el nombre mediante la extensión del mismo 
% (en este caso el prefijo o \cei{sigil} \verb|$|, \verb|@|, etc.).
% 
% 
% El proceso de identificar los nombres conlleva establecer enlaces
% entre las ocurrencias y sus declaraciones o bien - en caso de error -
% determinar que dicho enlace no existe. El resultado de este proceso
% de identificación (o análisis de ámbito y visibilidad)
% será utilizado durante las fases posteriores.
% 
% 
% \subsectionpractica{Análisis de Ámbito}
% \label{practica:ambitoytipossamplec}
% Haga el análisis de ámbito del lenguaje presentado
% en la práctica
% \ref{practica:esquemadetradsimple}.
% Para esta práctica use una revisión de la distribución de 
% Parse::Eyapp posterior a la 348.
% 
% \paragraph{La tabla de Símbolos}
% Comenzaremos describiendo las estructuras de datos que van a conformar la tabla de símbolos
% de nuestro compilador:
% 
% \begin{enumerate}
% \item
% Dote de los siguientes atributos a los nodos de tipo "bloque", 
% esto es a aquellos nodos que definen ámbito. Por ejemplo, los nodos asociados
% con la variable sintáctica \verb|block| son de tipo "bloque":
% \begin{verbatim}
% block:
%     %name BLOCK
%     '{' declaration %name DECLARATIONS * statement %name STATEMENTS * '}'
% \end{verbatim}
% 
%   \begin{enumerate}
%   \item
%   Atributo \verb|symboltable|: referencia a la tabla de símbolos asociada con el bloque
%   \item
%   Atributo \verb|fatherblock|: referencia al nodo \verb|BLOCK| que inmediatamente anida a este.
%   Los nodos de tipo bloque quedan enlazados según el árbol de anidamiento de bloques
%   \item
%   Los bloques con declaraciones vacías pueden ser simplificados en el árbol de bloques
%   \end{enumerate}
% 
% \item
% Los nodos \verb|FUNCTION| asociados con las
% funciones son nodos de tipo bloque y
% serán tratados de manera similar a los nodos  \verb|BLOCK|, esto es, 
% tendrán su tabla de símbolos asociada en la cual se guardarán los parámetros 
% de la función. Este bloque es el bloque padre del bloque formado por
% el cuerpo de la función.
% 
% \begin{verbatim}
% funcDef:
%     %name FUNCTION
%     ID '('  param <%name PARAMS * ','> ')' 
%       block
% \end{verbatim}
% 
% \item
% Los identificadores de funciones van en la tabla de símbolos global, asociada con el nodo
% \verb|PROGRAM|:
% 
% \begin{verbatim}
% program:
%     definition %name PROGRAM+ 
%       { $_[1] }
% \end{verbatim}
% Observe que en C una función puede ser usada antes de que aparezca su definición.
% 
% \item
%   Atributos de un nodo \verb|VAR|:
%   \begin{enumerate}
%   \item
%   Atributo \verb|entry|: Su entrada en la tabla de símbolos a la que pertenece
%   \item
%   Atributo \verb|scope|: Una referencia al nodo \verb|BLOCK| en el que fué declarada la variable
%   \end{enumerate}
% 
% \item
% La tabla de símbolos tiene una entrada para cada identificador que pertenece a su espacio
% de nombres. Aqui figuran los atributos del identificador: entre estos 
% últimos la línea en la que fue declarado y su tipo.
% 
% \end{enumerate}
% 
% \paragraph{Conoce tus árboles}
% Para la realización de esta práctica 
% deberá tener clara la forma de los árboles generados por su analizador sintáctico y
% especialmente la parte que se refiere a las declaraciones. Para un ejemplo de lo que
% es razonable esperar que un analizador sintáctico construido con \verb|eyapp| 
% genere para el programa fuente 
% \begin{verbatim}
% f() {
%   int a,b[1][2],a[1][2][3];
%   char d[10];
%   b[0][1] = a;
% }
% \end{verbatim}
% vea el apéndice en la página \pageref{apendice:arbolensimplec}.
% 
% Esta práctica se divide en dos partes. 
% 
% En una primera parte
% se construyen las declaraciones y las tablas de símbolos de cada bloque. 
% En la segunda parte (véase la siguiente práctica) 
% se resuelve el problema de la identificación de los
% nombres estableciendo la relación entre el uso de un nombre y la declaración
% que se le aplica (dada por los atributos \verb|scope| y \verb|entry|):
% 
% \paragraph{¿Que es una declaración?}
% Las declaraciones tal y como aparecen en el AST no permiten
% una comprobación de tipos eficiente. La comprobación de tipos
% es la fase que sigue al análisis de ámbito.
% Por ello, debemos modificar la fase de construcción del AST para
% producir declaraciones que permitan comprobar con facilidad
% la \cei{equivalencia de tipos}
% 
% La equivalencia de tipos se realiza habitualmente mediante 
% \cei{expresiones de tipo}. En nuestro caso vamos a
% elegir una representación mediante cadenas y árboles 
% las expresiones de tipo. Las cadenas serán términos
% árbol. Como primera aproximación, entenderemos
% que dos tipos son equivalentes si las cadenas que representan
% sus expresiones de tipo son iguales. Como tenemos dos tipos 
% básicos \verb|INT| y \verb|CHAR| declararemos en nuestro
% programa \verb|Simple.yp|:
% 
% \begin{verbatim}
% %{
% use List::Util qw(reduce);
% use List::MoreUtils qw(firstval);
% 
% my %reserved = (
%   ..... .. .......
% );
% 
% my %lexeme = (
%   .... .. .....
% );
%  .............. # support functions
% 
% my ($tokenbegin, $tokenend) = (1, 1);
% my %type = (
%   INT  => 1,
%   CHAR => 1,
% );
% 
% my %st; # Global symbol table
% %}
% \end{verbatim}
% 
% \paragraph{El código asociado con {\tt declaration}}
% Veamos como modificamos la construcción del AST durante las declaraciones:
% 
% \begin{verbatim}
% declaration:
%     %name DECLARATION
%     $basictype $declList ';' 
%       {  
%          my %st; # Symbol table local to this declaration
%          my $bt = $basictype->type;
%          my @decs = $declList->children(); 
%          while (my ($id, $arrspec) = splice(@decs, 0, 2)) {
%            my $name = $id->{attr}[0];
%            my $type = build_type($bt, $arrspec);
%            $type{$type} = 1; 
% 
%            # control duplicated declarations
%            die "Duplicated declaration of $name at line $id->{attr}[1]\n" if exists($st{$name});
%            $st{$name}->{type} = $type;
%            $st{$name}->{line} = $id->{attr}[1];
%          }
%          return \%st;
%       }
% \end{verbatim}
% 
% El código de la función \verb|build_type| es como sigue:
% 
% \begin{verbatim}
% sub build_type {
%   my $bt = shift;
%   my @arrayspec = shift()->children();
% 
%   my $type = '';
%   for my $s (@arrayspec) {
%     $type .= "A_$s->{attr}[0](";
%   }
%   if ($type) {
%     $type = "$type$bt".(")"x@arrayspec);
%   }
%   else {
%     $type = $bt;
%   }
%   return $type;
% }
% \end{verbatim}
% 
% \paragraph{Tratamiento de los Bloques}
% La variable sintáctica \verb|bloque|
% genera el lenguaje de las definiciones seguidas de sentencias,
% tal y como aparece en la definición EBNF del lenguaje:
% 
% \begin{tabular}{c}
%       '\{' \{ datadefinition \} \{ statement \} '\}'
% \end{tabular}
% 
% El lenguaje de los bloques es modificado en consonancia:
% 
% \begin{verbatim}
% block:
%     '{'.bracket 
%        { $depth++ } /* intermediate action! */
%      declaration<%name DECLARATIONS *>.decs statement<%name STATEMENTS *>.sts '}'
%        { 
%          my %st;
% 
%          for my $lst ($decs->children) {
% 
%            # control duplicated declarations
%            my $message;
%            die $message if $message = is_duplicated(\%st, $lst);
% 
%            %st = (%st, %$lst);
%          }
%          $sts->{symboltable} = \%st;
%          $sts->{line} = $bracket->[1];
%          $sts->{depth} = $depth--;
%          $sts->type("BLOCK");
%          push @pending_blocks, $sts;
%          return $sts; 
%        }
% \end{verbatim}
% 
% El código de la función \verb|is_duplicated| es como sigue:
% 
% \begin{verbatim}
% sub is_duplicated {
%   my ($st1, $st2) = @_;
% 
%   my $id;
% 
%     defined($id=firstval{exists $st1->{$_}} keys %$st2)
%   and return "Error. Variable $id at line $st2->{$id}->{line} declared twice.\n";
%   return 0;
% }
% \end{verbatim}
% 
% \paragraph{Tratamiento de las Funciones}
% 
% El código para las funciones es similar.
% Unimos la tabla de símbolos
% de los parámetros a la del bloque para posteriormente reconvertir el
% bloque en un nodo \verb|FUNCTION|:
% 
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> sed -ne '195,218p' Simple4.eyp | cat -n
%  1  funcDef:
%  2      $ID '('  $params  ')'
%  3        $block
%  4      {
%  5         my $st = $block->{symboltable};
%  6         my @decs = $params->children();
%  7         $block->{parameters} = [];
%  8         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
%  9             my $bt = ref($bt); # The string 'INT', 'CHAR', etc.
% 10             my $name = $id->{attr}[0];
% 11             my $type = build_type($bt, $arrspec);
% 12             $type{$type} = 1; 
% 13
% 14             # control duplicated declarations
% 15             die "Duplicated declaration of $name at line $id->{attr}[1]\n" if exists($st->{$name});
% 16             $st->{$name}->{type} = $type;
% 17             $st->{$name}->{param} = 1;
% 18             $st->{$name}->{line} = $id->{attr}[1];
% 19             push @{$block->{parameters}}, $name;
% 20         }
% 21         $block->{function_name} = $ID;
% 22         $block->type("FUNCTION");
% 23         return $block;
% 24      }
% \end{verbatim}
% 
% En una segunda fase, a la altura de \verb|definition| 
% se construye la entrada para la función en la tabla de símbolos global:
% 
% \begin{verbatim}
% definition:
%     $funcDef 
%       { 
%         build_function_scope($funcDef, 'INT');
%       }
%   | %name FUNCTION
%     $basictype $funcDef
%       { 
%         build_function_scope($funcDef, $basictype->type);
%       }
%   | declaration 
%      { 
%        #control duplicated declarations
%        my $message;
%        die $message if $message = is_duplicated(\%st, $_[1]);
%        %st = (%st,  %{$_[1]}); # improve this code
%        return undef; # will not be inserted in the AST
%      }
% \end{verbatim}
% El código de la función \verb|build_function_scope| es como sigue:
% 
% \begin{verbatim}
% sub build_function_scope { 
%   my ($funcDef, $returntype) = @_;
% 
%   my $function_name = $funcDef->{function_name}[0];
%   my @parameters = @{$funcDef->{parameters}};
%   my $lst = $funcDef->{symboltable};
%   my $numargs = scalar(@parameters);
% 
%   #compute type
%   my ($partype, $sep) = ("", "");
%   if (@parameters) {
%     $partype .= reduce { "$lst->{$a}{type},$lst->{$b}{type}" } @parameters;
%     $sep =',';
%   }
%   my $type = "F_$numargs($partype$sep$returntype)";
% 
%   #insert it in the hash of types
%   $type{$type} = 1;
% 
%   #insert it in the global symbol table
%   die "Duplicated declaration of $function_name at line $funcDef-->{attr}[1]\n" 
%     if exists($st{$function_name});
%   $st{$function_name}->{type} = $type;
%   $st{$function_name}->{line} = $funcDef->{function_name}[1];
% 
%   return $funcDef;
% }
% \end{verbatim}
% 
% \paragraph{Procesado de las Listas de Parámetros}
% Como puede verse en el apéndice 
% en la página \pageref{apendice:simplecastparametros}
% el nodo \verb|PARAMS| para la entrada
% \verb|int f(int a,char b[10],int c[10][20]) { a = b[1]; }| tiene
% la estructura:
% \begin{verbatim}
% PS(P(T(int), T(a), AS(T([]))), P(T(chr),T(b),AS(T(10))), P(T(int), T(c), AS(T(10),T(20))))
% \end{verbatim}
% La lista de parámetros estaba definida por:
% \begin{verbatim}
% params: 
%     ( basictype ID arraySpec)<%name PARAMS * ','>
%       { $_[1] }
% \end{verbatim}
% 
% \paragraph{El Tratamiento del Programa Principal}
% Sigue el código (incompleto) asociado con la variable sintáctica de
% arranque:
% \begin{verbatim}
% program:
%     definition<%name PROGRAM +>.program
%       { 
%         $program->{symboltable} = { %st };  # creates a copy of the s.t.
%         for (keys %type) {
%           $type{$_} = Parse::Eyapp::Node->new($_);
%         }
%         $program->{depth} = 0;
%         $program->{line}  = 1;
%         $program->{types} = { %type };  
%         $program->{lines} = $tokenend;  
% 
%         # Reset file scope variables
%         %st = (); # reset symbol table
%         ($tokenbegin, $tokenend) = (1, 1);
%         %type = (INT => "INT", CHAR => "CHAR");
%         $program;
%       }
% \end{verbatim}
% 
% \paragraph{Nombres de atributos de expresiones complejas Eyapp}
% Un inciso para explicar la parte derecha de la regla de producción
% usada en el párrafo anterior:
% 
% \verb|program: definition<%name PROGRAM +>.program|
% 
% observe los siguientes detalles:
% 
% \begin{enumerate}
% \item
% Es posible usar los símbolos menor/mayor para incidir en el hecho de que la especificación
% del tipo del nodo construido como nodo \verb|PROGRAM| se le da a la lista no vacía 
% de repeticiones de \verb|definition|. 
% Funciona como un paréntesis de agrupamiento y es opcional. Podríamos haber escrito:
% 
% \verb|program: definition %name PROGRAM +.program|
% 
% pero es, sin duda, mas confuso para el lector.
% 
% \item
% Si queremos darle nombre al nodo asociado con el único elemento en la parte derecha
% de la regla:
% 
% \verb|program: definition %name PROGRAM +.program|
% 
% no podemos usar la \cei{notación dolar}. Este código que pretende ser equivalente al anterior:
% \begin{verbatim}
% program:
%     $definition<%name PROGRAM +>
% \end{verbatim}
% produce un mensaje de error:
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> eyapp Simple4
% *Fatal* $ is allowed for identifiers only, at line 144 at file Simple4.eyp
% \end{verbatim}
% La razón del mensaje es que la expresión \verb|$definition<%name PROGRAM +>| es interpretada
% como \verb|$(definition<%name PROGRAM +>)|, esto es el dolar esta actuando sobre 
% la expresión \verb|definition<%name PROGRAM +>| que no es un identificador sino
% una expresión compleja.
% 
% \emph{En vez del dolar deberemos usar la \cei{notación punto} para darle
% nombre al atributo, como se ha hecho en el ejemplo}.
% \end{enumerate}
% 
% \paragraph{La Jerarquía de Bloques}
% Para construir la jerarquía de bloques usaremos treeregexps. 
% Aún cuando el programa árbol es trivial, vamos a aislarlo
% en un fichero \verb|SimpleTrans.trg| en la esperanza de que irá 
% creciendo en complejidad conforme avancemos en las sucesivas
% etapas del compilador:
% 
% \begin{verbatim}
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> cat -n SimpleTrans.trg
%      1  blocks:  /BLOCK|FUNCTION|PROGRAM/
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> make
% treereg SimpleTrans
% eyapp Simple4
% nereida:~/doc/casiano/PLBOOK/PLBOOK/code> ls -ltr | tail -4
% -rw-rw----  1 pl users 12465 2006-11-23 16:21 Simple4.eyp
% -rw-rw----  1 pl users    34 2006-11-23 16:25 SimpleTrans.trg
% -rw-rw----  1 pl users   860 2006-11-23 16:25 SimpleTrans.pm
% -rw-rw----  1 pl users 44463 2006-11-23 16:25 Simple4.pm
% \end{verbatim}
% 
% ello significa que en el fichero \verb|Simple4.eyp| 
% tenemos que explicitar el uso 
% del módulo generado por \verb|treereg|. 
% Además importaremos la función \verb|lastval|:
% 
% \begin{verbatim}
% %{
% use strict;
% use Data::Dumper;
% use List::Util qw(reduce);
% use List::MoreUtils qw(firstval lastval);
% use SimpleTrans;
% ...............
% 
% sub Run {
%  my($self)=shift;
%  my ($a, $t);
%  for (@tests) {
%    $self->YYData->{INPUT} = $_;
%    eval {
%      $t = $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, #yydebug => 0x1F 
%      );
%    };
%    if ($@) { print "Error in test program\n$@"; }
%    else {
%      $t->build_blocks_tree();
%      push @$a, $t;
%    }
%  }
%  return $a;
% }
% \end{verbatim}
% 
% Observe que \verb|build_blocks_tree| es llamado como si fuera un método
% del objeto nodo \verb|$t|. Lo que hemos hecho es alargar el nombre
% de \verb|build_blocks_tree| para que pertenezca a la clase \verb|Parse::Eyapp::Node|:
% 
% \begin{verbatim}
% sub Parse::Eyapp::Node::build_blocks_tree {
%   my $t = shift; # tree
% 
%   my (@b, @blocks);
%   @b = @blocks = $SimpleTrans::blocks->m($t);
%   while (@blocks) {     
%     my $b = pop @blocks;
%     my $d = $b->{depth};
%     my $f = lastval { $_->{depth} < $d} @blocks; 
%     last unless $f;
%     $b->{fatherblock} = $f;
%   }
%   wantarray? @b : $t;
% }
% \end{verbatim}
% 
% El método \verb|build_blocks_tree| usa el método \verb|m| (por \emph{m}atch)
% del objeto transformación \verb|$SimpleTrans|. Cuando es llamado
% en un contexto de lista
% \verb|m| devuelve la lista de nodos que casan en orden primero profundo de 
% recorrido del árbol \verb|$t|.
% 
% Nótese que - por la forma del recorrido - 
% el padre de un nódo \verb|$b| es el primer nodo a la izquierda de este 
% en el array devuelto que tiene menor profundidad
% que \verb|$b|. Esta propiedad es aprovechada para hilvanar 
% los nodos bloque en un árbol ascendente.
% 
% Este sub-árbol de bloques puede ayudarnos en la fase de ubicar que declaración
% se aplica a una aparición de un objeto dado en el texto del programa.
% Para cada ocurrencia debemos determinar si fué declarada en el bloque
% en el que ocurre o bien en uno de los nodos bloque antepasados 
% de este.
% 
% \paragraph{Ejemplo de Salida:  La estructura de datos resultante}
% Veamos un ejemplo de la estructura de como queda el árbol
% para el programa de entrada:
% \begin{verbatim}
% int a,b[1][2],c[1][2][3]; 
% char d,e[1][2]; 
% char f(int a, char b[10]) {
%   int c[1][2];
%   char d[10], e[9];
% 
%   return b[0];
% }
% \end{verbatim}
% Al volcarlo con \verb|Data::Dumper| obtenemos:
% \begin{verbatim}
% $VAR1 = bless( {
%   'types' => {
%     'A_1(A_2(CHAR))' => bless( {
%       'children' => [
%         bless( { 'children' => [ bless( { 'children' => [] }, 'CHAR' ) ] }, 'A_2' )
%       ]
%     }, 'A_1' ),
%     'F_2(INT,A_10(CHAR),CHAR)' => bless( {
%       'children' => [
%         bless( { 'children' => [] }, 'INT' ), # Type of the first arg
%         bless( { 'children' => [ bless( { 'children' => [] }, 'CHAR' ) ] }, 'A_10' ),
%         bless( { 'children' => [] }, 'CHAR' ) # Returns CHAR
%       ]
%     }, 'F_2' ),
%     'CHAR' => bless( { 'children' => [] }, 'CHAR' ),
%     'A_1(A_2(A_3(INT)))' => bless( { # A_1
%       'children' => [
%         bless( { # A_2
%           'children' => [
%             bless( { 'children' => [ bless( { 'children' => [] }, 'INT' ) ] }, 'A_3' )
%           ]
%         }, 'A_2' )
%       ]
%     }, 'A_1' ),
%     'INT' => bless( { 'children' => [] }, 'INT' ),
%     'A_1(A_2(INT))' => bless( {
%       'children' => [
%         bless( { 'children' => [ bless( { 'children' => [] }, 'INT' ) ] }, 'A_2' )
%       ]
%     }, 'A_1' ),
%     'A_9(CHAR)' => bless( { 'children' => [ bless( { 'children' => [] }, 'CHAR' ) ] }, 'A_9' ),
%     'A_10(CHAR)' => bless( { 'children' => [ bless( { 'children' => [] }, 'CHAR' ) ] }, 'A_10' )
%   },
%   'symboltable' => {
%     'e' => { 'type' => 'A_1(A_2(CHAR))', 'line' => 2 },
%     'c' => { 'type' => 'A_1(A_2(A_3(INT)))', 'line' => 1 },
%     'a' => { 'type' => 'INT', 'line' => 1 },
%     'b' => { 'type' => 'A_1(A_2(INT))', 'line' => 1 },
%     'd' => { 'type' => 'CHAR', 'line' => 2 },
%     'f' => { 'type' => 'F_2(INT,A_10(CHAR),CHAR)', 'line' => 3 }
%   },
%   'lines' => 8,
%   'children' => [
%     bless( {
%       'parameters' => [ 'a', 'b' ],
%       'symboltable' => {
%         'e' => { 'type' => 'A_9(CHAR)', 'line' => 5 },
%         'c' => { 'type' => 'A_1(A_2(INT))', 'line' => 4 },
%         'a' => { 'type' => 'INT', 'param' => 1, 'line' => 3 },
%         'b' => { 'type' => 'A_10(CHAR)', 'param' => 1, 'line' => 3 },
%         'd' => { 'type' => 'A_10(CHAR)', 'line' => 5 }
%       },
%       'function_name' => [ 'f', 3 ],
%       'children' => [
%         bless( { # RETURN 
%           'children' => [
%             bless( { 'children' => [], 'attr' => [ 'RETURN', 7 ], 'token' => 'RETURN' }, 'TERMINAL' ),
%             bless( { # VARARRAY 
%               'children' => [
%                 bless( { 'children' => [], 'attr' => [ 'b', 7 ], 'token' => 'ID' }, 'TERMINAL' ),
%                 bless( { # INDEXSPEC 
%                   'children' => [
%                     bless( { # INUM
%                       'children' => [
%                         bless( { 'children' => [], 'attr' => [ '0', 7 ], 'token' => 'INUM' }, 'TERMINAL' )
%                       ]
%                     }, 'INUM' )
%                   ]
%                 }, 'INDEXSPEC' )
%               ]
%             }, 'VARARRAY' )
%           ]
%         }, 'RETURN' )
%       ]
%     }, 'FUNCTION' )
%   ]
% }, 'PROGRAM' );
% \end{verbatim}
% 
% \paragraph{Ejemplo de Salida: Función sin Parámetros}
% Un segundo ejemplo. Ante la entrada:
% \begin{verbatim}
% char d,e[1][2]; 
% char f() {
%   int c[2];
%   char d;
% 
%   return d;
% }
% \end{verbatim}
% Obtenemos la salida:
% \begin{verbatim}
% $VAR1 = bless( {
%   'types' => {
%     'A_1(A_2(CHAR))' => bless( {
%       'children' => [
%         bless( { 'children' => [ bless( { 'children' => [] }, 'CHAR' ) ] }, 'A_2' )
%       ]
%     }, 'A_1' ),
%     'A_2(INT)' => bless( { 'children' => [ bless( { 'children' => [] }, 'INT' ) ] }, 'A_2' ),
%     'CHAR' => bless( { 'children' => [] }, 'CHAR' ),
%     'F_0(CHAR)' => bless( { 'children' => [ bless( { 'children' => [] }, 'CHAR' ) ] }, 'F_0' ),
%     'INT' => bless( { 'children' => [] }, 'INT' )
%   },
%   'symboltable' => {
%     'e' => { 'type' => 'A_1(A_2(CHAR))', 'line' => 1 },
%     'd' => { 'type' => 'CHAR', 'line' => 1 },
%     'f' => { 'type' => 'F_0(CHAR)', 'line' => 2 }
%   },
%   'lines' => 7,
%   'children' => [
%     bless( {
%       'parameters' => [],
%       'symboltable' => {
%         'c' => { 'type' => 'A_2(INT)', 'line' => 3 },
%         'd' => { 'type' => 'CHAR', 'line' => 4 }
%       },
%       'function_name' => [ 'f', 2 ],
%       'children' => [
%         bless( {
%           'children' => [
%             bless( { 'children' => [], 'attr' => [ 'RETURN', 6 ], 'token' => 'RETURN' }, 'TERMINAL' ),
%             bless( {
%               'children' => [
%                 bless( { 'children' => [], 'attr' => [ 'd', 6 ], 'token' => 'ID' }, 'TERMINAL' )
%               ]
%             }, 'VAR' )
%           ]
%         }, 'RETURN' )
%       ]
%     }, 'FUNCTION' )
%   ]
% }, 'PROGRAM' );
% \end{verbatim}
% 
% \sectionpractica{Establecimiento de la relación uso-declaración}
% \label{practica:identificaciondelosnombres}
% En la segunda parte se resuelve el problema de la identificación de los
% nombres estableciendo la relación entre el uso de un nombre y la declaración
% que se le aplica (dada por los atributos \verb|scope| y \verb|type|):

\section{Recursión por la Izquierda}
\label{section:recursionizquierda}

\begin{definition}
Una \cei{gramática es recursiva por la izquierda} cuando existe una derivación
$A \stackrel{*}{\Longrightarrow} A \alpha$. 

En particular, es recursiva por la izquierda si contiene
una regla de producción de la forma $A \rightarrow A \alpha$. 
En este caso se dice que la recursión por la izquierda es directa.
\end{definition}

Cuando la gramática es \cei{recursiva por la izquierda}, 
el método 
de análisis recursivo descendente predictivo no funciona. 
En ese caso, el procedimiento
\verb|A| asociado con $A$ ciclaría para siempre sin llegar a consumir ningún 
terminal. 

\subsection{Eliminación de la Recursión por la Izquierda en la Gramática}
\label{subsection:eliminaleftrec}
Es posible modificar la gramática para eliminar la recursión por 
la izquierda. En este apartado nos limitaremos al caso de recursión 
por la izquierda directa. 
La generalización al caso de recursión por la izquierda no-directa
se reduce a la iteración de la solución propuesta 
para el caso directo.

Consideremos una variable $A$ con dos producciones:

\vspace{0.25cm}
\begin{center}
\begin{tabular}{ll}
$A   \rightarrow A \alpha$  & $|\ \beta$  
\end{tabular}
\end{center}

\noindent donde $\alpha, \beta \in (V \cup \Sigma)^*$ no comienzan por $A$.
Estas dos producciones pueden ser sustituidas por:

\vspace{0.25cm}
\begin{center}
\begin{tabular}{ll}
$A   \rightarrow \beta R$  &\\
$R   \rightarrow  \alpha R$ &$|\ \epsilon$
\end{tabular}
\end{center}

\noindent
eliminando así la recursión por la izquierda.

\begin{definition}
La producción $R   \rightarrow  \alpha R$ se dice \cei{recursiva por la derecha}.
\end{definition}

Las producciones recursivas por la derecha dan lugar a árboles
que se hunden hacia la derecha. Es mas difícil traducir desde esta clase
de árboles operadores como el menos, que son asociativos a izquierdas.

\begin{exercise}
Elimine la recursión por la izquierda de la gramática 

\vspace{0.5cm}
\begin{tabular}{l}
$expr   \rightarrow expr  -  NUM$  \\
$expr   \rightarrow NUM$            
\end{tabular}
\vspace{0.5cm}

\end{exercise}

\begin{exercise}
¿Que hay de erróneo en este esquema de traducción?

\vspace{0.5cm}
\begin{tabular}{ll}
$expr   \rightarrow NUM - expr_1$  & \verb|{ $expr{T} = $NUM{VAL}." ".$expr[1]{T}." - "}| \\
$expr   \rightarrow NUM$           & \verb|{ $expr{T} = $NUM{VAL} }|
\end{tabular}
\vspace{0.5cm}
\end{exercise}

\begin{exercise}
Dado el esquema de traducción:

\vspace{0.25cm}
\begin{tabular}{ll}
$e   \rightarrow\ NUM\ r$    & \verb|{ $e{TRA} = $NUM{VAL}." ".$r{TRA} }| \\
$r   \rightarrow - e$       & \verb|{ $r{TRA} = $e{TRA}." - " }|\\
$r   \rightarrow \epsilon$  & \verb|{ $r{TRA} = "" }|
\end{tabular}
\vspace{0.5cm}

¿Cuál es el lenguaje generado por la gramática? ¿Puede el lenguaje
ser analizado por un APDR?
¿Cual es la traducción de 4-5-6? ¿Es un esquema de traducción adecuado 
para traducir de infijo a postfijo?
¿Cuál es la traducción si cambiamos el anterior esquema por este otro?:

\vspace{0.25cm}
\begin{tabular}{ll}
$e   \rightarrow NUM\  r$    & \verb|{ $e{TRA} = $NUM{VAL}." ".$r{TRA} }| \\
$r   \rightarrow - e$       & \verb|{ $r{TRA} = " - ".$e{TRA} }|\\
$r   \rightarrow \epsilon$  & \verb|{ $r{TRA} = "" }|
\end{tabular}
\vspace{0.5cm}
\end{exercise}

\subsection{Eliminación de la Recursión por la Izquierda en un Esquema de Traducción}
\label{subsection:eliminarecesquem}
La eliminación de la recursión por la izquierda es sólo un paso: debe 
ser extendida a esquemas de traducción, 
de manera que no sólo se preserve el lenguaje
sino la secuencia de acciones. Supongamos que tenemos un esquema de
traducción de la forma:

\vspace{0.25cm}
\begin{tabular}{ll}
$A   \rightarrow A \alpha$  & \verb|{ alpha_action }|\\
$A   \rightarrow A \beta$   & \verb|{ beta_action }|\\
$A   \rightarrow \gamma$    & \verb|{ gamma_action }|
\end{tabular}
\vspace{0.25cm}

\noindent para una sentencia como $\gamma \beta \alpha$ la secuencia de
acciones será: 

\begin{center}
\verb|gamma_action  beta_action alpha_action|
\end{center}

¿Cómo construir un esquema de traducción para la gramática resultante
de eliminar la recursión por la izquierda que ejecute las acciones
asociadas en el mismo orden?. Supongamos para simplificar,
que las acciones no dependen
de atributos ni computan atributos, sino que actúan sobre
variables globales. En tal caso, la siguiente
ubicación de las acciones da lugar a que se ejecuten en el mismo
orden:

\vspace{0.25cm}
\begin{tabular}{l}
$A   \rightarrow \gamma$ \verb|{ gamma_action }| $R$\\
$R   \rightarrow \beta$ \verb| { beta_action }| $R$\\
$R   \rightarrow \alpha$ \verb| { alpha_action }| $R$\\
$R   \rightarrow \epsilon$  
\end{tabular}

Si hay atributos en juego, la estrategia para construir un
esquema de traducción equivalente para la gramática resultante
de eliminar la recursividad por la izquierda se complica.
Consideremos de nuevo el esquema de traducción de infijo a
postfijo de expresiones aritméticas de restas:

\vspace{0.5cm}
\begin{tabular}{ll}
$expr   \rightarrow expr_1  -  NUM$  & \verb|{ $expr{T} = $expr[1]{T}." ".$NUM{VAL}." - "}| \\
$expr   \rightarrow NUM$             & \verb|{ $expr{T} = $NUM{VAL} }|
\end{tabular}
\vspace{0.5cm}

En este caso introducimos un atributo \verb|H| para los nodos de la clase
$r$ el cuál 
acumula la traducción a postfijo hasta el momento. Observe como
este atributo se computa en un nodo $r$ a partir del
correspondiente atributo del el padre y/o de los hermanos del nodo:

\vspace{0.5cm}
\noindent
$expr   \rightarrow NUM$ \verb|{ $r{H} = $NUM{VAL} }|  $r$ \verb|{ $expr{T} = $r{T} }| \\
$r   \rightarrow - NUM$ \verb|{ $r_1{H} = $r{H}." ".$NUM{VAL}." - " }| $r_1$ \verb|{ $r{T} = $r_1{T} }|\\
$r \rightarrow \epsilon$ \verb|{ $r{T} = $r{H} }|
\vspace{0.5cm}

El atributo \verb|H| es un ejemplo de atributo heredado.

\subsection{Ejercicio}
Calcule los valores de los atributos
cuando se aplica el esquema de traducción anterior
a la frase \verb|4 - 5 - 7|. 

\subsection{Convirtiendo el Esquema en un Analizador Predictivo}
% ver directorio /home/lhp/projects/perl/src/topdown/Simple
A partir del esquema propuesto, que se basa en una fase de
descenso con un atributo heredado y una de ascenso con un atributo
sintetizado:

\vspace{0.5cm}
\noindent
$expr   \rightarrow NUM$ \verb|{ $r{H} = $NUM{VAL} }|  $r$ \verb|{ $expr{T} = $r{T} }| \\
$r   \rightarrow - NUM$ \verb|{ $r_1{H} = $r{H}." ".$NUM{VAL}." - " }| $r_1$ \verb|{ $r{T} = $r_1{T} }|\\
$r \rightarrow \epsilon$ \verb|{ $r{T} = $r{H} }|
\vspace{0.5cm}


es posible construir un APDR que ejecuta las acciones semánticas
en los puntos indicados por el esquema de traducción. El atributo heredado
se convierte en un parámetro de entrada a la subrutina asociada con la variable
sintáctica:

\begin{verbatim}
sub expression() {
  my $r = $value." "; #accion intermedia
  match('NUM'); 
  return rest($r); # accion final $expr{T} = $r{T}
}

sub rest($) {
  my $v = shift;

  if ($lookahead eq '-') {
    match('-');
    my $r = "$v $value -"; # accion intermedia
    match('NUM');
    return rest($r); # accion final $r{t} = $r_1{t}
  }
  elsif ($lookahead ne 'EOI') {
    error("Se esperaba un operador");
  }
  else { return $v; } # r -> epsilon { $r{t} = $r{h} }
}
\end{verbatim}

\subsection{Ejercicio}
Generalize la estrategia anterior 
para eliminar la recursividad por la izquierda al siguiente esquema de 
traducción genérico recursivo por la izquierda y
con un atributo sintetizado $A^s$:

\vspace{0.5cm}
\begin{tabular}{ll}
$A   \rightarrow A_1 X_1 X_2 X_3$  & $ \{ A^s = f_X(A^s_1, X_1^s, X_2^s, X_3^s) \}$ \\
$A   \rightarrow A_1 Y_1 Y_2 Y_3$  & $ \{ A^s = f_Y(A^s_1, Y_1^s, Y_2^s, Y_3^s) \}$ \\
$A   \rightarrow Z_1 Z_2 Z_3$      & $ \{ A^s = f_Z(Z_1^s, Z_2^s, Z_3^s) \}$
\end{tabular}
\vspace{0.5cm}

donde $f_X, f_Y$ y $f_Z$ son funciones cualesquiera.

\subsectionpractica{Eliminación de la Recursividad por la Izquierda}
\label{practica:recizq}
En esta práctica  vamos a 
extender las fases de análisis léxico y sintáctico del 
compilador del lenguaje Tutu cuya gramática se definió
en el ejercicio \ref{ejercicio:tutugrammar} 
con expresiones que incluyen diferencias 
y divisiones. Además construiremos una representación
del árbol sintáctico concreto.
Para ello consideremos el siguiente esquema de traducción
recursivo por la izquierda (en concreto las reglas recursivas
por la izquierda son las 10, 11, 13 y 14):

\vspace{0.5cm}
\begin{small}
\begin{tabular}{|r|ll|}
\hline
0 & p  $\rightarrow$  ds  ss     & \verb|{ $p{t}  = { n => 0, ds => $ds{t}, ss => $ss{t} } }|\\
\hline
1 & p  $\rightarrow$  ss         & \verb|{ $p{t}  = { n => 1, ss => $ss{t} } }|\\
\hline
2 & ds $\rightarrow$ d  ';'  ds  & \verb|{ $ds{t} = { n => 2, d => $d{t}, ; => ';', ds => $ds{t} } }|\\
\hline
3 & ds $\rightarrow$  d ';'      & \verb|{ $ds{t} = { n => 3, d => $d{t} ; => ';' } }|\\
\hline
4 & d  $\rightarrow$ INT  il     & \verb|{ $d{t}  = { n => 4, INT => 'INT', il >$il{t} } }|\\
\hline
5 & d  $\rightarrow$  STRING  il & \verb|{ $d{t}  = { n => 5, STRING => 'STRING', il >$il{t} } }|\\
\hline
6 & ss $\rightarrow$ s  ';'  ss  & \verb|{ $ss{t} = { n => 6, s => $s{t}, ; => ';' ss => $ss{t} } }|\\
\hline
7 & ss $\rightarrow$  s          & \verb|{ $ss{t} = { n => 7, s => $s{t} } }|\\
\hline
8 & s  $\rightarrow$ ID '=' e    & \verb|{ $s{t}  = { n => 8, ID => $ID{v}, = => '=', e => $e{t} } }|\\
\hline
9 & s  $\rightarrow$  P  e       & \verb|{ $s{t}  = { n => 9, P => 'P', e => $e{t} } }|\\
\hline
10 & e $\rightarrow$ e1 '+' t    & \verb|{ $e{t}  = { n => 10, e => $e1{t}, + => '+', t => $t{t} } }|\\
\hline
11 & e $\rightarrow$ e1 '-' t    & \verb|{ $e{t}  = { n => 11, e => $e1{t}, - => '-', t => $t{t} } }|\\
\hline
12 & e $\rightarrow$ t           & \verb|{ $e{t}  = { n => 12, t => $t{t} } }|\\
\hline
13 & t $\rightarrow$ t1 '*' f    & \verb|{ $t{t}  = { n => 13, t => $t1{t}, * => '*', f => $f{t} } }|\\
\hline
14 & t $\rightarrow$ t '/' f     & \verb|{ $t{t}  = { n => 14, t => $t1{t}, / => '/', f => $f{t} } }|\\
\hline
15 & t $\rightarrow$ f           & \verb|{ $t{t}  = { n => 15, f => $f{t} } }|\\
\hline
16 & f $\rightarrow$ '(' e ')'   & \verb|{ $f{t}  = { n => 16, ( => '(', e => $e{t}, ) => ')' } }|\\
\hline
17 & f $\rightarrow$  ID         & \verb|{ $f{t}  = { n => 17, ID => $ID{v} } }|\\
\hline
18 & f $\rightarrow$  NUM        & \verb|{ $f{t}  = { n => 18, NUM => $NUM{v} } }|\\
\hline
19 & f $\rightarrow$  STR        & \verb|{ $f{t}  = { n => 19, STR => $STR{v} } }|\\
\hline
20 & il $\rightarrow$ ID ',' il  & \verb|{ $il{t} = { n => 20, ID => $ID{v}, ',' => ',', il => $il{t} } }|\\ 
\hline
21 & il $\rightarrow$ ID         & \verb|{ $il{t} = { n => 21, ID => $ID{v} } }|\\
\hline
22 & s $\rightarrow \epsilon$    &  \verb|{ $s{t} = { n => 22, s => '' }}|\\
\hline
\end{tabular}
\end{small}
\vspace{0.25cm}

Por razones de espacio hemos abreviado los nombres de las variables.
El atributo \verb|t| (por \emph{tree}) es una referencia a un hash.
La entrada \verb|n| contiene el número de la regla en juego.
Hay una entrada por símbolo en la parte derecha. El atributo \verb|v| de 
\verb|ID| es la cadena asociada con el identificador. 
El atributo \verb|v| de \verb|NUM| es el valor numérico asociado con el terminal.
Se trata de, siguiendo la metodología explicada en la sección anterior,
construir un analizador descendente predictivo recursivo que sea equivalente
al esquema anterior. Elimine la recursión por la izquierda. Traslade las acciones a los
lugares convenientes en el nuevo esquema e introduzca los atributos heredados que sean necesarios.
Genere pruebas siguiendo la metodología 
explicada en la sección \ref{subsection:tests}. ¡Note que el árbol que debe producir 
es el de la gramática inicial, ¡No el de la gramática transformada!

\section{Árbol de Análisis Abstracto}
\label{section:aat}
\subsection{Lenguajes Árbol y Gramáticas Árbol}
\label{subsection:lenguajesarbol}
Un \cei{árbol de análisis abstracto}  (denotado \cei{AAA}, en
inglés \cei{abstract syntax tree} o \cei{AST}) 
porta la misma información que
el árbol de análisis sintáctico pero de forma mas condensada, eliminándose
terminales y producciones que no aportan información.

\begin{definition}
Un \cei{alfabeto con función de aridad} es un par $(\Sigma, \rho)$
donde $\Sigma$ es un conjunto finito y
$\rho$ es una función $\rho: \Sigma \rightarrow \mathds{N}_0$, denominada 
\cei{función de aridad}.
Denotamos por $\Sigma_k = \{ a \in \Sigma :\ \rho(a) = k \}$.

Definimos el \cei{lenguaje árbol homogéneo} $B(\Sigma)$ sobre $\Sigma$ inductivamente:
\begin{itemize}
\item
Todos los elementos de aridad 0 están en $B(\Sigma)$: $a \in  \Sigma_0$
implica $a \in B(\Sigma)$
\item
Si $b_1, \ldots , b_k \in B(\Sigma)$ y $f \in \Sigma_k$ es un elemento
$k$-ario, entonces $f(b_1, \ldots , b_k) \in B(\Sigma)$
\end{itemize}
Los elementos de $B(\Sigma)$ se llaman  \cei{árboles} o \cei{términos}.
\end{definition}

\begin{example}
Sea $\Sigma = \{A, CONS, NIL \}$ con $\rho(A) = \rho(NIL) = 0, \rho(CONS) = 2$. 
Entonces 

$B(\Sigma) = \{ A, NIL, CONS(A,NIL), CONS(NIL, A), CONS(A, A), CONS(NIL,NIL), \ldots \}$
\end{example}

\begin{example}
\label{example:tutuast}
Una versión simplificada del alfabeto con aridad en el que estan basados
los árboles construidos por el compilador de Tutu es:

\begin{tabular}{l}
$\Sigma = \{ID, NUM, LEFTVALUE, STR, PLUS, TIMES, ASSIGN, PRINT \}$\\
$\rho(ID) = \rho(NUM) = \rho(LEFTVALUE) = \rho(STR) = 0$\\
$\rho(PRINT) = 1$\\
$\rho(PLUS) = \rho(TIMES) = \rho(ASSIGN) = 2$.
\end{tabular}

Observe que los elementos en $B(\Sigma)$ no necesariamente son 
árboles ``correctos''. Por ejemplo, el árbol
$ASSIGN(NUM, PRINT(ID))$
es un elemento de $B(\Sigma)$.
\end{example}

\begin{definition}
Una \cei{gramática árbol regular} es una cuadrupla $((\Sigma, \rho), N, P, S)$, 
donde:
\begin{itemize}
\item
$(\Sigma, \rho)$ es un alfabeto con aricidad $\rho: \Sigma \rightarrow \mathds{N}$
\item
$N$ es un conjunto finito de variables sintácticas o no terminales
\item
$P$ es un conjunto finito de reglas de producción de la forma
$X \rightarrow s$ con $X \in N$ y $s \in B(\Sigma \cup N)$
\item
$S \in N$ es la variable o símbolo de arranque
\end{itemize}


%Definimos el patrón $\tilde{s}$ asociado con la parte derecha $s$
%como el  patrón en $B(\Sigma \cup \{x_1, \ldots x_k\})$ resultante
%de reemplazar los noterminales $X_j$ de $N$ por las variables $x_j$.
\end{definition}

\begin{definition}
Dada una gramática $(\Sigma, N, P, S)$,
se dice que un árbol $t \in B(\Sigma \cup N)$ es del tipo $(X_1, \ldots X_k)$
si el $j$-ésimo noterminal, contando desde la izquierda, que aparece en $t$
es $X_j \in N$. 

Si $p = X \rightarrow s$ es una producción y $s$ es de tipo $(X_1, \ldots X_n)$,
diremos que la producción $p$ es de tipo $(X_1, \ldots X_n) \rightarrow X$.
\end{definition}

\begin{definition}
Consideremos un árbol  $t \in B(\Sigma \cup N)$
que sea del tipo $(X_1, \ldots X_n)$, esto es las variables sintácticas
en el árbol leídas de izquierda a derecha son $(X_1, \ldots X_n)$.

\begin{itemize}
\item
Si $X_i \rightarrow s_i \in P$ para algún $i$, entonces 
decimos que el árbol $t$ \cei{deriva en un paso en el árbol}
$t'$ resultante de sustituir el nodo $X_i$ por el árbol $s_i$ y escribiremos
$t \Longrightarrow t'$.  Esto es, $t' = t\{X_i/s_i\}$
\item
Todo árbol deriva en cero pasos
en si mismo $t \stackrel{0}{\Longrightarrow} t$. 
\item
Decimos que un árbol $t$ deriva en $n$ pasos en el árbol $t'$
y escribimos $t \stackrel{n}{\Longrightarrow} t'$
si $t$ deriva en un paso en un árbol $t''$ el cuál deriva en $n-1$ pasos en $t'$.
En general, si $t$ deriva en un cierto número de pasos en $t'$ escribiremos
$t \stackrel{*}{\Longrightarrow} t'$.
\end{itemize}
\end{definition}

\begin{definition}
Se define el \cei{lenguaje árbol generado por una gramática} $G = (\Sigma, N, P, S)$
como el lenguaje $L(G) = \{ t \in B(\Sigma): \exists S \stackrel{*}{\Longrightarrow} t \}$.
\end{definition}

\begin{example}
\label{example:listtreegrammar}
Sea $G = (\Sigma, V, P, S)$ con
$\Sigma = \{A, CONS, NIL \}$ y $\rho(A) = \rho(NIL) = 0, \rho(CONS) = 2$
y sea $V = \{ E, L \}$. El conjunto de producciones $P$ es:

\begin{center}
$P_1 = \{ L \rightarrow NIL, L \rightarrow CONS(E,L),E \rightarrow a \}$
\end{center}

La producción $L \rightarrow CONS(E,L)$ es del tipo $(E,L) \rightarrow L$. 
%El patrón asociado con su parte derecha $s = CONS(E,L)$ es $\tilde{s} = CONS(x_1, x_2)$. 

Informalmente, el lenguaje generado por $G$ se obtiene realizando sustituciones
sucesivas (derivando) desde el símbolo de arranque hasta producir un
árbol cuyos nodos estén etiquetados con elementos de $\Sigma$. Debería ser claro
que, en este ejemplo, $L(G)$ es el conjunto de las listas en $A$, incluyendo la lista vacía:

\begin{center}
$L(G) = \{ NIL, CONS(A, NIL), CONS(A, CONS(A,NIL)), \ldots \}$
\end{center}

\end{example}

\begin{exercise} 
Construya una derivación para el árbol $CONS(A, CONS(A,NIL))$.
¿De que tipo es el árbol $CONS(E, CONS(A, CONS(E,L)))$?.
\end{exercise}

Cuando hablamos del AAA producido por un analizador sintáctico,
estamos en realidad hablando de un lenguaje árbol cuya definición 
precisa debe hacerse a través de una gramática
árbol regular.
Mediante las gramáticas árbol regulares disponemos de un mecanismo para
describir formalmente el lenguaje de los 
AAA que producirá el analizador sintáctico
para las sentencias Tutu.

\begin{example}
\label{example:tututreegrammar}
Sea $G = (\Sigma, V, P, S)$ con

\begin{center}
\begin{tabular}{l}
$\Sigma = \{ID, NUM, LEFTVALUE, STR, PLUS, TIMES, ASSIGN, PRINT \}$\\
$\rho(ID) = \rho(NUM) = \rho(LEFTVALUE) = \rho(STR) = 0$\\
$\rho(PRINT) = 1$\\
$\rho(PLUS) = \rho(TIMES) = \rho(ASSIGN) = 2$\\
$V = \{ st, expr \}$\\
\end{tabular}
\end{center}
y las producciones:

\begin{center}
\begin{tabular}{lll}
$P =$    &$\{$      &\\
         & $st$     &$\rightarrow ASSIGN(LEFTVALUE, expr)$\\
         & $st$     &$\rightarrow PRINT(expr)$\\
         & $expr$   &$\rightarrow PLUS(expr, expr)$\\
         & $expr$   &$\rightarrow TIMES(expr, expr)$\\
         & $expr$   &$\rightarrow NUM$\\
         & $expr$   &$\rightarrow ID$\\
         & $expr$   &$\rightarrow STR$\\
         &$\}$      & 
\end{tabular}
\end{center}

Entonces el lenguaje $L(G)$ contiene árboles
como el siguiente: 

\begin{tabular}{llll}
$ASSIGN$  & $($          &         &\\
          & $LEFTVALUE$, &   &\\
          & $PLUS$       & $($     &\\
          &              & $ID$,   & \\
          &              & $TIMES$ & $($\\
          &              &         & $NUM$,\\
          &              &         & $ID$\\
          &              &         & $)$\\
          &              & $)$     &\\
          & $)$          &         &
\end{tabular}

El cual podría corresponderse con una sentencia como
\verb|a = b + 4 * c|.

El lenguaje de árboles descrito por esta gramática árbol 
es el lenguaje de los AAA de las sentencias de Tutu.
\end{example}

\begin{exercise}
Redefina el concepto de árbol de análisis concreto dado
en la definición \ref{definition:arbolconcreto} utilizando el
concepto de gramática árbol. Con mas precisión,
dada una gramática $G = (\Sigma, V, P, S)$ defina una gramática
árbol $T = (\Omega, N, R, U)$ tal que $L(T)$ sea el lenguaje 
de los árboles concretos de $G$. Puesto que las partes 
derechas de las reglas de producción de $P$ pueden ser 
de distinta longitud, existe un problema con
la aricidad de los elementos de $\Omega$. Discuta posibles
soluciones.
\end{exercise}

\begin{exercise}
¿Cómo son los árboles sintácticos en las derivaciones árbol?
Dibuje varios árboles sintácticos para las gramáticas 
introducidas en los ejemplos 
\ref{example:listtreegrammar}
y \ref{example:tututreegrammar}.

Intente dar una definición formal del concepto de árbol de análisis
sintáctico asociado con una derivación en una gramática árbol
\end{exercise}

\begin{definition} 
\label{definition:dewey}
La notación de Dewey es una forma de especificar los subárboles
de un árbol $t \in B(\Sigma)$. La notación sigue el mismo
esquema que la numeración de secciones en un texto: 
es una palabra formada por números separados
por puntos. Así {\it t/2.1.3 }
denota al tercer hijo del primer hijo del segundo hijo
del árbol $t$.
La definición formal sería:
\begin{itemize}
\item
$t/\epsilon = t$
\item
Si $t = a(t_1, \ldots t_k)$ y $j \in \{ 1 \ldots k \}$ y $n$ es una 
cadena de números y puntos, se define 
inductivamente el subárbol $t/j.n$ como el subárbol $n$-ésimo del
$j$-ésimo subárbol de $t$. Esto es: $t/j.n = t_j/n$
\end{itemize}
\end{definition}

\begin{exercise}
Sea el árbol:

\vspace{0.5cm}
\begin{tabular}{llll}
$t = ASSIGN$  & $($          &         &\\
          & $LEFTVALUE$, &   &\\
          & $PLUS$       & $($     &\\
          &              & $ID$,   & \\
          &              & $TIMES$ & $($\\
          &              &         & $NUM$,\\
          &              &         & $ID$\\
          &              &         & $)$\\
          &              & $)$     &\\
          & $)$          &         &
\end{tabular}

\vspace{0.5cm}
Calcule los subárboles $t/\epsilon$, $t/2\ldotp2\ldotp1$, $t/2\ldotp1$ y $t/2\ldotp1\ldotp2$.
\end{exercise}

\subsection{Realización del AAA para Tutu en Perl}
En la sección 
\ref{subsection:introduccion}
nos limitamos a realizar un recorrido del árbol
de análisis sintáctico concreto. En esta sección construimos un 
\cei{árbol de análisis sintáctico abstracto}. Este proceso puede
verse como \emph{la traducción desde el lenguaje de árboles concretos
hasta el lenguaje de árboles abstractos}.

\begin{definition}
\label{definition:tutuast}
La gramática árbol extendida que especifica los árboles AAA
para el compilador de Tutu es esta:

\begin{center}
\begin{tabular}{l|ll}
  1 & $prog$   &$\rightarrow PROGRAM(decls, sts)$\\
  2 & $decls$  &$\rightarrow$ list $decl$\\
  3 & $sts$    &$\rightarrow$ list $st$\\
  4 & $decl$   &$\rightarrow INT(idlist)$\\
  5 & $decl$   &$\rightarrow STRING(idlist)$\\
  6 & $idlist$ &$\rightarrow$ list $SIMPLEID$\\
  7 & $st$     &$\rightarrow ASSIGN(LEFTVALUE, expr)$\\
  8 & $st$     &$\rightarrow PRINT(expr)$\\
  9 & $expr$   &$\rightarrow PLUS(expr, expr)$\\
 10 & $expr$   &$\rightarrow TIMES(expr, expr)$\\
 11 & $expr$   &$\rightarrow NUM$\\
 12 & $expr$   &$\rightarrow ID$\\
 13 & $expr$   &$\rightarrow STR$\\
\end{tabular}
\end{center}
\end{definition}

Hemos extendido el concepto de gramática 
árbol con el concepto de \cei{lista de no terminales}. 
A la hora de construir las estructuras de datos
las listas de variables se van a traducir por listas de árboles.

Por ejemplo, un árbol abstracto para el programa

\begin{verbatim}
int a,b;
string c, d;
a = 4;
p a
\end{verbatim}

Sería de la forma:

\begin{verbatim}
PROGRAM(
         DECLS[INT[ID, ID], STRING[ID, ID]], 
         STS[ASSIGN(LEFTVALUE, NUM), PRINT(ID)]
       )
\end{verbatim}

Donde los corchetes indican listas y los paréntesis tuplas.

Para llevar a cabo la traducción deberemos 
tomar decisiones sobre que forma de representación nos conviene.
Cada nodo del AAA va a ser un objeto y la clase indicará si es un nodo
suma, producto, una declaración, una asignación, etc. 

Cada nodo del árbol AAA va a ser un objeto. 
De este modo el acceso a los atributos del nodo se hará a través de
los métodos asociados. Además, el procedimiento de traducción
al lenguaje objetivo depende del tipo de nodo. Así por ejemplo,
el método \emph{traducción}
es diferente para un nodo de tipo $PLUS$ que para otro de tipo $ASSIGN$.

Resumamos antes de entrar en detalle, la forma de manejar los
objetos en Perl:

\begin{itemize}
\item
Para crear una \cei{clase} se construye un ``package'':
\begin{verbatim}
package NUM;
\end{verbatim}
\item
Para crea un \cei{método} se escribe una subrutina:
\begin{verbatim}
package NUM;
sub incr { my $self = shift; $self->{VAL}++ }
\end{verbatim}
el primer argumento de un método suele ser la referencia al 
objeto en cuestión.
\item
Para crear un \cei{objeto}, se bendice (``bless'') una referencia.
Los objetos Perl son datos normales como hashes y arrays que han sido 
``bendecidos'' en un paquete. Por ejemplo:
\begin{verbatim}
my $a = bless {VAL => 4}, 'NUM';
\end{verbatim}
crea un objeto referenciado por \verb|$a| que pertenece a la clase \verb|NUM|.
Los métodos del objeto son las subrutinas que aparecen en el \verb|package NUM|.
\item
Para referirse a un método de un objeto se usa la sintáxis ``flecha'':
\begin{verbatim}
$a->incr;
\end{verbatim}
Cuando se usa la sintáxis flecha, el primer argumento de la rutina es 
la referencia al objeto, esto es, la llamada anterior es equivalente a
\verb|NUM::incr($a)|
\item
Constructores: En Perl son rutinas que retornan una referencia a un objeto 
recién creado e inicializado
\begin{verbatim}
sub new { my ($class, $value) = @_; return bless {VAL => $value}, $class; }
\end{verbatim}
Normalmente se llaman usando la sintáxis flecha, pero a la izquierda de la
flecha va el nombre de la clase. Por ejemplo:

\verb|my $a = NUM->new(4)| 

En este caso,
el primer argumento es el nombre de la clase. La llamada anterior es
equivalente a 

\verb|NUM::new('NUM', 4)|
\end{itemize}

Volviendo a nuestro problema de crear el AAA, para crear los 
objetos de las diferentes clases de nodos
usaremos el módulo  \verb|Class::MakeMethods::Emulator::MethodMaker|
(véase la línea 9):

\begin{verbatim}
 1 package PL::Syntax::Analysis;
 2
 3 use 5.006;
 4 use strict;
 5 use warnings;
 6 use Data::Dumper;
 7 use IO::File;
 8 use Class::MakeMethods::Emulator::MethodMaker '-sugar';
 9
10 require Exporter;
11 our @ISA = qw(Exporter);
12 our @EXPORT = qw( );
13 our $VERSION = '0.02';
14
15 #######################################################
16
17 # Grammar:
18 # P : DD L      | L
19 # DD: D ';' DD  | D ';'
20 # D : int I     | string I
21 # L : S         | S ; L
22 # S : ID '=' E  | p E  | epsilon
23 # E : T '+' E   | T
24 # T : F '*' T   | F
25 # F : '(' E ')' | id | num | str
26 # I : id ',' I  | id
\end{verbatim}

Hemos aislado la fase de análisis sintáctica en un módulo
aparte denominado \verb|PL::Syntax::Analysis|.
La dependencia se actualiza en \verb|Makefile.PL|:
\begin{verbatim}
PL0506/04sintactico/PL-Tutu$ cat -n Makefile.PL
  1  use 5.008004;
  2  use ExtUtils::MakeMaker;
  3  WriteMakefile(
  4      NAME              => 'PL::Tutu',
  5      VERSION_FROM      => 'lib/PL/Tutu.pm', # finds $VERSION
  6      PREREQ_PM         => {Class::MakeMethods::Emulator::MethodMaker => 0},1
  7      EXE_FILES         => [ 'scripts/tutu.pl', 'scripts/tutu' ],
  8      ($] >= 5.005 ?     ## Add these new keywords supported since 5.005
  9        (ABSTRACT_FROM  => 'lib/PL/Tutu.pm', # retrieve abstract from module
 10         AUTHOR         => 'Casiano Rodriguez Leon <casiano@ull.es>') : ()),
 11  );
\end{verbatim}
Se actualiza también MANIFEST:
\begin{verbatim}
$ cat -n MANIFEST
 1  Changes
 2  lib/PL/Error.pm
 3  lib/PL/Lexical/Analysis.pm
 4  lib/PL/Syntax/Analysis.pm
 5  lib/PL/Tutu.pm
 6  Makefile.PL
 7  MANIFEST
 8  MANIFEST.SKIP
 9  README
10  scripts/test01.tutu
11  scripts/tutu
12  scripts/tutu.pl
13  t/01Lexical.t
\end{verbatim}

Ahora \verb|compile| llama a \verb|Syntax::Analysis::parser| pasándole
como argumento la lista de terminales \verb|@tokens|. La función \verb|parser|
devuelve el AAA:
\begin{verbatim}
04sintactico/PL-Tutu/lib/PL$ sed -ne '/sub compile\>/,/^}/p' Tutu.pm | cat -n
  1  sub compile {
  2    my ($input) = @_;
  3    #my %symbol_table = ();
  4    #my $data = ""; # Contiene todas las cadenas en el programa fuente
  5    my $target = ""; # target code
  6    my @tokens = ();
  7    my $tree = undef; # abstract syntax tree
  8    #my $global_address = 0;
  9
 10
 11    ########lexical analysis
 12    @tokens = scanner($input);
 13    #print "@tokens\n";
 14
 15    ########syntax (and semantic) analysis
 16    $tree = &Syntax::Analysis::parser(@tokens);
 17    print Dumper($tree);
 18
 19    ########machine independent optimizations
 20    &Machine::Independent::Optimization::Optimize;
 21
 22    ########code generation
 23    &Code::Generation::code_generator;
 24
 25    ########peephole optimization
 26    &Peephole::Optimization::transform($target);
 27
 28    return \$target;
 29  }
\end{verbatim}
El módulo \verb|Class::MakeMethods::Emulator::MethodMaker|
permite crear constructores y métodos de acceso.
El módulo no viene con la distribución de Perl, así que, en general, deberá 
descargarlo desde CPAN e instalarlo.
Así definimos que existe una clase de nodos \verb|TYPE|
que nuestro AAA va a tener:

\begin{verbatim}
package TYPE;
make methods
  get_set       => [ 'NAME', 'LENGTH' ],
  new_hash_init => 'new';
\end{verbatim}

El uso de los argumentos \verb|get_set => [ 'NAME', 'LENGTH' ]|
hace que se cree un objeto de tipo hash  con claves 
\verb|'NAME'| y \verb|'LENGTH'| así como métodos \verb|NAME|
y \verb|LENGTH| que cuando se llaman con un argumento devuelven
el valor y cuando se llaman con dos argumentos modifican el
valor correspondiente. 
La clave \verb|get_set| produce métodos de acceso
y modificación de los atributos del objeto que
tienen la forma:

\begin{verbatim}
sub TYPE::NAME {
  my ($self, $new) = @_;
  defined($new) and $self->{NAME} = $new;
  return $self->{NAME};
}
\end{verbatim}

Asi mismo el uso de \verb|new_hash_init => 'new'|
genera un constructor cuyo nombre
será \verb|'new'| y que cuando es llamado inicializará el
objeto con los argumentos con nombre especificados en la llamada.
El constructor construído (vaya retruécano) cuando se usa la clave
\verb|new_hash_init| tiene el siguiente aspecto:

\begin{verbatim}
sub TYPE::new {
  my ($class, %args) = @_;
  my $self = {};

  bless $self, $class;
  foreach my $attribute (keys %args) {
    $self->$attribute($args{$attribute});
  }
  return $self;
}
\end{verbatim}

Ahora podemos crear objetos de la clase \verb|TYPE| haciendo:
\begin{verbatim}
my $int_type = TYPE->new(NAME => 'INTEGER', LENGTH => 1); 
my $string_type = TYPE->new(NAME => 'STRING', LENGTH => 2);
my $err_type = TYPE->new(NAME => 'ERROR', LENGTH => 0);
\end{verbatim}
Cada uno de estos objetos es un hash con las correspondientes
claves para el nombre y el tipo.

Otros tipos de nodos del AAA son:

\begin{verbatim}
package PROGRAM; # raíz del AAA
make methods
  get_set       => [ 'DECLS', 'STS' ],
  new_hash_init => 'new';

package STRING; # tipo
make methods
  get_set       => [ 'TYPE', 'IDLIST' ],
  new_hash_init => 'new';

package INT; # tipo
make methods
  get_set       => [ 'TYPE', 'IDLIST' ],
  new_hash_init => 'new';

package ASSIGN; #sentencia
make methods
  get_set       => [ 'LEFT', 'RIGHT' ],
  new_hash_init => 'new';

package PRINT; #sentencia
make methods
  get_set       => [ 'EXPRESSION' ],
  new_hash_init => 'new';

package NUM; # para los números
make methods
  get_set       => [ 'VAL', 'TYPE' ],
  new_hash_init => 'new';

package ID; # Nodos identificador. Parte derecha
make methods
  get_set       => [ 'VAL', 'TYPE' ],
  new_hash_init => 'new';

package STR; # Clase para las constantes cadena
make methods
  get_set       => [ 'OFFSET', 'LENGTH', 'TYPE' ],
  new_hash_init => 'new';

package PLUS; # Nodo suma
make methods
  get_set       => [ 'LEFT', 'RIGHT', 'TYPE' ],
  new_hash_init => 'new';

package TIMES;
make methods
  get_set       => [ 'LEFT', 'RIGHT', 'TYPE' ],
  new_hash_init => 'new';

package LEFTVALUE; # Identificador en la parte izquierda
make methods       # de una asignación
  get_set       => [ 'VAL', 'TYPE' ],
  new_hash_init => 'new';
\end{verbatim}


Hemos extendido el concepto de gramática 
árbol con el concepto de \cei{lista de no terminales}. 
A la hora de construir las estructuras de datos
las listas de variables se van a traducir por listas de árboles.
Los tipos de nodos ($ASSIGN$, $PRINT$, \ldots )
se traducen en nombres de clases. Hemos hecho
una excepción con $SIMPLEID$ el cual es simplemente una 
variable cadena conteniendo el identificador correspondiente.

El siguiente esquema de traducción resume la idea para una gramática 
simplificada: cada vez que encontremos un nodo en el árbol sintáctico 
concreto con una operación crearemos un nodo en el AAA cuya clase
viene definida por el tipo de operación. Para los terminales
creamos igualmente nodos indicando de que clase de terminal 
se trata. El atributo nodo lo denotaremos por \verb|n|:

\vspace{0.25cm}
\begin{tabular}{ll}
$e   \rightarrow\ e_1 + f$  & \verb|{ $e{n} = PLUS->new(LEFT=>$e_1{n}, RIGHT=>$f{n}) }| \\
$f   \rightarrow NUM$       & \verb|{ $f{n} = NUM->new(VAL => $NUM{VAL}) }|\\
$f   \rightarrow ID$        & \verb|{ $f{n} = ID->new(VAL => $ID{VAL}) }|
\end{tabular}
\vspace{0.5cm}

La estructura de cada rutina sigue siendo la misma, 
sólo que ampliada con las acciones para la construcción de los
correspondientes nodos. Veamos por ejemplo, como modificamos
la subrutina factor:

\begin{verbatim}
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') {
    $num = $value;
    match('NUM');
    return NUM->new(VAL => $num, TYPE => $int_type);
  }
  elsif ($lookahead eq 'ID') {
    $id = $value;
    match('ID');
    return ID->new( VAL => $id, TYPE => undef);
  }
  elsif ($lookahead eq 'STR') {
    $str = $value;
    match('STR');
    return STR->new(OFFSET => undef, LENGTH => undef, TYPE => $string_type);
  }
  elsif ($lookahead eq '(') {
    match('(');
    $e = expression;
    match(')');
    return $e;
  }
  else {
    Error::fatal("Se esperaba (, NUM o ID");
  }
}
\end{verbatim}

\subsection{AAA: Otros tipos de nodos}
Hemos optado por que las rutinas asociadas a variables sintácticas que 
describen listas de subcategorías devuelvan 
las correspondientes listas de nodos. Teníamos tres variables tipo lista.
Las reglas para las listas eran:

\vspace{0.25cm}
\begin{center}
\begin{tabular}{|l||l|}
\hline
Gramática de los Árboles de Tutu       & Gramática del lenguaje Tutu\\
\hline
$decls$  $\rightarrow list\ decl$ & declarations $\rightarrow$ declaration  ';'  declarations    $|$ declaration ';'\\
\hline
$sts$    $\rightarrow list\ st$ & statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
\hline
$idlist$ $\rightarrow list\ SIMPLEID$ & idlist       $\rightarrow$ ID ',' idlist $|$ ID\\
\hline
\end{tabular}
\end{center}

En este caso las subrutinas asociadas no devuelven
objetos sino listas de objetos. 
Esto da lugar a una compactación del AAA.
Veánse los códigos de \verb|statements| y \verb|idlist|:
\begin{verbatim}
sub statements() {
  my @s;

  @s = (statement());
  if ($lookahead eq ';') {
    match(';');
    push @s, statements();
  }
  return @s;
}

sub idlist() {
  my @id;

  if ($lookahead eq 'ID') {
    @id = ($value); # no es un objeto 
    match('ID');
    if ($lookahead eq ',') {
      match(',');
      push @id, idlist();
    }
  }
  else {
    Error::fatal('Se esperaba un identificador');
    @id = ('ERROR');
  }
  return @id;
}
\end{verbatim}

\subsection{Declaraciones}
 Los nodos del tipo declaration no existen propiamente, son nodos 
de la clase $INT$ o de la clase $STRING$. 
La parte de la gramática árbol de la que hablamos es:

\begin{center}
\begin{tabular}{l|ll}
  2 & $decls$  &$\rightarrow$ list $decl$\\
  4 & $decl$   &$\rightarrow INT(idlist)$\\
  5 & $decl$   &$\rightarrow STRING(idlist)$\\
  6 & $idlist$ &$\rightarrow$ list $SIMPLEID$\\
\end{tabular}
\end{center}

Los nodos declaration son un hash con una clave \verb|TYPE| la cual
apunta a la estructura de datos/objeto
describiendo el tipo. La otra clave del hash \verb|IDLIST| apunta  a una 
lista de identificadores. Los elementos de esta lista son simples
identificadores (identificados en la gramática árbol anterior 
como $SIMPLEID$ y no como objetos $ID$).
La parte de la gramática implicada en las declaraciones es:

\vspace{0.5cm}
\begin{tabular}{l}
declaration  $\rightarrow$ INT  idlist   $|$ STRING   idlist\\
idlist       $\rightarrow$ ID ',' idlist $|$ ID
\end{tabular}
\vspace{0.25cm}

Así pues, el código construye un nodo de la clase 
\verb|INT| o \verb|STRING| según sea el caso.

\begin{verbatim}
sub declaration() {
  my ($t, $class, @il);

  if (($lookahead eq 'INT') or ($lookahead eq 'STRING')) {
    $class = $lookahead;
    $t = &type();
    @il = &idlist();
    return $class->new(TYPE => $t, IDLIST => \@il);
  }
  else {
    Error::fatal('Se esperaba un tipo');
  }
}
\end{verbatim}
Observe la llamada \verb|$class->new(TYPE => $t, IDLIST => \@il)|
en la cual la clase se usa a través de una referencia simbólica.

\subsectionpractica{Arbol de Análisis Abstracto}
\label{practica:AAA}
Complete la fase de análisis sintáctico para la gramática  de Tutu extendida 
con sentencias de bloque (vea las reglas 1,2,3 y 11)
construyendo el AAA según el lenguaje árbol especificado  
por una gramática árbol que extienda la dada en la definición 
\ref{definition:tutuast}.
Genere pruebas, usando \verb|make test| 
para comprobar el correcto funcionamiento de su analizador sobre las mismas.
Utilize el módulo \verb|Data::Dumper| para volcar las estructuras de datos
resultantes.

\vspace{0.5cm}
\begin{small}
\begin{center}
\begin{tabular}{|r|l|}
\hline
1 &  p  $\rightarrow$  b     \\
\hline
2 &  b  $\rightarrow$  ds  ss     \\
\hline
3 &  b  $\rightarrow$  ss         \\
\hline
4 &  ds $\rightarrow$ d  ';'  ds  \\
\hline
5 &  ds $\rightarrow$  d ';'      \\
\hline
6 &  d  $\rightarrow$ INT  il     \\
\hline
7 &  d  $\rightarrow$  STRING  il \\
\hline
8 &  ss $\rightarrow$ s  ';'  ss  \\
\hline
9 &  ss $\rightarrow$  s          \\
\hline
10 &  s  $\rightarrow$ ID = e   \\
\hline
11 &  s  $\rightarrow$ '\{' b '\}'   \\
\hline
12 &  s  $\rightarrow$  P  e       \\
\hline
13 &  s $\rightarrow \epsilon$    \\
\hline
14 &  e $\rightarrow$ e1 '+' t    \\
\hline
15 &  e $\rightarrow$ e1 '-' t    \\
\hline
16 &  e $\rightarrow$ t           \\
\hline
17 &  t $\rightarrow$ t1 '*' f    \\
\hline
18 &  t $\rightarrow$ t '/' f     \\
\hline
19 &  t $\rightarrow$ f           \\
\hline
20 &  f $\rightarrow$ '(' e ')'   \\
\hline
21 &  f $\rightarrow$  ID         \\
\hline
22 &  f $\rightarrow$  NUM        \\
\hline
23 &  f $\rightarrow$  STR        \\
\hline
24 &  il $\rightarrow$ ID ',' il  \\
\hline
25 &  il $\rightarrow$ ID         \\
\hline
\end{tabular}
\end{center}
\end{small}
\vspace{0.25cm}


%\subsectionpractica{Recursividad por la Izquierda}
%Escriba un programa Perl que indique que reglas de producción de una gramática
%independiente del contexto (administrada como en el ejemplo desarrollado 
%en la sección \ref{subsection:dbmhashes}) son
%recursivas por la izquierda. Se dice que una regla de producción es
%recursiva por la izquierda si es de la forma $A->A \beta$. Esto es, la variable
%sintáctica $A$ es el primer símbolo de la parte derecha de la regla
%de producción.

\section{Análisis Semántico}
Hay quien dice que el análisis semántico es la determinación 
de aquellas propiedades que, siendo dependientes del contexto, pueden ser
computadas estáticamente en tiempo de compilación para cualquier programa
correcto. Entre estas propiedades
están: la comprobación de que las variables son declaradas,
la compatibilidad de tipos
en las expresiones, el correcto uso de las llamadas a función asi
como el ámbito y visibilidad de las variables.
La fase de análisis semántico puede verse como una fase de ``adornado''
o ``etiquetado'' del AAA, en la cual los atributos de los nodos
del AAA son computados.

Aunque la veamos como una fase separada del análisis sintáctico, puede
en numerosas ocasiones llevarse a cabo al mismo tiempo que se construye
el árbol. Así lo hacemos en este ejemplo: incrustamos la acción semántica
en la correspondiente rutina de análisis sintáctico. Así, en la rutina \verb|term|, una vez 
que hemos obtenido los dos operandos, comprobamos que son de tipo numérico
llamando (línea 8) a 

\begin{center}
\verb|Semantic::Analysis::check_type_numeric_operator|:
\end{center}

Observe como aparece un nuevo atributo \verb|TYPE| decorando el nodo
creado (línea 9):

\begin{verbatim}
 1 sub term() {
 2   my ($t, $t2);
 3 
 4   $t = factor;
 5   if ($lookahead eq '*') {
 6     match('*');
 7     $t2 = term;
 8     my $type = Semantic::Analysis::check_type_numeric_operator($t, $t2, '*');
 9     $t = TIMES->new( LEFT => $t, RIGHT => $t2, TYPE => $type);
10   }
11   return $t;
12 }
\end{verbatim}

En el manejo de errores de tipo, un tipo especial \verb|$err_type|
es usado para indicar un error de tipo:

\begin{verbatim}
  sub check_type_numeric_operator {
    my ($op1, $op2, $operator) = @_;

    my $type = numeric_compatibility($op1, $op2, $operator);
    if ($type == $err_type) {
      Error::fatal("Operandos incompatibles para el operador $operator") 
    }
    else {
      return $type;
    }
  }
\end{verbatim}
La subrutina \verb|numeric_compatibility| comprueba que los
dos operandos son de tipo numérico y devuelve el correspondiente
tipo. Si ha ocurrido un error de tipo, intenta encontrar 
un tipo conveniente para el operando:

\begin{verbatim}
  sub numeric_compatibility {
    my ($op1, $op2, $operator) = @_;

    if (($op1->TYPE == $op2->TYPE) and is_numeric($op1->TYPE)) {
      return $op1->TYPE; # correct
    }
    ... # código de recuperación de errores de tipo
  }

  sub is_numeric {
    my $type = shift;

    return ($type == $int_type); # añadir long, float, double, etc.
  }
\end{verbatim}

Es parte del análisis semántico la declaración de tipos:

\begin{verbatim}
sub declaration() {
  my ($t, $class, @il);

  if (($lookahead eq 'INT') or ($lookahead eq 'STRING')) {
    $class = $lookahead;
    $t = &type();
    @il = &idlist();
    &Semantic::Analysis::set_types($t, @il);
    &Address::Assignment::compute_address($t, @il);
    return $class->new(TYPE => $t, IDLIST => \@il);
  }
  else {
    Error::fatal('Se esperaba un tipo');
  }
}
\end{verbatim}
Para ello se utiliza una tabla de símbolos que es un hash \verb|%symbol_table|
indexado en los identificadores del programa:

\begin{verbatim}
sub set_types {
  my $type = shift;
  my @vars = @_;

  foreach my $var (@vars) {
    if (!exists($symbol_table{$id})) { $symbol_table{$var}->{TYPE} = $type; }
    else { Error::error("$id declarado dos veces en el mismo ámbito"); }
  }
}
\end{verbatim}

Cada vez que aparece una variable en el código, bien en un factor o en 
una asignación, comprobamos que ha sido declarada:

\begin{verbatim}
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') { ... }
  elsif ($lookahead eq 'ID') {
    $id = $value;
    match('ID');
    my $type = Semantic::Analysis::check_declared($id);
    return ID->new( VAL => $id, TYPE => $type);
  }
  elsif ($lookahead eq 'STR') { ... }
  elsif ($lookahead eq '(') { ... }
  else { Error::fatal("Se esperaba (, NUM o ID"); }
}
\end{verbatim}

La función \verb|check_declared| devuelve el atributo
\verb|TYPE| de la correspondiente entrada en la tabla de 
símbolos.

\begin{verbatim}
sub check_declared {
  my $id = shift;

  if (!exists($symbol_table{$id})) {
    Error::error("$id no ha sido declarado!");
    # auto-declaración de la variable a err_type
    Semantic::Analysis::set_types($err_type, ($id));
  }
  return $symbol_table{$id}->{TYPE};
}
\end{verbatim}


\subsectionpractica{Declaraciones Automáticas}

Modifique la subrutina \verb|check_declared| para que cuando
una variable no haya sido declarada se declare ``sobre la marcha''. 
¿Puede utilizar 
información dependiente del contexto para decidir cual es la mejor forma
de declararla?

\subsectionpractica{Análisis Semántico}
\label{practica:analisis_semantico}
Extienda el código de la práctica 
\ref{practica:AAA}
para comprobar la compatibilidad de tipos.

\vspace{0.5cm}
\begin{small}
\begin{center}
\begin{tabular}{|r|l|}
\hline
1 &  p  $\rightarrow$  b     \\
\hline
2 &  b  $\rightarrow$  ds  ss     \\
\hline
3 &  b  $\rightarrow$  ss         \\
\hline
4 &  ds $\rightarrow$ d  ';'  ds  \\
\hline
5 &  ds $\rightarrow$  d ';'      \\
\hline
6 &  d  $\rightarrow$ INT  il     \\
\hline
7 &  d  $\rightarrow$  STRING  il \\
\hline
8 &  ss $\rightarrow$ s  ';'  ss  \\
\hline
9 &  ss $\rightarrow$  s          \\
\hline
10 &  s  $\rightarrow$  ID '=' e   \\
\hline
11 &  s  $\rightarrow$ '\{' b '\}'   \\
\hline
12 &  s  $\rightarrow$  P  e       \\
\hline
13 &  s $\rightarrow \epsilon$    \\
\hline
14 &  e $\rightarrow$ e1 '+' t    \\
\hline
15 &  e $\rightarrow$ e1 '-' t    \\
\hline
16 &  e $\rightarrow$ t           \\
\hline
17 &  t $\rightarrow$ t1 '*' f    \\
\hline
18 &  t $\rightarrow$ t '/' f     \\
\hline
19 &  t $\rightarrow$ f           \\
\hline
20 &  f $\rightarrow$ '(' e ')'   \\
\hline
21 &  f $\rightarrow$  ID         \\
\hline
22 &  f $\rightarrow$  NUM        \\
\hline
23 &  f $\rightarrow$  STR        \\
\hline
24 &  il $\rightarrow$ ID ',' il  \\
\hline
25 &  il $\rightarrow$ ID         \\
\hline
\end{tabular}
\end{center}
\end{small}
\vspace{0.25cm}
En cuanto a las sentencias de bloque,
se pretende que el ámbito y visibilidad de las variables sea como en el lenguaje
C, esto es, las declaraciones mas internas con el mismo identificador
ocultan las mas externas. Así:

\begin{verbatim}
int a;
a = 4;
{
  int a;
  a = 5;
  p a
}; /* el ; es necesario */
p a
\end{verbatim}

Imprimiría 5 y 4. Para traducir esta sentencia es necesario 
\emph{usar una lista/pila de referencias a tablas de símbolos. Cada 
sentencia compuesta o bloque tendrá
su propia tabla de símbolos}. Los identificadores se búscan
en la lista de referencias a tablas de símbolos, primero 
en la última tabla de símbolos insertada y sino se encuentra
se busca en la penúltima insertada, etc.

Guarde como un atributo del identificador ($SYMTABLE$) 
la referencia a la tabla de símbolos
a la que pertenece. Guarde como un atributo del nodo bloque ($BLOCK$) 
la referencia a la tabla de símbolos asociada.

\section{Optimización Independiente de la Máquina}
\label{section:optimizacion}
En esta fase se hace un análisis del árbol, sometiéndolo a transformaciones 
que aumenten la eficiencia del código final producido. 
%Esta fase podría considerarse
%una extensión de la fase de análisis semántico, especialmente 
%si atendemos a la definición de la fase de análisis semántico como ``fase de determinación 
%de aquellas propiedades que, siendo dependientes del contexto, pueden ser
%computadas estáticamente en tiempo de compilación''

Ejemplos de tareas que se pueden llevar a cabo en esta fase son: 
\begin{itemize}
\item
Extracción del interior de un bucle de cálculos que son invariantes del bucle
\item
Plegado de constantes: computar las expresiones constantes en tiempo de compilación,
no de ejecución
\item
Propagación de las constantes: si se sabe que una variable  en un punto del programa
tiene un valor constante \verb|a = 4|, se puede sustituir su uso por el de la constante
\item
Eliminación de computaciones redundantes, cuando la misma expresión aparece repetidas
veces con los mismos valores de las variables
\item
La eliminación de código ``muerto'': código que se sabe que nunca podrá ser ejecutado
\end{itemize}

En nuestro primer ejemplo, reduciremos esta fase a realizar una tarea de plegado
de las constantes. Primero lo haremos mediante la rutina

\begin{center}
\begin{verbatim}
&Machine::Independent::Optimization::fold
\end{verbatim}
\end{center}

En esta fase transformamos los AAA: si tenemos un árbol de la forma 
OPERATION(left, right), esto es, su raíz es una operación,
primero plegamos los subárboles left y right, y si se han
transformado en constantes numéricas, entonces plegamos el nodo
que pasa a ser numérico:

\begin{verbatim}
 1 sub operator_fold { # Obsérvese el uso del aliasing
 2 
 3   if ($_[0]->LEFT->is_operation) {
 4     $_[0]->{LEFT}->fold; 
 5   }
 6   if ($_[0]->RIGHT->is_operation) {
 7     $_[0]->{RIGHT}->fold;
 8   }
 9   if (ref($_[0]->LEFT) eq "NUM" and ref($_[0]->RIGHT) eq "NUM") {
10     $_[0] = reduce_children($_[0]);
11   }
12 }
13 
14 sub PLUS::fold {
15  operator_fold(@_);
16 }
17 
18 sub TIMES::fold {
19  operator_fold(@_);
20 }
\end{verbatim}

El plegado de las operaciones binarias se ha delegado
en la subrutina \verb|operator_fold|. En las líneas 3 y 6 se comprueba
que se trata de un nodo de tipo operación. Si es así se procede
a su plegado. Una vez plegados los dos subárboles hijo comprobamos
en la línea 9 que los hijos actuales son de la clase \verb|NUM|.
Si es el caso, en la línea 10 cambiamos el nodo por el resultado de operar
los dos hijos. Los nodos han sido
extendidos con un método \verb|is_operation| que determina si 
se trata de un nodo operación binaria o no. Para ello 
se han introducido nuevas clases de nodos: la clase \verb|Node|
está en la raíz de la jerarquía de herencia, las clases \verb|Leaf|
y \verb|Binary| se usan para representar los nodos hoja y binarios
y heredan de la anterior.
Una clase informa a Perl que desea heredar de otra clase añadiendo 
el nombre de esa clase a la variable \verb|@ISA| de su paquete.
La herencia en Perl determina la forma de búsqueda de un método. Si el objeto
no se puede encontrar en la clase, recursivamente y en orden primero-profundo
se busca en las clases de las cuales esta hereda, esto es en las clases
especificadas en el vector \verb|@ISA|.

\begin{verbatim}
package Node;

sub is_operation {
  my $node = shift;

  return ref($node) =~ /^(TIMES)|(PLUS)$/;
}

package Leaf; # hoja del AAA
our @ISA = ("Node");
sub children {
  return ();
}

package Binary;
our @ISA = ("Node");
sub children {
  my $self = shift;

  return (LEFT => $self->{LEFT}, RIGHT => $self->{RIGHT});
}
\end{verbatim}
Así pues, los objetos de la clase \verb|Leaf| tienen acceso 
al método \verb|is_operation|.

Ahora hacemos que las clases \verb|PLUS| y \verb|TIMES| 
hereden de la clase \verb|BINARY|:
\begin{verbatim}
package PLUS;
our @ISA = ("Binary");

sub operator {
  my $self = shift;

  $_[0]+$_[1];
}

....

package TIMES;
our @ISA = ("Binary");

sub operator {
  my $self = shift;

  $_[0]*$_[1];
}

....
\end{verbatim}

Obsérvese que en las líneas 4 y 7 del código del plegado
de nodos de operación se ha accedido directamente 
al dato en vez de usar el método para modificar el atributo, 
saltándonos lo que la buena programación
orientada a objetos indica. La forma en la que esta escrito
hace que, por ejemplo, \verb|$_[0]->{LEFT}| sea modificado. 
Recuérdese que en Perl
\emph{los argumentos son alias de los parámetros}.

La subrutina \verb|reduce_children| es la encargada 
de crear el nuevo nodo con el resultado de operar los
hijos izquierdo y derecho:

\begin{verbatim}
1 sub reduce_children {
2   my ($node) = @_;
3 
4   my $value = $node->operator($node->LEFT->VAL, $node->RIGHT->VAL);
5   NUM->new(VAL => $value, TYPE => $PL::Tutu::int_type);
6 }
\end{verbatim}

En la línea 4 se usa el método \verb|operator| asociado 
con un nodo operación. 

Plegar una sentencia de impresión es plegar la expresión
a imprimir:
\begin{verbatim}
sub PRINT::fold {
  $_[0]->{EXPRESSION}->fold;
}
\end{verbatim}
Plegar una sentencia de asignación es plegar
la parte derecha de la asignación:
\begin{verbatim}
sub ASSIGN::fold {
  $_[0]->{RIGHT}->fold;
}
\end{verbatim}
de nuevo, hemos accedido a los campos en vez de usar los métodos.

Las restantes operaciones de plegado son triviales:
\begin{verbatim}
sub ID::fold { }

sub NUM::fold { }

sub STR::fold { }
\end{verbatim}
Por último, para plegar todas las expresiones
recorremos la lista de sentencias del programa
y las plegamos una a una.

\begin{verbatim}
sub fold {
  my @statements = @{$tree->{STS}};
  for my $s (@statements) {
    $s->fold;
  }
}
\end{verbatim}

\subsectionpractica{Plegado de las Constantes}
Complete su proyecto de compilador de Tutu 
con la fase de plegado de las constantes siguiendo 
la metodología explicada 
en los párrafos previos. Mejore la jerarquía de 
clases con una clase abstracta \verb|Operation| que represente a los nodos
que se corresponden con operaciones binarias. Defina el método
abstracto \verb|operation| en dicha clase. 
Un \cei{método abstracto} es uno que, mas que proveer un servicio 
representa un servicio o categoría.
La idea es que al definir un clase base abstracta se indica un conjunto de métodos
que deberían estar definidos en todas las clases que heredan de la clase base abstracta.
Es como una declaración de interfaz que indica la necesidad de definir su funcionalidad
en las clases descendientes, pero que no se define en la clase base.
Un método abstracto debe producir una excepción con el mensaje de error adecuado
si no se ha redefinido en la clase desendiente. 

Para ello use la clave 
\verb|abstract| del módulo \verb|Class::MethodMaker|. Consulte 
la documentación del módulo \verb|Class::MethodMaker|. Consulte 
\eref{subsection:abstractos}
para saber más sobre clases abstractas.

\section{Patrones Árbol y Transformaciones Árbol}
\label{section:patronesarbol}
En la fase de optimización presentada en la sección
\ref{section:optimizacion} transformabamos el programa 
en su representación intermedia, como un AAA
decorado, para obtener otro AAA decorado.

Una transformación de un programa puede ser descrita
como un conjunto de \cei{reglas de transformación} 
o \cei{esquema de traducción árbol}
sobre el árbol abstracto que representa el programa.

Antes de seguir, es conveniente que repase los conceptos
en la sección 
\ref{subsection:lenguajesarbol}
sobre lenguajes y gramáticas árbol.

En su forma mas sencilla, estas reglas de transformación
vienen definidas
por ternas $(p, e, action)$, donde la primera componente de la
terna $p$ es un \cei{patrón árbol} que dice que árboles
deben ser seleccionados. La segunda componente 
$e$ dice cómo debe transformarse el árbol que casa con el patrón
$p$. La acción $action$ indica como deben
computarse los atributos del árbol transformado
a partir de los atributos 
del árbol que casa con el patrón $p$.
Una forma de representar este esquema sería:

\begin{center}
$p \Longrightarrow e$  \verb|{ action }|
\end{center}

Por ejemplo:

\vspace{0.25cm}
$PLUS(NUM_1, NUM_2) \Longrightarrow NUM_3$ \verb|{ $NUM_3{VAL} = $NUM_1{VAL} + $NUM_2{VAL} }|
\vspace{0.25cm}

cuyo significado es que dondequiera que haya un nódo del AAA que case 
con el \cei{patrón de entrada} $PLUS(NUM, NUM)$ deberá sustituirse
el subárbol $PLUS(NUM, NUM)$ por el subárbol $NUM$. Al igual que en los 
esquemas de traducción, enumeramos las apariciones de los símbolos,
para distinguirlos en la parte semántica. La acción indica 
como deben recomputarse los atributos para el nuevo árbol:
El atributo \verb|VAL| del árbol resultante es la suma de los atributos
\verb|VAL| de los operandos en el árbol que ha casado.
La transformación se repite hasta que se produce la \cei{normalización del árbol}.

Las reglas de ``casamiento''  de árboles pueden ser mas complejas, 
haciendo alusión a propiedades de los atributos, por ejemplo

\vspace{0.25cm}
$ASSIGN(LEFTVALUE, x)\ and$ \verb|{ notlive($LEFTVALUE{VAL}) }| $\Longrightarrow NIL$
\vspace{0.25cm}

indica que se pueden eliminar aquellos árboles de tipo asignación
en los cuáles la variable asociada con el nodo $LEFTVALUE$
no se usa posteriormente. 

Otros ejemplos con variables $S_1$ y $S_2$:

\begin{center}
$IFELSE(NUM, S_1, S_2)$ and \verb|{ $NUM{VAL} != 0 }| $\Longrightarrow S_1$\\ 
$IFELSE(NUM, S_1, S_2)$ and \verb|{ $NUM{VAL} == 0 }| $\Longrightarrow S_2$ 
\end{center}


%En realidad este formato con selección
%en términos de los atributos puede reducirse al anterior si se
%considera que la transformación sólo tiene lugar cuando la acción devuelve 
%un valor cierto.
%
%\vspace{0.25cm}
%$ASSIGN(LEFTVALUE, x) \Longrightarrow skip$ \verb|{ notlive($LEFTVALUE) }| 
%\vspace{0.25cm}
%

Observe que en el patrón de entrada $ASSIGN(LEFTVALUE, x)$ aparece un
``comodín'': la variable-árbol $x$, que hace que el árbol
patrón $ASSIGN(LEFTVALUE, x)$ case con cualquier árbol de asignación,
independientemente de la forma que tenga su subárbol derecho.

Las siguientes definiciones formalizan una aproximación simplificada 
al significado de los conceptos \cei{patrones árbol} y
\cei{casamiento de árboles}.

\begin{definition}
Sea $(\Sigma, \rho)$ un alfabeto con función de aridad
y un conjunto (puede ser infinito) 
de variables $V =\{ x_1, x_2, \ldots \}$. 
Las variables tienen
aridad cero: 

\begin{center}
$\rho(x) = 0\ \forall x \in V$. 
\end{center}

Un elemento de $B(V \cup \Sigma)$
se denomina \cei{patrón} sobre $\Sigma$.
\end{definition}

\begin{definition}
Se dice que un
patrón es un \cei{patrón lineal} si ninguna variable se repite.
\end{definition}

\begin{definition}
Se dice que un patrón es de tipo $(x_1, \ldots x_k)$ si las variables
que aparecen en el patrón leidas de izquierda a derecha en el árbol
son $x_1, \ldots x_k$.
\end{definition}

\begin{example}
Sea $\Sigma = \{A, CONS, NIL \}$ con $\rho(A) = \rho(NIL) = 0, \rho(CONS) = 2$
y sea $V = \{ x \}$. Los siguientes árboles son ejemplos de 
patrones sobre $\Sigma$:

\begin{center}
\{ $x, CONS(A, x), CONS(A, CONS(x, NIL)), \ldots \}$
\end{center}

El patrón $CONS(x, CONS(x, NIL))$ es un ejemplo de patrón no lineal.
La idea es que un patrón lineal como éste ``fuerza'' a que los árboles $t$
que casen con el patrón deben tener iguales los dos correspondientes
subárboles $t/1$ y $t/2 \ldotp 1$ situados en las posiciones de las variables
\footnote{Repase la notación de Dewey introducida en 
la definición \ref{definition:dewey}}

\end{example}

\begin{exercise}
Dado la gramática árbol:

\begin{center}
$S \rightarrow S_1(a, S, b)$\\
$S \rightarrow S_2(NIL)$ 
\end{center}

\noindent la cuál genera los árboles concretos para la gramática

\begin{center}
$S \rightarrow aSb$  $|$ $\epsilon$
\end{center}

\noindent ¿Es $S_1(a, X(NIL), b)$ un patrón árbol sobre el conjunto de variables $\{X, Y\}$?
¿Lo es $S_1(X, Y, a)$? ¿Es $S_1(X, Y, Y)$ un patrón árbol?
\end{exercise}

\begin{example}
Ejemplos de patrones para el AAA definido en el ejemplo
\ref{example:tutuast} para el lenguaje Tutu son:

\begin{center}
$x, y, PLUS(x, y), ASSIGN(x, TIMES(y,ID)), PRINT(y) \ldots$
\end{center}

considerando el conjunto de variables $V = \{ x, y \}$. El patrón 
$ASSIGN(x, TIMES(y,ID))$ es del tipo $(x, y)$.
\end{example}

\begin{definition}
Una \cei{sustitución} es una aplicación $\theta$ que asigna variables
a patrones $\theta: V \rightarrow B(V \cup \Sigma)$.

Tal función puede ser naturalmente extendida de las variables
a los árboles: los nodos (hoja) etiquetados con dichas variables son sustituidos
por los correspondientes subárboles.

\begin{center}
\begin{tabular}{l}
$\theta : B(V \cup \Sigma) \rightarrow B(V \cup \Sigma)$\\
$t \theta = \left \{ \begin{array}{ll}
                         x \theta & \mbox{si $t = x \in V$}\\
                         a(t_1  \theta, \ldots, t_k \theta) & \mbox{si $t = a(t_1, \ldots, t_k)$} 
                      \end{array}
             \right. $ 
\end{tabular}
\end{center}

Obsérvese que, al revés de lo que es costumbre, la aplicación 
de la sustitución $\theta$ al patrón se escribe por detrás: $t \theta$.

También se escribe $t \theta = t\{x_1/x_1 \theta, \ldots x_k/x_k \theta\}$ si las variables
que aparecen en $t$ de izquierda a derecha son $x_1, \ldots x_k$.
\end{definition}

\begin{example}
Si aplicamos la sustitución  $\theta = \{x/A, y/CONS(A, NIL)\}$
al patrón $CONS(x, y)$ obtenemos el árbol $CONS(A, CONS(A, NIL))$.
En efecto:

\begin{center}
$CONS(x, y)\theta = CONS(x\theta, y\theta) = CONS(A, CONS(A, NIL))$
\end{center}

\end{example}

\begin{example}
Si aplicamos la sustitución  $\theta = \{x/PLUS(NUM, x), y/TIMES(ID, NUM)\}$
al patrón $PLUS(x, y)$ obtenemos el árbol $PLUS(PLUS(NUM,x), TIMES(ID, NUM))$:

\begin{center}
$PLUS(x, y)\theta = PLUS(x\theta, y\theta) = PLUS(PLUS(NUM,x), TIMES(ID, NUM))$
\end{center}

\end{example}

\begin{definition}
Se dice que un patrón $\tau \in B(V \cup \Sigma)$ con variables
$x_1, \ldots x_k$ \cei{casa con un árbol}
$t \in B(\Sigma)$ si existe una sustitución de $\tau$ que produce $t$, esto
es, si existen $t_1, \ldots t_k \in B(\Sigma)$ tales que 
$t = \tau \{x_1/t_1, \ldots x_k/t_k\}$. 
También se dice que $\tau$ \cei{casa con la sustitución}
$\{x_1/t_1, \ldots x_k/t_k\}$.
\end{definition}

\begin{example}
El patrón $\tau = CONS(x, NIL)$ casa con el árbol $t = CONS(CONS(A,NIL),NIL)$ 
y con el subárbol  $t \ldotp 1$. Las respectivas sustituciones son $t\{x/CONS(A,NIL)\}$ y 
$t \ldotp 1 \{x/A\}$.

\begin{center}
$t = \tau \{x/CONS(A,NIL)\}$\\
$t \ldotp 1 = \tau \{x/A\}$
\end{center}

\end{example}

\begin{exercise}
Sea $\tau = PLUS(x, y)$ y $t = TIMES(PLUS(NUM, NUM), TIMES(ID, ID))$.
Calcule los subárboles $t'$ de $t$ y las sustituciones $\{x/t_1, y/t_2\}$ 
que hacen que $\tau$ case con $t'$.  

Por ejemplo es obvio que para el árbol raíz $t/\epsilon$ no existe sustitución
posible:

$t = TIMES(PLUS(NUM, NUM), TIMES(ID, ID)) = \tau\{x/t_1, y/t_2\} =
PLUS(x, y)\{x/t_1, y/t_2\}$

ya que un término con raíz $TIMES$ nunca podrá ser igual a un término con raíz 
$PLUS$.
\end{exercise}

El problema aquí es equivalente al de las expresiones regulares
en el caso de los lenguajes lineales. En aquellos, los autómatas finitos 
nos proveen con un mecanismo para reconocer si una determinada cadena
``casa''' o no con la expresión regular. Existe un concepto análogo,
el de \cei{autómata árbol} que resuelve el problema del ``casamiento''
de patrones árbol. Al igual que el concepto de autómata permite 
la construcción de software para la búsqueda de cadenas y su 
posterior modificación, el concepto de autómata árbol 
permite la construcción de software para la búsqueda de los
subárboles que casan con un patrón árbol dado.

Estamos ahora en condiciones de plantear una segunda aproximación
al problema de la optimización independiente de la máquina
utilizando una subrutina que busque por aquellos
árboles que queremos optimizar (en el caso del plegado 
los árboles de tipo operación) y los transforme 
adecuadamente. 

La función
\verb|match_and_transform_list| recibe una lista
de árboles los cuales recorre sometiéndolos 
a las transformaciones especificadas. La llamada para
producir el plegado sería:

\begin{verbatim}
  Tree::Transform::match_and_transform_list(
    NODES => $tree->{STS}, # lista de sentencias
    PATTERN => sub {
       $_[0]->is_operation and $_[0]->LEFT->isa("NUM") 
       and $_[0]->RIGHT->isa("NUM") 
    },
    ACTION => sub { 
      $_[0] = Machine::Independent::Optimization::reduce_children($_[0]) 
    }
  );
\end{verbatim}
Además de la lista de nodos le pasamos como argumentos una
referencia a la subrutina encargada de reconocer los patrónes
árbol (clave \verb|PATTERN|) y una referencia a la
subrutina que describe la acción que se ejecutará  (clave \verb|ACTION|) sobre 
el árbol que ha casado. Ambas subrutinas 
asumen que el primer argumento que se les pasa 
es la referencia a la raíz del árbol que está siendo explorado.

Los métodos \cei{isa}, \cei{can} y \cei{VERSION} 
son proporcionados por una clase especial denominada clase \verb|UNIVERSAL|,
de la cual implícitamente hereda toda clase. 
El método \verb|isa|  nos permite saber si una clase hereda de otra.

La subrutina \verb|match_and_transform_list|
recibe los argumentos y da valores por defecto a los mismos
en el caso de que no hayan sido establecidos.
Finalmente, llama a \verb|match_and_transform|
sobre cada uno de los nodos ``sentencia'' del programa.

\begin{verbatim}
sub match_and_transform_list {
  my %arg = @_;
  my @statements = @{$arg{NODES}} or 
   Error::fatal("Internal error. match_and_transform_list ".
   "espera una lista anónima de nodos");
  local $pattern = ($arg{PATTERN} or sub { 1 });
  local @pattern_args = @{$arg{PATTERN_ARGS}} if defined $arg{PATTERN_ARGS};
  local $action = ($arg{ACTION} or sub { print ref($_[0]),"\n" }); 
  local @action_args = @{$arg{ACTION_ARGS}} if defined $arg{ACTION_ARGS};

  for (@statements) {
    match_and_transform($_);
  }
}
\end{verbatim}

La subrutina \verb|match_and_transform|
utiliza el método \verb|can| para comprobar que el 
nodo actual dispone de un método
para calcular la lista con los hijos del nodo.
Una vez transformados los subárboles del nodo actual
procede a comprobar que el nodo casa con el patrón
y si es el caso le aplica la acción definida:

\begin{verbatim}
package Tree::Transform;

our $pattern;
our @pattern_args;
our $action;
our @action_args;
our @statements;

sub match_and_transform {
  my $node = $_[0] or Error::fatal("Error interno. match_and_transform necesita un nodo");
  Error::fatal("Error interno. El nodo de la clase",ref($node),
               " no dispone de método 'children'") unless $node->can("children");
  
  my %children = $node->children;

  for my $k (keys %children) {
    $node->{$k} = match_and_transform($children{$k});
  }

  if ($pattern->($node, @pattern_args)) {
    $action->( $node, @action_args); 
  }
  return $node;
}
\end{verbatim}

Recordemos el esquema de herencia que presentamos en la sección anterior.
Las clases \verb|Leaf| y \verb|Binary| proveen versiones del método \verb|children|.
Teníamos:
\begin{verbatim}
package Node;

sub is_operation {
  my $node = shift;

  return ref($node) =~ /^(TIMES)|(PLUS)$/;
}

package Leaf; # hoja del AAA
our @ISA = ("Node");
sub children {
  return ();
}

package Binary;
our @ISA = ("Node");
sub children {
  my $self = shift;

  return (LEFT => $self->{LEFT}, RIGHT => $self->{RIGHT});
}
\end{verbatim}
Los objetos de la clase \verb|Leaf| tienen acceso 
al método \verb|is_operation|.

Las clases \verb|PLUS| y \verb|TIMES| 
heredan de la clase \verb|BINARY|:
\begin{verbatim}
package PLUS;
our @ISA = ("Binary");

sub operator {
  my $self = shift;

  $_[0]+$_[1];
}

....

package TIMES;
our @ISA = ("Binary");

sub operator {
  my $self = shift;

  $_[0]*$_[1];
}

....
\end{verbatim}

La subrutina \verb|reduce_children| introducida en la
sección 
\ref{section:optimizacion}
es la encargada 
de crear el nuevo nodo con el resultado de operar los
hijos izquierdo y derecho:

\begin{verbatim}
1 sub reduce_children {
2   my ($node) = @_;
3 
4   my $value = $node->operator($node->LEFT->VAL, $node->RIGHT->VAL);
5   NUM->new(VAL => $value, TYPE => $PL::Tutu::int_type);
6 }
\end{verbatim}

En la línea 4 se usa el método \verb|operator| asociado 
con un nodo operación. 

\subsectionpractica{Casando y Transformando Árboles}
\label{practica:casandoytransformando}
Complete su proyecto para el compilador de Tutu completando
las subrutinas \verb|match_and_transform| tal y como se explicó en la sección
\ref{section:patronesarbol}.

Ademas del plegado
de constantes use las nuevas subrutinas 
para aplicar simultáneamente 
las siguientes transformaciones algebraicas:

\vspace{0.25cm}
\begin{tabular}{lll}
$PLUS(NUM, x)$  & $\wedge$ \verb|{ $NUM{VAL} == 0 }| & $\Longrightarrow x$\\ 
$PLUS(x, NUM)$  & $\wedge$ \verb|{ $NUM{VAL} == 0 }| & $\Longrightarrow x$  \\ 
$TIMES(NUM, x)$ & $\wedge$ \verb|{ $NUM{VAL} == 1 }| & $\Longrightarrow x$ \\ 
$TIMES(x, NUM)$ & $\wedge$ \verb|{ $NUM{VAL} == 1 }| & $\Longrightarrow x$  
\end{tabular}
\vspace{0.25cm}

\begin{enumerate}
\item
Dado un programa como

\begin{verbatim}
int a; a = a * 4 * 5;
\end{verbatim}
¿Será plegado el \verb|4 * 5|?
Sin embargo si que se pliega si el programa es de la forma:
\begin{verbatim}
int a; a = a * (4 * 5);
\end{verbatim}
No intente en esta práctica que programas como el primero  o como
\verb|4*a*5*b| sean plegados.
Para lograrlo sería necesario introducir transformaciones adicionales
y esto no se requiere en esta práctica.
\item
¿Existe un orden óptimo en el que ejecutar las transformaciones?
\item
Ponga un ejemplo en el que sea beneficioso ejecutar el plegado primero.
\item
Ponga otro ejemplo en el que sea beneficioso ejecutar el plegado después.
\item
¿Es necesario  aplicar las transformaciones reiteradamente? 
\item
\label{item:parada}
¿Cuál es la condición de parada?
\item
Como es habitual la pregunta 
\ref{item:parada} tiene 
una respuesta TIMTOWTDI: 
una posibilidad la da el módulo 
\htmladdnormallink{Data::Compare}
{http://search.cpan.org/~dcantrell/Data-Compare-0.13/lib/Data/Compare.pm}
el cual puede obtenerse desde CPAN y que permite comparar estructuras de datos, 
pero existe una solución mas sencilla. ¿Cuál?
\end{enumerate}

\section{Asignación de Direcciones}
Esta suele ser considerada  la primera de las fases de síntesis.
Las anteriores lo eran de análisis. La fase de análisis
es una transformación $texto\ fuente \rightarrow arbol$, mientras
que la fase síntesis es una transformación inversa
$arbol \rightarrow texto\ objeto$ que produce una ``linealización''
del árbol. En general, se ubican en la fase de síntesis todas
las tareas que dependan del lenguaje objeto.

La asignación de direcciones depende de la máquina objetivo en cuanto
conlleva consideraciones sobre la longitud de palabra, las unidades
de memoria direccionables, la compactación de objetos pequeños (por ejemplo,
valores lógicos), el alineamiento a fronteras de palabra, etc.

En nuestro caso debemos distinguir entre las cadenas y las variables enteras.

Las constantes literales (como \verb|"hola"|) se almacenan 
concatenadas en orden de aparición textual.
Una variable de tipo cadena ocupa dos palabras, una dando su dirección 
y otra dando su longitud.

\begin{verbatim}
sub factor() {
  my ($e, $id, $str, $num);

  if ($lookahead eq 'NUM') { ... }
  elsif ($lookahead eq 'ID') { ... }
  elsif ($lookahead eq 'STR') {
    $str = $value;
    my ($offset, $length) = Address::Assignment::str($str);
    match('STR');
    return STR->new(OFFSET => $offset, LENGTH => $length, TYPE => $string_type);
  }
  elsif ($lookahead eq '(') { ... }
  else { Error::fatal("Se esperaba (, NUM o ID"); }
}
\end{verbatim}

El código de la subrutina \verb|Address::Assignment::str| es:
\begin{verbatim}
  sub str {
    my $str = shift;
    my $len = length($str);
    my $offset = length($data);
    $data .= $str;
    return ($offset, $len);
  }
\end{verbatim}
Una posible mejora es la que se describe en 
el punto
\ref{item:norepetidas}
de la práctica
\ref{practica:calculodelasdirecciones}.

Hemos supuesto que las variables enteras y las referencias ocupan una palabra.
Cada vez que una variable es declarada, se le computa su dirección relativa:

\begin{verbatim}
# declaration -> type idlist
# type        -> INT | STRING
sub declaration() {
  my ($t, $decl, @il);

  if (($lookahead eq 'INT') or ($lookahead eq 'STRING')) {
    $t = &type(); @il = &idlist();
    &Semantic::Analysis::set_types($t, @il);
    &Address::Assignment::compute_address($t, @il);
    $decl = [$t, \@il];
    return bless $decl, 'DECL';
  }
  else { Error::fatal('Se esperaba un tipo'); }
}
\end{verbatim}

Se usa una variable \verb|$global_address| para llevar la cuenta de la última 
dirección utilizada y se introduce un atributo \verb|ADDRESS| en 
la tabla de símbolos:

\begin{verbatim}
  sub compute_address {
    my $type = shift;
    my @id_list = @_;

    for my $i (@id_list) {
      $symbol_table{$i}->{ADDRESS} = $global_address;
      $global_address += $type->LENGTH;
    }
  }
\end{verbatim}

Por último situamos todas las cadenas después de las variables
del programa fuente:

\begin{verbatim}
  ... 
  ##### En compile, despues de haber calculado las direcciones
  Tree::Transform::match_and_transform_list(
    NODES => $tree->{STS},
    PATTERN => sub { 
      $_[0]->isa('STR')
    },
    ACTION => sub { $_[0]->{OFFSET} += $global_address; }
  );
\end{verbatim}

Esta aproximación es bastante simplista en cuanto que usa una palabra
por carácter. 
El punto
\ref{item:compacta}
de la práctica
\ref{practica:calculodelasdirecciones} propone una mejora.

\subsectionpractica{Cálculo de las Direcciones}
\label{practica:calculodelasdirecciones}
Modifique el cálculo de las direcciones para la gramática de Tutu
extendida con sentencias compuestas que fué presentada en 
la sección 
\ref{practica:analisis_semantico}.


\begin{enumerate}
\item
Resuelva el problema de calcular las direcciones de las variables
declaradas en los bloques. La memoria ocupada por dichas variables
se libera al terminar el bloque. Por tanto la variable \verb|$global_address|
disminuye al final de cada bloque.
\item
\label{item:norepetidas}
En el código de la subrutina \verb|Address::Assignment::str| 

\begin{verbatim}
  sub str {
    my $str = shift;
    my $len = length($str);
    my $offset = length($data);
    $data .= $str;
    return ($offset, $len);
  }
\end{verbatim}

no se comprueba si la cadena \verb|$str| ya está en \verb|$data|. 
Es natural que si ya está no la insertemos de nuevo. Introduzca esa 
mejora. Para ello use la función \verb|pos|,
la cual devuelve el desplazamiento en \verb|$data| donde
quedó la última búsqueda \verb|$data =~ m/regexp/g|.
 El siguiente ejemplo con
el depurador le muestra como trabaja. Escriba \verb|perldoc -f pos|
para obtener mas información sobre la función \verb|pos|.
Vea un ejemplo de uso:

\begin{verbatim}
DB<1> $str = "world"
#              012345678901234567890123456789012
DB<2> $data = "hello worldjust another statement"
DB<3> $res = $data =~ m{$str}g
DB<4> x pos($data) # la siguiente busqueda comienza en la 11
0  11
DB<5> $s = "hello"
DB<6> $res = $data =~ m{$s}g
DB<7> x pos($data) # No hay "hello" despues de world en $data
0  undef
DB<8> $res = $data =~ m{$str}g # Repetimos ...
DB<9> x pos($data)
0  11
DB<10> pos($data) = 0  # Podemos reiniciar pos!
DB<11> $res = $data =~ m{$s}g
DB<12> x pos($data) # Ahora si se encuentra "hello"
0  5
\end{verbatim}

\item
\label{item:compacta}
Empaquete las cadenas asumiendo que cada carácter ocupa un octeto o byte.
Una posible solución al problema de alineamiento que se produce es
rellenar con ceros los bytes que faltan hasta completar la última palabra
ocupada por la cadena. Por ejemplo, si la longitud de palabra de la 
máquina objeto es de 4 
bytes, la palabra \emph{procesador} se cargaría asi:

\begin{center}
\begin{verbatim}
   0    |    1    |    2      
0 1 2 3 | 4 5 6 7 | 8 9 10  11
p r o c | e s a d | o r \0  \0
\end{verbatim}
\end{center}


Existen dos posibles formas de hacer esta empaquetado.
Por ejemplo, si tenemos las cadenas
\verb|lucas| y \verb|pedro| las podemos introducir en 
la cadena \verb|$data| asi:

\begin{center}
\begin{verbatim}
   0    |     1      |    2      |    3
0 1 2 3 | 4  5  6  7 | 8 9 10 11 | 12 13 14 15
l u c a | s \0 \0 \0 | p e  d  r |  o \0 \0 \0
\end{verbatim}
\end{center}

o bien:

\begin{center}
\begin{verbatim}
   0    |    1    |    2     
0 1 2 3 | 4 5 6 7 | 8 9 10 11
l u c a | s p e d | r o \0 \0
\end{verbatim}
\end{center}

La segunda forma aunque compacta más tiene la desventaja de hacer luego mas 
lento el código para el 
direccionamiento de las cadenas, ya que no empiezan en frontera de palabra. 
Utilice el primer modo.

Observe que este empaquetado introduce un efecto en lo que 
se considera un éxito en la búsqueda de una cadena 
\verb|$str| en \verb|$data|. ¿Que ocurre si \verb|$str|
aparece en \verb|$data| como subcadena de una cadena
previamente empaquetada ocupando una posición que no es frontera de palabra?

Cuando rellene con \verb|\0| la cadena use el operador \verb|x| (letra equis)
para multiplicar número por cadena:

\begin{verbatim}
DB<1> $x = "hola"x4
DB<2> p $x
holaholaholahola
\end{verbatim}

esto le evitará escribir un bucle.
\item
Mantega atributos distintos en el nodo \verb|STR|
para el desplazamiento y longitud 
de \verb|$str| en \verb|$data| (en caracteres)
y su dirección y tamaño final en memoria (en palabras).

\end{enumerate}

\section{Generación de Código: Máquina Pila}
\label{section:pila}
El generador de código emite el código para el lenguaje objeto, utilizando
las direcciones calculadas en la fase anterior. Hemos simplificado esta fase
considerando una máquina orientada a pila: una memoria de pila en la que se
computan las expresiones, un segmento de datos en el que se guardan las variables
y un segmento para guardar las cadenas.
La estrategia utilizada es similar a la que vimos en el plegado de las constantes.
Definimos un método para la traducción de cada clase de nodo del AAA.
Entonces, para traducir el programa basta con llamar al correspondiente método:

\begin{verbatim}
  $tree = Syntax::Analysis::parser;
  ... # otras fases
  ########code generation
  local $target = ""; # target code
  $tree->translate;
  ...
\end{verbatim}

en la cadena \verb|$target| dejamos el código emitido.
Cada método visita los hijos, traduciéndolos y añadiendo 
el código que fuera necesario para la traducción del nodo.

\begin{verbatim}
sub PROGRAM::translate {
  my $tree = shift;

  $target .= "DATA ". $data."\n" if $data;
  $tree->STS->translate;
}
\end{verbatim}

Traducir la lista de sentencias es concatenar la traducción
de cada una de las sentencias en la lista:

\begin{verbatim}
sub STATEMENTS::translate {
  my $statements = shift;
  my @statements = @{$statements};

  for my $s (@statements) {
    $s->translate;
  }
}
\end{verbatim}

Si suponemos que disponemos en el ensamblador de nuestra máquina
objeto de instrucciones \verb|PRINT_INT|  y \verb|PRINT_STR|
que imprimen el contenido 
de la expresión que esta en la cima de la pila, la traducción será:

\begin{verbatim}
sub PRINT::translate {
  my $self = shift;

  $self->EXPRESSION->translate;
  if ($self->EXPRESSION->TYPE == $int_type) { emit "PRINT_INT\n"; }
  else {emit "PRINT_STR\n"; }
}
\end{verbatim}
Asi, si la sentencia era \verb|P c|, donde \verb|c| es del tipo cadena, 
se debería eventualmente llamar al método de traducción del identificador:

\begin{verbatim}
sub ID::translate {
  my $self = shift;

  my $id = $self->VAL;
  my $type =  Semantic::Analysis::get_type($id);
  if ($type == $int_type) {
    emit "LOAD ".$symbol_table{$id}->{ADDRESS}."\n";
  }
  else {
    emit "LOAD_STRING ".$symbol_table{$id}->{ADDRESS}."\n";
  }
}
\end{verbatim}
la función \verb|emit| simplemente concatena el código 
producido a la salida:

\begin{verbatim}
sub emit { $target .= shift; }
\end{verbatim}

Para la traducción de una sentencia de asignación
supondremos de la existencia de isntrucciones \verb|STORE_INT|
y \verb|STORE_STRING|. La instrucción \verb|STORE_STRING| asume 
que en la cima de la pila están la dirección y la cadena a almacenar.

\begin{verbatim}
sub ASSIGN::translate {
  my $self = shift;

  $self->RIGHT->translate;
  my $id = $self->LEFT;
  $id->translate;
  my $type =  Semantic::Analysis::get_type($id->VAL);

  if ($type == $int_type) {
    emit "STORE_INT\n";
  }
  else {
    emit "STORE_STRING\n";
  }
}
\end{verbatim}
Si se está traduciendo una sentencia como \verb|a = "hola"|,
se acabará llamando al método 
de traducción asociado con la clase \verb|STR|
el cual actúa empujando la dirección y la longitud de la cadena en
la pila:
\begin{verbatim}
sub STR::translate {
  my $self = shift;

  emit "PUSHSTR ".$self->OFFSET." ".$self->LENGTH."\n";
}
\end{verbatim}
Así la traducción de este fuente:

\begin{verbatim}
$ cat test06.tutu
string a;
a = "hola";
p a
\end{verbatim}

es:

\begin{verbatim}
$ ./main.pl test06.tutu test06.ok
$ cat test06.ok
DATA 2, hola
PUSHSTR 2 4
PUSHADDR 0
STORE_STRING
LOAD_STRING 0
PRINT_STR
\end{verbatim}

El resto de los métodos de traducción es similar:
\begin{verbatim}
sub LEFTVALUE::translate {
  my $id = shift ->VAL;

  emit "PUSHADDR ".$symbol_table{$id}->{ADDRESS}."\n";
}

sub NUM::translate {
  my $self = shift;

  emit "PUSH ".$self->VAL."\n";
}

sub PLUS::translate {
  my $self = shift;

  $self->LEFT->translate;
  $self->RIGHT->translate;
  emit "PLUS\n";
}

sub TIMES::translate {
  my $self = shift;

  $self->LEFT->translate;
  $self->RIGHT->translate;
  emit "MULT\n";
}
\end{verbatim}

Veamos un ejemplo. Dado el código fuente:
\begin{verbatim}
$ cat test02.tutu
int a,b; string c; 
a = 2+3; b = 3*4; c = "hola"; p c; 
c = "mundo"; p c; p 9+2; p a+1; p b+1
\end{verbatim}
el código generado es:
\begin{verbatim}
$ ./main.pl test02.tutu test02.ok
$ cat test02.ok
DATA 4, holamundo
PUSH 5
PUSHADDR 0
STORE_INT
PUSH 12
PUSHADDR 1
STORE_INT
PUSHSTR 4 4
PUSHADDR 2
STORE_STRING
LOAD_STRING 2
PRINT_STR
PUSHSTR 8 5
PUSHADDR 2
STORE_STRING
LOAD_STRING 2
PRINT_STR
PUSH 11
PRINT_INT
LOAD 0
INC
PRINT_INT
LOAD 1
INC
PRINT_INT
\end{verbatim}

\section{Generación de Código: Máquina Basada en Registros}
La máquina orientada a pila para la que generamos código en la sección
\ref{section:pila}
es un ejemplo de la clase de máquinas que es usada por la mayoría 
de los lenguajes interpretados: Perl, Python; java, etc.

En esta sección introduciremos una máquina basada en registros.
Suponemos que la máquina tiene $k$ registros $R_0 \ldots R_{k-1}$.
Las instrucciones toman dos argumentos, dejando el resultado en
el primer argumento. Son las siguientes:

\vspace{0.5cm}
\begin{tabular}{ll}
\verb|LOADM Ri, [a]| & $R_i = M_a$\\
\verb|LOADC Ri, c|  & $R_i = c$\\
\verb|STORE [a], Ri|  & $M_a = R_i$\\
\verb|ADDR Ri, Rj|  & $R_i += R_j$\\
\verb|ADDM Ri, [a]|  & $R_i += M_a$\\
\verb|ADDC Ri, c|  & $R_i += c$\\
\ldots              & \ldots 
\end{tabular}

El problema es generar el código con el menor número 
de instrucciones posible, teniendo 
en cuenta la limitación existente de registros.

Supongamos que queremos traducir un subárbol
$OP(t_1, t_2)$  y que la traducción del subárbol $t_1$ requiere $r_1$ registros
y que la traducción de $t_2$ requiere $r_2$ registros, con $r_1 < r_2 \le k$.
Si realizamos primero la evaluación de $t_1$, debemos dejar el 
resultado en un registro que no podrá ser utilizado en la evaluación de 
$t_2$. Si $r_2 = k$, la evaluación de $t_2$ podría dar lugar 
a la necesidad de recurrir a almacenamiento temporal.
Esta situación no se da si evaluamos primero $t_2$.
En tal caso, dado que hay un registro en el que se guarda el resultado de
$t_2$, quedan libres al menos $r_2 - 1$ registros. 
Como $r_2 - 1 \ge r_1$ se sigue que tenemos suficientes registros
para traducir $t_1$.
Como regla general es mejor evaluar primero el subárbol
que mayores requerimientos de registros tiene.

La siguiente cuestión es como calcular los requerimientos en registros
de una expresión dada. No consideraremos en esta fase límites en el número de 
registros disponibles. Obsérvese que si los requerimientos para los subárboles
son distintos, $r_1 \neq r_2$ la traducción puede realizarse usando 
el máximo de ambos $\max\{r_1, r_2\}$ siguiendo la estrategia 
de traducir primero el que mayores requerimentos tenga. 
Si son iguales entonces se necesitan $r_1 + 1$
registros ya que es necesario un registro para guardar el resultado de
la primera traducción. 

Nótese que, como el juego de instrucciones
para un operando  puede tener como segundo argumento una dirección de memoria,
los ``segundos operandos'' no necesitan registro. Por ejemplo, 
el árbol  $PLUS(a,b)$ se traduce por 

\begin{verbatim}
LOADM R0, a
PLUSM R0, b
\end{verbatim}

Asi $b$ no requiere registro, mientras que $a$ si lo requiere. Por tanto, las 
hojas izquierdas requieren de registro mientras que las hojas derechas no.

Si $t$ es un nodo de la forma
$OP(t_1, t_2)$ el número de registros $r_t$ requeridos por $t$ viene dado por 
la fórmula:

\vspace{0.25cm}
\begin{center}
$r_t =  \left \{ \begin{array}{ll}
               \max\{r_1, r_2\} & \mbox{si $r_1 \neq r_2$}\\
               r_1 + 1 & \mbox{si $r_1 = r_2$} 
           \end{array}
        \right .$ 
\end{center}
\vspace{0.25cm}

Dotaremos a cada nodo del AST de un método \verb|required_registers|
que computa la demanda en registros de dicho nodo. 
Lo que haremos es introducir en la clase \verb|Operation| de la cual heredan
las operaciones binarias el correspondiente método \verb|required_registers|:

\begin{verbatim}
package Operation;
our @ISA = ("Binary");

sub required_registers {
  my $self = shift;

  my $rl = $self->LEFT->required_registers('LEFT');
  my $rr = $self->RIGHT->required_registers('RIGHT');
  $self->{REQ_REG} = ($rl == $rr)? $rl+1: Aux::max($rl, $rr);
  return $self->REQ_REG;
}
\end{verbatim}

El segundo argumento que recibe \verb|required_registers| es 
su posición (izquierda o derecha) entre los hijos de su padre.
dicha información no es usada en los nodos binarios. 
Su necesidad queda clara cuando se considera el cómputo
del número de registros requeridos por las hojas.

El cómputo en las hojas corre a cargo del correspondiente método
en la clase \verb|Value|. Los nodos de tipo número (clase \verb|NUM|), cadena 
(clase \verb|STR|) y variable (clase \verb|ID|)
heredan de la clase \verb|Value|.

\begin{verbatim}
package Value;
our @ISA = ("Leaf");

sub required_registers {
  my $self = shift;
  my $position = shift;

  $self->{REQ_REG} = ($position eq 'LEFT') ? 1 : 0;
  return $self->REQ_REG;
}
\end{verbatim}

El atributo \verb|REQ_REG| se computa para cada una de las sentencias 
del programa:

\begin{verbatim}
package STATEMENTS;

sub required_registers {
  my $self = shift;
  my @sts = @{$self};

  for (@sts) {
    $_->required_registers;
  }
}
\end{verbatim}

Por supuesto los nodos \verb|ASSIGN| y \verb|PRINT|
poseen sus propios métodos \verb|required_registers|.

Una vez computados los requerimientos en registros de cada
nódo, la generación de código para un nodo gestiona la
asignación de registros usando una cola en la que se guardan 
los registros disponibles. Se
siguen básicamente dos reglas para la traducción de un
nodo  \verb|Operation|:

\begin{enumerate}
\item
Realizar primero la traducción del hijo con mayores
requerimientos y luego el otro
\item
El resultado queda siempre en el registro que ocupa 
\underline{la primera posición} en la cola
\end{enumerate}

Hay cuatro casos a considerar: el primero 
es que el operando derecho sea una hoja.
La generación de código para este caso es:

\begin{verbatim}
package Operation;
our @ISA = ("Binary");
...

sub gen_code {
  my $self = shift;

  if ($self->RIGHT->isa('Leaf')) {
    my $right = $self->RIGHT;
    my $a = $right->VAL;
    my $rightoperand = $right->gen_operand; # valor o dirección 
    my $key = $right->key;                  # M, C, etc.
    $self->LEFT->gen_code;
    Aux::emit($self->nemonic."$key $RSTACK[0], $rightoperand # $a\n");
  }
  ...
}
\end{verbatim}
La generación del nemónico se basa en tres métodos:

\begin{itemize}
\item
El método \verb|nemonic| devuelve el nemónico asociado con el nodo.
Por ejemplo, para la clase \verb|TIMES| el código es:
\begin{verbatim}
sub  nemonic {
  return "MULT";
}
\end{verbatim}
\item
El método \verb|key| devuelve el sufijo que hay que añadir 
para completar el nemónico, en términos de como sea el
operando: \verb|C| para los números, \verb|M| para los 
identificadores, etc.
\item
El método \verb|gen_operand| genera el operando. Así para las clases
número e identificador su código es:

\vspace{0,1cm}
\begin{tabular}{|p{5cm}|p{10cm}|}
\hline 
\begin{verbatim}
package NUM;
...
sub gen_operand {
  my $self = shift;

  return $self->VAL;
}
\end{verbatim} &
\begin{verbatim}
package ID;
...
sub gen_operand {
  my $self = shift;

  return $symbol_table{$self->VAL}->{ADDRESS},
}
\end{verbatim}\\
\hline
\end{tabular}
\vspace{0,1cm}


\end{itemize}

El resto del código distingue  tres casos,
según sean $r_1$, $r_2$ y el número de registros
disponibles. 
Los dos primeros casos desglosan
la posibilidad de que uno de los dos subárboles
pueda realizarse con el número de registros
disponible ($\min \{r_1, r_2 \} < k$).
El tercer caso corresponde a que 
se necesiten temporales: $\min \{r_1, r_2 \} \ge k$.


\begin{verbatim}
 1   ...
 2   if ($self->RIGHT->isa('Leaf')) { ...  }
 3   else { # Hijo derecho no es una hoja
 4     my ($t1, $t2) = ($self->LEFT, $self->RIGHT);
 5     my ($r1, $r2) = ($t1->REQ_REG, $t2->REQ_REG);
 6 
 7     if ($r1 < Aux::min($r2, $NUM_REG)) {
 8       $t2->gen_code;
 9       my $R = shift @RSTACK;
10       $t1->gen_code;
11       Aux::emit($self->nemonic."R $RSTACK[0], $R\n");
12       push @RSTACK, $R;
13     }
14     ...
15   }
\end{verbatim}
En este caso debemos realizar primero la traducción
del hijo derecho. Salvando su resultado en \verb|$R|. 
El registro es retirado de la cola y traducimos el 
lado izquierdo. El resultado ha quedado en el primer
registro de la cola. Emitimos la operación, añadiendo
el sufijo \verb|R|, ya que se trata de una operación entre registros
y posteriormente devolvemos el registro a la cola.

\begin{exercise}
Responda a las siguientes preguntas:

\begin{enumerate}
\item
Si en el código anterior sustituimos la línea 12

\begin{center}
\verb|push @RSTACK, $R|
\end{center}

por 

\begin{center}
\verb|unshift @RSTACK, $R| 
\end{center}

¿Seguiría funcionando el código?

\item
¿Podemos asegurar en este subcaso que el código generado para \verb|$t2|
(línea 8) se ha realizado integramente en los registros?
\end{enumerate}
\end{exercise}

Los otros dos casos tienen similar tratamiento:

\begin{verbatim}
  if ($self->RIGHT->isa('Leaf')) { ...  }
  else { ...
    if ($r1 < Aux::min($r2, $NUM_REG)) { ... }
    elsif (($r1 >= $r2) and ($r2 < $NUM_REG)) {
      $t1->gen_code;
      my $R = shift @RSTACK;
      $t2->gen_code;
      Aux::emit($self->nemonic."R $R, $RSTACK[0]\n");
      unshift @RSTACK, $R;
    }
    elsif (($r1 >= $NUM_REG) and ($r2 >= $NUM_REG)) {
      $t2->gen_code;
      Aux::emit("STORE $T, $RSTACK[0]\n");
      $T++;
      $t1->gen_code;
      $T--;
      Aux::emit($self->nemonic."M $RSTACK[0], $T\n");
    }
  }
}
\end{verbatim}

Antes de comenzar a generar el código,
la variable \verb|$T| debe ser inicializada a un valor apropiado, 
de manera que se usen direcciones no ocupadas por los datos.
Por ejemplo:

\begin{verbatim}
local $T =  $final_global_address+length($data);
\end{verbatim}

El método \verb|gen_code| sólo debería ser llamado sobre una hoja
si se trata de una hoja izquierda (en cuyo caso el número de
registros requeridos es uno):
\begin{verbatim}
package Value;
our @ISA = ("Leaf");
...

sub gen_code {
  my $self = shift;
  my $a = $self->VAL;

  if ($self->REQ_REG == 1) {
    if (ref($self) eq "NUM") { Aux::emit("LOADC $RSTACK[0], $a\n"); }
    else { 
      my $address = $symbol_table{$a}->{ADDRESS};
      Aux::emit("LOADM $RSTACK[0], $address # $a\n");
    }
  }
  else {
    croak("gen_code visita hoja izquierda con REQ_REG = ".$self->REQ_REG);
  }
}
\end{verbatim}

La pila de registros es inicializada al número de registros disponibles:

\begin{verbatim}
use constant LAST_REG => 1;
our @RSTACK = map "R$_", 0..LAST_REG; # Registros disponibles
\end{verbatim}

\begin{exercise}
Responda a las siguientes preguntas:

\begin{itemize}
\item
¿Cuáles son los requerimientos de registros para un nodo de la clase $ASSIGN$?
\item
¿Cuáles son los requerimientos de registros para un nodo de la clase $PRINT$?
\item
¿Se puede lograr la funcionalidad proveída por el método 
\verb|required_registers|\\
usando \verb|match_and_transform|? 

¿Sería necesario introducir modificaciones
en \verb|match_and_transform|? Si es así, ¿Cuáles?.
\end{itemize}
\end{exercise}

\subsectionpractica{Generación de Código}
\label{practica:generaciondecodigo}
\begin{enumerate}
\item
Complete la generación de código para la máquina basada en registros.
Recuerde que debe escribir el método \verb|required_registers|
para las diferentes clases \verb|Value|, \verb|Operation|,
\verb|ASSIGN|, \verb|PRINT|, \verb|STATEMENTS|, etc. 
Asi mismo deberá escribir el método \verb|gen_code| para las diversas
clases: \verb|Value|, \verb|Operation|, \verb|ASSIGN|, \verb|PRINT|,
\verb|STATEMENTS|, etc.
Recuerde que los temporales usados durante la generación de código
deben ubicarse en una zona que no esté en uso.


\item
En la sección anterior no se consideraba la generación 
de código para las cadenas. Amplíe y/o modifique el
juego de instrucciones como considere conveniente.
El siguiente ejemplo de traducción sugiere
como puede ser la generación de código para las cadenas:
\begin{center}
\begin{tabular}{|p{3cm}|p{11cm}|}
\hline
Fuente & Objeto\\
\hline
\begin{verbatim}

string a,b;
a = "hola";
b = a;
p b
\end{verbatim}
&
\begin{verbatim}
1 LSTRG  R0, 4, 4 
2 STORES  0, R0 # a
3 LOADS  R0, 0 # a
4 STORES  2, R0 # b
5 LOADS  R0, 2 # b
6 PRNTS  R0
\end{verbatim}\\
\hline
\end{tabular}
\end{center}

Asuma que los registros pueden contener dos direcciones de memoria
(línea 1). La instrucción \verb|LSTRG R0, a, b| carga las constantes
(direcciones)
\verb|a| y \verb|b| en el registro.
La constante \verb|"hola"| ocupa en  la posición final
en la que se colocan los contenidos de \verb|$data| un desplazamiento
de 4 y ocupa 4 palabras. 
Las instrucción \verb|LOADS R, a| carga las dos palabras en las direcciones
\verb|a| y \verb|a+1| en el registro \verb|R|. 
La instrucción \verb|STORES a, R| se encarga de que las dos palabras
en la dirección \verb|a| queden referenciando 
una cadena igual a la apuntada por el registro \verb|R|.
La instrucción \verb|PRNTS| imprime la cadena apuntada
por el registro.  En una situación mas realista instrucciones como
\verb|STORES a, R| y \verb|PRNTS| probablemente serían llamadas
a funciones/servicios del sistema o de la librería para soporte
en tiempo de ejecución asociada al lenguaje.

\item
Se puede mejorar el código generado
si hacemos uso de las propiedades algebraicas de los 
operadores.
Por ejemplo, cuando se tiene un operador conmutativo que ha sido asociado 
a derechas, como ocurre en este programa fuente:
\begin{verbatim}
$ cat test18.tutu
int a,b,c;

a = a + (b + c)
\end{verbatim}

El código producido por el compilador es:

\begin{verbatim}
LOADM R0, 0 # a
LOADM R1, 1 # b
PLUSM R1, 2 # c
PLUSR R0, R1
STORE  0, R0 # a
\end{verbatim}

En este caso, la expresión \verb|a + (b + c)|  corresponde a un árbol 
que casa con el patrón árbol

\begin{center}
$PLUS(ID, t)$ and $\{ r_t \ge 1 \}$
\end{center}

Donde $r_t$ es el número de registros requeridos por $t$.
En tales casos es posible sacar ventaja
de la conmutatividad de la suma y transformar el
árbol

\begin{center}
$PLUS(ID, t)$ and $\{ r_t \ge 1 \} \Longrightarrow PLUS(t, ID)$
\end{center}

Observe que mientras el primer árbol requiere $\max \{2, r_t \}$
registros, el segundo requiere $r_t$ registros, que en general es menor.
Esta transformación invierte la traducción:

\begin{verbatim}
traduce(t)
ADDM $RSTACK[0], dirección de ID 
\end{verbatim}

que daría lugar a:

\begin{verbatim}
LOADM R0, 1 # b
PLUSM R0, 2 # c
PLUSM R0, 0 # a
STORE  0, R0 # a
\end{verbatim}

la cual usa una instrucción y un registro menos.

Usando \verb|match_and_transform| modifique el generador 
de código para que, después de la fase de cálculo del número
de registros requeridos, aplique esta 
transformación sobre los nodos conmutativos cuyo hijo izquierdo
sea un identificador y su hijo derecho requiera al menos un registro.
\end{enumerate}

\section{Optimización de Código}
Aunque en esta fase se incluyen toda clase de optimizaciones,
es aquí donde se hacen las optimizaciones de código dependientes
del sistema objeto. Normalmente se
recorre el código generado buscando secuencias 
de instrucciones que se puedan sustituir por otras cuya 
ejecución sea mas eficiente.
El nombre \cei{Peephole optimization} hace alusión a esta especie de
``ventana
de visión'' que se desplaza sobre el código.  En nuestro caso,
supongamos que disponemos de una instrucción \verb|INC| que permite
incrementar eficientemente una expresión. Recorremos el código buscando
por un patrón "sumar 1" y lo reeemplazamos adecuadamente.

\begin{verbatim}
package Peephole::Optimization;

sub transform {
  $target = shift;
  $target =~ s/PUSH 1\nPLUS/INC/g;
}
\end{verbatim}

Otro ejemplo de optimización peephole consiste en reemplazar las operaciones
flotantes de división por una constante por la multiplicación por la inversa
de la misma (aquí se pueden introducir diferencias en el resultado, debido
a la inexactitud de las operaciones en punto flotante y a que, si
se trata de un \cei{compilador cruzado} la aritmética 
flotante en la máquina en la que se ejecuta el compilador puede ser diferente
de la de la máquina que ejecutará el código objeto).

\subsectionpractica{Optimización Peephole}
\label{practica:peephole}
\begin{enumerate}
\item
Optimice el código generado para la máquina de registros sustituyendo
las operaciones de multiplicación y división enteras por una constante que sea
potencia de dos (de la forma $2^n$) por operaciones de desplazamiento.
Repase el capítulo de expresiones regulares. Es posible que aquí quiera emplear
una sustitución en la que la cadena de reemplazo
sea evaluada sobre la marcha. Si es así, repase la sección
\ref{section:regeval}. La siguiente sesión con el depurador
pretende ilustrar la idea:
\begin{verbatim}
$ perl -de 0
DB<1> $a = "MUL R2, 16"
DB<2> $a =~ s/MUL R(\d), (\d+)/($2 == 16)?"SHL R$1, 4":$&/e
DB<3> p $a
SHL R2, 4
DB<5> $a = "MUL R2, 7"
DB<6> $a =~ s/MUL R(\d), (\d+)/($2 == 16)?"SHL R$1, 4":$&/e
DB<7> p $a
MUL R2, 7
DB<8>
\end{verbatim}

\item
El plegado de constantes realizado durante la optimización de código independiente
de la máquina (véase la sección
\ref{section:optimizacion})
es parcial. Si los árboles para el producto se hunden a izquierdas, una expresión
como \verb|a = a * 2 * 3| no será plegada, ya que produce
un árbol de la forma 

\begin{center}
$t = TIMES(TIMES(a,2),3)$
\end{center}

Dado que el algoritmo no
puede plegar $t/1$ tampoco plegará $t$.  Busque en el código objeto
secuencias de multiplicaciones 
por constantes y abrévielas en una. Haga lo mismo para las restantes operaciones.

\item
Dado el siguiente programa:
\begin{verbatim}
$ cat test14.tutu
int a,b; a = 2; b = a*a+1
\end{verbatim}
El código producido por el traductor para la máquina de registros es:
\begin{verbatim}
1 LOADC R0, 2
2 STORE  0, R0 # a
3 LOADM R0, 0 # a
4 MULTM R0, 0 # a
5 PLUSC R0, 1 # 1
6 STORE  1, R0 # b
\end{verbatim}
Se ve que la instrucción de carga \verb|LOADM R0, 0| de la 
línea 3 es innecesaria por cuanto
el contenido de la variable \verb|a| ya está en el registro \verb|R0|, 
ya que fué cargada en el registro en la línea 2.
Nótese que esta hipótesis no es necesariamente cierta
si la línea 3 fuera el objetivo de un salto desde 
otro punto del programa. Esta condición se cumple
cuando nos movemos dentro de un \cei{bloque básico}: 
una secuencia de instrucciones que no contiene instrucciones
de salto ni es el objetivo de instrucciones de salto, con la excepción
de las instrucciones inicial y final.
Mejore el código generado 
intentando detectar patrones
de este tipo, eliminando la operación de carga correspondiente.
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter_descendente/descendente_en_perl.tex

\chapter{Análisis Sintáctico Ascendente en JavaScript}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_bottomup/jison.tex
\section{Conceptos Básicos para el Análisis Sintáctico}
\label{section:conceptos}
Suponemos que el lector de esta sección ha realizado con éxito
un curso en teoría de autómatas y lenguajes formales.
Las siguientes definiciones repasan los conceptos mas importantes.

\begin{definition}
Dado un conjunto $A$, se define $A^*$ el cierre de Kleene de $A$ como:
\begin{math}
A^* = \cup_{n=0}^{\infty} A^n
\end{math}

Se admite que $A^0 = \{ \epsilon \}$, donde $\epsilon$ denota la palabra vacía, esto es
la palabra que tiene longitud cero, formada por cero símbolos del conjunto base $A$.
\end{definition}

\begin{definition}
Una gramática $G$ es una cuaterna $G =(\Sigma,V,P,S)$. 
$\Sigma$ es el conjunto de terminales. $V$ es un conjunto (disjunto de $\Sigma$)
que se denomina conjunto de \emph{variables sintácticas} o \emph{categorías gramáticales},
P es un conjunto de pares de $V \times (V \cup \Sigma )^*$. En vez de escribir
un par usando la notación $(A, \alpha) \in P$ se escribe $A \rightarrow \alpha$.
Un elemento de $P$ se denomina producción. Por último, $S$ es un símbolo del conjunto
$V$ que se denomina símbolo de arranque.
\end{definition}

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y $\mu = \alpha A \beta \in (V \cup \Sigma)^*$
una frase formada por variables y terminales y $A \rightarrow \gamma$ una producción de 
$P$, decimos que  $\mu$ deriva en un paso en  $\alpha \gamma \beta$. Esto es, derivar 
una cadena $\alpha A \beta$ es sustituir 
una variable sintáctica $A$ de $V$ por la parte derecha $\gamma$ de una de sus reglas de producción.
Se dice que $\mu$ deriva en $n$ pasos en $\delta$ si deriva en $n-1$ pasos en una cadena
$\alpha A \beta$ la cual deriva en un paso en $\delta$. Se escribe entonces
que $\mu  \stackrel{*}{\Longrightarrow}  \delta$. Una cadena deriva en 0 pasos en si misma.

\end{definition}

\begin{definition}
\label{definition:lenguajegenerado}
Dada una gramática $G=(\Sigma,V,P,S)$ se denota por $L(G)$ o lenguaje
generado por $G$ al lenguaje:

\begin{center}
$L(G) = \{ x \in \Sigma^* : S \stackrel{*}{\Longrightarrow} x \}$
\end{center}

Esto es, el lenguaje generado por la gramática $G$ esta formado por las cadenas
de terminales que pueden ser derivados desde el símbolo de arranque.
\end{definition}

\begin{definition}
Una derivación que comienza en el símbolo de arranque y termina en una secuencia
formada por sólo terminales de $\Sigma$ se dice \emph{completa}.

Una derivación $\mu  \stackrel{*}{\Longrightarrow}  \delta$ 
en la cual en cada paso $\alpha A x$ la regla de producción aplicada $A \rightarrow \gamma$
se aplica en la variable sintáctica mas a la derecha se dice \emph{una derivación a derechas}

Una derivación $\mu  \stackrel{*}{\Longrightarrow}  \delta$ 
en la cual en cada paso $x A \alpha$ la regla de producción aplicada $A \rightarrow \gamma$
se aplica en la variable sintáctica mas a la izquierda se dice \emph{una derivación a izquierdas}
\end{definition}

\begin{definition}
Observe que una derivación puede ser representada como un árbol cuyos nodos
están etiquetados en $V \cup \Sigma$. La aplicación de la regla de 
producción $A \rightarrow \gamma$ se traduce en asignar como hijos del nodo etiquetado con $A$
a los nodos etiquetados con los símbolos $X_1 \ldots X_n$ que constituyen
la frase $\gamma = X_1 \ldots X_n$.  
Este árbol se llama \cei{árbol sintáctico concreto} asociado 
con la derivación.
\end{definition}

\begin{definition}
\label{definition:arbolconcreto}
Observe que, dada una frase $x \in L(G)$ una derivación desde el
símbolo de arranque da lugar a  un árbol. Ese árbol tiene como raíz el 
símbolo de arranque y como hojas los terminales 
$x_1 \ldots x_n$ que forman $x$. Dicho árbol se denomina \emph{árbol
de análisis sintáctico concreto} de $x$. Una derivación determina
una forma de recorrido del árbol de análisis sintáctico concreto.
\end{definition}

\begin{definition}
Una gramática $G$ se dice ambigua si existe alguna frase $x \in L(G)$
con al menos dos árboles sintácticos. 
Es claro que esta definición es equivalente a afirmar que existe 
alguna frase $x \in L(G)$ para la cual existen dos derivaciones a 
izquierda (derecha) distintas.
\end{definition}

\subsection{Ejercicio}
\label{ejercicio:tutugrammar}
Dada la gramática con producciones:

\vspace{0.5cm}
\begin{tabular}{l}
program      $\rightarrow$  declarations  statements         $|$ statements\\
declarations $\rightarrow$ declaration  ';'  declarations    $|$ declaration ';'\\
declaration  $\rightarrow$ INT  idlist                       $|$ STRING   idlist\\
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM $|$ STR\\
idlist       $\rightarrow$ ID ',' idlist $|$ ID
\end{tabular}
\vspace{0.25cm}

En esta gramática, $\Sigma$ esta formado por los caracteres entre comillas simples y 
los símbolos cuyos identificadores están en mayúsculas. Los restantes identificadores
corresponden a elementos de $V$. El símbolo de arranque es $S = program$.

Conteste a las siguientes cuestiones:

\begin{enumerate}
\item
Describa con palabras el lenguaje generado.
\item
\label{ejer:arbol}
Construya el árbol de análisis sintáctico
concreto para cuatro frases del lenguaje.
\item
Señale a que recorridos del árbol corresponden las respectivas
derivaciones a izquierda y a derecha en el apartado \ref{ejer:arbol}.
\item
¿Es ambigua esta gramática?. Justifique su respuesta.
\end{enumerate}

\section{Ejemplo Simple en Jison}

\parrafo{Gramática}

\begin{verbatim}
%%

S   : A
    ;
A   : /* empty */  
    | A x 
    ;
\end{verbatim}

\parrafo{basic2\_lex.jison}
\begin{verbatim}
[~/jison/examples/basic2_lex(develop)]$ cat basic2_lex.jison 
/* description: Basic grammar that contains a nullable A nonterminal. */

%lex
%%

\s+               {/* skip whitespace */}
[a-zA-Z_]\w*      {return 'x';}

/lex

%%

S   : A
           { return $1+" identifiers"; }
    ;
A   : /* empty */  
           { 
              console.log("starting"); 
              $$ = 0; 
           }
    | A x  { 
              $$ = $1 + 1;  
              console.log($$)
           }
    ;
\end{verbatim}

\parrafo{index.html}
\begin{verbatim}
$ cat basic2_lex.html
<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Jison</title>
    <link rel="stylesheet" href="global.css" type="text/css" media="screen" charset="utf-8" />
  </head>
  <body>
    <h1>basic2_lex demo</h1>
    <div id="content">
      <script src="jquery/jquery.js"></script> 
      <script src="basic2_lex.js"></script>
      <script src="main.js"></script>
      <p>
        <input type="text" value="x x x x" /> <button>parse</button> 
        <span id="output"></span> <!-- Output goes here! -->
      </p>
    </div>
  </body>
</html>
\end{verbatim}

\parrafo{Rakefile}

\begin{verbatim}
$ cat Rakefile 
# install package:
#     sudo npm install beautifier
# 
#   more about beautifier:
#       https://github.com/rickeyski/node-beautifier

dec "compile the grammar basic2_lex_ugly.jison"
task :default => %w{basic2_lex_ugly.js} do
  sh "mv basic2_lex.js basic2_lex_ugly.js"
  sh "jsbeautify basic2_lex_ugly.js > basic2_lex.js"
  sh "rm -f basic2_lex_ugly.js"
end

file "basic2_lex_ugly.js" => %w{basic2_lex.jison} do
  sh "jison basic2_lex.jison -o basic2_lex.js"
end
\end{verbatim}

\begin{enumerate}
\item 
\htmladdnormallink{node-beautifier}{https://github.com/rickeyski/node-beautifier}
\end{enumerate}

\parrafo{Véase También}
\begin{enumerate}
\item 
\htmladdnormallink{JISON}{http://zaach.github.com/jison/}
\item 
\htmladdnormallink{Try Jison Examples}{http://zaach.github.com/jison/try/usf/}
\item 
\htmladdnormallink{JavaScript 1.4 LR(1) Grammar}{http://www-archive.mozilla.org/js/language/grammar14.html} 1999.
\item 
\htmladdnormallink{Creating a JavaScript Parser}{http://cjihrig.com/blog/creating-a-javascript-parser/} Una implementación de ECAMScript 5.1 usando Jison 
disponible 
en GitHub
 en
\htmladdnormallink{https://github.com/cjihrig/jsparser}{https://github.com/cjihrig/jsparser}.
Puede probarse en:
\htmladdnormallink{http://www.cjihrig.com/development/jsparser/}{http://www.cjihrig.com/development/jsparser/}
\item 
\htmladdnormallink{Slogo}{http://hansineffect.github.com/Slogo/} a language written using Jison
\item 
\htmladdnormallink{List of languages that compile to JS}{https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS}
\item 
\htmladdnormallink{Prototype of a Scannerless, Generalized Left-to-right Rightmost (SGLR) derivation parser for JavaScript}{http://blog.kalleberg.org/post/1256702765/prototype-of-a-scannerless-generalized-left-to-right}
\end{enumerate}
\parrafo{global.css}

\begin{verbatim}
[~/jison/examples/basic2_lex(develop)]$ cat global.css 
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: left; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: none; }
.unhidden    { display: block; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }
span.header { background-color: blue }
span.comments { background-color: orange }
span.blanks { background-color: green }
span.nameEqualValue { background-color: cyan }
span.error { background-color: red }

body
{
 background-color:#b0c4de;  /* blue */
}
\end{verbatim}


\subsection{Véase También}
\begin{enumerate}
\item 
\htmladdnormallink{JISON}{http://zaach.github.com/jison/}
\item 
\htmladdnormallink{Try Jison Examples}{http://zaach.github.com/jison/try/usf/}
\item 
\htmladdnormallink{JavaScript 1.4 LR(1) Grammar}{http://www-archive.mozilla.org/js/language/grammar14.html} 1999.
\item 
\htmladdnormallink{Creating a JavaScript Parser}{http://cjihrig.com/blog/creating-a-javascript-parser/} Una implementación de ECAMScript 5.1 usando Jison 
disponible 
en GitHub
 en
\htmladdnormallink{https://github.com/cjihrig/jsparser}{https://github.com/cjihrig/jsparser}.
Puede probarse en:
\htmladdnormallink{http://www.cjihrig.com/development/jsparser/}{http://www.cjihrig.com/development/jsparser/}
\item 
\htmladdnormallink{Slogo}{http://hansineffect.github.com/Slogo/} a language written using Jison
\item 
\htmladdnormallink{List of languages that compile to JS}{https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS}
\item 
\htmladdnormallink{Prototype of a Scannerless, Generalized Left-to-right Rightmost (SGLR) derivation parser for JavaScript}{http://blog.kalleberg.org/post/1256702765/prototype-of-a-scannerless-generalized-left-to-right}
\end{enumerate}

\subsectionpractica{Secuencia de Asignaciones Simples}
Modifique este ejemplo para que el lenguaje acepte una secuencia
de sentencias de asignación de la forma \verb|ID = NUM| separadas
por puntos y comas, por ejemplo \verb|a = 4; b = 4.56; c = -8.57e34|.
El analizador retorna un hash/objeto 
cuyas claves son los identificadores y cuyos valores 
son los números.
Clone el repositorio en
\htmladdnormallink{https://github.com/crguezl/jison-basic2}{https://github.com/crguezl/jison-basic2}.


Modifique los analizadores léxico y sintáctico de forma conveniente.

Añada acciones semánticas para que el analizador devuelva una tabla de símbolos con los identificadores y sus valores.




\section{Ejemplo en Jison: Calculadora Simple}
\label{section:calculadora}

\begin{enumerate}
\item 
Enlace al fork  \htmladdnormallink{del proyecto jison de crguezl}{https://github.com/crguezl/jison/tree/develop/examples/html_calc_example} (GitHub)
\end{enumerate}
\parrafo{calculator.jison}
\begin{verbatim}
[~/jison/examples/html_calc_example(develop)]$ cat calculator.jison 

/* description: Parses end executes mathematical expressions. */

/* lexical grammar */
%lex
%%

\s+                   /* skip whitespace */
[0-9]+("."[0-9]+)?\b  return 'NUMBER'
"*"                   return '*'
"/"                   return '/'
"-"                   return '-'
"+"                   return '+'
"^"                   return '^'
"!"                   return '!'
"%"                   return '%'
"("                   return '('
")"                   return ')'
"PI"                  return 'PI'
"E"                   return 'E'
<<EOF>>               return 'EOF'
.                     return 'INVALID'

/lex

/* operator associations and precedence */

%left '+' '-'
%left '*' '/'
%left '^'
%right '!'
%right '%'
%left UMINUS

%start expressions

%% /* language grammar */

expressions
    : e EOF
        { typeof console !== 'undefined' ? console.log($1) : print($1);
          return $1; }
    ;

e
    : e '+' e
        {$$ = $1+$3;}
    | e '-' e
        {$$ = $1-$3;}
    | e '*' e
        {$$ = $1*$3;}
    | e '/' e
        {$$ = $1/$3;}
    | e '^' e
        {$$ = Math.pow($1, $3);}
    | e '!'
        {{
          $$ = (function fact (n) { return n==0 ? 1 : fact(n-1) * n })($1);
        }}
    | e '%'
        {$$ = $1/100;}
    | '-' e %prec UMINUS
        {$$ = -$2;}
    | '(' e ')'
        {$$ = $2;}
    | NUMBER
        {$$ = Number(yytext);}
    | E
        {$$ = Math.E;}
    | PI
        {$$ = Math.PI;}
    ;
\end{verbatim}

\parrafo{main.js}
\begin{verbatim}
[~/jison/examples/html_calc_example(develop)]$ cat main.js
$(document).ready(function () {
  $("button").click(function () {
    try {
      var result = calculator.parse($("input").val())
      $("span").html(result);
    } catch (e) {
      $("span").html(String(e));
    }
  });
});
\end{verbatim}

\parrafo{calculator.html}
\begin{verbatim}
[~/jison/examples/html_calc_example(develop)]$ cat calculator.html 
<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Calc</title>
    <link rel="stylesheet" href="global.css" type="text/css" media="screen" charset="utf-8" />
  </head>
  <body>
    <h1>Calculator demo</h1>
    <div id="content">
      <script src="jquery/jquery.js"></script> 
      <script src="calculator.js"></script>
      <script src="main.js"></script>
      <p>
        <input type="text" value="PI*4^2 + 5" /> <button>equals</button> 
        <span></span> <!-- Output goes here! -->
      </p>
    </div>
  </body>
</html>
\end{verbatim}

\parrafo{Rakefile}
\begin{verbatim}
[~/jisoncalc(clase)]$ cat Rakefile 
task :default => %w{calcugly.js} do
  sh "jsbeautify calcugly.js > calculator.js"
  sh "rm -f calcugly.js"
end

file "calcugly.js" => %w{calculator.jison} do
  sh "jison calculator.jison calculator.l -o calculator.js; mv calculator.js calcugly.js"
end

task :testf do
  sh "open -a firefox test/test.html"
end

task :tests do
  sh "open -a safari test/test.html"
end
\end{verbatim}

\parrafo{global.css}

\begin{verbatim}
[~/jison/examples/html_calc_example(develop)]$ cat global.css
html *
{
   font-size: large; 
   /* The !important ensures that nothing can override what you've set in this style (unless it is also important). */
   font-family: Arial;
}

.thumb {
    height: 75px;
    border: 1px solid #000;
    margin: 10px 5px 0 0;
  }

h1            { text-align: center; font-size: x-large; }
th, td        { vertical-align: top; text-align: left; }   
/* #finaltable  * { color: white; background-color: black; }   */

/* #finaltable table { border-collapse:collapse; } */
/* #finaltable table, td { border:1px solid white; } */
#finaltable:hover td { background-color: blue; } 
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
input        { text-align: right;  border: none;       }     /* Align input to the right  */
textarea     { border: outset; border-color: white;       }                        
table        { border: inset; border-color: white; }
.hidden      { display: none; }
.unhidden    { display: block; }
table.center { margin-left:auto; margin-right:auto; }
#result      { border-color: red; }
tr.error       { background-color: red; }
pre.output   { background-color: white; }
span.repeated { background-color: red }
span.header { background-color: blue }
span.comments { background-color: orange }
span.blanks { background-color: green }
span.nameEqualValue { background-color: cyan }
span.error { background-color: red }

body
{
 background-color:#b0c4de;  /* blue */
}
\end{verbatim}

\parrafo{test/assert.html}
\begin{verbatim}
$ cat test/assert.js 
var output = document.getElementById('output');

function assert( outcome, description) {
  var li = document.createElement('li');
  li.className = outcome ? 'pass' : 'fail';
  li.appendChild(document.createTextNode(description));
  
  output.appendChild(li);
};
\end{verbatim}

\parrafo{test/test.css}

\begin{verbatim}
~/jisoncalc(clase)]$ cat test/test.css 
.pass:before {
  content: 'PASS: ';
  color:  blue;
  font-weight: bold;
}

.fail:before {
  content: 'FAIL: ';
  color: red;
  font-weight: bold;
  
}
\end{verbatim}

\parrafo{test/test.html}

\begin{verbatim}
[~/jisoncalc(clase)]$ cat test/test.html
<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Testing Our Simple Calculator</title>
    <link rel="stylesheet" href="test.css" />
    <script type="text/javascript" src="../calculator.js"></script>

  </head>
  <body>
    <h1>Testing Our Simple Calculator
    </h1>
    
    <ul id="output"></ul>
    <script type="text/javascript" src="______.js"></script>
    
    <script type="text/javascript">
      var r = __________.parse("a = 4*8");
      assert(_______________, "a is 4*8");
      assert(_____________, "32 == 4*8");
      r = calculator.parse("a = 4;\nb=a+1;\nc=b*2");
      assert(____________, "4 is the first computed result ");
      assert(______________, "a is 4");
      assert(______________, "b is 5");
      assert(______________, "c is 10");
    </script>
      See the NetTuts+ tutorial at <a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/">Quick and Easy JavaScript Testing</a>
  </body>
</html>
\end{verbatim}

\subsectionpractica{Calculadora con Listas de Expresiones y Variables}
\label{subsectionpractica:calculadora}
Modifique la calculadora vista en la sección anterior 
\ref{section:calculadora}
para que el lenguaje cumpla los siguientes requisitos:
\begin{itemize}
\item
Extienda el lenguaje de la calculadora para que admita expresiones
de asignación \verb|a = 2*3|
\item
Extienda el lenguaje de la calculadora para que admita listas de
sentencias \verb|a = 2; b = a +1|
\item
El analizador devuelve la lista de expresiones
evaluadas y la tabla de símbolos (con las parejas variable-valor).
\item
Emita un mensaje de error específico si se intentan modificar las constantes 
\verb|PI| y \verb|e|.
\item
Emita un mensaje de error específico si se intenta una división por cero
\item
Emita un mensaje de error específico si se intenta acceder para lectura a una variable 
no inicializada \verb|a = c|
\item
El lenguaje debería admitir expresiones vacías, estos es secuencias consecutivas de puntos y comas sin producir error (\verb|a = 4;;; b = 5|)
\item
Introduzca pruebas unitarias como las descritas en 
la sección \ref{section:tstingfacil} ({\it
\htmladdnormallink{Quick Tip: Quick and Easy JavaScript Testing with “Assert”}{http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/}})

\end{itemize}

\section{Conceptos Básicos del Análisis LR}
\label{section:conceptosbasicos}
Los analizadores generados por \verb|jison| entran en la categoría de analizadores
\cei{LR}. Estos analizadores construyen una derivación a derechas inversa 
(o \cei{antiderivación}).
De ahí la R en LR (del inglés \cei{rightmost derivation}). El árbol sintáctico 
es construido de las hojas hacia la raíz, siendo el último paso en la antiderivación
la construcción de la primera derivación desde el símbolo de arranque.

Empezaremos entonces considerando las frases que pueden aparecer en una derivación
a derechas. Tales frases consituyen el \cei{lenguaje de las formas sentenciales a rderechas} $FSD$:

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ no ambigua, se denota por $FSD$ 
(lenguaje de las formas Sentenciales a Derechas) al lenguaje de 
las sentencias que aparecen en una derivación a derechas desde el símbolo de arranque.

\begin{center}
$FSD = \left \{ \alpha \in (\Sigma \cup V)* : \exists S \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array} \alpha \right \}$
\end{center}

Donde la notacion RM indica una derivación a derechas (\emph{rightmost}).
Los elementos de $FSD$ se llaman ``formas sentenciales derechas''.
\end{definition}

Dada una gramática no ambigua $G=(\Sigma,V,P,S)$ y una frase $x \in L(G)$ el proceso
de antiderivación consiste en encontrar la última derivación a derechas que dió lugar a 
$x$. Esto es, si $x \in L(G)$ es porque existe una derivación a derechas de la forma

\begin{center}
$S \stackrel{*}{\Longrightarrow} y A z \Longrightarrow y w z = x$. 
\end{center}

El problema es averiguar que regla $A \rightarrow w$ se aplicó y en que lugar 
de la cadena $x$ se aplicó. En general, si queremos antiderivar
una forma sentencial derecha $\beta \alpha w$ 
debemos averiguar por que regla $A \rightarrow \alpha$
seguir y en que lugar de la forma (después de $\beta$ en el ejemplo)
aplicarla. 

\begin{center}
$S \stackrel{*}{\Longrightarrow} \beta A w \Longrightarrow \beta \alpha w$. 
\end{center}

La pareja formada por la regla y la posición 
se denomina \cei{handle}, \cei{mango} o \cei{manecilla} de la forma. Esta denominación viene
de la visualización gráfica de la regla de producción como una mano
que nos permite escalar hacia arriba en el árbol. Los ``dedos'' serían los
símbolos en la parte derecha de la regla de producción.

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ no ambigua, y dada una forma sentencial derecha 
$\alpha = \beta \gamma x$, con $x \in \Sigma^*$, el \cei{mango} o \cei{handle}  de 
$\alpha$ es la última producción/posición  que dió lugar a $\alpha$:

\begin{center}
$ S \begin{array}{c} *\\\Longrightarrow  \\ {\scriptstyle RM} \end{array} \beta B x \Longrightarrow \beta \gamma x = \alpha$
\end{center}

\end{definition}
Escribiremos: 
$handle(\alpha) = (B \rightarrow \gamma, \beta \gamma)$. La función $handle$ tiene dos componentes:
$handle_1(\alpha) = B \rightarrow \gamma$ y 
$handle_2(\alpha) =  \beta \gamma$

Si dispusieramos de un procedimiento que fuera capaz de identificar el mango,
esto es, de detectar la regla y el lugar en el que se posiciona, tendríamos un
mecanismo para construir un analizador. 
Lo curioso es que, a menudo es posible encontrar un autómata finito que
reconoce el lenguaje de los prefijos $\beta \gamma$  que terminan 
en el mango. Con mas precisión, del lenguaje:

\begin{definition}
El conjunto de \emph{prefijos viables} de una gramática G se define
como  el conjunto:

\begin{center}
$PV = \left \{ \delta \in (\Sigma \cup V)* :  \exists S \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array} \alpha = \beta \gamma x \mbox{ y }\delta\ es\ un\ prefijo\ de\  handle_2(\alpha) = \beta \gamma \right \}$ 
\end{center}
\end{definition}

Esto es, es el lenguaje de los prefijos viables es el 
conjunto de frases que son prefijos de 
$handle_2(\alpha)) =  \beta \gamma$, 
siendo $\alpha$ una forma sentencial derecha ($\alpha \in FSD$). Los
elementos de $PV$ se denominan prefijos viables.

Obsérvese que si se dispone de un autómata que reconoce 
$PV$ entonces se dispone de un mecanismo para investigar el lugar y 
el aspecto que pueda tener el mango. Si damos como 
entrada la sentencia $\alpha = \beta \gamma x$
a dicho autómata, el autómata aceptará la cadena $\beta \gamma$ pero rechazará
cualquier extensión del prefijo. Ahora sabemos que el mango 
será alguna regla de producción de $G$ cuya parte derecha 
sea un sufijo de  $\beta \gamma$.

\begin{definition}
\label{definition:slrautomata}
El siguiente autómata finito no determinista puede ser utilizado para
reconocer el lenguaje de los prefijos viables PV:
\begin{itemize}
\item
Alfabeto = $V \cup \Sigma$
\item
Los estados del autómata se denominan LR(0) items. Son parejas formadas
por una regla de producción de la gramática y una posición en la parte derecha 
de la regla de producción. Por ejemplo, $(E \rightarrow E + E, 2)$ sería un
LR(0) item para la gramática de las expresiones.

Conjunto de Estados:

$Q =  \left \{ (A \rightarrow \alpha, n) :  A \rightarrow \alpha \in P,\ n \le |\alpha| \right \}$

 La notación $\mid \alpha \mid$ denota la longitud de la cadena $\mid \alpha \mid$.
 En vez de la notación $(A \rightarrow \alpha, n)$ escribiremos: 
 $A \rightarrow \beta _\uparrow \gamma$ $ = \alpha$, 
 donde la flecha ocupa el lugar indicado por el número $n = \mid \beta \mid$ :
\item
La función de transición intenta conjeturar que partes derechas de reglas de producción son viables. El conjunto de estados actual del NFA representa el conjunto de pares 
(regla de producción, posición en la parte derecha) que tienen alguna posibilidad de
ser aplicadas de acuerdo con la entrada procesada hasta el momento:

\begin{center}
$\delta(A \rightarrow \alpha _\uparrow X \beta, X) = A \rightarrow \alpha X _\uparrow \beta\ \forall X \in  V \cup \Sigma$ 

$\delta(A \rightarrow \alpha _\uparrow B \beta, \epsilon) = B \rightarrow 
_\uparrow \gamma\  \forall B \rightarrow \gamma \in  P$ 
\end{center}

\item
Estado de arranque: Se añade la ``superregla'' $S' \rightarrow S$ a la gramática $G = (\Sigma,V,P,S)$. El LR(0) item 
$S' \rightarrow _\uparrow S$ es el estado de arranque.
\item
Todos los estados definidos (salvo el de muerte) son de aceptación.
\end{itemize}
\end{definition}

Denotaremos por $LR(0)$ a este autómata. Sus estados se denominan $LR(0)-items$. La idea es que este
autómata nos ayuda a reconocer los prefijos viables $PV$.

Una vez que se tiene un autómata que reconoce los prefijos viables es posible construir un analizador sintáctico que construye una antiderivación a derechas. La estrategia consiste en ``alimentar'' el autómata con la forma sentencial derecha. El lugar en el que el autómata se detiene, rechazando indica el lugar exacto en el que termina el \emph{handle} de dicha forma.


\begin{example}
\label{example:asb}
Consideremos la gramática:

\vspace{0.5cm}
\begin{center}
\begin{tabular}{l}
S      $\rightarrow$  a S b\\
S      $\rightarrow$ $\epsilon$ 
\end{tabular}
\end{center}
\vspace{0.25cm}

El lenguaje generado por esta gramática es $L(G) = \{ a^n b^n\ :\ n \ge 0 \}$
Es bien sabido que el lenguaje $L(G)$ no es regular.
La figura \ref{fig:nfa} muestra 
el \cei{autómata finito no determinista con $\epsilon$-transiciones} 
(\cei{NFA})
que reconoce los prefijos viables de esta gramática, construido
de acuerdo con el algoritmo \ref{definition:slrautomata}.

Véase \htmladdnormallink{https://github.com/crguezl/jison-aSb}{https://github.com/crguezl/jison-aSb} para una implementación en Jison de una variante de esta gramática.

%\begin{center}
%\begin{figure}[htb]
%\centerline{\includegraphics[scale=1.2]{chapter_bottomup/nfa.png}}
%\caption{NFA que reconoce los prefijos viables}
%\label{fig:nfa}
%\end{figure}
%\end{makeimage}
%\end{center}

\begin{center}
\begin{figure}[htb]
\centerline{\epsfig{file=chapter_bottomup/nfa.eps, width=12cm}}
\caption{NFA que reconoce los prefijos viables}
\label{fig:nfa}
\end{figure}
\end{center}
\end{example}

\begin{exercise}
Simule el comportamiento del autómata sobre la entrada $aabb$. ¿Donde rechaza?
¿En que estados está el autómata en el momento del rechazo?. ¿Qué etiquetas tienen?
Haga también las
trazas del autómata para las entradas $aaSbb$ y $aSb$. ¿Que antiderivación 
ha construido el autómata con sus sucesivos rechazos? ¿Que terminales
se puede esperar que hayan en la entrada cuando se produce el rechazo
del autómata?
\end{exercise}

\section{Construcción de las Tablas para el Análisis SLR}

\subsection{Los conjuntos de Primeros y Siguientes}
Repasemos las nociones de conjuntos de \cei{Primeros} y \cei{siguientes}:

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y una frase $\alpha \in (V \cup \Sigma)^*$ se define el conjunto $FIRST(\alpha)$ como:

$FIRST(\alpha) = \left \{ b \in \Sigma :  \alpha  \stackrel{*}{\Longrightarrow}  b \beta \right \}
\cup N(\alpha)$ 

\noindent donde:

$N(\alpha) = \left \{ \begin{array}{ll}
                         \left \{ \epsilon \right \}& \mbox{si $\alpha \stackrel{*}{\Longrightarrow} \epsilon$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y una variable $A \in V$ se define el conjunto $FOLLOW(A)$ como: 

$FOLLOW(A) = \left \{ b \in \Sigma :  \exists\ S  \stackrel{*}{\Longrightarrow}  \alpha A b \beta \right \} \cup E(A)$

\noindent donde

$E(A) = \left \{ \begin{array}{ll}
                         \{ \$  \}& \mbox{si $S \stackrel{*}{\Longrightarrow} \alpha A$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}

\begin{algorithm} Construcción de los conjuntos $FIRST(X)$
\begin{enumerate}
\item
$Si\ X \in \Sigma\ entonces\ FIRST(X) = {X}$
\item
$Si\ X \rightarrow \epsilon\ entonces\ FIRST(X) =  FIRST(X) \cup \{ \epsilon \}$
\item
$Si X \in V \ y\ X \rightarrow Y_1 Y_2 \cdots Y_k \in P\ entonces$
\begin{eqnarray*}
&&i = 1; \\
&&do\\
&&\ \ FIRST(X) = FIRST(X) \cup FIRST(Y_i) - \{ \epsilon \};\\
&&\ \ i++;\\
&&mientras\ (\epsilon \in FIRST(Y_i)\ and\ (i \leq k))\\
&&si\ (\epsilon \in FIRST(Y_k)\ and\ i > k)\ FIRST(X) = FIRST(X) \cup \{ \epsilon \}
\end{eqnarray*}
\end{enumerate}
\end{algorithm}
Este algoritmo puede ser extendido para calcular $FIRST(\alpha)$ para $\alpha = X_1 X_2 \cdots X_n \in (V \cup \Sigma)^*$.

\begin{algorithm} Construcción del conjunto $FIRST(\alpha)$ 
\begin{eqnarray*}
&&i = 1; \nonumber\\
&&FIRST(\alpha) = \emptyset; \nonumber\\
&&do \nonumber\\
&&\ \ FIRST(\alpha) = FIRST(\alpha) \cup FIRST(X_i) - \{ \epsilon \}; \nonumber\\
&&\ \ i++; \nonumber\\
&&mientras\ (\epsilon \in FIRST(X_i)\ and\ (i \leq n)) \nonumber\\
&&si\ (\epsilon \in FIRST(X_n)\ and\ i > n)\ FIRST(\alpha) = FIRST(X) \cup \{ \epsilon \}
\end{eqnarray*}
\end{algorithm} 

\begin{algorithm} Construcción de los conjuntos $FOLLOW(A)$
para las variables sintácticas $A \in V$: 

Repetir los siguientes pasos hasta que ninguno de los conjuntos $FOLLOW$ cambie:
\begin{enumerate} 
\item 
$FOLLOW(S) = \{\$\} $  ($\$$ representa el final de la entrada)
\item
$Si\ A \rightarrow \alpha B \beta\ entonces$
\[ FOLLOW(B) =  FOLLOW(B) \cup (FIRST(\beta) - \{\epsilon\})\]
\item
$Si\ A \rightarrow \alpha B$ o bien $A \rightarrow \alpha B \beta$
y $\epsilon \in FIRST(\beta)$  entonces

\[ FOLLOW(B) = FOLLOW(B) \cup FOLLOW(A)\]
\end{enumerate}
\end{algorithm}

\subsection{Construcción de las Tablas}
\label{subsection:nfa2dfa}

Para la construcción de las tablas de un analizador SLR
se construye el \cei{autómata finito determinista} (\cei{DFA}) 
$(Q, \Sigma, \delta, q_0)$ equivalente al NFA 
presentado en la sección
\ref{section:conceptosbasicos}
usando el \cei{algoritmo de construcción del subconjunto}.

Como recordará, en la construcción del subconjunto,
partiendo del estado de arranque $q_0$ del NFA con $\epsilon$-transiciones
se calcula su \cei{clausura} $\overline{\{q_0\}}$ y las 
clausuras de los conjuntos de estados $\overline{\delta(\overline{\{q_0\}},a)}$ 
a los que transita.  Se repite el proceso
con los conjuntos resultantes hasta que no se introducen nuevos
conjuntos-estado.

La clausura $\overline{A}$ de un subconjunto de estados del autómata $A$ esta formada
por todos los estados que pueden ser alcanzados mediante transiciones
etiquetadas con la palabra vacía (denominadas $\epsilon$ transiciones)
desde los estados de $A$. Se incluyen en $\overline{A}$, naturalmente los estados 
de $A$.

\begin{center}
$\overline{A} = \{ q \in Q\ /\  \exists q' \in Q\ :\ \hat{\delta}(q', \epsilon) = q \}$
\end{center}

Aquí $\hat{\delta}$ denota la \cei{función de transición del autómata} extendida  a cadenas
de $\Sigma^*$.

\begin{equation}
\label{equation:deltahat}
\hat{\delta}(q, x) = \left \{ \begin{array}{ll}
                         \delta(\hat{\delta}(q,y),a) & \mbox{si $x = ya$} \\
                         q & \mbox{si $x = \epsilon$} 
                      \end{array}
             \right.  
\end{equation}

En la práctica, y a partir de ahora así lo haremos, se prescinde de diferenciar
entre $\delta$ y $\hat{\delta}$ usándose indistintamente la notación
$\delta$ para ambas funciones.

La clausura puede ser computada usando una estructura de pila o aplicando 
la expresión recursiva dada en la ecuación \ref{equation:deltahat}.

Para el NFA mostrado en el ejemplo \ref{example:asb} el DFA construído mediante esta
técnica es el que se muestra en la figura \ref{fig:dfa}. Se ha utilizado el símbolo
\verb|#| como marcador. Se ha omitido el número 3 para que los estados coincidan
en numeración con los generados por \verb|jison| (véase el cuadro
\ref{table:tablaslalr}).

\begin{center}
\begin{figure}[htb]
%\centerline{\includegraphics[scale=1.2]{chapter_bottomup/dfa.png}}
\centerline{\epsfig{file=chapter_bottomup/dfa.eps, width=12cm}}
\caption{DFA equivalente al NFA de la figura \ref{fig:nfa}}
\label{fig:dfa}
\end{figure}
\end{center}

Un analizador sintáctico LR utiliza una tabla para su análisis.
Esa tabla se construye a partir de la tabla de transiciones del DFA.
De hecho, la tabla se divide en dos tablas, una llamada 
\cei{tabla de saltos} o \cei{tabla de gotos} y la otra
\cei{tabla de acciones}.

La tabla \cei{goto} de un analizador \cei{SLR}
no es más que la tabla de transiciones del autómata DFA 
obtenido aplicando la construcción del subconjunto al NFA
definido en \ref{definition:slrautomata}. De hecho es la tabla
de transiciones restringida a $V$ (recuerde que el alfabeto del
autómata es $V \cup \Sigma$).
Esto es, 

\begin{center}
$\delta_{| V \times Q} :  V \times Q \rightarrow Q$. 

donde se define $goto(i, A) = \delta(A,I_i)$
\end{center}

La parte de la función de transiciones
del DFA que corresponde a los terminales que no producen rechazo, 
esto es, $\delta_{| \Sigma \times Q} :  \Sigma \times Q \rightarrow Q$
se adjunta a una tabla que se denomina \cei{tabla de acciones}.
La tabla de acciones es una tabla de doble entrada en los estados
y en los símbolos de $\Sigma$.
Las acciones de transición ante terminales 
se denominan \cei{acciones de desplazamiento} o (\cei{acciones shift}):

\begin{center}
$\delta_{| \Sigma \times Q} :  \Sigma \times Q \rightarrow Q$

donde se define $action(i, a) = shift\ \delta(a,I_i)$
\end{center}

Cuando un estado $s$ contiene un LR(0)-item de la forma 
$A \rightarrow \alpha_\uparrow$, 
esto es, el estado corresponde a un posible rechazo,
ello indica que hemos llegado a un final del prefijo viable, que hemos
visto $\alpha$ y que, por tanto, es probable que $A \rightarrow \alpha$
sea el \emph{handle} de la forma sentencial derecha actual. Por tanto,
añadiremos en entradas de la forma $(s,a)$ de la tabla de acciones 
una acción que indique que hemos encontrado el mango en la 
posición actual y que la regla asociada es $A \rightarrow \alpha$.
A una acción de este tipo se la denomina \cei{acción de reducción}.

La cuestión es, ¿para que valores de $a \in \Sigma$ debemos disponer que
la acción para $(s, a)$ es de reducción?

\begin{center}
Se define $action(i, a) = reduce\ A \rightarrow \alpha$ ¿Pero, para que $a \in \Sigma$?
\end{center}


Podríamos decidir que ante cualquier terminal $a \in \Sigma$
que produzca un rechazo del autómata, pero podemos ser un poco mas
selectivos. No cualquier terminal puede estar en la entrada en el momento
en el que se produce la antiderivación o reducción. 
Observemos que si $A \rightarrow \alpha$ es el \emph{handle}
de $\gamma$ es porque:

\begin{center}
$\exists S \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array} \beta A b x \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array}  
\beta \alpha b x = \gamma$
\end{center}

Por tanto, cuando estamos reduciendo por $A \rightarrow \alpha$
los únicos terminales legales que cabe esperar en una reducción por $A \rightarrow \alpha$ son los terminales $b \in FOLLOW(A)$.

\begin{center}
Se define $action(i, b) = reduce\ A \rightarrow \alpha$ Para $b \in FOLLOW(A)$
\end{center}

Dada una gramática $G=(\Sigma,V,P,S)$, podemos construir las tablas de acciones (\emph{action table}) y  transiciones (\emph{gotos table}) mediante el siguiente algoritmo:

\begin{algorithm} 
\label{alg:tables}       
Construcción de Tablas \cei{SLR}

\begin{enumerate}
\item
Utilizando el Algoritmo de Construcción del Subconjunto, se construye
el Autómata Finito Determinista (DFA) $(Q, V \cup \Sigma, \delta, I_0, F)$
equivalente al Autómata Finito No
Determinista (NFA) definido en \ref{definition:slrautomata}.
Sea $C = \left \{ I_1, I_2, \cdots I_n \right \}$ el conjunto de estados
del DFA. Cada estado $I_i$ es un conjunto de LR(0)-items o estados
del NFA. Asociemos un índice $i$ con cada conjunto $I_i$.
\item
La tabla de \emph{gotos} no es más que la función de transición del 
autómata restringida a las variables de la gramática:

\begin{center}
$goto(i,A) = \delta(I_i, A)$ para todo $A \in V$
\end{center}
\item
Las acciones para el estado $I_i$ se determinan como sigue:
  \begin{enumerate}
  \item
  Si $A \rightarrow \alpha _\uparrow a \beta \in I_i$, $\delta(I_i,a) = I_j$, $a \in \Sigma$ 
  entonces:

\begin{center}
  $action[i][a] = shift\ j$
\end{center}
  \item
  Si $S' \rightarrow S_\uparrow \in I_i$ entonces 

\begin{center}
  $action[i][\$] = accept$
\end{center}
  \item
  Para cualquier otro caso de la forma $A \rightarrow \alpha _\uparrow \in I_i$ 
  distinto del anterior hacer

\begin{center}
  $\forall a \in\ FOLLOW(A):\ action[i][a] = reduce\ A \rightarrow \alpha$
\end{center}
  \end{enumerate}
\item
  Las entradas de la tabla de acción que queden indefinidas después de aplicado el proceso anterior corresponden a acciones de ``$error$''.
\end{enumerate}
\end{algorithm}

\begin{definition}
Si alguna de las entradas de la tabla resulta multievaluada, decimos
que existe un conflicto y que la gramática no es \cei{SLR}.

\begin{enumerate}
\item
En tal caso, si una de las acciones es de `reducción'' y la otra es de
`desplazamiento'', decimos que hay un \cei{conflicto shift-reduce} o
\cei{conflicto de desplazamiento-reducción}. 
\item
Si las
dos reglas indican una acción de reducción, decimos que tenemos un 
\cei{conflicto reduce-reduce} o de \cei{reducción-reducción}.
\end{enumerate}
\end{definition}

\begin{example}
\label{example:tablasslr}
Al aplicar el algoritmo \ref{alg:tables}       
a la gramática \ref{example:asb} 

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|l|l|}
\hline
1 & S      $\rightarrow$  a S b\\
\hline
2 & S      $\rightarrow$ $\epsilon$ \\
\hline
\end{tabular}
\end{center}
\vspace{0.25cm}

partiendo del autómata finito determinista
que se construyó en 
la figura \ref{fig:dfa} y calculando los 
conjuntos de primeros y siguientes

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
     & FIRST  & FOLLOW \\
\hline
S    & a, $\epsilon$ & b, \$\\
\hline
\end{tabular}
\end{center}

obtenemos la siguiente tabla de acciones SLR:

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
     &  a  &  b  & \$ \\
\hline
0    & s2  &  r2 & r2 \\
\hline
1    &     &     & aceptar\\
\hline
2    & s2  & r2  & r2\\
\hline
4    &     & s5  &   \\
\hline
5    &     & r1  & r1\\
\hline
\end{tabular}
\end{center}

Las entradas denotadas con $s$ $n$ ($s$ por shift) indican un desplazamiento
al estado $n$, las denotadas con $r$ $n$ ($r$ por reduce o reducción) indican una operación
de reducción o antiderivación por la regla $n$.  Las entradas vacías 
corresponden a acciones de error.
\end{example}

El método de análisis \cei{LALR} usado por \verb|jison|
es una extensión del método SLR esbozado
aqui. Supone un compromiso entre potencia (conjunto de gramáticas
englobadas) y eficiencia (cantidad de memoria utilizada, tiempo de
proceso).
Veamos como \verb|jison| aplica la construcción del subconjunto a la 
gramática del ejemplo
\ref{example:asb}.
Para ello construimos el siguiente programa \verb|jison|:
\begin{verbatim}
[~/srcPLgrado/aSb(develop)]$ cat -n aSb.jison 
     1  %lex
     2  %%
     3  .               { return yytext; }
     4  /lex
     5  %%
     6  P: S            { return $1; }
     7  ;
     8  S: /* empty */  { console.log("empty");    $$ = ''; }
     9     | 'a' S 'b'  { console.log("S -> aSb"); $$ = $1+$2+$3; }
    10  ;
    11  %%
\end{verbatim}
y lo compilamos con \verb|jison|. Estas son las opciones disponibles:
\begin{verbatim}
nereida:[~/PLgradoBOOK(eps)]$ jison --help

Usage: jison [file] [lexfile] [options]

file        file containing a grammar
lexfile     file containing a lexical grammar

Options:
   -o FILE, --outfile FILE       Filename and base module name of the generated parser
   -t, --debug                   Debug mode
   -t TYPE, --module-type TYPE   The type of module to generate (commonjs, amd, js)
   -V, --version                 print version and exit
\end{verbatim}
Desafortunadamente carece de la típica opción \verb|-v| que permite generar las tablas
de análisis. Podemos intentar usar \verb|bison|, pero, obviamente, \verb|bison| protesta ante la entrada:

\begin{verbatim}
[~/srcPLgrado/aSb(develop)]$ bison -v aSb.jison 
aSb.jison:1.1-4: invalid directive: `%lex'
aSb.jison:3.1: syntax error, unexpected identifier
aSb.jison:4.1: invalid character: `/'
\end{verbatim}
El error es causado por la presencia del analizador léxico 
empotrado en el fichero \verb|aSb.jison|.  Si suprimimos provisionalmente
las líneas del analizador léxico empotrado,
\verb|bison| es capaz de analizar la gramática:
\begin{verbatim}
[~/srcPLgrado/aSb(develop)]$ bison -v aSb.jison 
[~/srcPLgrado/aSb(develop)]$ ls -ltr | tail -1
-rw-rw-r--  1 casiano  staff    926 19 mar 13:29 aSb.output
\end{verbatim}
Que tiene los siguientes contenidos:
\begin{verbatim}
[~/srcPLgrado/aSb(develop)]$ cat -n aSb.output 
     1  Grammar
     2  
     3      0 $accept: P $end
     4  
     5      1 P: S
     6  
     7      2 S: /* empty */
     8      3  | 'a' S 'b'
     9  
    10  
    11  Terminals, with rules where they appear
    12  
    13  $end (0) 0
    14  'a' (97) 3
    15  'b' (98) 3
    16  error (256)
    17  
    18  
    19  Nonterminals, with rules where they appear
    20  
    21  $accept (5)
    22      on left: 0
    23  P (6)
    24      on left: 1, on right: 0
    25  S (7)
    26      on left: 2 3, on right: 1 3
    27  
    28  
    29  state 0
    30  
    31      0 $accept: . P $end
    32  
    33      'a'  shift, and go to state 1
    34  
    35      $default  reduce using rule 2 (S)
    36  
    37      P  go to state 2
    38      S  go to state 3
    39  
    40  
    41  state 1
    42  
    43      3 S: 'a' . S 'b'
    44  
    45      'a'  shift, and go to state 1
    46  
    47      $default  reduce using rule 2 (S)
    48  
    49      S  go to state 4
    50  
    51  
    52  state 2
    53  
    54      0 $accept: P . $end
    55  
    56      $end  shift, and go to state 5
    57  
    58  
    59  state 3
    60  
    61      1 P: S .
    62  
    63      $default  reduce using rule 1 (P)
    64  
    65  
    66  state 4
    67  
    68      3 S: 'a' S . 'b'
    69  
    70      'b'  shift, and go to state 6
    71  
    72  
    73  state 5
    74  
    75      0 $accept: P $end .
    76  
    77      $default  accept
    78  
    79  
    80  state 6
    81  
    82      3 S: 'a' S 'b' .
    83  
    84      $default  reduce using rule 3 (S)
\end{verbatim}

El contenido del fichero \verb|aSb.output| se muestra
en la tabla 
\ref{table:tablaslalr}.
Los números de referencia a las producciones en las acciones
de reducción vienen dados por:

\begin{verbatim}
                      0:	$start -> S $end
                      1:	S -> /* empty */
                      2:	S -> 'a' S 'b'
\end{verbatim} 

Observe que el final de la entrada se denota 
por \verb|$end| y el marcador en un LR-item 
por un punto. Fíjese en el estado 2: 
En ese estado están también los items

\begin{center}
 \verb|S -> . 'a' S 'b'|
y \verb|S -> .|
\end{center}

sin embargo no se explicitan
por que se entiende que su pertenencia es
consecuencia directa de aplicar la operación 
de clausura. Los LR items cuyo marcador
no está al principio se denominan
\cei{items núcleo}. 

\vspace{0.5cm}
\begin{table}[htb]
\begin{center}
\begin{tabular}{|p{4cm}|p{4cm}|p{4cm}|}
\hline
Estado 0 & Estado 1 & Estado 2\\
\hline
\begin{verbatim}
	$start -> . S $end	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 1
\end{verbatim} 
&
\begin{verbatim}
	$start -> S . $end	
	$end	shift 3
\end{verbatim} 
&
\begin{verbatim}
	S -> 'a' . S 'b'	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 4
\end{verbatim} 

\\

\hline
Estado 3 & Estado 4 & Estado 5\\
\hline

\begin{verbatim}
	$start -> S $end .	
	$default	accept
\end{verbatim} 
&
\begin{verbatim}
	S -> 'a' S . 'b'	
	'b'	shift 5
\end{verbatim} 
&
\begin{verbatim}
	S -> 'a' S 'b' .	
	$default	reduce 2 (S)
\end{verbatim}
\\
\hline
\end{tabular}
\end{center}
\caption{Tablas generadas por {\tt bison}. El estado 3 resulta de transitar con \$}
\label{table:tablaslalr}
\end{table}

\begin{exercise}
Compare la tabla \ref{table:tablaslalr} resultante de 
aplicar \verb|jison| con la que obtuvo en el ejemplo
\ref{example:tablasslr}.
\end{exercise}

\section{Algoritmo de Análisis LR}
\label{section:algoritmoLR}
Asi  pues la tabla de transiciones del autómata nos genera dos tablas:
la tabla de acciones y la de saltos.
El  algoritmo  de análisis sintáctico \emph{LR} en el  que 
se basa \emph{jison} utiliza una pila y dos tablas 
para analizar la entrada. % (véase la figura \ref{fig:lrparser}). 
Como se ha visto, la tabla  de acciones contiene cuatro tipo de acciones: 
\begin{enumerate}
\item
Desplazar (\emph{shift})
\item
Reducir (\emph{reduce})
\item
Aceptar
\item
Error
\end{enumerate}
El algoritmo utiliza una pila en la que se guardan los estados
del autómata. De este modo se evita tener que ``comenzar'' 
el procesado de la forma sentencial derecha resultante
después de una reducción (antiderivación).
\begin{algorithm}
\label{alg:parser}       
Análizador LR
\begin{verbatim}
push(s0);
 b = yylex();
 for( ; ; ;) {
   s = top(0); a = b;
   switch (action[s][a]) {
     case "shift t" : 
       push(t); 
       b = yylex();
       break;
     case "reduce A ->alpha" : 
       eval(Sub{A -> alpha}->(top(|alpha|-1).attr, ... , top(0).attr)); 
       pop(|alpha|); 
       push(goto[top(0)][A]); 
       break;
     case "accept" : return (1); 
     default : yyerror("syntax error");
   }
 }
\end{verbatim}
\end{algorithm}
Como es habitual, $|x|$ denota la longitud de la cadena $x$.
La función \verb|top(k)| devuelve el elemento que ocupa la 
posición \verb|k| desde el \emph{top} de la pila (esto es, está a profundidad \verb|k|).
La función \verb|pop(k)| extrae \verb|k| elementos de la pila.
La notación \verb|state.attr| hace referencia al atributo
asociado con cada estado. Denotamos por \verb|sub_{reduce A -> alpha}|
el código de la acción asociada con la regla $A \rightarrow \alpha$.
%\begin{figure}
%\input{parser_fig.tex}
%\caption{Estructura de un Análizador LR}
%\label{fig:lrparser}       
%\end{figure}

Todos los analizadores LR comparten, salvo pequeñas
exepciones, el mismo algoritmo
de análisis. Lo que más los diferencia es la forma en 
la que construyen las tablas.
En \verb|jison|
la construcción de las tablas de \emph{acciones} y \emph{gotos}
se realiza mediante el algoritmo \emph{LALR}.

\sectionpractica{Traducción de Infijo a Postfijo}
\label{section:calculadoraampliada}
Modifique el programa Jison realizado en la práctica 
\ref{subsectionpractica:calculadora}
para traducir de infijo a postfijo. 
Añada los operadores de comparación e igualdad.
Por ejemplo

\begin{center}
\begin{tabular}{p{6cm}|p{6cm}}
Infijo              & Postfijo \\
\verb|a = 3+2*4|    &  \verb| 3 2 4 * + &a = |\\
\verb|b = a == 11|  &  \verb| a 11 == &b = |
\end{tabular}
\end{center}
En estas traducciones la notación 
\verb|&a| indica la dirección de la variable \verb|a|
y \verb|a| indica el valor almacenado en la variable \verb|a|.

Añada sentencias 
\verb|if| ...
\verb|then| e \verb|if| ... \verb|then| ... \verb|else|

Para realizar la traducción de estas sentencias
añada 
instrucciones \verb|jmp label| y \verb|jmpz label| (por {\it jump if zero})
y etiquetas:

\begin{center}
\begin{tabular}{p{8cm}|p{6cm}}
Infijo              & Postfijo \\
\begin{verbatim}
a = (2+5)*3;
if a == 0 then b = 5 else b = 3;
c = b + 1;
\end{verbatim}
&
\begin{verbatim}
        2
        5
        +
        3
        *
        &a
        =
        a
        0
        ==
        jmpz else1
        5
        &b
        =
        jmp endif0
:else1
        3
        &b
        =
:endif0
        b
        1
        +
        &c
        =
\end{verbatim}
\end{tabular}
\end{center}
Introduzca pruebas unitarias como las descritas en 
la sección \ref{section:tstingfacil} ({\it
\htmladdnormallink{Quick Tip: Quick and Easy JavaScript Testing with “Assert”}{http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/}})

\begin{verbatim}
[~/srcPLgrado/jisoninfix2postfix(master)]$ cat test/test.html 
<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Testing Our Simple Translator</title>
    <link rel="stylesheet" href="test.css" />
    <script type="text/javascript" src="../calculator.js"></script>

  </head>
  <body>
    <h1>Testing Our Simple Translator
    </h1>
    
    <ul id="output"></ul>
    <script type="text/javascript" src="assert.js"></script>
    
    <script type="text/javascript">

      var r = calculator.parse("a = 4*8");
      assert( /4\s*8\s*[*]\s*a\s*=\s*/.exec(r), "a is 4*8");
      
      r = calculator.parse("a=4;b=a+1");
      r = r.replace(/\s+/g,'');
      var expected = "4a=a1+b=";
      assert( r == expected, "a = 4;\nb=a+1 translated");


      var r = calculator.parse("if a > 0 then b = 1 else b = 2");
      r = r.replace(/\s+/g,'');
      expected = "a 0 > jmpz else1 1 b = jmp endif0 :else1 2 b = :endif0".
                 replace(/\s+/g,'');
      assert( r == expected, "'if a > 0 then b = 1 else b = 2' translated");
    </script>
      See the NetTuts+ tutorial at <a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-quick-and-easy-javascript-testing-with-assert/">Quick and Easy JavaScript Testing</a>
  </body>
</html>
\end{verbatim}

\section{El módulo Generado por {\tt jison}}
\label{section:tablas}

%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_bottomup/aSb.tex
\subsection{Version}

En esta sección estudiamos el analizador generado por Jison:
\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ jison --version
0.4.2
\end{verbatim}

\subsection{Gramática Inicial}
Veamos el módulo generado por jison para esta gramática:
\begin{verbatim}
[~/srcPLgrado/aSb(develop)]$ cat aSb.jison 
%lex
%%
.               { return yytext; }
/lex
%%
S: /* empty */  { console.log("empty"); }
   | 'a' S 'b'  { console.log("S -> aSb"); }
;
%%
\end{verbatim}

% edit chapter_bottomup/aSb.tex
\subsection{Tablas}
Esta es la primera parte del parser generado:
\begin{verbatim}
/* parser generated by jison 0.4.2 */
var aSb = (function() {
    var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
            "$accept": 0, /* super-arranque $accept -> S */
            "$end": 1     /* end of input */
            "error": 2, /* numero para el símbolo 'error' */
            "S": 3,     /* numero para el símbolo 'S' */
            "a": 4,
            "b": 5,
        },
        /* array inverso de terminales */
        terminals_: {   /* numero -> terminal */
            2: "error", 
            4: "a",
            5: "b"
        },
        productions_: 
        [0, 
/* 1 */     [3, 0], /* S : vacio        simbolo,longitud de la parte derecha */
/* 2 */     [3, 3]  /* S : a S b        simbolo,longitud */
        ],
\end{verbatim}

\begin{center}
\begin{latexonly}
\begin{figure}[htb]
%\centerline{\includegraphics[scale=1.2]{chapter_bottomup/dfa.png}}
\centerline{\epsfig{file=chapter_bottomup/aSb.eps, width=12cm}}
\caption{DFA construido por Jison}
\label{fig:dfa}
\end{figure}
\end{latexonly}
\begin{rawhtml}
<img src="aSb.png" width="50%"/>
<p>

DFA construido por Jison
\end{rawhtml}
\end{center}

\subsection{Acciones Semánticas}
Cada vez que se produce una acción de reducción esta función es llamada:
\begin{verbatim}
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

    var $0 = $$.length - 1;
    switch (yystate) { /* yystate: numero de regla de producción */
        case 1:
            console.log("empty");
            break;
        case 2:
            console.log("S -> aSb");
            break;
    }
},
\end{verbatim}
\begin{itemize}
\item
Parece que  cuando se llama a este método \verb|this| refiere a un objeto \verb|yyval|. Este es el
punto  de llamada a la acción semántica dentro del parser generado por Jison.
Puede encontrarse dentro del parser en el caso de un \verb|switch| 
que corresponde a la acción de reducción:
\begin{verbatim}
r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
\end{verbatim}
El método \verb|call|
nos permite invocar una función como si fuera un método de algún otro 
objeto. Véase la sección 
\ref{subsection:callyapply}.

Este objeto \verb|yyval| tiene dos atributos: \verb|$| y \verb|_$|.
  \begin{itemize}
  \item
  El atributo 
  \verb|$| se corresponde con \verb|$$| de la gramática (atributo de la variable
  sintactica en la parte izquierda)
  \item
  El atributo \verb|_$| guarda información
  sobre la posición del último token leído.
  \end{itemize}
\item
\verb|yytext| parece contener el texto asociado con el token actual
\item
\verb|yyleng| es la longitud del token actual
\item
\verb|yylineno| es la línea actual (empezando en 0)
\item
\verb|yy| es un objeto con dos atributos \verb|lexer| y \verb|parser| 
\item
\verb|yystate| es el estado actual 
\item
\verb|$$| parece ser un array/pila conteniendo 
los valores de los atributos asociados con los estados de la pila (\verb|vstack| ¿Por value stack?)
\item
Asi pues \verb|$0| es el índice en \verb|$0| del último elemento de \verb|$$|.
Por ejemplo, una acción semántica como:
\begin{verbatim}
$$ = $1 + $2 + $3;
\end{verbatim}
Se traduce por:
\begin{verbatim}
this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
\end{verbatim}
\item
\verb|_$|
Es un array con la información sobre la localización de los simbolos (\verb|lstack| ¿Por location stack?)
\end{itemize}

\subsection{Tabla de Acciones y GOTOs}

\begin{verbatim}
        table: [{
/* 0 */     1: [2, 1],    /* En estado 0 viendo $end(1) reducir por S : vacio */
            3: 1,         /* En el estado 0 viendo S(3) ir al estado 1 */
            4: [1, 2]     /* Estado 0 viendo a(4) shift(1) al estado 2 */
        }, {
/* 1 */     1: [3]        /* En 1 viendo $end(1) aceptar */
        }, {
/* 2 */     3: 3,         /* En 2 viendo S ir a 3 */
            4: [1, 2],    /* En 2 viendo a(4) shift a 2 */
            5: [2, 1]     /* En 2 viendo b(5) reducir por regla 1: S -> vacio */
        }, {
/* 3 */     5: [1, 4]     /* En 3 viendo b(5) shift a 4 */
        }, {
/* 4 */     1: [2, 2],    /* En 4  viendo $end(1) reducir(2) por la 2: S -> aSb */
            5: [2, 2]     /* En 4 viendo b(5) reducir por la 2: S-> aSb */
        }],
\end{verbatim}

\begin{itemize}
\item
La tabla es un array de objetos
\item
El índice de la tabla es el estado. En el ejemplo tenemos 5 estados
\item
El objeto/hash que es el valor contiene las acciones ante los símbolos.
\begin{enumerate}
\item
Los atributos/claves son los símbolos, los valores las acciones
\item
Las acciones son de dos tipos:
\begin{enumerate}
\item
El número del estado al que se transita mediante la tabla \verb|goto|
cuando el símbolo es una variable sintactica 
\item
Un par \verb|[tipo de acción, estado o regla]|. 
Si el \verb|tipo de acción| es 1 indica un shift al \verb|estado| con ese número.
Si el \verb|tipo de acción| es 2 indica una reducción por la \verb|regla| con ese número.
\end{enumerate}
\item
Por ejemplo \verb|table[0]| es 
\begin{verbatim}
        {
            1: [2, 1],    /* En estado 0 viendo $end(1) reducir(2) por S : vacio */
            3: 1,         /* En el estado 0 viendo S(3) ir (goto) al estado 1 */
            4: [1, 2]     /* Estado 0 viendo a(4) shift(1) al estado 2 */
        } 
\end{verbatim}
\end{enumerate}


\end{itemize}

\subsection{defaultActions}
\begin{verbatim}
        defaultActions: {},
\end{verbatim}


\begin{itemize}
\item
\verb|defaultActions| contiene las acciones por defecto.

\item
Después de la construcción de la tabla, Jison identifica para
cada estado la reducción que tiene el conjunto 
de lookaheads mas grande. Para reducir el tamaño del parser,
Jison puede decidir suprimir dicho conjunto y asiganr esa reducción como 
acción del parser por defecto. Tal reducción se conoce como
\cei{reducción por defecto}.
\item Esto puede verse en este segmento del código del parser:
\begin{verbatim}
    while (true) {
          state = stack[stack.length - 1]; 
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
              }   
              action = table[state] && table[state][symbol];
          }   
          ...
    }
\end{verbatim}
\end{itemize}

\subsection{Reducciones}
\begin{verbatim}
parse: function parse(input) {
    ...
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == "undefined") {
                symbol = lex(); /* obtener siguiente token */
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          ... // error
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: ..." 
        }
        switch (action[0]) {
            case 1:                                    // shift
                ...
                break;
            case 2:                                    // reduce
                len = this.productions_[action[1]][1]; // longitud de la producción
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {                           // datos de la posición
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                };
                ...
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                if (typeof r !== "undefined") {
                    return r; /* un return de algo distinto de undefined nos saca del parser */
                }
                if (len) {                                  /* retirar de las pilas */
                    stack = stack.slice(0, - 1 * len * 2);  /* simbolo, estado, simbolo, estado ... */
                    vstack = vstack.slice(0, - 1 * len);    /* retirar atributos */
                    lstack = lstack.slice(0, - 1 * len);    /* retirar localizaciones */
                }
                stack.push(this.productions_[action[1]][0]); /* empujemos el símbolo */
                vstack.push(yyval.$);                        /* empujemos valor semantico */
                lstack.push(yyval._$);                       /* empujemos localización */
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);                        /* empujemos goto[top][A]*/
                break;
            case 3: // accept
                return true;
        }
    }
    return true;
}
\end{verbatim}

\subsection{Desplazamientos/Shifts}

\begin{verbatim}
parse: function parse(input) {
    ...
    while (true) {
        state = stack[stack.length - 1];     /* estado en el top de la pila */
        if (this.defaultActions[state]) {    /* definida la acción por defecto? */
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();              /* obtener token */
            }
            action = table[state] && table[state][symbol]; /* obtener la acción para el estado actual */
        }
        if (typeof action === "undefined" || !action.length || !action[0]) { 
            ... /* error */
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
            case 1:
                stack.push(symbol);                /* empujamos token */
                vstack.push(this.lexer.yytext);    /* empujamos el atributo del token */
                lstack.push(this.lexer.yylloc);    /* salvamos la localización del token */
                stack.push(action[1]);             /* salvamos el estado */
                symbol = null;
                if (!preErrorSymbol) {             /* si no hay errores ... */
                    yyleng = this.lexer.yyleng;    /* actualizamos los atributos */
                    yytext = this.lexer.yytext;    /* del objeto */
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0) recovering--; /* las cosas van mejor si hubieron errores */
                } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;
            case 2:
                ...
                break;
            case 3:
                return true;
        }
    }
    return true;
}
\end{verbatim}

\subsection{Manejo de Errores}

\begin{verbatim}
while (true) {
    state = stack[stack.length - 1];
    if (this.defaultActions[state]) { action = this.defaultActions[state]; } 
    else {
        if (symbol === null || typeof symbol == "undefined") { symbol = lex(); }
        action = table[state] && table[state][symbol];
    }
    if (typeof action === "undefined" || !action.length || !action[0]) {
        var errStr = "";
        if (!recovering) { /* recovering = en estado de recuperación de un error */
            expected = [];                       /* computemos los tokens esperados */
            for (p in table[state])              /* si el estado "state" transita con p */
              if (this.terminals_[p] && p > 2) { /* y "p" es un terminal no especial */
                  expected.push("'" + this.terminals_[p] + "'"); /* entonces es esperado */
              }
            if (this.lexer.showPosition) { /* si esta definida la función showPosition */
                errStr = "Parse error on line " + (yylineno + 1) + 
                         ":\n" + this.lexer.showPosition() + 
                         "\nExpecting " + expected.join(", ") + 
                         ", got '" + 
                         (this.terminals_[symbol] || symbol) + /* terminals_ es el array inverso */
                         "'";                                  /* numero -> terminal             */
            } else { /* ¡monta la cadena como puedas! */
                errStr = "Parse error on line " + (yylineno + 1) + 
                         ": Unexpected " + 
                         (symbol == 1 ? "end of input" : "'" + 
                         (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {    /* genera la excepción */
                text: this.lexer.match,  /* hash/objeto conteniendo los detalles del */
                token: this.terminals_[symbol] || symbol,                   /* error */
                line: this.lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
    }
    if (action[0] instanceof Array && action.length > 1) {
        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
    }
    ...
}
\end{verbatim}

La función \verb|parseError| genera una excepción:

\begin{verbatim}
        parseError: function parseError(str, hash) {
            throw new Error(str); /* El hash contiene info sobre el error: token, linea, etc. */
        },
\end{verbatim}

\begin{itemize}
\item
\verb|parseError| es llamada cada vez que ocurre un error sintáctico.
\verb|str| contiene la cadena con el mensaje de error del tipo: 
\verb|Expecting something, got other thing'|.
\verb|hash| contiene atributos como \verb|expected|: el array de tokens esperados; 
\verb|line| la línea implicada, \verb|loc| una descripción de la localización detallada del punto/terminal
en el que ocurre el error; etc.
\end{itemize}


\subsection{Analizador Léxico}
El analizador léxico:
\begin{verbatim}
/* generated by jison-lex 0.1.0 */
var lexer = (function() {
    var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) { /* manejo de errores léxicos */ },
        setInput: function(input) { /* inicializar la entrada para el analizadorléxico */},
        input: function() { /* ... */ },
        unput: function(ch) { /* devolver al flujo de entrada */ },
        more: function() { /* ... */ },
        less: function(n) { /* ... */ },
        pastInput: function() { /* ... */ },
        upcomingInput: function() { /* ... */ },
        showPosition: function() { /* ... */ },
        next: function() {
                if (this.done) { return this.EOF; }
                if (!this._input) this.done = true;

                var token, match, tempMatch, index, col, lines;
                if (!this._more) { this.yytext = ''; this.match = ''; }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: 
                          lines ? lines[lines.length - 1].length - 
                                  lines[lines.length - 1].match(/\r?\n?/)[0].length 
                                  : 
                                  this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(
                                 this, 
                                 this.yy, 
                                 this, 
                                 rules[index], 
                                 this.conditionStack[this.conditionStack.length - 1]
                            );
                    if (this.done && this._input) this.done = false;
                    if (token) return token;
                    else return;
                }
                if (this._input === "") { return this.EOF; } 
                else {
                    return this.parseError(
                             'Lexical error on line ' + (this.yylineno + 1) + 
                              '. Unrecognized text.\n' + this.showPosition(), 
                              { text: "", token: null, line: this.yylineno }
                           );
                }
            },
        lex: function lex() {
            var r = this.next();
            if (typeof r !== 'undefined') {
                return r;
            } else {
                return this.lex();
            }
        },
        begin: function begin(condition) { },
        popState: function popState() { },
        _currentRules: function _currentRules() { },
        topState: function() { },
        pushState: function begin(condition) { },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START)
        {
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
                case 0:
                    return yy_.yytext;
                    break;
            }
        },
        rules: [/^(?:.)/], /* lista de expresiones regulares */
        conditions: { /* ... */ }
  }
};
\end{verbatim}

\subsection{Exportación}

Si no ha sido exportado ya ...
\begin{verbatim}
if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.parser = aSb;         /* hacemos accesible el objeto aSb  */
    exports.Parser = aSb.Parser;
\end{verbatim}
El objeto \verb|aSb.Parser| representa al parser. Este es el código que lo crea.
\begin{verbatim}
      function Parser() {
          this.yy = {}; 
      }   
      Parser.prototype = parser;
      parser.Parser = Parser;
      return new Parser;
  })();
\end{verbatim}
También se exporta una función \verb|parse|:
\begin{verbatim}
    exports.parse = function() {
        return aSb.parse.apply(aSb, arguments);
    };
\end{verbatim}
y una función \verb|main|:
\begin{verbatim}
    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log('Usage: ' + args[0] + ' FILE');
            process.exit(1);
        }
        var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
        return exports.parser.parse(source);
    };
    if (typeof module !== 'undefined' && require.main === module) {
        exports.main(process.argv.slice(1));
    }
}
\end{verbatim}
Esto permite ejecutar el módulo directamente:
\begin{verbatim}
[~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ node aSb.js input.ab 
empty
S -> aSb
S -> aSb
[~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ cat input.ab 
aabb
\end{verbatim}

\begin{verbatim}
~/Dropbox/src/javascript/PLgrado/jison-aSb(develop)]$ node debug aSb.js input.ab 
< debugger listening on port 5858
connecting... ok
break in aSb.js:2
  1 /* parser generated by jison 0.4.2 */
  2 var aSb = (function() {
  3     var parser = {
  4         trace: function trace() {},
debug> n
break in aSb.js:390
 388     return new Parser;
 389 })();
 390 if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
 391     exports.parser = aSb;
 392     exports.Parser = aSb.Parser;
\end{verbatim}

\begin{verbatim}
debug> repl
Press Ctrl + C to leave debug repl
> 
> typeof require
'function'
> typeof exports
'object'
> aSb
{ yy: {} }
> aSb.Parser
[Function]
^C
debug> sb(396)
 395     };
debug> c
break in aSb.js:396
 394         return aSb.parse.apply(aSb, arguments);
 395     };
*396     exports.main = function commonjsMain(args) {
 397         if (!args[1]) {
 398             console.log('Usage: ' + args[0] + ' FILE');
debug> n
break in aSb.js:404
 402         return exports.parser.parse(source);
 403     };
 404     if (typeof module !== 'undefined' && require.main === module) {
 405         exports.main(process.argv.slice(1));
 406     }
debug> repl
Press Ctrl + C to leave debug repl
> process.argv.slice(1)
[ '/Users/casiano/Dropbox/src/javascript/PLgrado/jison-aSb/aSb.js',
  'input.ab' ]
> typeof module
'object'
> require.main
{ id: '.',
  exports: 
   { parser: { yy: {} },
     Parser: [Function],
     parse: [Function],
     main: [Function] },
  parent: null,
  filename: '/Users/casiano/Dropbox/src/javascript/PLgrado/jison-aSb/aSb.js',
  loaded: false,
  children: [],
  paths: 
   [ '/Users/casiano/Dropbox/src/javascript/PLgrado/jison-aSb/node_modules',
     '/Users/casiano/Dropbox/src/javascript/PLgrado/node_modules',
     '/Users/casiano/Dropbox/src/javascript/node_modules',
     '/Users/casiano/Dropbox/src/node_modules',
     '/Users/casiano/Dropbox/node_modules',
     '/Users/casiano/node_modules',
     '/Users/node_modules',
     '/node_modules' ] }
^C
debug> n
break in aSb.js:405
 403     };
 404     if (typeof module !== 'undefined' && require.main === module) {
 405         exports.main(process.argv.slice(1));
 406     }
 407 }
debug> n
< empty
< S -> aSb
< S -> aSb
break in aSb.js:409
 407 }
 408 
 409 });
debug> c
program terminated
debug> 
\end{verbatim}
%%% TEXEXPAND: END FILE ./chapter_bottomup/aSb.tex

\section{Precedencia y Asociatividad}
\label{section:prioridades}
Recordemos que si al construir la tabla LALR,
alguna de las entradas de la tabla resulta multievaluada, decimos
que existe un conflicto.
Si una de las acciones es de `reducción'' y la otra es de
`desplazamiento'', se dice que hay un \cei{conflicto shift-reduce} o
\cei{conflicto de desplazamiento-reducción}. Si las
dos reglas indican una acción de reducción, decimos que tenemos un 
\cei{conflicto reduce-reduce} o de \cei{reducción-reducción}.
En caso de que no existan indicaciones específicas \emph{jison} resuelve
los conflictos que aparecen en la construcción de la tabla utilizando
las siguientes reglas:

\begin{enumerate}
\item
Un conflicto \emph{reduce-reduce} se resuelve eligiendo la producción
que se listó primero en la especificación de la gramática.
\item
Un conflicto \emph{shift-reduce} se resuelve siempre en favor del \emph{shift}
\end{enumerate}

Las declaraciones de precedencia y asociatividad mediante las
palabras reservadas \tei{\%left}, \tei{\%right}, \tei{\%nonassoc}
se utilizan para modificar estos criterios por defecto. 
La declaración de \tei{token}s mediante la palabra
reservada \tei{\%token} no modifica la precedencia. Si lo hacen las
declaraciones realizadas usando las palabras \tei{left}, \tei{right}
y \tei{nonassoc}. 

\begin{enumerate}
\item
Los \emph{tokens} declarados  en la misma línea
tienen igual precedencia e igual asociatividad. 
La precedencia es mayor cuanto mas abajo 
su posición en
el texto. Así, en el ejemplo de la calculadora en la sección 
\ref{section:ejemplodeuso}, el \emph{token} \verb1*1 tiene 
mayor precedencia que \verb1+1 pero la misma que \verb1/1.
\item
La precedencia de una regla $A \rightarrow \alpha$ se
define como la del terminal mas a la derecha que aparece en
$\alpha$. En el ejemplo, la producción 

\begin{center}
\verb1 expr : expr '+' expr1 
\end{center}

tiene la precedencia del \emph{token} \verb1+1.
\item
Para decidir en un conflicto \emph{shift-reduce} se comparan la precedencia 
de la regla con la del terminal que va a ser desplazado. Si la de la
regla es mayor se reduce
si la del \emph{token} es mayor, se desplaza.
\item
Si en un conflicto \emph{shift-reduce} ambos la regla y el terminal que
va a ser desplazado tiene la misma precedencia \emph{jison} considera la
asociatividad, si es asociativa a izquierdas, reduce y si es asociativa
a derechas desplaza. Si no es asociativa, genera un mensaje de error.\\
Obsérvese que, en esta situación, la asociatividad de la regla y la del
\emph{token} han de ser por fuerza, las mismas.  Ello es así, porque en
\emph{jison} los \emph{tokens} con la misma precedencia se declaran en
la misma línea y sólo se permite una declaración por línea.

\item
\emph{ Por tanto es imposible declarar dos \emph{tokens} con diferente
asociatividad y la misma precedencia}.
\item
Es posible modificar la precedencia ``natural'' de una regla, calificándola
con un \emph{token} específico.  para ello se escribe a la derecha de
la regla \verb|prec token|, donde \verb|token| es un \emph{token} con
la precedencia que deseamos. Vea el uso del \emph{token} \verb|dummy|
en el siguiente ejercicio.
\end{enumerate}


Para ilustrar las reglas anteriores usaremos el siguiente 
programa \verb|jison|:

\begin{verbatim}
$ cat -n Precedencia.yp
     1  %token NUMBER
     2  %left '@'
     3  %right '&'  dummy
     4  %%
     5  list
     6      :
     7      | list '\n'
     8      | list e
     9      ;
    10
    11  e : NUMBER
    12    | e '&' e
    13    | e '@' e %prec dummy
    14    ;
    15
    16  %%
\end{verbatim}            

El código del programa cliente es el siguiente:

\begin{verbatim}
$ cat -n useprecedencia.pl
cat -n useprecedencia.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Precedencia;
     4
     5  sub Error {
     6    exists $_[0]->YYData->{ERRMSG}
     7    and do {
     8      print $_[0]->YYData->{ERRMSG};
     9      delete $_[0]->YYData->{ERRMSG};
    10      return;
    11    };
    12    print "Syntax error.\n";
    13  }
    14
    15  sub Lexer {
    16    my($parser)=shift;
    17
    18    defined($parser->YYData->{INPUT})
    19    or  $parser->YYData->{INPUT} = <STDIN>
    20    or  return('',undef);
    21
    22    $parser->YYData->{INPUT}=~s/^[ \t]//;
    23
    24    for ($parser->YYData->{INPUT}) {
    25        s/^([0-9]+(?:\.[0-9]+)?)//
    26                and return('NUMBER',$1);
    27        s/^(.)//s
    28                and return($1,$1);
    29    }
    30  }
    31
    32  my $debug_level = (@ARGV)? oct(shift @ARGV): 0x1F;
    33  my $parser = Precedencia->new();
    34  $parser->YYParse( yylex => \&Lexer, yyerror => \&Error, yydebug => $debug_level );
\end{verbatim}

Observe la llamada al analizador en la línea 34. Hemos 
añadido el parámetro con nombre \cei{yydebug} 
con argumento \verb|yydebug => $debug_level| (véase la
sección \ref{section:depuracion} para ver los posibles
valores de depuración).

Compilamos a continuación el módulo usando la opción \verb|-v| para
producir información sobre los conflictos y las tablas de salto y 
de acciones:
\begin{verbatim}
yapp -v -m Precedencia Precedencia.yp
$ ls -ltr |tail -2
-rw-r--r--  1 lhp lhp   1628 2004-12-07 13:21 Precedencia.pm
-rw-r--r--  1 lhp lhp   1785 2004-12-07 13:21 Precedencia.output
\end{verbatim}

La opción \verb|-v| genera el fichero \verb|Precedencia.output|
el cual contiene información detallada sobre el autómata:

\begin{verbatim}
$ cat -n Precedencia.output
     1  Conflicts:
     2  ----------
     3  Conflict in state 8 between rule 6 and token '@' resolved as reduce.
     4  Conflict in state 8 between rule 6 and token '&' resolved as shift.
     5  Conflict in state 9 between rule 5 and token '@' resolved as reduce.
     6  Conflict in state 9 between rule 5 and token '&' resolved as shift.
     7
     8  Rules:
     9  ------
    10  0:      $start -> list $end
    11  1:      list -> /* empty */
    12  2:      list -> list '\n'
    13  3:      list -> list e
    14  4:      e -> NUMBER
    15  5:      e -> e '&' e
    16  6:      e -> e '@' e
    17  ...
\end{verbatim}
¿Porqué se produce un conflicto en el estado 8 entre la regla
6 (\verb|e -> e '@' e|) y el terminal \verb|'@'|?. Editando el fichero
\verb|Precedencia.output| podemos ver los contenidos
del estado 8:
\begin{verbatim}
85  State 8:
86
87          e -> e . '&' e  (Rule 5)
88          e -> e . '@' e  (Rule 6)
89          e -> e '@' e .  (Rule 6)
90
91          '&'     shift, and go to state 7
92
93          $default        reduce using rule 6 (e)
\end{verbatim}
El item de la línea 88 indica que debemos desplazar, el de 
la línea 89 que debemos reducir por la regla 6. ¿Porqué \verb|jison|
resuelve el conflicto optando por reducir?
¿Que prioridad tiene la regla 6?
¿Que asociatividad tiene la regla 6?
La declaración en la línea 13 modifica la precedencia y asociatividad
de la regla:

\begin{verbatim}
    13    | e '@' e %prec dummy
\end{verbatim}

de manera que la regla pasa a tener la precedencia y asociatividad
de \verb|dummy|. Recuerde que habíamos declarado \verb|dummy| como
asociativo a derechas:
\begin{verbatim}
     2  %left '@'
     3  %right '&'  dummy
\end{verbatim}
¿Que ocurre? Que \verb|dummy| tiene mayor prioridad
que \verb|'@'| y por tanto la regla tiene mayor prioridad
que el terminal: por tanto se reduce.

¿Que ocurre cuando el terminal en conflicto es \verb|'&'|?
En ese caso la regla y el terminal tienen la misma prioridad.
Se hace uso de la asociatividad a derechas que indica que el conflicto
debe resolverse desplazando.

\begin{exercise}
Explique la forma en que \verb|jison| resuelve 
los conflictos que aparecen en el estado 9.
Esta es la información sobre el estado 9:

\begin{verbatim}
State 9:

	e -> e . '&' e	(Rule 5)
	e -> e '&' e .	(Rule 5)
	e -> e . '@' e	(Rule 6)
	'&'	shift, and go to state 7
	$default	reduce using rule 5 (e)
\end{verbatim}
\end{exercise}

Veamos un ejemplo de ejecución:

\begin{verbatim}
$ ./useprecedencia.pl
----------------------------------------
In state 0:
Stack:[0]
Don't need token.
Reduce using rule 1 (list,0): Back to state 0, then go to state 1.
\end{verbatim}
Lo primero que ocurre es una reducción por la regla 
en la que \verb|list| produce vacío. Si miramos el estado 0
del autómata vemos que contiene:
\begin{verbatim}
20 State 0:
21
22   $start -> . list $end (Rule 0)
23
24   $default  reduce using rule 1 (list)
25
26   list  go to state 1
\end{verbatim}
A continuación se transita desde 0 con \verb|list|
y se consume el primer terminal:
\begin{verbatim}
----------------------------------------
In state 1:
Stack:[0,1]
2@3@4
Need token. Got >NUMBER<
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 1, then go to state 2.
----------------------------------------
\end{verbatim}
En el estado 5 se reduce por la regla \verb|e -> NUMBER|.
Esto hace que se retire el estado 5 de la pila y se
transite desde el estado 1 viendo el símbolo \verb|e|:
\begin{verbatim}
In state 2:
Stack:[0,1,2]
Need token. Got >@<
Shift and go to state 6.
----------------------------------------
In state 6:
Stack:[0,1,2,6]
Need token. Got >NUMBER<
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,2,6,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 6, then go to state 8.
----------------------------------------
In state 8:
Stack:[0,1,2,6,8]
Need token. Got >@<
Reduce using rule 6 (e,3): Back to state 1, then go to state 2.
----------------------------------------
...
Accept.
\end{verbatim}
Obsérvese la resolución del conflicto en el estado 8

La presencia de conflictos, aunque no siempre, en muchos casos es debida
a la introducción de ambiguedad en la gramática. Si el conflicto 
es de desplazamiento-reducción se puede resolver explicitando 
alguna regla que rompa la ambiguedad. Los conflictos de
reducción-reducción suelen producirse por un diseño erróneo
de la gramática. En tales casos, suele ser mas adecuado
modificar la gramática.

\section{Depuración en {\tt jison}}
\label{section:depuracion}

\section{Construcción del Árbol Sintáctico}
El siguiente ejemplo usa \verb|jison| 
para construir el árbol sintáctico de una expresión en infijo:

\section{Esquemas de Traducción}
Un \cei{esquema de traducción} es una gramática independiente del
contexto en la cuál se han asociado atributos a los símbolos de la gramática.
Un atributo queda caracterizado por un identificador
o nombre y un tipo o clase. Además se han insertado acciones, esto es,
código Perl/Python/C, \ldots en medio de las partes derechas.
En ese código es posible referenciar los atributos de los
símbolos de la gramática como variables del lenguaje subyacente.

Recuerde que el orden en que se evalúan los fragmentos de código
es el de un recorrido primero-profundo del árbol de análisis sintáctico.
Mas específicamente, considerando a las acciones como hijos-hoja del nodo,
el recorrido que realiza un esquema de traducción es:


\section{Definición Dirigida por la Sintáxis}
Una \cei{definición dirigida por la sintáxis} es un pariente cercano
de los esquemas de traducción. En una definición dirigida por la
sintáxis una gramática $G = (V, \Sigma, P, S)$ se aumenta 
con nuevas características:
\begin{itemize}
\item
A cada símbolo $S \in V \cup \Sigma$ de la gramática se le asocian
cero o mas atributos. Un atributo queda caracterizado por un identificador
o nombre y un tipo o clase. A este nivel son \cei{atributos formales},
como los parámetros formales, en el sentido de que su realización 
se produce cuando el nodo del árbol es creado.
\item
A cada regla de producción $A \rightarrow X_1 X_2 \ldots X_n \in P$
se le asocian un conjunto de \cei{reglas de evaluación de los atributos}
o \cei{reglas semánticas} que indican que el atributo en la parte
izquierda de la regla semántica depende de los atributos que aparecen en la parte
derecha de la regla. El atributo que aparece en la parte izquierda de la regla semántica
puede estar asociado con un símbolo en la parte derecha de la regla de producción.
\item
Los atributos de cada símbolo de la gramática $X \in V \cup \Sigma$
se dividen en dos grupos disjuntos: \cei{atributos sintetizados}
y \cei{atributos heredados}. Un atributo de $X$ es un \cei{atributo heredado} 
si depende de atributos de su padre y hermános en el árbol.
Un \cei{atributo sintetizado} es aquél tal que el valor del atributo depende
de los valores de los atributos de los hijos, 
es decir en tal caso $X$ ha de ser una variable sintáctica
y los atributos en la parte derecha de la regla semántica deben
ser atributos de símbolos en la parte derecha de la regla de producción 
asociada.
\item
Los atributos predefinidos se denominán \cei{atributos intrínsecos}.
Ejemplos de atributos intrínsecos son los atributos 
sintetizados de los terminales, los cuáles se han
computado durante la fase de análisis léxico. También
son atributos intrínsecos los atributos heredados del símbolo
de arranque, los cuales son pasados como parámetros 
al comienzo de la computación.
\end{itemize}

La diferencia principal con un esquema de traducción está en que
no se especifica el orden de ejecución de las reglas semánticas.
Se asume que, bien de forma manual o automática, se resolverán
las dependencias existentes entre los atributos determinadas
por la aplicación de las reglas semánticas, de manera
que serán evaluados primero aquellos atributos que no dependen
de ningún otro, despues los que dependen de estos, etc. siguiendo
un esquema de ejecución que viene guiado por las dependencias
existentes entre los datos.

Aunque hay muchas formas de realizar un evaluador de una definición
dirigida por la sintáxis, conceptualmente, tal evaluador debe:

\begin{enumerate}
\item
Construir el árbol de análisis sintáctico para la gramática
y la entrada dadas.
\item
Analizar las reglas semánticas para determinar los atributos,
su clase y las dependencias entre los mismos.
\item
Construir el \cei{grafo de dependencias} de los atributos,
el cual tiene
un nodo para cada ocurrencia de un atributo en el árbol de análisis
sintáctico etiquetado con dicho atributo. El grafo tiene una arista entre dos
nodos si existe una dependencia entre los dos atributos a través de alguna
regla semántica. 
\item
Supuesto que el grafo de dependencias determina un \cei{orden parcial}
(esto es cumple las propiedades reflexiva, antisimétrica y transitiva) 
construir un \cei{orden topológico} compatible con el orden parcial.
\item
Evaluar las reglas semánticas de acuerdo con el orden topológico.
\end{enumerate}

Una definición dirigida por la sintáxis en la que las reglas semánticas
no tienen efectos laterales se denomina una \cei{gramática atribuída}.

Si la definición dirigida por la sintáxis puede ser realizada 
mediante un esquema de traducción se dice que es \cei{L-atribuída}.
Para que una definición dirigida por la sintáxis sea L-atribuída
deben cumplirse que cualquiera que sea la regla de producción
$A \rightarrow X_1 \ldots X_n$, los atributos heredados de
$X_j$ pueden depender únicamente de:
\begin{enumerate}
\item
Los atributos de los símbolos a la izquierda de $X_j$
\item
Los atributos heredados de $A$
\end{enumerate}

Nótese que las restricciones se refieren a los atributos heredados.
El cálculo de los atributos sintetizados no supone 
problema para un esquema de traducción. Si la gramática
es LL(1), resulta fácil realizar una definición 
L-atribuída en un analizador descendente recursivo predictivo.

Si la definición dirigida por la sintáxis sólo utiliza 
atributos sintetizados se denomina \cei{S-atribuída}. Una
definición S-atribuída puede ser fácilmente trasladada a un programa
\verb|jison|.

\section{Manejo en {\tt jison} de Atributos Heredados}
\label{section:heredados}
Jison no soporta acciones en medio de una regla.


\section{Acciones en Medio de una Regla y Atributos Heredados}
\label{section:mediaregla}
Jison no soporta acciones en medio de una regla.

\section{Recuperación de Errores}
\label{section:errores}
Jison no soporta recuperación de errores.

\section{Consejos a seguir al escribir un programa {\tt jison}}
\label{section:consejosjison}
Cuando escriba un programa \verb|jison| asegurese
de seguir los siguientes consejos:

\begin{enumerate}
\item
Coloque el punto y coma de separación de reglas en una línea aparte.
Un punto y coma ``pegado'' al final de una regla puede confundirse
con un terminal de la regla.

\item
Si hay una regla que produce vacío, coloquela en primer lugar y acompáñela de 
un comentario resaltando ese hecho.
\item
Nunca escriba dos reglas de producción en la misma línea.
\item
Sangre convenientemente todas las partes derechas de las reglas
de producción de una variable, de modo que queden
alineadas.
\item
Ponga nombres representativos a sus variables sintácticas. No llame 
\verb|Z| a una variable que representa el concepto ``lista de parámetros'',
llámela \verb|ListaDeParametros|.
\item
Es conveniente que declare los terminales simbólicos, esto es, aquellos que 
llevan un identificador asociado. Si no llevan prioridad asociada o no 
es necesaria, use una declaración \verb|%token|. De esta manera
el lector de su programa se dará cuenta rápidamente que dichos identificadores
no se corresponden con variables sintácticas. Por la misma razón,
si se trata de terminales
asociados con caracteres o cadenas no es tan necesario que los declare, 
a menos que, 
como en el ejemplo de la calculadora para \verb|'+'| y \verb|'*'|,
sea necesario asociarles una
precedencia.
\item
Es importante que use la opción \verb|-v| para producir
el fichero \verb|.output| conteniendo información detallada sobre
los conflictos y el autómata. Cuando haya un conflicto shift-reduce
no resuelto busque en el fichero el estado implicado y 
vea que LR(0) items $A \rightarrow \alpha_\uparrow$
y $B \rightarrow \beta_\uparrow \gamma$ entran en conflicto.

\item
\label{item:conflictos}
Si según el informe de \verb|jison|
el conflicto se produce ante un terminal $a$,
es porque $a \in FOLLOW(A)$ y
$a \in FIRST(\gamma)$. Busque las causas por las que esto ocurre 
y modifique su gramática con vistas a eliminar la presencia
del terminal $a$ en uno de los dos conjuntos implicados
o bien establezca reglas de prioridad entre los terminales
implicados que resuelvan el conflicto.

\item
Nótese que cuando existe un conflicto de desplazamiento 
reducción entre $A \rightarrow \alpha_\uparrow$ 
y  $B \rightarrow \beta_\uparrow \gamma$, el programa
\verb|jison| contabiliza un error por cada terminal 
$a \in FOLLOW(A) \cap FIRST(\gamma)$. Por esta razón,
si hay 16 elementos en $FOLLOW(A) \cap FIRST(\gamma)$,
el analizador \verb|jison| informará de la existencia
de 16 conflictos \emph{shift-reduce},
cuando en realidad se trata de uno sólo. No desespere, 
los conflictos ``auténticos'' suelen
ser menos de los que \verb|jison| anuncia.

\item
Si necesita declarar variables globales, inicializaciones, etc.
que afectan la conducta global del analizador, escriba el código 
correspondiente en la cabecera del analizador, protegido
por los delimitadores \verb|%{| y \verb|%}|. Estos delimitadores
deberán aparecer en una línea aparte. Por ejemplo:

\begin{verbatim}
%{
our contador = 0;
%}

%token NUM
...
%%
\end{verbatim}



\end{enumerate}

%%% TEXEXPAND: END FILE ./chapter_bottomup/jison.tex

\chapter{Análisis Sintáctico Ascendente en Perl}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_bottomup/analisis_bottomup_en_perl.tex
\section{{\tt Parse::Yapp}: Ejemplo de Uso}
\label{section:ejemplodeuso}
El generador de analizadores sintácticos \tei{Parse::Yapp} es un
analizador LALR inspirado en \tei{yacc}. El módulo
\verb|Parse::Yapp| no viene con la distribución de Perl, por lo que es necesario
bajarlo desde CPAN, en la dirección 

\begin{latexonly}
\begin{verbatim}
\http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.p
\end{verbatim}
\end{latexonly}

\begin{rawhtml}
<a href="http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm">http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm</a> 
\end{rawhtml}

o bien en nuestros servidores locales,
por ejemplo en el mismo directorio en que se guarda
la versión HTML de estos apuntes encontrará una copia de 
\htmladdnormallink{Parse-Yapp-1.05.tar.gz}{Parse-Yapp-1.05.tar.gz}.
La versión a la que se refiere este capítulo es la 1.05.


Para ilustrar su uso veamos
un ejemplo en el que se genera una sencilla calculadora numérica. 
Los contenidos del programa \tei{yapp} los hemos guardado
en un fichero denominado \verb|Calc.yp|
(el código completo figura en el apéndice 
en la página \pageref{apendice:calcyp})

\begin{verbatim}
 1  #
 2  # Calc.yp
 3  # 
 4  # Parse::Yapp input grammar example.
 5  #
 6  # This file is PUBLIC DOMAIN 
 7  #
 8  #
\end{verbatim}
Se pueden poner comentarios tipo Perl o tipo C (\verb|/* ... */|)
a lo largo del fichero.
\begin{verbatim}
 9  %right  '='
10  %left   '-' '+'
11  %left   '*' '/'
12  %left   NEG
13  %right  '^'
14  
15  %%
16  input:  #empty
17       |   input line  { push(@{$_[1]},$_[2]); $_[1] }
18  ;
\end{verbatim}
las declaraciones \tei{\%left} y \tei{\%right} expresan la asociatividad
y precedencia de los terminales, permitiendo decidir que árbol construir 
en caso de  ambiguedad. 
\emph{ Los terminales declarados en líneas 
posteriores tienen mas prioridad que los declarados en las líneas anteriores}.
Véase la sección \ref{section:prioridades} para mas detalles.

Un programa \verb|yapp| consta de tres partes: la cabeza, el cuerpo
y la cola. Cada una de las partes va separada de las otras por el
símbolo \verb|%%| en una línea aparte. Así, el \verb|%%| de la línea 15
separa la cabeza del cuerpo. En la cabecera se colocan el
código de inicialización, las declaraciones de terminales, las reglas
de precedencia, etc.  El cuerpo contiene las reglas de la gramática y
las acciones asociadas. Por último, la cola de un program \verb|yapp|
contiene las rutinas de soporte al código que aparece en las acciones 
asi como, posiblemente, rutinas para el análisis léxico 
y el tratamiento de errores.

En \verb|Parse::Yapp| las acciones son convertidas en subrutinas
anónimas. Mas bien en métodos anónimos. 
Así pues el primer argumento de la subrutina se identifica con 
una referencia al analizador (\verb|$_[0]|).  Los restantes parámetros
se corresponden con los \cei{atributos de los símbolos}
en la parte derecha de la regla de producción (\verb|$_[1]| \ldots ).
Por ejemplo, el código en la línea 21 imprime el atributo asociado
con la variable sintáctica \verb|expr|, que en este caso es su valor numérico.

La línea 17 indica que el atributo asociado con la variable
sintáctica \verb|input| es una referencia
a una pila y que el atributo asociado con la variable sintáctica
\verb|line| debe empujarse
en la pila. De hecho, el atributo asociado con \verb|line| es el valor
de la expresión. Asi pues el atributo retornado por \verb|input| es
una referencia a una lista conteniendo los valores de las expresiones
evaluadas.

Para saber mas sobre las estructuras internas de 
\verb|yapp| para la representación  de las acciones asociadas con las reglas
véase la sección \ref{section:tablas}.


\begin{verbatim}
19  
20  line:  '\n'       { 0 }
21      |  exp '\n'   { print "$_[1]\n"; $_[1] }
22      |  error '\n' { $_[0]->YYErrok; 0 }
23  ;
\end{verbatim}

El terminal
\verb|error| en la línea 22 esta asociado con la aparición de un error.
El tratamiento es el mismo que en \verb|yacc|. Cuando se produce un error
en el análisis, \verb|yapp| emite un mensaje de error y
produce ``mágicamente'' un terminal especial denominado
\verb|error|. A partir de ahí permanecerá silencioso,
consumiendo terminales hasta encontrar uno de los terminales que le
hemos indicado en las reglas de recuperación de errores,
en este caso, cuando encuentre un retorno de carro.
Como se ha dicho, en \verb|Parse::Yapp| el primer argumento de la acción denota al 
analizador sintáctico. Así pues el código \verb|$_[0]->YYErrok|
es una llamada al método \verb|YYErrok| del analizador. Este método
funciona como la macro \verb|yyerrok| de \verb|yacc|, indicando 
que la presencia del retorno del carro (\verb|\n|) la podemos considerar
un signo seguro de que nos hemos recuperado del error. A partir
de este momento, \verb|yapp| volverá a emitir mensajes de error.
Para saber más sobre la recuperación de 
errores en \verb|yapp| léase la sección
\ref{section:errores}.

\begin{verbatim}
24  
25  exp:        NUM
\end{verbatim}
La acción por defecto es retornar \verb|$_[1]|. 
Por tanto, en este caso el valor retornado es el asociado a \verb|NUM|.
\begin{verbatim}
26          |   VAR           { $_[0]->YYData->{VARS}{$_[1]} }
\end{verbatim}
El método \verb|YYData| provee acceso a un hash que contiene los datos 
que están siendo analizados. En este caso creamos una entrada
\verb|VARS| que es una referencia a un hash en el que guardamos las
variables. Este hash es la tabla de símbolos de la calculadora.
\begin{verbatim}
27          |   VAR '=' exp   { $_[0]->YYData->{VARS}{$_[1]}=$_[3] }
28          |   exp '+' exp   { $_[1] + $_[3] }
29          |   exp '-' exp   { $_[1] - $_[3] }
30          |   exp '*' exp   { $_[1] * $_[3] }
\end{verbatim}
Hay numerosas ambiguedades en esta gramática. Por ejemplo,

\begin{itemize}
\item
¿Como debo interpretar la expresión \verb|4 - 5 - 2|?
¿Como \verb|(4 - 5) - 2|? ¿o bien \verb|4 - (5 - 2)|?
La respuesta la da la asignación de asociatividad a los operadores
que hicimos en las líneas 9-13.
Al declarar como asociativo a izquierdas al terminal \verb|-| 
(línea 10) hemos 
resuelto este tipo de ambiguedad. Lo que estamos haciendo es
indicarle al analizador que a la hora de elegir entre 
los árboles abstractos 
$-(-(4,5),2)$ y $-(4, -(5,2))$ elija siempre
el árbol que se hunde a izquierdas.
\item
¿Como debo interpretar la expresión \verb|4 - 5 * 2|?
¿Como \verb|(4 - 5) * 2|? ¿o bien \verb|4 - (5 * 2)|?
Al declarar que \verb|*| tiene mayor prioridad que \verb|-| estamos
resolviendo esta otra fuente de ambiguedad. Esto es así pues
\verb|*| fué declarado en la línea 11 y \verb|-| en la 10.
\end{itemize}

\begin{verbatim}
31          |   exp '/' exp   {
32                              $_[3]
33                              and return($_[1] / $_[3]);
34                              $_[0]->YYData->{ERRMSG}
35                                =   "Illegal division by zero.\n";
36                              $_[0]->YYError;
37                              undef
38                            }
\end{verbatim}

En la regla de la división comprobamos que el divisor es 
distinto de cero. Si es cero inicializamos el atributo 
\verb|ERRMSG| en la zona de datos con el mensaje de
error apropiado. Este mensaje es aprovechado por la subrutina
de tratamiento de errores (véase la subrutina \verb|_Error|
en la zona de la cola). La subrutina \verb|_Error| es llamada
automáticamente por \verb|yapp| cada vez que ocurre un error
sintáctico. Esto es asi por que en la llamada 
al analizador se especifican quienes son las diferentes
rutinas de apoyo:

\begin{verbatim}
my $result = $self->YYParse( yylex => \&_Lexer, 
                             yyerror => \&_Error,
                             yydebug => 0x0 );
\end{verbatim}

Por defecto, \emph{una regla de producción
tiene la prioridad del último terminal que aparece
en su parte derecha}.
Una regla de producción puede ir seguida de una directiva
\verb|%prec| la cual le da una prioridad explícita.  
Esto puede ser de gran ayuda en ciertos casos de 
ambiguedad.

\begin{verbatim}
39          |   '-' exp %prec NEG   { -$_[2] }
\end{verbatim}
¿Cual es la ambiguedad que surge con esta regla? 
Una de las ambiguedad de esta regla 
esta relacionada con el doble significado
del menos como operador unario y binario: hay frases
como \verb|-y-z| que tiene dos posibles interpretaciones:
Podemos verla como \verb|(-y)-z| o bien como \verb|-(y-z)|.
Hay dos árboles posibles. El analizador, cuando este analizando
la entrada \verb|-y-z| y vea el
segundo \verb|-| deberá escoger uno de los dos árboles. 
¿Cuál?. El conflicto puede verse como una ``lucha'' entre
la regla \verb|exp: '-' exp| la cual interpreta la frase como
\verb|(-y)-z| y la segunda aparición del terminal \verb|-| 
el cuál ``quiere entrar'' para que gane la regla \verb|exp: exp '-' exp|
y dar lugar a la interpretación \verb|-(y-z)|.
En este caso, las dos reglas 
$E \rightarrow - E$ y $E \rightarrow E - E$ tienen, en principio
la prioridad del terminal \verb|-|, el cual fué declarado en la
línea 10.
La prioridad expresada explícitamente
para la regla por la declaración \verb|%prec NEG| de la línea
39 hace que la regla tenga la prioridad
del terminal \verb|NEG| (línea 12) y por tanto mas prioridad
que el terminal \verb|-|. Esto hará que \verb|yapp| finalmente opte
por la regla \verb|exp: '-' exp|.

La declaración de \verb|^| como asociativo a derechas y con un nivel
de prioridad alto resuelve las ambiguedades relacionadas 
con este operador:

\begin{verbatim}
40          |   exp '^' exp         { $_[1] ** $_[3] }
41          |   '(' exp ')'         { $_[2] }
42  ;
\end{verbatim}

Después de la parte de la gramática, y separada de la anterior
por el símbolo \verb|%%|, sigue la parte en la que se 
suelen poner las rutinas de apoyo. Hay al menos dos rutinas de apoyo que 
el analizador sintáctico requiere le sean pasados como argumentos: 
la de manejo de errores y la de análisis léxico. El método \verb|Run|
ilustra como se hace la llamada al método de análisis sintáctico 
generado, utilizando la técnica de llamada con argumentos con nombre 
y pasándole las referencias a las dos subrutinas (en Perl,
es un convenio que si el nombre de una subrutina comienza
por un guión bajo es que el autor la considera privada):
\begin{verbatim}
...

sub Run {
    my($self)=shift;
    my $result = $self->YYParse( yylex => \&_Lexer, 
                                 yyerror => \&_Error,
                                 yydebug => 0x0 );
    my @result = @$result;
    print "@result\n";
}
\end{verbatim}

La subrutina de manejo de errores \verb|_Error| imprime 
el mensaje de error proveído por el usuario, el cual, si existe, fué guardado en
\verb|$_[0]->YYData->{ERRMSG}|.
\begin{verbatim}
43  # rutinas de apoyo 
44  %%
45  
46  sub _Error {
47    exists $_[0]->YYData->{ERRMSG}
48      and do {
49          print $_[0]->YYData->{ERRMSG};
50          delete $_[0]->YYData->{ERRMSG};
51          return;
52      };
53    print "Syntax error.\n";
54  }
55  
\end{verbatim}
A continuación sigue el método que implanta
el  análisis léxico \verb|_Lexer|.
En primer lugar se comprueba la existencia de
datos en \verb|parser->YYData->{INPUT}|. Si no es el caso, los datos
se tomarán de la entrada estándar:
\begin{verbatim}
56  sub _Lexer {
57    my($parser)=shift;
58  
59    defined($parser->YYData->{INPUT})
60    or  $parser->YYData->{INPUT} = <STDIN>
61    or  return('',undef);
62  
\end{verbatim}
Cuando el analizador léxico alcanza el final de la entrada
debe devolver la pareja \verb|('',undef)|.

Eliminamos los blancos iniciales (lo que en inglés se conoce por
\cei{trimming}):
\begin{verbatim}
63    $parser->YYData->{INPUT}=~s/^[ \t]//;
64  
\end{verbatim}
A continuación vamos detectando los números, identificadores
y los símbolos individuales. El bucle \verb|for ($parser->YYData->{INPUT})|
se ejecuta mientras la cadena
en \verb|$parser->YYData->{INPUT}| no sea vacía, lo que ocurrirá cuando todos 
los terminales hayan sido consumidos.

\begin{verbatim}
65    for ($parser->YYData->{INPUT}) {
66      s/^([0-9]+(?:\.[0-9]+)?)//
67        and return('NUM',$1);
68      s/^([A-Za-z][A-Za-z0-9_]*)//
69        and return('VAR',$1);
70      s/^(.)//s
71        and return($1,$1);
72    }
73  }
\end{verbatim}

\begin{exercise}
\begin{enumerate}
\item ¿Quién es la variable índice en la línea 65? 
\item ¿Sobre quién ocurre el binding en las líneas 66, 68 y 70? 
\item ¿Cual es la razón por la que \verb|$parser->YYData->{INPUT}| se 
ve modificado si no aparece como variable para el binding en las líneas 66, 68 y 70?
\end{enumerate}
\end{exercise}

Construimos el módulo \verb|Calc.pm| a partir del fichero \verb|Calc.yp|
especificando la gramática, usando un fichero \verb|Makefile|:
\begin{verbatim}
> cat Makefile
Calc.pm: Calc.yp
        yapp -m Calc Calc.yp
> make
yapp -m Calc Calc.yp
\end{verbatim}
Esta compilación genera el fichero \verb|Calc.pm| conteniendo el
analizador:
\begin{verbatim}
> ls -ltr
total 96
-rw-r-----    1 pl       users        1959 Oct 20  1999 Calc.yp
-rw-r-----    1 pl       users          39 Nov 16 12:26 Makefile
-rwxrwx--x    1 pl       users          78 Nov 16 12:30 usecalc.pl
-rw-rw----    1 pl       users        5254 Nov 16 12:35 Calc.pm
\end{verbatim}

El script \verb|yapp| es un \emph{frontend} al módulo \verb|Parse::Yapp|.
Admite diversas formas de uso:

\begin{itemize}
\item
{\tt yapp [options] \textit{grammar}[.yp]}

El sufijo {\tt .yp} es opcional.
\item
{\tt yapp \textit{-V}}

Nos muestra la versión:
\begin{verbatim}
$ yapp -V
This is Parse::Yapp version 1.05.
\end{verbatim}

\item
{\tt yapp \textit{-h}}

Nos muestra la ayuda:

\begin{verbatim}
$ yapp -h

Usage:  yapp [options] grammar[.yp]
  or    yapp -V
  or    yapp -h

    -m module   Give your parser module the name <module>
                default is <grammar>
    -v          Create a file <grammar>.output describing your parser
    -s          Create a standalone module in which the driver is included
    -n          Disable source file line numbering embedded in your parser
    -o outfile  Create the file <outfile> for your parser module
                Default is <grammar>.pm or, if -m A::Module::Name is
                specified, Name.pm
    -t filename Uses the file <filename> as a template for creating the parser
                module file.  Default is to use internal template defined
                in Parse::Yapp::Output
    -b shebang  Adds '#!<shebang>' as the very first line of the output file

    grammar     The grammar file. If no suffix is given, and the file
                does not exists, .yp is added

    -V          Display current version of Parse::Yapp and gracefully exits
    -h          Display this help screen

\end{verbatim}

\end{itemize}

La opción \textit{-m module} \mbox{}
da el nombre  al paquete o espacio de nombres o clase encapsulando el
analizador. Por defecto toma el nombre de la gramática.  En el ejemplo
podría haberse omitido.

La opción \textit{-o outfile} \mbox{}
da el nombre del fichero de salida. Por defecto toma el nombre de la gramática,
seguido del sufijo \verb|.pm|. sin embargo, si hemos especificado la opción
\textit{-m A::Module::Name} el valor por defecto será  \emph{Name.pm}.


Veamos los contenidos del ejecutable \verb|usecalc.pl| el cuál
utiliza el módulo generado por \verb|yapp|:
\begin{verbatim}
> cat usecalc.pl
#!/usr/local/bin/perl5.8.0 -w

use Calc;

$parser = new Calc();
$parser->Run;
\end{verbatim}
Al ejecutar obtenemos:
\begin{verbatim}
$ ./usecalc3.pl
2+3
5
4*8
32
^D
5 32
\end{verbatim}
Pulsamos al final \verb|Ctrl-D| para generar el final de fichero.
El analizador devuelve la lista de valores computados la cual es 
finalmente impresa.

¿En que orden ejecuta \verb|YYParse| las acciones? 
La respuesta es que el analizador generado por 
\verb|yapp| construye una derivación a derechas 
inversa y ejecuta las acciones asociadas a las reglas de producción
que se han aplicado. Así, para la frase \verb|3+2| la antiderivación es:

\begin{center}
\begin{math}
NUM + NUM \stackrel{NUM \leftarrow E}{\Longleftarrow} E + NUM \stackrel{NUM \leftarrow E}{\Longleftarrow} E + E \stackrel{E +E \leftarrow E}{\Longleftarrow} E
\end{math}
\end{center}

por tanto las acciones ejecutadas son las asociadas con las correspondientes reglas 
de producción:
\begin{enumerate}
\item
La acción de la línea 25:
\begin{verbatim}
25  exp:        NUM { $_[1]; } # acción por defecto 
\end{verbatim}
Esta instancia de \verb|exp| tiene ahora como atributo \verb|3|.
\item
De nuevo la acción de la línea 25:
\begin{verbatim}
25  exp:        NUM { $_[1]; } # acción por defecto 
\end{verbatim}
Esta nueva instancia de \verb|exp| tiene como atributo \verb|2|.
\item
La acción asociada con $E \rightarrow E + E$, en la línea 28:
\begin{verbatim}
28          |   exp '+' exp   { $_[1] + $_[3] }
\end{verbatim}
La nueva instancia (nodo) \verb|exp| tiene como atributo \verb|5 = 3 + 2|. 
\end{enumerate}
Obsérvese que la antiderivación a derechas da lugar a un
recorrido ascendente y a izquierdas del árbol:

\begin{verbatim}
                         E(3)
                       / | \
                    (1)E + E(2)
                      /     \ 
                    NUM     NUM   
\end{verbatim}

Los números entre paréntesis indican el orden de visita de las producciones.

\section{Conceptos Básicos}
\label{section:conceptosbasicos}
Los analizadores generador por \verb|yapp| entran en la categoría de analizadores
\cei{LR}. Estos analizadores construyen una derivación a derechas inversa 
(o \cei{antiderivación}).
De ahí la R en LR (del inglés \cei{rightmost derivation}). El árbol sintáctico 
es construido de las hojas hacia la raíz, siendo el último paso en la antiderivación
la construcción de la primera derivación desde el símbolo de arranque.

Empezaremos entonces considerando las frases que pueden aparecer en una derivación
a derechas. Tales frases consituyen el lenguaje $FSD$:

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ no ambigua, se denota por $FSD$ 
(lenguaje de las formas Sentenciales a Derechas) al lenguaje de 
las sentencias que aparecen en una derivación a derechas desde el símbolo de arranque.

\begin{center}
$FSD = \left \{ \alpha \in (\Sigma \cup V)* : \exists S \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array} \alpha \right \}$
\end{center}

Donde la notacion RM indica una derivación a derechas (\emph{rightmost}).
Los elementos de $FSD$ se llaman ``formas sentenciales derechas''.
\end{definition}

Dada una gramática no ambigua $G=(\Sigma,V,P,S)$ y una frase $x \in L(G)$ el proceso
de antiderivación consiste en encontrar la última derivación a derechas que dió lugar a 
$x$. Esto es, si $x \in L(G)$ es porque existe una derivación a derechas de la forma

\begin{center}
$S \stackrel{*}{\Longrightarrow} y A z \Longrightarrow y w z = x$. 
\end{center}

El problema es averiguar que regla $A \rightarrow w$ se aplicó y en que lugar 
de la cadena $x$ se aplicó. En general, si queremos antiderivar
una forma sentencial derecha $\beta \alpha w$ 
debemos averiguar por que regla $A \rightarrow \alpha$
seguir y en que lugar de la forma (después de $\beta$ en el ejemplo)
aplicarla. 

\begin{center}
$S \stackrel{*}{\Longrightarrow} \beta A w \Longrightarrow \beta \alpha w$. 
\end{center}

La pareja formada por la regla y la posición 
se denomina mango o manecilla de la forma. Esta denominación viene
de la visualización gráfica de la regla de producción como una mano
que nos permite escalar hacia arriba en el árbol. Los ``dedos'' serían los
símbolos en la parte derecha de la regla de producción.

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ no ambigua, y dada una forma sentencial derecha 
$\alpha = \beta \gamma x$, con $x \in \Sigma^*$, el \cei{mango} o \cei{handle}  de 
$\alpha$ es la última producción/posición  que dió lugar a $\alpha$:

\begin{center}
$ S \begin{array}{c} *\\\Longrightarrow  \\ {\scriptstyle RM} \end{array} \beta B x \Longrightarrow \beta \gamma x = \alpha$
\end{center}

\end{definition}
Escribiremos: 
$handle(\alpha) = (B \rightarrow \gamma, \beta \gamma)$. La función $handle$ tiene dos componentes:
$handle_1(\alpha) = B \rightarrow \gamma$ y 
$handle_2(\alpha) =  \beta \gamma$

Si dispusieramos de un procedimiento que fuera capaz de identificar el mango,
esto es, de detectar la regla y el lugar en el que se posiciona, tendríamos un
mecanismo para construir un analizador. 
Lo curioso es que, a menudo es posible encontrar un autómata finito que
reconoce el lenguaje de los prefijos $\beta \gamma$  que terminan 
en el mango. Con mas precisión, del lenguaje:

\begin{definition}
El conjunto de \emph{prefijos viables} de una gramática G se define
como  el conjunto:

\begin{center}
$PV = \left \{ \delta \in (\Sigma \cup V)* :  \exists S \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array} \alpha\  y\ \delta\ es\ un\ prefijo\ de\  handle_2(\alpha) \right \}$ 
\end{center}
\end{definition}

Esto es, es el lenguaje de los prefijos viables es el 
conjunto de frases que son prefijos de 
$handle_2(\alpha)) =  \beta \gamma$, 
siendo $\alpha$ una forma sentencial derecha ($\alpha \in FSD$). Los
elementos de $PV$ se denominan prefijos viables.

Obsérvese que si se dispone de un autómata que reconoce 
$PV$ entonces se dispone de un mecanismo para investigar el lugar y 
el aspecto que pueda tener el mango. Si damos como 
entrada la sentencia $\alpha = \beta \gamma x$
a dicho autómata, el autómata aceptará la cadena $\beta \gamma$ pero rechazará
cualquier extensión del prefijo. Ahora sabemos que el mango 
será alguna regla de producción de $G$ cuya parte derecha 
sea un sufijo de  $\beta \gamma$.

\begin{definition}
\label{definition:slrautomata}
El siguiente autómata finito no determinista puede ser utilizado para
reconocer el lenguaje de los prefijos viables PV:
\begin{itemize}
\item
$Alfabeto = V \cup \Sigma$
\item
Los estados del autómata se denominan LR(0) items. Son parejas formadas
por una regla de producción de la gramática y una posición en la parte derecha 
de la regla de producción. Por ejemplo, $(E \rightarrow E + E, 2)$ sería un
LR(0) item para la gramática de las expresiones.

Conjunto de Estados:

$Q =  \left \{ (A \rightarrow \alpha, n) :  A \rightarrow \alpha \in P,\ n \le |\alpha| \right \}$

 La notación $\mid \alpha \mid$ denota la longitud de la cadena $\mid \alpha \mid$.
 En vez de la notación $(A \rightarrow \alpha, n)$ escribiremos: 
 $A \rightarrow \beta _\uparrow \gamma$ $ = \alpha$, 
 donde la flecha ocupa el lugar indicado por el número $n = \mid \beta \mid$ :
\item
Función de transición:

$\delta(A \rightarrow \alpha _\uparrow X \beta, X) = A \rightarrow \alpha X _\uparrow \beta\ \forall X \in  V \cup \Sigma$ 

$\delta(A \rightarrow \alpha _\uparrow B \beta, \epsilon) = B \rightarrow \gamma  \forall B \in  V$ 
\item
Estado de arranque: Se añade la ``superregla'' $S' \rightarrow S$ a la gramática $G = (\Sigma,V,P,S)$. El LR(0) item 
$S' \rightarrow _\uparrow S$ es el estado de arranque.
\item
Todos los estados definidos (salvo el de muerte) son de aceptación.
\end{itemize}
\end{definition}

Denotaremos por $LR(0)$ a este autómata. Sus estados se denominan $LR(0)-items$. La idea es que este
autómata nos ayuda a reconocer los prefijos viables $PV$.

Una vez que se tiene un autómata que reconoce los prefijos viables es posible construir un analizador sintáctico que construye una antiderivación a derechas. La estrategia consiste en ``alimentar'' el autómata con la forma sentencial derecha. El lugar en el que el autómata se detiene, rechazando indica el lugar exacto en el que termina el \emph{handle} de dicha forma.


\begin{example}
\label{example:asb}
Consideremos la gramática:

\vspace{0.5cm}
\begin{center}
\begin{tabular}{l}
S      $\rightarrow$  a S b\\
S      $\rightarrow$ $\epsilon$ 
\end{tabular}
\end{center}
\vspace{0.25cm}

El lenguaje generado por esta gramática es $L(G) = \{ a^n b^n\ :\ n \ge 0 \}$
Es bien sabido que el lenguaje $L(G)$ no es regular.
La figura \ref{fig:nfa} muestra 
el \cei{autómata finito no determinista con $\epsilon$-transiciones} 
(\cei{NFA})
que reconoce los prefijos viables de esta gramática, construido
de acuerdo con el algoritmo \ref{definition:slrautomata}.

\begin{center}
%\begin{makeimage}
\begin{figure}[htb]
%\begin{VCPicture}{(0, 0)(6,6)}
%% states
%\StateVar[S' \rightarrow _\uparrow S]{(2,0)}{0} 
%\StateVar[S' \rightarrow S_\uparrow]{(3,4)}{1} 
%\StateVar[S \rightarrow _\uparrow a S b ]{(8,4)}{2}
%\StateVar[S \rightarrow _\uparrow ]{(6,0)}{3}
%\StateVar[S \rightarrow a _\uparrow S b]{(6,2)}{4}
%\StateVar[S \rightarrow a S _\uparrow b]{(11,1)}{5}
%\StateVar[S \rightarrow a S b _\uparrow]{(13,3)}{6}
%% initial--final
%\Initial{0} %\Final{2}
%% transitions 
%\EdgeL{0}{1}{S} 
%\ArcL{0}{2}{\epsilon} 
%\ArcL{0}{3}{\epsilon} 
%\ArcL{2}{4}{a} 
%\ArcL{4}{2}{\epsilon} 
%\ArcL{4}{3}{\epsilon} 
%\ArcL{4}{5}{S} 
%\ArcL{5}{6}{b} 
%%\LoopN{0}{a} \LoopS{C}{d}
%%
%\end{VCPicture}
%\centerline{\epsfig{file=figures/nfa.eps, width=17cm}}
\caption{NFA que reconoce los prefijos viables}
\label{fig:nfa}
\end{figure}
%\end{makeimage}
\end{center}
\end{example}

\begin{exercise}
Simule el comportamiento del autómata sobre la entrada $aabb$. ¿Donde rechaza?
¿En que estados está el autómata en el momento del rechazo?. ¿Qué etiquetas tienen?
Haga también las
trazas del autómata para las entradas $aaSbb$ y $aSb$. ¿Que antiderivación 
ha construido el autómata con sus sucesivos rechazos? ¿Que terminales
se puede esperar que hayan en la entrada cuando se produce el rechazo
del autómata?
\end{exercise}

\section{Construcción de las Tablas para el Análisis SLR}

\subsection{Los conjuntos de Primeros y Siguientes}
Repasemos las nociones de conjuntos de \cei{Primeros} y \cei{siguientes}:

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y un símbolo $\alpha \in (V \cup \Sigma)^*$ se define el conjunto $FIRST(\alpha)$ como:

$FIRST(\alpha) = \left \{ b \in \Sigma :  \alpha  \stackrel{*}{\Longrightarrow}  b \beta \right \}
\cup N(\alpha)$ 

\noindent donde:

$N(\alpha) = \left \{ \begin{array}{ll}
                         \left \{ \epsilon \right \}& \mbox{si $\alpha \stackrel{*}{\Longrightarrow} \epsilon$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y una variable $A \in V$ se define el conjunto $FOLLOW(A)$ como: 

$FOLLOW(A) = \left \{ b \in \Sigma :  \exists\ S  \stackrel{*}{\Longrightarrow}  \alpha A b \beta \right \} \cup E(A)$

\noindent donde

$E(A) = \left \{ \begin{array}{ll}
                         \{ \$  \}& \mbox{si $S \stackrel{*}{\Longrightarrow} \alpha A$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}

\begin{algorithm} Construcción de los conjuntos $FIRST(X)$
\begin{enumerate}
\item
$Si\ X \in \Sigma\ entonces\ FIRST(X) = {X}$
\item
$Si\ X \rightarrow \epsilon\ entonces\ FIRST(X) =  FIRST(X) \cup \{ \epsilon \}$
\item
$Si X \in V \ y\ X \rightarrow Y_1 Y_2 \cdots Y_k \in P\ entonces$
\begin{eqnarray*}
&&i = 1; \\
&&do\\
&&\ \ FIRST(X) = FIRST(X) \cup FIRST(Y_i) - \{ \epsilon \};\\
&&\ \ i++;\\
&&mientras\ (\epsilon \in FIRST(Y_i)\ and\ (i \leq k))\\
&&si\ (\epsilon \in FIRST(Y_k)\ and\ i > k)\ FIRST(X) = FIRST(X) \cup \{ \epsilon \}
\end{eqnarray*}
\end{enumerate}
\end{algorithm}
Este algoritmo puede ser extendido para calcular $FIRST(\alpha)$ para $\alpha = X_1 X_2 \cdots X_n \in (V \cup \Sigma)^*$.

\begin{algorithm} Construcción del conjunto $FIRST(\alpha)$ 
\begin{eqnarray*}
&&i = 1; \nonumber\\
&&FIRST(\alpha) = \emptyset; \nonumber\\
&&do \nonumber\\
&&\ \ FIRST(\alpha) = FIRST(\alpha) \cup FIRST(X_i) - \{ \epsilon \}; \nonumber\\
&&\ \ i++; \nonumber\\
&&mientras\ (\epsilon \in FIRST(X_i)\ and\ (i \leq n)) \nonumber\\
&&si\ (\epsilon \in FIRST(X_n)\ and\ i > n)\ FIRST(\alpha) = FIRST(X) \cup \{ \epsilon \}
\end{eqnarray*}
\end{algorithm} 

\begin{algorithm} Construcción de los conjuntos $FOLLOW(A)$
para las variables sintácticas $A \in V$: 

Repetir los siguientes pasos hasta que ninguno de los conjuntos $FOLLOW$ cambie:
\begin{enumerate} 
\item 
$FOLLOW(S) = \{\$\} $  ($\$$ representa el final de la entrada)
\item
$Si\ A \rightarrow \alpha B \beta\ entonces$
\[ FOLLOW(B) =  FOLLOW(B) \cup (FIRST(\beta) - \{\epsilon\})\]
\item
$Si\ A \rightarrow \alpha B$ o bien $A \rightarrow \alpha B \beta$
y $\epsilon \in FIRST(\beta)$  entonces

\[ FOLLOW(B) = FOLLOW(B) \cup FOLLOW(A)\]
\end{enumerate}
\end{algorithm}

\subsection{Construcción de las Tablas}
\label{subsection:nfa2dfa}

Para la construcción de las tablas de un analizador SLR
se construye el \cei{autómata finito determinista} (\cei{DFA}) 
$(Q, \Sigma, \delta, q_0)$ equivalente al NFA 
presentado en la sección
\ref{section:conceptosbasicos}
usando el \cei{algoritmo de construcción del subconjunto}.

Como recordará, en la construcción del subconjunto,
partiendo del estado de arranque $q_0$ del NFA con $\epsilon$-transiciones
se calcula su \cei{clausura} $\overline{\{q_0\}}$ y las 
clausuras de los conjuntos de estados $\overline{\delta(\overline{\{q_0\}},a)}$ 
a los que transita.  Se repite el proceso
con los conjuntos resultantes hasta que no se introducen nuevos
conjuntos-estado.

La clausura $\overline{A}$ de un subconjunto de estados del autómata $A$ esta formada
por todos los estados que pueden ser alcanzados mediante transiciones
etiquetadas con la palabra vacía (denominadas $\epsilon$ transiciones)
desde los estados de $A$. Se incluyen en $\overline{A}$, naturalmente los estados 
de $A$.

\begin{center}
$\overline{A} = \{ q \in Q\ /\  \exists q' \in Q\ :\ \hat{\delta}(q, \epsilon) = q \}$
\end{center}

Aquí $\hat{\delta}$ denota la \cei{función de transición del autómata} extendida  a cadenas
de $\Sigma^*$.

\begin{equation}
\label{equation:deltahat}
\hat{\delta}(q, x) = \left \{ \begin{array}{ll}
                         \delta(\hat{\delta}(q,y),a) & \mbox{si $x = ya$} \\
                         q & \mbox{si $x = \epsilon$} 
                      \end{array}
             \right.  
\end{equation}

En la práctica, y a partir de ahora así lo haremos, se prescinde de diferenciar
entre $\delta$ y $\hat{\delta}$ usándose indistintamente la notación
$\delta$ para ambas funciones.

La clausura puede ser computada usando una estructura de pila o aplicando 
la expresión recursiva dada en la ecuación \ref{equation:deltahat}.

Para el NFA mostrado en el ejemplo \ref{example:asb} el DFA construído mediante esta
técnica es el que se muestra en la figura \ref{fig:dfa}. Se ha utilizado el símbolo
\verb|#| como marcador. Se ha omitido el número 3 para que los estados coincidan
en numeración con los generados por \verb|yapp| (véase el cuadro
\ref{table:tablaslalr}).

\begin{center}
\begin{figure}
%\centerline{\epsfig{file=figures/dfa.eps, width=12cm}}
\caption{DFA equivalente al NFA de la figura \ref{fig:nfa}}
\label{fig:dfa}
\end{figure}
\end{center}

Un analizador sintáctico LR utiliza una tabla para su análisis.
Esa tabla se construye a partir de la tabla de transiciones del DFA.
De hecho, la tabla se divide en dos tablas, una llamada 
\cei{tabla de saltos} o \cei{tabla de gotos} y la otra
\cei{tabla de acciones}.

La tabla \cei{goto} de un analizador \cei{SLR}
no es más que la tabla de transiciones del autómata DFA 
obtenido aplicando la construcción del subconjunto al NFA
definido en \ref{definition:slrautomata}. De hecho es la tabla
de transiciones restringida a $V$ (recuerde que el alfabeto del
autómata es $V \cup \Sigma$).
Esto es, 

\begin{center}
$\delta_{| V \times Q} :  V \times Q \rightarrow Q$. 

donde se define $goto(i, A) = \delta(A,I_i)$
\end{center}

La parte de la función de transiciones
del DFA que corresponde a los terminales que no producen rechazo, 
esto es, $\delta_{| \Sigma \times Q} :  \Sigma \times Q \rightarrow Q$
se adjunta a una tabla que se denomina \cei{tabla de acciones}.
La tabla de acciones es una tabla de doble entrada en los estados
y en los símbolos de $\Sigma$.
Las acciones de transición ante terminales 
se denominan \cei{acciones de desplazamiento} o (\cei{acciones shift}):

\begin{center}
$\delta_{| \Sigma \times Q} :  \Sigma \times Q \rightarrow Q$

donde se define $action(i, a) = \delta(a,I_i)$
\end{center}

Cuando un estado $s$ contiene un LR(0)-item de la forma 
$A \rightarrow \alpha_\uparrow$, 
esto es, el estado corresponde a un posible rechazo,
ello indica que hemos llegado a un final del prefijo viable, que hemos
visto $\alpha$ y que, por tanto, es probable que $A \rightarrow \alpha$
sea el \emph{handle} de la forma sentencial derecha actual. Por tanto,
añadiremos en entradas de la forma $(s,a)$ de la tabla de acciones 
una acción que indique que hemos encontrado el mango en la 
posición actual y que la regla asociada es $A \rightarrow \alpha$.
A una acción de este tipo se la denomina \cei{acción de reducción}.

La cuestión es, ¿para que valores de $a \in \Sigma$ debemos disponer que
la acción para $(s, a)$ es de reducción?
Podríamos decidir que ante cualquier terminal $a \in \Sigma$
que produzca un rechazo del autómata, pero podemos ser un poco mas
selectivos. No cualquier terminal puede estar en la entrada en el momento
en el que se produce la antiderivación o reducción. 
Observemos que si $A \rightarrow \alpha$ es el \emph{handle}
de $\gamma$ es porque:

\begin{center}
$\exists S \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array} \beta A b x \begin{array}{c} *\\ \Longrightarrow \\ {\scriptstyle RM} \end{array}  
\beta \alpha b x = \gamma$
\end{center}

Por tanto, cuando estamos reduciendo por $A \rightarrow \alpha$
los únicos terminales legales que cabe esperar en una reducción por $A \rightarrow \alpha$ son los terminales $b \in FOLLOW(A)$.


Dada una gramática $G=(\Sigma,V,P,S)$, podemos construir las tablas de acciones (\emph{action table}) y  transiciones (\emph{gotos table}) mediante el siguiente algoritmo:

\begin{algorithm} 
\label{alg:tables}       
Construcción de Tablas \cei{SLR}

\begin{enumerate}
\item
Utilizando el Algoritmo de Construcción del Subconjunto, se construye
el Autómata Finito Determinista (DFA) $(Q, V \cup \Sigma, \delta, I_0, F)$
equivalente al Autómata Finito No
Determinista (NFA) definido en \ref{definition:slrautomata}.
Sea $C = \left \{ I_1, I_2, \cdots I_n \right \}$ el conjunto de estados
del DFA. Cada estado $I_i$ es un conjunto de LR(0)-items o estados
del NFA. Asociemos un índice $i$ con cada conjunto $I_i$.
\item
La tabla de \emph{gotos} no es más que la función de transición del 
autómata restringida a las variables de la gramática:

\begin{center}
$goto(i,A) = \delta(I_i, A)$ para todo $A \in V$
\end{center}
\item
Las acciones para el estado $I_i$ se determinan como sigue:
  \begin{enumerate}
  \item
  Si $A \rightarrow \alpha _\uparrow a \beta \in I_i$, $\delta(I_i,a) = I_j$, $a \in \Sigma$ 
  entonces:

\begin{center}
  $action[i][a] = shift\ j$
\end{center}
  \item
  Si $S' \rightarrow S_\uparrow \in I_i$ entonces 

\begin{center}
  $action[i][\$] = accept$
\end{center}
  \item
  Para cualquier otro caso de la forma $A \rightarrow \alpha _\uparrow \in I_i$ 
  distinto del anterior hacer

\begin{center}
  $\forall a \in\ FOLLOW(A):\ action[i][a] = reduce\ A \rightarrow \alpha$
\end{center}
  \end{enumerate}
\item
  Las entradas de la tabla de acción que queden indefinidas después de aplicado el proceso anterior corresponden a acciones de ``$error$''.
\end{enumerate}
\end{algorithm}

\begin{definition}
Si alguna de las entradas de la tabla resulta multievaluada, decimos
que existe un conflicto y que la gramática no es \cei{SLR}.

\begin{enumerate}
\item
En tal caso, si una de las acciones es de `reducción'' y la otra es de
`desplazamiento'', decimos que hay un \cei{conflicto shift-reduce} o
\cei{conflicto de desplazamiento-reducción}. 
\item
Si las
dos reglas indican una acción de reducción, decimos que tenemos un 
\cei{conflicto reduce-reduce} o de \cei{reducción-reducción}.
\end{enumerate}
\end{definition}

\begin{example}
\label{example:tablasslr}
Al aplicar el algoritmo \ref{alg:tables}       
a la gramática \ref{example:asb} 

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|l|l|}
\hline
1 & S      $\rightarrow$  a S b\\
\hline
2 & S      $\rightarrow$ $\epsilon$ \\
\hline
\end{tabular}
\end{center}
\vspace{0.25cm}

partiendo del autómata finito determinista
que se construyó en 
la figura \ref{fig:dfa} y calculando los 
conjuntos de primeros y siguientes

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
     & FIRST  & FOLLOW \\
\hline
S    & a, $\epsilon$ & b, \$\\
\hline
\end{tabular}
\end{center}

obtenemos la siguiente tabla de acciones SLR:

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
     &  a  &  b  & \$ \\
\hline
0    & s2  &  r2 & r2 \\
\hline
1    &     &     & aceptar\\
\hline
2    & s2  & r2  & r2\\
\hline
4    &     & s5  &   \\
\hline
5    &     & r1  & r1\\
\hline
\end{tabular}
\end{center}

Las entradas denotadas con $s$ $n$ ($s$ por shift) indican un desplazamiento
al estado $n$, las denotadas con $r$ $n$ ($r$ por reduce o reducción) indican una operación
de reducción o antiderivación por la regla $n$.  Las entradas vacías 
corresponden a acciones de error.
\end{example}

El método de análisis \cei{LALR} usado por \verb|yapp|
es una extensión del método SLR esbozado
aqui. Supone un compromiso entre potencia (conjunto de gramáticas
englobadas) y eficiencia (cantidad de memoria utilizada, tiempo de
proceso).
Veamos como \verb|yapp| aplica la construcción del subconjunto a la 
gramática del ejemplo
\ref{example:asb}.
Para ello construimos el siguiente programa \verb|yapp|:
\begin{verbatim}
$ cat -n aSb.yp
     1  %%
     2  S:  # empty
     3      |   'a' S 'b'  
     4  ;
     5  %%
     ......
\end{verbatim}
y compilamos, haciendo uso de la opción \verb|-v| para que \verb|yapp| produzca
las tablas en el fichero \verb|aSb.output|:
\begin{verbatim}
$ ls -l aSb.*
-rw-r--r--  1 lhp lhp  738 2004-12-19 09:52 aSb.output
-rw-r--r--  1 lhp lhp 1841 2004-12-19 09:52 aSb.pm
-rw-r--r--  1 lhp lhp  677 2004-12-19 09:46 aSb.yp
\end{verbatim}

El contenido del fichero \verb|aSb.output| se muestra
en la tabla 
\ref{table:tablaslalr}.
Los números de referencia a las producciones en las acciones
de reducción vienen dados por:

\begin{verbatim}
                      0:	$start -> S $end
                      1:	S -> /* empty */
                      2:	S -> 'a' S 'b'
\end{verbatim} 

Observe que el final de la entrada se denota 
por \verb|$end| y el marcador en un LR-item 
por un punto. Fíjese en el estado 2: 
En ese estado están también los items

\begin{center}
 \verb|S -> . 'a' S 'b'|
y \verb|S -> .|
\end{center}

sin embargo no se explicitan
por que se entiende que su pertenencia es
consecuencia directa de aplicar la operación 
de clausura. Los LR items cuyo marcador
no está al principio se denominan
\cei{items núcleo}. 

\vspace{0.5cm}
\begin{table}[htb]
\begin{center}
\begin{tabular}{|p{4cm}|p{4cm}|p{4cm}|}
\hline
Estado 0 & Estado 1 & Estado 2\\
\hline
\begin{verbatim}
	$start -> . S $end	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 1
\end{verbatim} 
&
\begin{verbatim}
	$start -> S . $end	
	$end	shift 3
\end{verbatim} 
&
\begin{verbatim}
	S -> 'a' . S 'b'	
	'a'	shift 2
	$default	reduce 1 (S)
	S	go to state 4
\end{verbatim} 

\\

\hline
Estado 3 & Estado 4 & Estado 5\\
\hline

\begin{verbatim}
	$start -> S $end .	
	$default	accept
\end{verbatim} 
&
\begin{verbatim}
	S -> 'a' S . 'b'	
	'b'	shift 5
\end{verbatim} 
&
\begin{verbatim}
	S -> 'a' S 'b' .	
	$default	reduce 2 (S)
\end{verbatim}
\\
\hline
\end{tabular}
\end{center}
\caption{Tablas generadas por {\tt yapp}. El estado 3 resulta de transitar con \$}
\label{table:tablaslalr}
\end{table}
Puede encontrar el listado completo de las tablas en \verb|aSb.output|
en el apéndice que se encuentra en la página 
\ref{apendice:asb}.

\begin{exercise}
Compare la tabla \ref{table:tablaslalr} resultante de 
aplicar \verb|yapp| con la que obtuvo en el ejemplo
\ref{example:tablasslr}.
\end{exercise}

\section{El módulo Generado por {\tt yapp}}
\label{section:tablas}
La ejecución de la orden \verb|yapp -m Calc Calc.yp| produce 
como salida el módulo \verb|Calc.pm| el cual contiene las tablas LALR(1)
para la gramática descrita en \verb|Calc.yp|. Estas tablas son las que
dirigen al analizador LR. 
Puede ver el código completo del módulo en el apéndice
que se encuentra en la página \pageref{apendice:calcpm}.
La  estructura del módulo \verb|Calc.pm| es como sigue:

\begin{verbatim}
 1 package Calc;
 2 use vars qw ( @ISA );
 3 use strict;
 4 @ISA= qw ( Parse::Yapp::Driver );
 5 use Parse::Yapp::Driver;
 6 
 7 sub new {
 8    my($class)=shift;
 9    ref($class) and $class=ref($class);
10 
11     my($self)=$class->SUPER::new( 
12        yyversion => '1.05',
13        yystates => [ 
..          ...
32        ], # estados
33        yyrules  => [
..       	# ... mas reglas
70        ], # final de las reglas
71        @_); # argumentos pasados
72   bless($self,$class);
73 }
\end{verbatim}

La clase \verb|Calc| hereda de \verb|Parse::Yapp::Driver|, pero el objeto creado
será bendecido en la clase \verb|Calc| (Línea 4, véanse también 
la figura \ref{fig:yappinheritance} 
y la línea 72 del fuente). 
Por tanto, el constructor llamado en la línea 11 es el de \verb|Parse::Yapp::Driver|.
Se utiliza la estrategia de llamada con parámetros con nombre. 
El valor para la clave \verb|yystates| es una referencia anónima 
al array de estados y el valor para la clave \verb|yyrules| 
es una referencia anónima a las reglas.
\begin{verbatim}
10 
11     my($self)=$class->SUPER::new( 
12        yyversion => '1.05',
13        yystates => [
14         {#State 0
15           DEFAULT => -1, GOTOS => { 'input' => 1 }
16         },
17         {#State 1
18           ACTIONS => {
19             'NUM' => 6, '' => 4, "-" => 2, "(" => 7,
20             'VAR' => 8, "\n" => 5, 'error' => 9
21           },
22           GOTOS => { 'exp' => 3, 'line' => 10 }
23         },
24         # ...  mas estados
25         {#State 27
26           ACTIONS => {
27             "-" => 12, "+" => 13, "/" => 15, "^" => 16,
28             "*" => 17
29           },
30           DEFAULT => -8
31         }
32        ], # estados
\end{verbatim}
Se ve que un estado se pasa como un hash anónimo indexado en las acciones
y los saltos. 

Para consultar los números asociados con las reglas de producción
vea el apéndice en la página \pageref{apendice:calcouput}
conteniendo el fichero \verb|Calc.output|.

A continuación vienen las reglas:
\begin{verbatim}
33        yyrules  => [
34        [#Rule 0
35              '$start', 2, undef ],
36        [#Rule 1
37              'input', 0, undef ],
38        [#Rule 2
39              'input', 2, sub
40 #line 17 "Calc.yp"
41              { push(@{$_[1]},$_[2]); $_[1] }
42        ],
43        [#Rule 3
44              'line', 1, sub
45 #line 20 "Calc.yp"
46              { $_[1] }
47        ],
48        [#Rule 4
49              'line', 2, sub
50 #line 21 "Calc.yp"
51              { print "$_[1]\n" }
52        ],
53   # ... mas reglas
54     [#Rule 11
55             'exp', 3, sub
56 #line 30 "Calc.yp"
57 { $_[1] * $_[3] }
58    ],
59   [#Rule 12
60             'exp', 3, sub
61 #line 31 "Calc.yp"
62   {
63     $_[3] and return($_[1] / $_[3]);
64     $_[0]->YYData->{ERRMSG} =   "Illegal division by zero.\n";
65     $_[0]->YYError;
66     undef
67   }
68     ],
69   # ... mas reglas
70   ], # final de las reglas
\end{verbatim}
Las reglas son arrays anónimos conteniendo el nombre de la regla o
variable sintáctica (\verb|exp|), el número de símbolos en la parte
derecha y la subrutina anónima con el código asociado.

Vemos como la acción es convertida en una subrutina anónima. 
Los argumentos de dicha subrutina son los atributos semánticos
asociados con los símbolos en la parte derecha de la regla de 
producción. El valor retornado por la acción/subrutina
es el valor asociado con la reducción.

Para hacer que 
el compilador Perl diagnostique los errores relativos al fuente 
\verb|Calc.yp| se usa una directiva \verb|#line|.


\begin{verbatim}
71   @_);
72   bless($self,$class);
73 }
74 
\end{verbatim}

la bendición con dos argumentos hace que el objeto pertenezca a la
clase \verb|Calc|. A continuación siguen las subrutinas de soporte:
\begin{verbatim}
75 #line 44 "Calc.yp" 
76 
77 
78 sub _Error {
79   # ...
80 }
81 
82 sub _Lexer {
83   my($parser)=shift;
84   # ...
85 }
86 
87 sub Run {
88     my($self)=shift;
89     $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
90 }
91 
92 my($calc)=new Calc;
93 $calc->Run;
94 
95 1;
\end{verbatim}

\section{Algoritmo de Análisis LR}
\label{section:algoritmoLR}
Asi  pues la tabla de transiciones del autómata nos genera dos tablas:
la tabla de acciones y la de saltos.
El  algoritmo  de análisis sintáctico \emph{LR} en el  que 
se basa \emph{yapp} utiliza una pila y dos tablas 
para analizar la entrada. % (véase la figura \ref{fig:lrparser}). 
Como se ha visto, la tabla  de acciones contiene cuatro tipo de acciones: 
\begin{enumerate}
\item
Desplazar (\emph{shift})
\item
Reducir (\emph{reduce})
\item
Aceptar
\item
Error
\end{enumerate}
El algoritmo utiliza una pila en la que se guardan los estados
del autómata. De este modo se evita tener que ``comenzar'' 
el procesado de la forma sentencial derecha resultante
después de una reducción (antiderivación).
\begin{algorithm}
\label{alg:parser}       
Análizador LR
\begin{verbatim}
push(s0);
 b = yylex();
 for( ; ; ;) {
   s = top(0); a = b;
   switch (action[s][a]) {
     case "shift t" : 
       push(t); 
       b = yylex();
       break;
     case "reduce A ->alpha" : 
       eval(Sub{A -> alpha}->(top(|alpha|-1).attr, ... , top(0).attr)); 
       pop(|alpha|); 
       push(goto[top(0)][A]); 
       break;
     case "accept" : return (1); 
     default : yyerror("syntax error");
   }
 }
\end{verbatim}
\end{algorithm}
Como es habitual, $|x|$ denota la longitud de la cadena $x$.
La función \verb|top(k)| devuelve el elemento que ocupa la 
posición \verb|k| desde el \emph{top} de la pila (esto es, está a profundidad \verb|k|).
La función \verb|pop(k)| extrae \verb|k| elementos de la pila.
La notación \verb|state.attr| hace referencia al atributo
asociado con cada estado. Denotamos por \verb|sub_{reduce A -> alpha}|
el código de la acción asociada con la regla $A \rightarrow \alpha$.
%\begin{figure}
%\input{parser_fig.tex}
%\caption{Estructura de un Análizador LR}
%\label{fig:lrparser}       
%\end{figure}

Todos los analizadores LR comparten, salvo pequeñas
exepciones, el mismo algoritmo
de análisis. Lo que más los diferencia es la forma en 
la que construyen las tablas.
En \verb|yapp|
la construcción de las tablas de \emph{acciones} y \emph{gotos}
se realiza mediante el algoritmo \emph{LALR}.

\section{Depuración en {\tt yapp}}
\label{section:depuracion}
Es posible añadir un parámetro en la llamada a \verb|YYParse|
con nombre \cei{yydebug} y valor el nivel de depuración requerido.
Ello 
nos permite observar la conducta del analizador. Los 
posibles valores de depuración son:

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|l|l|}
\hline
   Bit      &    Información de Depuración \\
\hline
    0x01    &    Lectura de los terminales\\
\hline
    0x02    &    Información sobre los estados\\
\hline
    0x04    &    Acciones (shifts, reduces, accept \ldots)\\
\hline
    0x08    &    Volcado de la pila\\
\hline
    0x10    &    Recuperación de errores\\
\hline
\end{tabular}
\end{center}
\vspace{0.5cm}
 
 Veamos un ejemplo de salida para la gramática
 que se describe en la página 
 \pageref{apendice:asb}
 cuando se llama con: 

 \verb|$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => 0x1F )|

 \begin{verbatim}
 1  $ ./use_aSb.pl
 2  ----------------------------------------
 3  In state 0:
 4  Stack:[0]
 5  ab  # el usuario ha escrito esto
 6  Need token. Got >a<
 7  Shift and go to state 2.
 8  ----------------------------------------
 9  In state 2:
10  Stack:[0,2]
11  Need token. Got >b<
12  Reduce using rule 1 (S,0): S -> epsilon
13  Back to state 2, then go to state 4.
14  ----------------------------------------
15  In state 4:
16  Stack:[0,2,4]
17  Shift and go to state 5.
18  ----------------------------------------
19  In state 5:
20  Stack:[0,2,4,5]
21  Don't need token.
22  Reduce using rule 2 (S,3): S -> a S b
23  Back to state 0, then go to state 1.
24  ----------------------------------------
25  In state 1:
26  Stack:[0,1]
27  Need token. Got ><
28  Shift and go to state 3.
29  ----------------------------------------
30  In state 3:
31  Stack:[0,1,3]
32  Don't need token.
33  Accept.
 \end{verbatim}

\section{Precedencia y Asociatividad}
\label{section:prioridades}
Recordemos que si al construir la tabla LALR,
alguna de las entradas de la tabla resulta multievaluada, decimos
que existe un conflicto.
Si una de las acciones es de `reducción'' y la otra es de
`desplazamiento'', se dice que hay un \cei{conflicto shift-reduce} o
\cei{conflicto de desplazamiento-reducción}. Si las
dos reglas indican una acción de reducción, decimos que tenemos un 
\cei{conflicto reduce-reduce} o de \cei{reducción-reducción}.
En caso de que no existan indicaciones específicas \emph{yapp} resuelve
los conflictos que aparecen en la construcción de la tabla utilizando
las siguientes reglas:

\begin{enumerate}
\item
Un conflicto \emph{reduce-reduce} se resuelve eligiendo la producción
que se listó primero en la especificación de la gramática.
\item
Un conflicto \emph{shift-reduce} se resuelve siempre en favor del \emph{shift}
\end{enumerate}

Las declaraciones de precedencia y asociatividad mediante las
palabras reservadas \tei{\%left}, \tei{\%right}, \tei{\%nonassoc}
se utilizan para modificar estos criterios por defecto. 
La declaración de \tei{token}s mediante la palabra
reservada \tei{\%token} no modifica la precedencia. Si lo hacen las
declaraciones realizadas usando las palabras \tei{left}, \tei{right}
y \tei{nonassoc}. 

\begin{enumerate}
\item
Los \emph{tokens} declarados  en la misma línea
tienen igual precedencia e igual asociatividad. 
La precedencia es mayor cuanto mas abajo 
su posición en
el texto. Así, en el ejemplo de la calculadora en la sección 
\ref{section:ejemplodeuso}, el \emph{token} \verb1*1 tiene 
mayor precedencia que \verb1+1 pero la misma que \verb1/1.
\item
La precedencia de una regla $A \rightarrow \alpha$ se
define como la del terminal mas a la derecha que aparece en
$\alpha$. En el ejemplo, la producción 

\begin{center}
\verb1 expr : expr '+' expr1 
\end{center}

tiene la precedencia del \emph{token} \verb1+1.
\item
Para decidir en un conflicto \emph{shift-reduce} se comparan la precedencia 
de la regla con la del terminal que va a ser desplazado. Si la de la
regla es mayor se reduce
si la del \emph{token} es mayor, se desplaza.
\item
Si en un conflicto \emph{shift-reduce} ambos la regla y el terminal que
va a ser desplazado tiene la misma precedencia \emph{yapp} considera la
asociatividad, si es asociativa a izquierdas, reduce y si es asociativa
a derechas desplaza. Si no es asociativa, genera un mensaje de error.\\
Obsérvese que, en esta situación, la asociatividad de la regla y la del
\emph{token} han de ser por fuerza, las mismas.  Ello es así, porque en
\emph{yapp} los \emph{tokens} con la misma precedencia se declaran en
la misma línea y sólo se permite una declaración por línea.

\item
\emph{ Por tanto es imposible declarar dos \emph{tokens} con diferente
asociatividad y la misma precedencia}.
\item
Es posible modificar la precedencia ``natural'' de una regla, calificándola
con un \emph{token} específico.  para ello se escribe a la derecha de
la regla \verb|prec token|, donde \verb|token| es un \emph{token} con
la precedencia que deseamos. Vea el uso del \emph{token} \verb|dummy|
en el siguiente ejercicio.
\end{enumerate}


Para ilustrar las reglas anteriores usaremos el siguiente 
programa \verb|yapp|:

\begin{verbatim}
$ cat -n Precedencia.yp
     1  %token NUMBER
     2  %left '@'
     3  %right '&'  dummy
     4  %%
     5  list
     6      :
     7      | list '\n'
     8      | list e
     9      ;
    10
    11  e : NUMBER
    12    | e '&' e
    13    | e '@' e %prec dummy
    14    ;
    15
    16  %%
\end{verbatim}            

El código del programa cliente es el siguiente:

\begin{verbatim}
$ cat -n useprecedencia.pl
cat -n useprecedencia.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Precedencia;
     4
     5  sub Error {
     6    exists $_[0]->YYData->{ERRMSG}
     7    and do {
     8      print $_[0]->YYData->{ERRMSG};
     9      delete $_[0]->YYData->{ERRMSG};
    10      return;
    11    };
    12    print "Syntax error.\n";
    13  }
    14
    15  sub Lexer {
    16    my($parser)=shift;
    17
    18    defined($parser->YYData->{INPUT})
    19    or  $parser->YYData->{INPUT} = <STDIN>
    20    or  return('',undef);
    21
    22    $parser->YYData->{INPUT}=~s/^[ \t]//;
    23
    24    for ($parser->YYData->{INPUT}) {
    25        s/^([0-9]+(?:\.[0-9]+)?)//
    26                and return('NUMBER',$1);
    27        s/^(.)//s
    28                and return($1,$1);
    29    }
    30  }
    31
    32  my $debug_level = (@ARGV)? oct(shift @ARGV): 0x1F;
    33  my $parser = Precedencia->new();
    34  $parser->YYParse( yylex => \&Lexer, yyerror => \&Error, yydebug => $debug_level );
\end{verbatim}

Observe la llamada al analizador en la línea 34. Hemos 
añadido el parámetro con nombre \cei{yydebug} 
con argumento \verb|yydebug => $debug_level| (véase la
sección \ref{section:depuracion} para ver los posibles
valores de depuración).

Compilamos a continuación el módulo usando la opción \verb|-v| para
producir información sobre los conflictos y las tablas de salto y 
de acciones:
\begin{verbatim}
yapp -v -m Precedencia Precedencia.yp
$ ls -ltr |tail -2
-rw-r--r--  1 lhp lhp   1628 2004-12-07 13:21 Precedencia.pm
-rw-r--r--  1 lhp lhp   1785 2004-12-07 13:21 Precedencia.output
\end{verbatim}

La opción \verb|-v| genera el fichero \verb|Precedencia.output|
el cual contiene información detallada sobre el autómata:

\begin{verbatim}
$ cat -n Precedencia.output
     1  Conflicts:
     2  ----------
     3  Conflict in state 8 between rule 6 and token '@' resolved as reduce.
     4  Conflict in state 8 between rule 6 and token '&' resolved as shift.
     5  Conflict in state 9 between rule 5 and token '@' resolved as reduce.
     6  Conflict in state 9 between rule 5 and token '&' resolved as shift.
     7
     8  Rules:
     9  ------
    10  0:      $start -> list $end
    11  1:      list -> /* empty */
    12  2:      list -> list '\n'
    13  3:      list -> list e
    14  4:      e -> NUMBER
    15  5:      e -> e '&' e
    16  6:      e -> e '@' e
    17  ...
\end{verbatim}
¿Porqué se produce un conflicto en el estado 8 entre la regla
6 (\verb|e -> e '@' e|) y el terminal \verb|'@'|?. Editando el fichero
\verb|Precedencia.output| podemos ver los contenidos
del estado 8:
\begin{verbatim}
85  State 8:
86
87          e -> e . '&' e  (Rule 5)
88          e -> e . '@' e  (Rule 6)
89          e -> e '@' e .  (Rule 6)
90
91          '&'     shift, and go to state 7
92
93          $default        reduce using rule 6 (e)
\end{verbatim}
El item de la línea 88 indica que debemos desplazar, el de 
la línea 89 que debemos reducir por la regla 6. ¿Porqué \verb|yapp|
resuelve el conflicto optando por reducir?
¿Que prioridad tiene la regla 6?
¿Que asociatividad tiene la regla 6?
La declaración en la línea 13 modifica la precedencia y asociatividad
de la regla:

\begin{verbatim}
    13    | e '@' e %prec dummy
\end{verbatim}

de manera que la regla pasa a tener la precedencia y asociatividad
de \verb|dummy|. Recuerde que habíamos declarado \verb|dummy| como
asociativo a derechas:
\begin{verbatim}
     2  %left '@'
     3  %right '&'  dummy
\end{verbatim}
¿Que ocurre? Que \verb|dummy| tiene mayor prioridad
que \verb|'@'| y por tanto la regla tiene mayor prioridad
que el terminal: por tanto se reduce.

¿Que ocurre cuando el terminal en conflicto es \verb|'&'|?
En ese caso la regla y el terminal tienen la misma prioridad.
Se hace uso de la asociatividad a derechas que indica que el conflicto
debe resolverse desplazando.

\begin{exercise}
Explique la forma en que \verb|yapp| resuelve 
los conflictos que aparecen en el estado 9.
Esta es la información sobre el estado 9:

\begin{verbatim}
State 9:

	e -> e . '&' e	(Rule 5)
	e -> e '&' e .	(Rule 5)
	e -> e . '@' e	(Rule 6)
	'&'	shift, and go to state 7
	$default	reduce using rule 5 (e)
\end{verbatim}
\end{exercise}

Veamos un ejemplo de ejecución:

\begin{verbatim}
$ ./useprecedencia.pl
----------------------------------------
In state 0:
Stack:[0]
Don't need token.
Reduce using rule 1 (list,0): Back to state 0, then go to state 1.
\end{verbatim}
Lo primero que ocurre es una reducción por la regla 
en la que \verb|list| produce vacío. Si miramos el estado 0
del autómata vemos que contiene:
\begin{verbatim}
20 State 0:
21
22   $start -> . list $end (Rule 0)
23
24   $default  reduce using rule 1 (list)
25
26   list  go to state 1
\end{verbatim}
A continuación se transita desde 0 con \verb|list|
y se consume el primer terminal:
\begin{verbatim}
----------------------------------------
In state 1:
Stack:[0,1]
2@3@4
Need token. Got >NUMBER<
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 1, then go to state 2.
----------------------------------------
\end{verbatim}
En el estado 5 se reduce por la regla \verb|e -> NUMBER|.
Esto hace que se retire el estado 5 de la pila y se
transite desde el estado 1 viendo el símbolo \verb|e|:
\begin{verbatim}
In state 2:
Stack:[0,1,2]
Need token. Got >@<
Shift and go to state 6.
----------------------------------------
In state 6:
Stack:[0,1,2,6]
Need token. Got >NUMBER<
Shift and go to state 5.
----------------------------------------
In state 5:
Stack:[0,1,2,6,5]
Don't need token.
Reduce using rule 4 (e,1): Back to state 6, then go to state 8.
----------------------------------------
In state 8:
Stack:[0,1,2,6,8]
Need token. Got >@<
Reduce using rule 6 (e,3): Back to state 1, then go to state 2.
----------------------------------------
...
Accept.
\end{verbatim}
Obsérvese la resolución del conflicto en el estado 8

La presencia de conflictos, aunque no siempre, en muchos casos es debida
a la introducción de ambiguedad en la gramática. Si el conflicto 
es de desplazamiento-reducción se puede resolver explicitando 
alguna regla que rompa la ambiguedad. Los conflictos de
reducción-reducción suelen producirse por un diseño erróneo
de la gramática. En tales casos, suele ser mas adecuado
modificar la gramática.

\section{Generación interactiva de analizadores {\tt Yapp}}
En el siguiente código, la subrutina {\tt create\_yapp\_package} 
nos muestra como crear un analizador {\tt Yapp} en tiempo de ejecución.
Las dos líneas:
\begin{verbatim}
  my $p = new Parse::Yapp(input => $grammar);
  $p = $p->Output(classname => $name);
\end{verbatim}
crean una cadena en \verb|$p| conteniendo el código de 
la clase que implanta el analizador. Todo el truco está en hacer
\begin{verbatim}
  eval $p;
\end{verbatim}
para tener el paquete a mano:
\begin{verbatim}
$ cat left.pl
#!/usr/local/bin/perl5.8.0 -w
#use strict;
use Parse::Yapp;

sub lex{
    my($parser)=shift;

    return('',undef) unless $parser->YYData->{INPUT};
    for ($parser->YYData->{INPUT}) {
        s/^\s*//;
        s/^(.)//;
        my $ret = $1;
        return($ret, $ret);
    }
}

sub yapp {
  my $grammar = shift
     or die "Must specify a grammar as first argument";
  my $name = shift
     or die "Must specify the name of the class as second argument";

  my $p = new Parse::Yapp(input => $grammar) or die "Bad grammar.";
  $p = $p->Output(classname => $name) or die "Can't generate parser.";

  eval $p;
  $@ and die "Error while compiling your parser: $@\n";
}

######## main #########
my $grammar = q {
%left '*'
%%
S:  A
;

A:  A '*' A  { "($_[1] $_[2] $_[3])" }
 |  B
;

B:  'a' | 'b' | 'c' | 'd'
;

%%
};

&yapp($grammar, "Example");
my $p = new Example(yylex => \&lex, yyerror => sub {});

print "Expresion: ";
$p->YYData->{INPUT} = <>;
$p->YYData->{INPUT} =~ s/\s*$//;

my $out=$p->YYParse;
print "out = $out\n";
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
$ ./left.pl
Expresion: a*b*c*d
out = (((a * b) * c) * d)
\end{verbatim}

\section{Construcción del Árbol Sintáctico}
El siguiente ejemplo usa \verb|yapp| 
para construir el árbol sintáctico de una expresión en infijo:
\begin{verbatim}
$ cat -n Infixtree_bless.yp
 1  #
 2  # Infixtree.yp
 3  #
 4
 5  %{
 6  use Data::Dumper;
 7  %}
 8  %right  '='
 9  %left   '-' '+'
10  %left   '*' '/'
11  %left   NEG
12
13  %%
14  input:  #empty
15          |   input line
16  ;
17
18  line:     '\n'         { $_[1] }
19          | exp '\n'     { print Dumper($_[1]); }
20          | error '\n'   { $_[0]->YYErrok }
21  ;
22
23  exp:        NUM
24          |   VAR                 { $_[1] }
25          |   VAR '=' exp         { bless [$_[1], $_[3]], 'ASSIGN' }
26          |   exp '+' exp         { bless [$_[1], $_[3] ], 'PLUS'}
27          |   exp '-' exp         { bless [$_[1], $_[3] ], 'MINUS'}
28          |   exp '*' exp         { bless [$_[1], $_[3]], 'TIMES' }
29          |   exp '/' exp         { bless [$_[1], $_[3]], 'DIVIDE' }
30          |   '-' exp %prec NEG   { bless [$_[2]], 'NEG' }
31          |   '(' exp ')'         { $_[2] }
32  ;
33
34  %%
35
36  sub _Error {
37          exists $_[0]->YYData->{ERRMSG}
38      and do {
39          print $_[0]->YYData->{ERRMSG};
40          delete $_[0]->YYData->{ERRMSG};
41          return;
42      };
43      print "Syntax error.\n";
44  }
45
46  sub _Lexer {
47      my($parser)=shift;
48
49          defined($parser->YYData->{INPUT})
50      or  $parser->YYData->{INPUT} = <STDIN>
51      or  return('',undef);
52
53      $parser->YYData->{INPUT}=~s/^[ \t]//;
54
55      for ($parser->YYData->{INPUT}) {
56          s/^([0-9]+(?:\.[0-9]+)?)//
57                  and return('NUM',$1);
58          s/^([A-Za-z][A-Za-z0-9_]*)//
59                  and return('VAR',$1);
60          s/^(.)//s
61                  and return($1,$1);
62      }
63  }
64
65  sub Run {
66      my($self)=shift;
67      $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
68  }
\end{verbatim}
Para compilar hacemos:
\begin{verbatim}
$ yapp -m Infixtree Infixtree_bless.yp
\end{verbatim}
El guión que usa el analizador anterior es similar al que vimos en la 
sección \ref{section:ejemplodeuso}:
\begin{verbatim}
$ cat -n ./useinfixtree.pl
     1  #!/usr/bin/perl -w
     2
     3  use Infixtree;
     4
     5  $parser = new Infixtree();
     6  $parser->Run;
\end{verbatim}
Veamos un ejemplo de ejecución:
\begin{verbatim}
$ ./useinfixtree.pl
a = 2+3
$VAR1 = bless( [
                 'a',
                 bless( [
                          '2',
                          '3'
                        ], 'PLUS' )
               ], 'ASSIGN' );
b = a*4+a
$VAR1 = bless( [
                 'b',
                 bless( [
                          bless( [
                                   'a',
                                   '4'
                                 ], 'TIMES' ),
                          'a'
                        ], 'PLUS' )
               ], 'ASSIGN' );
\end{verbatim}

\section{Acciones en Medio de una Regla}
A veces necesitamos insertar una acción en medio de una regla.
Una acción en medio de una regla puede hacer referencia a los atributos de
los símbolos que la preceden (usando \verb|$n|), pero no a los que le siguen.

Cuando se  inserta una acción $\left \{ action_1\right \}$
para su ejecución en medio de una regla $A \rightarrow \alpha
\beta$ :
\begin{center}
$A \rightarrow \alpha \left \{ action_1 \right \} \beta \left \{ action_2\right \}$ 
\end{center}
\verb|yapp| crea una variable sintáctica temporal $T$ e introduce una nueva regla:

\begin{center}
\begin{enumerate}
\item
$A \rightarrow \alpha T \beta \left \{ action_2\right \}$ 
\item
$T \rightarrow \epsilon \left \{ action_1 \right \}$ 
\end{enumerate}
\end{center}

Las acciones en mitad de una regla cuentan como un símbolo mas en la parte 
derecha de la regla. Asi pues, en una acción posterior en la regla,
se deberán referenciar los  atributos de los símbolos, teniendo en cuenta este hecho.

Las acciones en mitad de la regla pueden tener un atributo. 
Las acciones posteriores
en la regla se referirán a él como \verb|$_[n]|, siendo \verb|n| su número de orden
en la parte derecha. 

\section{Esquemas de Traducción}
Un \cei{esquema de traducción} es una gramática independiente del
contexto en la cuál se han asociado atributos a los símbolos de la gramática.
Un atributo queda caracterizado por un identificador
o nombre y un tipo o clase. Además se han insertado acciones, esto es,
código Perl/Python/C, \ldots en medio de las partes derechas.
En ese código es posible referenciar los atributos de los
símbolos de la gramática como variables del lenguaje subyacente.

Recuerde que el orden en que se evalúan los fragmentos de código
es el de un recorrido primero-profundo del árbol de análisis sintáctico.
Mas específicamente, considerando a las acciones como hijos-hoja del nodo,
el recorrido que realiza un esquema de traducción es:

\begin{verbatim}
 1     sub esquema_de_traduccion {
 2       my $node = shift;
 3 
 4       for my $child ($node->children) { # de izquierda a derecha
 5         if ($child->isa('ACTION') {
 6           $child->execute;
 7         }
 8         else { esquema_de_traduccion($child) }
 9       }
10     }
\end{verbatim}

Obsérvese que, como el bucle de la línea 4 recorre a los hijos
de izquierda a derecha, se debe dar la siguiente
condición para que un esquema  de traducción funcione:

Para cualquier regla de producción aumentada con acciones, de la forma 

\begin{center}
$A \rightarrow X_1 \ldots X_j$\verb|{ action($A{b}, $X|$_1$\verb|{c}|$ \ldots$\verb| X|$_n$\verb|{d})}|$X_{j+1} \ldots X_n$
\end{center}

debe ocurrir que los atributos evaluados en
la acción insertada después de $X_j$ 
dependan de atributos y variables que fueron computadas durante
la visita de los hermanos izquierdos o de sus ancestros.
En particular no deberían depender de atributos asociados
con las variables $X_{j+1} \ldots X_n$. Ello no significa que
no sea correcto evaluar atributos de $X_{j+1} \ldots X_n$
en esa acción.

\section{Definición Dirigida por la Sintáxis}
Una \cei{definición dirigida por la sintáxis} es un pariente cercano
de los esquemas de traducción. En una definición dirigida por la
sintáxis una gramática $G = (V, \Sigma, P, S)$ se aumenta 
con nuevas características:
\begin{itemize}
\item
A cada símbolo $S \in V \cup \Sigma$ de la gramática se le asocian
cero o mas atributos. Un atributo queda caracterizado por un identificador
o nombre y un tipo o clase. A este nivel son \cei{atributos formales},
como los parámetros formales, en el sentido de que su realización 
se produce cuando el nodo del árbol es creado.
\item
A cada regla de producción $A \rightarrow X_1 X_2 \ldots X_n \in P$
se le asocian un conjunto de \cei{reglas de evaluación de los atributos}
o \cei{reglas semánticas} que indican que el atributo en la parte
izquierda de la regla semántica depende de los atributos que aparecen en la parte
derecha de la regla. El atributo que aparece en la parte izquierda de la regla semántica
puede estar asociado con un símbolo en la parte derecha de la regla de producción.
\item
Los atributos de cada símbolo de la gramática $X \in V \cup \Sigma$
se dividen en dos grupos disjuntos: \cei{atributos sintetizados}
y \cei{atributos heredados}. Un atributo de $X$ es un \cei{atributo heredado} 
si depende de atributos de su padre y hermános en el árbol.
Un \cei{atributo sintetizado} es aquél tal que el valor del atributo depende
de los valores de los atributos de los hijos, 
es decir en tal caso $X$ ha de ser una variable sintáctica
y los atributos en la parte derecha de la regla semántica deben
ser atributos de símbolos en la parte derecha de la regla de producción 
asociada.
\item
Los atributos predefinidos se denominán \cei{atributos intrínsecos}.
Ejemplos de atributos intrínsecos son los atributos 
sintetizados de los terminales, los cuáles se han
computado durante la fase de análisis léxico. También
son atributos intrínsecos los atributos heredados del símbolo
de arranque, los cuales son pasados como parámetros 
al comienzo de la computación.
\end{itemize}

La diferencia principal con un esquema de traducción está en que
no se especifica el orden de ejecución de las reglas semánticas.
Se asume que, bien de forma manual o automática, se resolverán
las dependencias existentes entre los atributos determinadas
por la aplicación de las reglas semánticas, de manera
que serán evaluados primero aquellos atributos que no dependen
de ningún otro, despues los que dependen de estos, etc. siguiendo
un esquema de ejecución que viene guiado por las dependencias
existentes entre los datos.

Aunque hay muchas formas de realizar un evaluador de una definición
dirigida por la sintáxis, conceptualmente, tal evaluador debe:

\begin{enumerate}
\item
Construir el árbol de análisis sintáctico para la gramática
y la entrada dadas.
\item
Analizar las reglas semánticas para determinar los atributos,
su clase y las dependencias entre los mismos.
\item
Construir el \cei{grafo de dependencias} de los atributos,
el cual tiene
un nodo para cada ocurrencia de un atributo en el árbol de análisis
sintáctico etiquetado con dicho atributo. El grafo tiene una arista entre dos
nodos si existe una dependencia entre los dos atributos a través de alguna
regla semántica. 
\item
Supuesto que el grafo de dependencias determina un \cei{orden parcial}
(esto es cumple las propiedades reflexiva, antisimétrica y transitiva) 
construir un \cei{orden topológico} compatible con el orden parcial.
\item
Evaluar las reglas semánticas de acuerdo con el orden topológico.
\end{enumerate}

Una definición dirigida por la sintáxis en la que las reglas semánticas
no tienen efectos laterales se denomina una \cei{gramática atribuída}.

Si la definición dirigida por la sintáxis puede ser realizada 
mediante un esquema de traducción se dice que es \cei{L-atribuída}.
Para que una definición dirigida por la sintáxis sea L-atribuída
deben cumplirse que cualquiera que sea la regla de producción
$A \rightarrow X_1 \ldots X_n$, los atributos heredados de
$X_j$ pueden depender únicamente de:
\begin{enumerate}
\item
Los atributos de los símbolos a la izquierda de $X_j$
\item
Los atributos heredados de $A$
\end{enumerate}

Nótese que las restricciones se refieren a los atributos heredados.
El cálculo de los atributos sintetizados no supone 
problema para un esquema de traducción. Si la gramática
es LL(1), resulta fácil realizar una definición 
L-atribuída en un analizador descendente recursivo predictivo.

Si la definición dirigida por la sintáxis sólo utiliza 
atributos sintetizados se denomina \cei{S-atribuída}. Una
definición S-atribuída puede ser fácilmente trasladada a un programa
\verb|yapp|.

\section{Manejo en {\tt yapp} de Atributos Heredados}
\label{section:heredados}
Supongamos  que \verb|yapp| esta inmerso 
en la construcción de la antiderivación a derechas y que la forma sentencial
derecha en ese momento es:

\begin{center}
$X_m \ldots X_1 X_0 Y_1 \ldots  Y_n a_1 \ldots a_0$
\end{center}

y que el mango es $B \rightarrow Y_1 \ldots  Y_n$ y en la entrada quedan por 
procesar $a_1 \ldots a_0$.

Es posible acceder en \verb|yapp| a los valores de los atributos de los estados en la pila
del analizador que se encuentran ``por debajo'' o si se quiere
``a la izquierda'' de los estados asociados
con la regla por la que se reduce. Para ello se usa una llamada al método
\cei{{\tt YYSemval}}. La llamada es de la forma 
\verb|$_[0]->YYSemval( index )|, donde \verb|index| es un entero.
Cuando se usan los valores \verb|1| \ldots \verb|n| devuelve lo mismo
que \verb|$_[1]|, \ldots \verb|$_[n]|. Esto es 
\verb|$_[1]| es el atributo asociado con $Y_1$ y \verb|$_[n]| es el atributo
asociado con $Y_n$.  Cuando se usa con el valor
0 devolverá el valor del atributo asociado con el símbolo que esta a la izquierda 
del mango actual, esto es el atributo asociado con $X_0$, 
si se llama con -1 el que está dos unidades a la izquierda de la variable actual, 
esto es, el asociado con $X_1$ etc. Así \verb|$_[-m]| denota el atributo
de $X_m$.

Esta forma de acceder a los atributos es especialmente útil cuando se 
trabaja con \cei{atributos heredados}. Esto es, cuando un atributo
de un nodo del árbol sintáctico se computa en términos
de valores de atributos de su padre y/o sus hermanos.
Ejemplos de atributos heredados son la clase y tipo en la declaración
de variables. Supongamos que tenemos el siguiente 
\cei{esquema de traducción} para calcular la clase (C) y tipo (T) en 
las declaraciones (D) de listas (L) de identificadores:

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|ll|}
\hline
D $\rightarrow$& C T \verb|{ $L{c} = $C{c}; $L{t} = $T{t} }| L\\
C $\rightarrow$& global   \verb|{ $C{c} = "global" }|\\
C $\rightarrow$& local    \verb|{ $C{c} = "local" }|\\
T $\rightarrow$& integer  \verb|{ $T{t} = "integer" }|\\
T $\rightarrow$& float    \verb|{ $T{t} = "float" }|\\
L $\rightarrow$& \verb|{ $L|$_1$\verb|{t} = $L{t}; $L|$_1$\verb|{c} = $L{c}; }| L$_1$ ','\\
               & id \verb|{ set_class($id{v}, $L{c}); set_type($id{v}, $L{t}); }|\\
L $\rightarrow$& id   \verb|{ set_class($id{v}, $L{c}); set_type($id{v}, $L{t}); }|\\
\hline
\end{tabular}
\end{center}
\vspace{0.25cm}

Los atributos \verb|c| y \verb|t| denotan respectivamente
la clase y el tipo. 

\begin{exercise}
Evalúe el esquema de traducción para la entrada
\verb|global float x,y|. Represente el árbol de análisis, las
acciones incrustadas y determine el orden de ejecución.

Olvide por un momento la notación usada en las acciones y 
suponga que se tratara de acciones \verb|yapp|. ¿En que orden
construye \verb|yapp| el árbol y en que orden ejecutará las
acciones?
\end{exercise}

A la hora de transformar este esquema de traducción en un programa
\verb|yapp| es importante darse cuenta que en cualquier derivación a derechas
desde D, cuando se reduce por una de las reglas 

\begin{center}
L $\rightarrow$ id $|$ L$_1$  ',' id
\end{center}

el símbolo a la izquierda de L es T y el que esta a la izquierda de T es C.
Considere, por ejemplo la derivación a derechas:

\begin{center}
D $\Longrightarrow$ C T L $\Longrightarrow$ C T L, id $\Longrightarrow$ C T L, id, id
$\Longrightarrow$ C T id, id, id $\Longrightarrow$ \\
$\Longrightarrow$ C float id, id, id $\Longrightarrow$ local float id, id, id
\end{center}

\noindent Observe que el orden de recorrido de \verb|yapp| es:
\begin{center}
local float id, id, id $\Longleftarrow$ C float id, id $\Longleftarrow$
C T id, id, id $\Longleftarrow$\\
$\Longleftarrow$ C T L, id, id $\Longleftarrow$ C T L, id $\Longleftarrow$ C T L $\Longleftarrow$ D
\end{center}

\noindent en la antiderivación, cuando el mango es una de las dos reglas 
para listas de identificadores, L $\rightarrow$ id y L $\rightarrow$ L, id 
es decir durante las tres ultimas antiderivaciones:

\begin{center}
C T L, id, id $\Longleftarrow$ C T L, id $\Longleftarrow$ C T L $\Longleftarrow$ D
\end{center}

\noindent las variables a la izquierda del mango son
T y C. Esto ocurre siempre. 
Estas observaciones nos conducen al siguiente
programa \verb|yapp|: 

\begin{verbatim}
$ cat -n Inherited.yp
 1  %token FLOAT INTEGER
 2  %token GLOBAL
 3  %token LOCAL
 4  %token NAME
 5
 6  %%
 7  declarationlist
 8    : # vacio
 9    | declaration ';' declarationlist
10    ;
11
12  declaration
13    : class type namelist { ; }
14    ;
15
16  class
17    : GLOBAL
18    | LOCAL
19    ;
20
21  type
22    : FLOAT
23    | INTEGER
24    ;
25
26  namelist
27    : NAME
28       { printf("%s de clase %s, tipo %s\n",
29               $_[1], $_[0]->YYSemval(-1),$_[0]->YYSemval(0)); }
30    | namelist ',' NAME
31        { printf("%s de clase %s, tipo %s\n",
32                 $_[3], $_[0]->YYSemval(-1),$_[0]->YYSemval(0)); }
33    ;
34  %%
\end{verbatim}

A continuación escribimos el programa que usa 
el módulo generado por \verb|yapp|:

\begin{verbatim}
$ cat -n useinherited.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3  use Inherited;
 4
 5  sub Error {
 6    exists $_[0]->YYData->{ERRMSG}
 7    and do {
 8      print $_[0]->YYData->{ERRMSG};
 9      delete $_[0]->YYData->{ERRMSG};
10      return;
11    };
12    print "Error sintáctico\n";
13  }
14
15  { # hagamos una clausura con la entrada
16    my $input;
17    local $/ = undef;
18    print "Entrada (En Unix, presione CTRL-D para terminar):\n";
19    $input = <stdin>;
20
21    sub scanner {
22
23      { # Con el redo del final hacemos un bucle "infinito"
24        if ($input =~ m|\G\s*INTEGER\b|igc) {
25          return ('INTEGER', 'INTEGER');
26        }
27        elsif ($input =~ m|\G\s*FLOAT\b|igc) {
28          return ('FLOAT', 'FLOAT');
29        }
30        elsif ($input =~ m|\G\s*LOCAL\b|igc) {
31          return ('LOCAL', 'LOCAL');
32        }
33        elsif ($input =~ m|\G\s*GLOBAL\b|igc) {
34          return ('GLOBAL', 'GLOBAL');
35        }
36        elsif ($input =~ m|\G\s*([a-z_]\w*)\b|igc) {
37          return ('NAME', $1);
38        }
39        elsif ($input =~ m/\G\s*([,;])/gc) {
40          return ($1, $1);
41        }
42        elsif ($input =~ m/\G\s*(.)/gc) {
43          die "Caracter invalido: $1\n";
44        }
45        else {
46          return ('', undef); # end of file
47        }
48        redo;
49      }
50    }
51  }
52
53  my $debug_level = (@ARGV)? oct(shift @ARGV): 0x1F;
54  my $parser = Inherited->new();
55  $parser->YYParse( yylex => \&scanner, yyerror => \&Error, yydebug => $debug_level );
\end{verbatim}
En las líneas de la 15 a la 51 esta nuestro analizador léxico.
La entrada se lee en una variable local cuyo valor permanece
entre llamadas: hemos creado una clausura con la variable
\verb|$input| (véase la sección \eref{section:clausura} para mas detalles
sobre el uso de clausuras en Perl). Aunque la variable \verb|$input|
queda inaccesible desde fuera de la clausura, persiste entre llamadas
como consecuencia de que la subrutina \verb|scanner| la utiliza.

A continuación sigue un ejemplo de ejecución:

\begin{verbatim}
$ ./useinherited.pl 0
Entrada (En Unix, presione CTRL-D para terminar):
global integer x, y, z;
local float a,b;
x de clase GLOBAL, tipo INTEGER
y de clase GLOBAL, tipo INTEGER
z de clase GLOBAL, tipo INTEGER
a de clase LOCAL, tipo FLOAT
b de clase LOCAL, tipo FLOAT
\end{verbatim}

\begin{exercise}
El siguiente programa \verb|yapp| calcula 
un árbol de análisis abstracto para la gramática
del ejemplo anterior:
\begin{verbatim}
%token FLOAT INTEGER 
%token GLOBAL 
%token LOCAL 
%token NAME

%%
declarationlist 
  : /* vacio */                     { bless [], 'declarationlist' } 
  | declaration ';' declarationlist { push @{$_[3]}, $_[1]; $_[3] }
  ;

declaration
  : class type namelist 
      { 
        bless {class => $_[1], type => $_[2], namelist => $_[3]}, 'declaration'; 
      }
  ;

class
  : GLOBAL  { bless { GLOBAL => 0}, 'class' } 
  | LOCAL   { bless { LOCAL => 1}, 'class' }
  ;

type
  : FLOAT   { bless { FLOAT => 2}, 'type' } 
  | INTEGER { bless { INTEGER => 3}, 'type' }
  ;

namelist
  : NAME  
     { bless [ $_[1]], 'namelist' }
  | namelist ',' NAME 
      { push @{$_[1]}, $_[3]; $_[1] }
  ;
%%
\end{verbatim}
sigue un ejemplo de ejecución:
\begin{verbatim}
$ ./useinherited3.pl
Entrada (En Unix, presione CTRL-D para terminar):
global float x,y;
$VAR1 = bless( [
  bless( {
    'namelist' => bless( [ 'x', 'y' ], 'namelist' ),
    'type' => bless( { 'FLOAT' => 2 }, 'type' ),
    'class' => bless( { 'GLOBAL' => 0 }, 'class' )
  }, 'declaration' )
], 'declarationlist' );
\end{verbatim}

Extienda el programa del ejemplo para que la gramática 
incluya las acciones del esquema de traducción.
Las acciones se tratarán como un terminal \verb|CODE|
y serán devueltas por el analizador léxico. Su atributo
asociado es el texto del código. El programa 
\verb|yapp| deberá devolver el árbol abstracto
extendido con las acciones-terminales.
La parte mas difícil de este problema consiste en ``reconocer''
el código Perl incrustado. La estrategia seguir consiste
en contar el número de llaves que se abren y se cierran.
Cuando el contador alcanza cero es que hemos llegado
al final del código Perl incrustado. Esta estrategia
tiene una serie de problemas. ¿Sabría decir cuáles?
(sugerencia: repase la sección \ref{subsection:elcuerpo} 
o vea como \verb|yapp| resuelve el problema).
\end{exercise}

\section{Acciones en Medio de una Regla y Atributos Heredados}
\label{section:mediaregla}
La estrategia utilizada en la sección \ref{section:heredados} funciona
si podemos predecir la posición del atributo en la pila del analizador.
En el ejemplo anterior los atributos clase y tipo estaban siempre,
cualquiera que fuera la derivación a derechas, 
en las posiciones 0 y -1. Esto no siempre es asi. Consideremos
la siguiente \cei{definición dirigida por la sintáxis}:

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|l|l|}
\hline
S $\rightarrow$ a A C   & \verb|$C{i} = $A{s}|\\
\hline
S $\rightarrow$ b A B C & \verb|$C{i} = $A{s}|\\
\hline
C $\rightarrow$ c       & \verb|$C{s} = $C{i}|\\
\hline
A $\rightarrow$ a       & \verb|$A{s} = "a"|\\
\hline
B $\rightarrow$ b       & \verb|$B{s} = "b"|\\
\hline
\end{tabular}
\end{center}
\vspace{0.25cm}


\begin{exercise}
Determine un orden correcto de evaluación de la anterior
definición dirigida por la sintáxis para la entrada \verb|b a b c|.
\end{exercise}

C hereda el atributo sintetizado de A. El problema es que, en la pila
del analizador el atributo \verb|$A{s}| puede estar en la posición 0 
o -1 dependiendo de si la regla por la que se derivó fué
S $\rightarrow$ a A C o bien S $\rightarrow$ b A B C. La solución
a este tipo de problemas consiste en insertar acciones 
intermedias de copia del atributo de manera que se garantize que el atributo
de interés está siempre a una distancia fija. Esto es, se inserta
una variable sintáctica intermedia auxiliar M la cual deriva a vacío
y que tiene como acción asociada una regla de copia:

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|l|l|}
\hline
S $\rightarrow$ a A C   & \verb|$C{i} = $A{s}|\\
\hline
S $\rightarrow$ b A B M C & \verb|$M{i} = $A{s}; $C{i} = $M{s}|\\
\hline
C $\rightarrow$ c       & \verb|$C{s} = $C{i}|\\
\hline
A $\rightarrow$ a       & \verb|$A{s} = "a"|\\
\hline
B $\rightarrow$ b       & \verb|$B{s} = "b"|\\
\hline
M $\rightarrow \epsilon$& \verb|$M{s} = $M{i}|\\
\hline
\end{tabular}
\end{center}
\vspace{0.25cm}

El nuevo esquema de traducción puede ser implantado mediante
un programa \verb|yapp|:

\begin{verbatim}
$ cat -n Inherited2.yp
     1  %%
     2  S : 'a' A C
     3    | 'b' A B  { $_[2]; } C
     4    ;
     5
     6  C : 'c' { print "Valor: ",$_[0]->YYSemval(0),"\n"; $_[0]->YYSemval(0) }
     7    ;
     8
     9  A : 'a' { 'a' }
    10    ;
    11
    12  B : 'b' { 'b' }
    13    ;
    14
    15  %%
\end{verbatim}

La ejecución muestra como se ha propagado el valor del atributo:
\begin{verbatim}
$ ./useinherited2.pl '0x04'
Entrada (En Unix, presione CTRL-D para terminar):
b a b c
Shift 2.  Shift 6.
Reduce using rule 5 (A,1): Back to state 2, then state 5.
Shift 8.
Reduce 6 (B,1): Back to state 5, then state 9.
Reduce 2 (@1-3,0): Back to state 9, then state 12.
\end{verbatim}

En este momento se esta ejecutando la acción intermedia.
Lo podemos comprobar revisando el fichero \verb|Inherited2.output|
que fué generado usando la opción \verb|-v| al llamar a \verb|yapp|.
La regla 2 por la que se reduce es la asociada con la acción 
intermedia:

\begin{verbatim}
$ cat -n Inherited2.output
     1  Rules:
     2  ------
     3  0:      $start -> S $end
     4  1:      S -> 'a' A C
     5  2:      @1-3 -> /* empty */
     6  3:      S -> 'b' A B @1-3 C
     7  4:      C -> 'c'
     8  5:      A -> 'a'
     9  6:      B -> 'b'
        ...
\end{verbatim}

Obsérvese la notación usada por \verb|yapp| para la 
\cei{acción en medio de la regla}: \verb|@1-3|.
Continuamos con la antiderivación:

\begin{verbatim}
Shift 10.
Reduce 4 (C,1): 
Valor: a
Back to state 12, then 13.
Reduce using rule 3 (S,5): Back to state 0, then state 1.
Shift 4.
Accept.
\end{verbatim}

El método puede ser generalizado a casos en los
que el atributo de interés este a diferentes distancias en
diferentes reglas sin mas que introducir las correspondientes
acciones intermedias de copia.

\section{Recuperación de Errores}
\label{section:errores}
Las entradas de un traductor pueden contener errores. 
El lenguaje \verb|yapp| proporciona un \emph{token} especial,
\verb|error|, que puede ser utilizado en el programa fuente
para extender el traductor con ``producciones de error'' 
que lo doten de cierta capacidad para 
recuperase de  una entrada errónea y poder continuar 
analizando el resto de la entrada.

Consideremos lo que ocurre al ejecutar nuestra calculadora
\verb|yapp| con una entrada errónea. Recordemos 
la gramática:

\begin{verbatim}
 9  %right  '='
10  %left   '-' '+'
11  %left   '*' '/'
12  %left   NEG
13  %right  '^'
14
15  %%
16  input:  # empty
17          |   input line  { push(@{$_[1]},$_[2]); $_[1] }
18  ;
19
20  line:       '\n'       { $_[1] }
21          |   exp '\n'   { print "$_[1]\n" }
22          |   error '\n' { $_[0]->YYErrok }
23  ;
\end{verbatim}

La regla \verb|line |$\rightarrow$ \verb|error '\n'| es una producción de
error. La idea general de uso es que, a traves de la misma, el programador 
le indica a \verb|yapp| que, cuando se produce un error
dentro de una expresión, descarte todos los \emph{tokens} hasta llegar al
retorno del carro y prosiga con el análisis. 
Además, mediante la llamada al método \verb|YYErrok| el programador
anuncia que, si se alcanza este punto, la recuperación puede considerarse 
``completa''  y que \verb|yapp| puede emitir a partir de ese momento 
mensajes de error
con la seguridad de que no son consecuencia de un comportamiento inestable
provocado por el primer error.

El resto de la gramática de la calculadora era como sigue:

\begin{verbatim}
24
25  exp:        NUM
26          |   VAR                 { $_[0]->YYData->{VARS}{$_[1]} }
27          |   VAR '=' exp         { $_[0]->YYData->{VARS}{$_[1]}=$_[3] }
28          |   exp '+' exp         { $_[1] + $_[3] }
29          |   exp '-' exp         { $_[1] - $_[3] }
30          |   exp '*' exp         { $_[1] * $_[3] }
31          |   exp '/' exp         {
32                                    $_[3]
33                                    and return($_[1] / $_[3]);
34                                    $_[0]->YYData->{ERRMSG}
35                                      =   "Illegal division by zero.\n";
36                                    $_[0]->YYError;
37                                    undef
38                                  }
39          |   '-' exp %prec NEG   { -$_[2] }
40          |   exp '^' exp         { $_[1] ** $_[3] }
41          |   '(' exp ')'         { $_[2] }
42  ;
\end{verbatim}
en la ejecución activamos el flag \verb|yydebug| a \verb|0x10| para 
obtener información sobre el tratamiento de errores:
\begin{verbatim}
$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => 0x10 );
\end{verbatim}
Pasemos a darle una primera entrada errónea:

\begin{verbatim}
$ ./usecalc.pl
3-+2
Syntax error.
**Entering Error recovery.
**Pop state 12.
**Pop state 3.
**Shift $error token and go to state 9.
**Dicard invalid token >+<.
**Pop state 9.
**Shift $error token and go to state 9.
**Dicard invalid token >NUM<.
**Pop state 9.
**Shift $error token and go to state 9.
**End of Error recovery.
\end{verbatim}


El esquema general del algoritmo de recuperación de errores usado 
por la versión actual de \verb|yapp| es el siguiente:

\begin{enumerate}
\item
Cuando se encuentra ante una acción de error, el analizador genera un 
\emph{token} \verb1error1.

\item
A continuación pasa a retirar estados de la pila hasta que descubre un
estado capaz de transitar ante el \emph{token} \verb1error1. 
En el ejemplo anterior el analizador estaba en el estado 12 y lo retira
de la pila. Los contenidos del estado 12 son:
\begin{verbatim}
	exp -> exp '-' . exp	(Rule 10)
	'('	shift 7 '-'	shift 2 NUM	shift 6 VAR	shift 8
	exp	go to state 21
\end{verbatim}
Obviamente no esperabamos ver un \verb|'+'| aqui. El siguiente
estado en la cima de la pila es el 3, el cual tampoco
tiene ninguna transición ante el terminal \verb|error|:

\begin{verbatim}
	line -> exp . '\n'	(Rule 4)
	exp -> exp . '+' exp	(Rule 9)
	exp -> exp . '-' exp	(Rule 10)
	exp -> exp . '*' exp	(Rule 11)
	exp -> exp . '/' exp	(Rule 12)
	exp -> exp . '^' exp	(Rule 14)

	'*'	shift 17 '+'	shift 13 '-'	shift 12 '/'	shift 15
	'\n'	shift 14 '^'	shift 16
\end{verbatim}
El pop sobre el estado 3 deja expuesto en la superficie al estado
1, el cuál ``sabe'' como manejar el error:
\begin{verbatim}
	$start -> input . $end	(Rule 0)
	input -> input . line	(Rule 2)

	$end	shift 4 '('	shift 7 '-'	shift 2 '\n'	shift 5
	NUM	shift 6 VAR	shift 8
	error	shift 9

	exp	go to state 3
	line	go to state 10
\end{verbatim}

\item
En este punto transita al estado correspondiente a desplazar el 
\emph{token} \verb1error1. 

En consecuencia, con lo dicho, en el ejemplo se va al estado 9:
\begin{verbatim}
	line -> error . '\n'	(Rule 5)
	'\n'	shift, and go to state 20
\end{verbatim}

\item
Entonces el algoritmo de recuperación va
leyendo \emph{tokens} y descartandolos hasta encontrar
uno que sea aceptable. En este caso hemos especificado
que el terminal que nos da cierta confianza de recuperación
es el retorno de carro:
\begin{verbatim}
**Dicard invalid token >+<.
**Pop state 9.
**Shift $error token and go to state 9.
**Dicard invalid token >NUM<.
**Pop state 9.
**Shift $error token and go to state 9.
**End of Error recovery.
\end{verbatim}

\item
Sólo se envían nuevos mensajes de error una vez asimilados (desplazados)
algunos símbolos terminales. De este modos se intenta evitar la aparición
masiva de mensajes de error.
\end{enumerate}

\section{Recuperación de Errores en Listas}
Aunque no existe un método exacto para decidir como ubicar
las reglas de recuperación de errores, 
en general, los s\'{\i}mbolos de error deben ubicarse intentado 
satisfacer las siguientes reglas:

\begin{itemize}
\item
Tan cerca como sea posible del s\'{\i}mbolo de arranque.
\item
Tan cerca como sea posible de los s\'{\i}mbolos terminales.
\item
Sin introducir nuevos conflictos.
\end{itemize}

En el caso particular de las listas, se recomienda seguir el
siguiente esquema:

\vspace{0.5cm}
\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Construcción       & EBNF & yapp\\
\hline
secuencia opcional & x:\{y\}   & \verb#x : /* null */             #\\ 
                   &           & \verb#  | x y  { $_[0]->YYErrok; }      #\\
                   &           & \verb#  | x error                #\\
\hline
secuencia          & x:y\{y\}  & \verb#x : y                      #\\ 
                  &           & \verb#  | xy   { $_[0]->YYErrok; }      #\\
                &           & \verb#  | error                  #\\
                &           & \verb#  | x error                #\\
\hline
lista              & x:y\{Ty\} & \verb#x : y                       #\\ 
                  &           & \verb#  | x T y { $_[0]->YYErrok; }      #\\
                &           & \verb#  | error                   #\\
                &           & \verb#  | x error                 #\\
                &           & \verb#  | x error y { $_[0]->YYErrok; }  #\\
                &           & \verb#  | x  T error              #\\
\hline
\end{tabular}
\end{center}
\caption{Recuperación de errores en listas}
\label{table:err}
\end{table}
\vspace{0.25cm}

\begin{exercise} 
Compruebe el funcionamiento de la metodología 
para la recuperación de errores en listas presentada
en la tabla \ref{table:err}
estudie el siguiente programa \verb|yapp| siguiendo la traza de estados,
generando entradas con todos los tipos de error posibles.
¿Cómo se recupera el analizador en caso de existencia de un segundo
error? ¿Que ocurre si dos errores consecutivos 
están muy próximos?
El programa corresponde al tercer caso de la tabla \ref{table:err}, 
el caso x:y\{Ty\} con 
x = {\tt list}, T = {\tt ','} e y = {\tt NUMBER}:
\begin{verbatim}
%token NUMBER
%%
command 
  : 
  | command list '\n' { $_[0]->YYErrok; } 
  ;

list 
    : NUMBER            { put($1); }
    | list ',' NUMBER   { put($3); $_[0]->YYErrok; }
    | error             { err(1); }
    | list error        { err(2); }
    | list error NUMBER { err(3); put($3); $_[0]->YYErrok; }
    | list ',' error    { err(4); }
    ;
    
%%    
sub put { my $x = shift; printf("%2.1lf\n",$x); }
sub err { my $code = shift; printf("err %d\n",$code); }
 ...
\end{verbatim} 
\end{exercise} 

\section{Consejos a seguir al escribir un programa {\tt yapp}}
\label{section:consejosyapp}
Cuando escriba un programa \verb|yapp| asegurese
de seguir los siguientes consejos:

\begin{enumerate}
\item
Coloque el punto y coma de separación de reglas en una línea aparte.
Un punto y coma ``pegado'' al final de una regla puede confundirse
con un terminal de la regla.

\item
Si hay una regla que produce vacío, coloquela en primer lugar y acompáñela de 
un comentario resaltando ese hecho.
\item
Nunca escriba dos reglas de producción en la misma línea.
\item
Sangre convenientemente todas las partes derechas de las reglas
de producción de una variable, de modo que queden
alineadas.
\item
Ponga nombres representativos a sus variables sintácticas. No llame 
\verb|Z| a una variable que representa el concepto ``lista de parámetros'',
llámela \verb|ListaDeParametros|.
\item
Es conveniente que declare los terminales simbólicos, esto es, aquellos que 
llevan un identificador asociado. Si no llevan prioridad asociada o no 
es necesaria, use una declaración \verb|%token|. De esta manera
el lector de su programa se dará cuenta rápidamente que dichos identificadores
no se corresponden con variables sintácticas. Por la misma razón,
si se trata de terminales
asociados con caracteres o cadenas no es tan necesario que los declare, 
a menos que, 
como en el ejemplo de la calculadora para \verb|'+'| y \verb|'*'|,
sea necesario asociarles una
precedencia.
\item
Es importante que use la opción \verb|-v| para producir
el fichero \verb|.output| conteniendo información detallada sobre
los conflictos y el autómata. Cuando haya un conflicto shift-reduce
no resuelto busque en el fichero el estado implicado y 
vea que LR(0) items $A \rightarrow \alpha_\uparrow$
y $B \rightarrow \beta_\uparrow \gamma$ entran en conflicto.

\item
\label{item:conflictos}
Si según el informe de \verb|yapp|
el conflicto se produce ante un terminal $a$,
es porque $a \in FOLLOW(A)$ y
$a \in FIRST(\gamma)$. Busque las causas por las que esto ocurre 
y modifique su gramática con vistas a eliminar la presencia
del terminal $a$ en uno de los dos conjuntos implicados
o bien establezca reglas de prioridad entre los terminales
implicados que resuelvan el conflicto.

\item
Nótese que cuando existe un conflicto de desplazamiento 
reducción entre $A \rightarrow \alpha_\uparrow$ 
y  $B \rightarrow \beta_\uparrow \gamma$, el programa
\verb|yapp| contabiliza un error por cada terminal 
$a \in FOLLOW(A) \cap FIRST(\gamma)$. Por esta razón,
si hay 16 elementos en $FOLLOW(A) \cap FIRST(\gamma)$,
el analizador \verb|yapp| informará de la existencia
de 16 conflictos \emph{shift-reduce},
cuando en realidad se trata de uno sólo. No desespere, 
los conflictos ``auténticos'' suelen
ser menos de los que \verb|yapp| anuncia.

\item
Si necesita declarar variables globales, inicializaciones, etc.
que afectan la conducta global del analizador, escriba el código 
correspondiente en la cabecera del analizador, protegido
por los delimitadores \verb|%{| y \verb|%}|. Estos delimitadores
deberán aparecer en una línea aparte. Por ejemplo:

\begin{verbatim}
%{
our contador = 0;
%}

%token NUM
...
%%
\end{verbatim}

\item
Si tiene problemas en tiempo de ejecución con el comportamiento del análizador
sintáctico use la opción \verb|yydebug => 0x1F| en la llamada al analizador.

\item
Si trabaja en windows y pasa los ficheros a unix tenga cuidado con la posible
introducción de caractéres espúreos en el fichero. Debido
a la presencia de caractéres de control invisibles, el analizador \verb|yapp| 
pasará a rechazar una gramatica aparentemente correcta.

\item
Sea consciente de que los analizadores sintáctico y  léxico mantienen
una relación de corutinas en \verb|yapp|: Cada vez que 
el analizador sintáctico necesita un nuevo terminal para decidir que regla de
producción se aplica, llama al analizador léxico, el cuál deberá retornar el siguiente
terminal. La estrategia es diferente de la utilizada en el ejemplo
usado para el lenguaje Tutu en el capítulo 
\ref{chapter:introcomp}. Allí generabamos en una primera fase
la lista de terminales. Aquí los terminales se generan  de uno en uno
y cada vez que se encuentra uno nuevo se retorna al analizador sintáctico.
La ventaja que tiene este método es que permite colaborar al analizador sintáctico
y al analizador léxico para ``dinámicamente'' modificar la conducta 
del análisis léxico. Por ejemplo en los compiladores del lenguaje C
es común hacer que el analizador léxico cuando descubre un identificador que 
previamente ha sido declarado como identificador de tipo (mediante 
el uso de \verb|typedef|) retorne un terminal \verb|TYPENAME| 
diferente del terminal \verb|ID|
que caracteriza a los identificadores. Para ello, el analizador
sintáctico, cuando detecta una tal declaración, ``avisa'' al analizador 
léxico para que modifique su conducta. El analizador sintáctico volverá
a avisarlo cuando la declaración del identificador como
identificador de tipo salga de ámbito y pierda
su especial condición.  

\item
En \verb|yapp| el analizador sintáctico espera que el analizador
léxico devuelva de cada vez una pareja formada por dos escalares.
El primer escalar es la cadena que designa el terminal. A diferencia
de la habitual costumbre \verb|yacc| de codificar los terminales
como enteros, en \verb|yapp| se suelen codificar como cadenas.
La segunda componente de la pareja es el atributo asociado con el terminal.
Si el atributo es un atributo complejo que necesitas representar
mediante un hash o un vector, lo mejor es hacer que esta componente
sea una referencia al objeto describiendo el atributo.
El analizador léxico le indica al sintáctico la
finalización de la entrada enviándole la pareja 
\verb|('',undef)| formada por la palabra vacía con atributo \verb|undef|.

\item
Hay fundamentalmente dos formas de hacer el analizador
léxico: hacerlo destructivo o no destructivo.
En los destructivos se usa el operador de sustitución \verb|s|
(véase el ejemplo de la sección 
\ref{section:ejemplodeuso}), en cuyo caso la entrada procesada
es retirada de la cadena leída.
En los no destructivos utilizamos el operador
de emparejamiento \verb|m|. Véase 
el ejemplo de analizador léxico en
la sección \ref{section:heredados}
(concretamente la subrutina \verb|scanner| en la 
línea 20 del fichero \verb|useinherited.pl|)
\end{enumerate}

\begin{example}
Consideremos de nuevo el programa \verb|yapp| para producir
árboles para las expresiones en infijo. Supongamos que olvidamos
introducir una prioridad explícita al terminal \verb|'='|:
\begin{verbatim}
$ cat -n Infixtree_conflict.yp
 1  #
 2  # Infixtree.yp
 3  #
 4
 5  %{
 6  use Data::Dumper;
 7  %}
 8  %left   '-' '+'
 9  %left   '*' '/'
10  %left   NEG
11
12  %%
13  input:  #empty
14          |   input line
15  ;
16
17  line:     '\n'         { $_[1] }
18          | exp '\n'     { print Dumper($_[1]); }
19          | error '\n'   { $_[0]->YYErrok }
20  ;
21
22  exp:        NUM
23          |   VAR                 { $_[1] }
24          |   VAR '=' exp         { bless [$_[1], $_[3]], 'ASSIGN' }
25          |   exp '+' exp         { bless [$_[1], $_[3] ], 'PLUS'}
26          |   exp '-' exp         { bless [$_[1], $_[3] ], 'MINUS'}
27          |   exp '*' exp         { bless [$_[1], $_[3]], 'TIMES' }
28          |   exp '/' exp         { bless [$_[1], $_[3]], 'DIVIDE' }
   ....
\end{verbatim}
en este caso al compilar encontraremos conflictos:
\begin{verbatim}
$ yapp -v -m Infixtree Infixtree_conflict.yp
4 shift/reduce conflicts
\end{verbatim}
En tal caso lo que debemos hacer es editar el fichero \verb|.output|.
El comienzo del fichero es como sigue:
\begin{verbatim}
$ cat -n Infixtree_conflict.output
1  Warnings:
2  ---------
3  4 shift/reduce conflicts
4
5  Conflicts:
6  ----------
7  Conflict in state 11 between rule 13 and token '-' resolved as reduce.
8  Conflict in state 11 between rule 13 and token '*' resolved as reduce.
  ...
\end{verbatim}
Tal y como indica la expresión \ldots \verb|resolved as| \ldots,
las líneas como la 7, la 8 y siguientes se refieren a conflictos resueltos.
Mas abajo encontraremos información sobre 
la causa de nuestros conflictos no resueltos:
\begin{verbatim}
    ...
26  Conflict in state 23 between rule 11 and token '/' resolved as reduce.
27  State 25 contains 4 shift/reduce conflicts
\end{verbatim}
Lo que nos informa que los conflictos 
ocurren en el estado 25 ante 4 terminales
distintos. Nos vamos a la parte del fichero 
en la que aparece la información relativa al estado 25. Para ello,
como el fichero es grande, buscamos por la cadena adecuada.
En \verb|vi| buscaríamos por \verb|/^State 25|. Las líneas
correspondientes contienen:

\begin{verbatim}
291 State 25:
292
293   exp -> VAR '=' exp .  (Rule 8)
294   exp -> exp . '+' exp  (Rule 9)
295   exp -> exp . '-' exp  (Rule 10)
296   exp -> exp . '*' exp  (Rule 11)
297   exp -> exp . '/' exp  (Rule 12)
298
299   '*' shift, and go to state 16
300   '+' shift, and go to state 13
301   '-' shift, and go to state 12
302   '/' shift, and go to state 15
303
304   '*' [reduce using rule 8 (exp)]
305   '+' [reduce using rule 8 (exp)]
306   '-' [reduce using rule 8 (exp)]
307   '/' [reduce using rule 8 (exp)]
308   $default  reduce using rule 8 (exp)
\end{verbatim}
El comentario en la línea 308 (\verb|$default| \ldots )
indica que por defecto, ante cualquier
otro terminal que no sea uno de los explícitamente listados, 
la acción a tomar por el analizador será reducir por la regla 8.

Una revisión a la numeración de la gramática, al comienzo
del fichero \verb|.output| nos permite ver cuál
es la regla 8:
\begin{verbatim}
29 Rules:
30 ------
31 0:  $start -> input $end
32 1:  input -> /* empty */
33 2:  input -> input line
34 3:  line -> '\n'
35 4:  line -> exp '\n'
36 5:  line -> error '\n'
37 6:  exp -> NUM
38 7:  exp -> VAR
39 8:  exp -> VAR '=' exp
40 9:  exp -> exp '+' exp
41 10: exp -> exp '-' exp
42 11: exp -> exp '*' exp
43 12: exp -> exp '/' exp
44 13: exp -> '-' exp
45 14: exp -> '(' exp ')'
\end{verbatim}
Efectivamente, es la regla de asignación \verb|exp -> VAR '=' exp|.
El conflicto aparece por que los terminales 
\verb|* + - /| están en el conjunto FOLLOW(\verb|exp|)
y también cabe esperarlos respectivamente 
en las reglas 9, 10, 11 y 12 ya que el estado 
25 contiene:

\begin{verbatim}
294   exp -> exp . '+' exp  (Rule 9)
295   exp -> exp . '-' exp  (Rule 10)
296   exp -> exp . '*' exp  (Rule 11)
297   exp -> exp . '/' exp  (Rule 12)
\end{verbatim}

Estamos ante un caso en el que se aplica el consejo número
\ref{item:conflictos}.
Los items de la forma
$B \rightarrow \beta_\uparrow \gamma$, son los
de la forma \verb|exp -> exp . '+' exp|, etc.
El item de la forma $A \rightarrow \alpha_\uparrow$ 
es en este caso \verb|exp -> VAR '=' exp|.

En efecto, en una expresión como \verb|a = 4 + 3| se produce
una ambiguedad. ¿Debe interpretarse como \verb|(a = 4) + 3|?
¿O bien como \verb|a = (4 + 3)|?. La primera interpretación
corresponde a reducir por la regla 8. La segunda a desplazar al
estado 13.  En este ejemplo, el conflicto
se resuelve haciendo que tenga prioridad el desplazamiento,
dando menor prioridad al terminal \verb|=| que a los 
terminales \verb|* + - /|.
\end{example}

\begin{exercise}
¿Que ocurre en el ejemplo anterior si dejamos que \verb|yapp| aplique 
las reglas por defecto?
\end{exercise}

\sectionpractica{Un C simplificado}
\label{section:samplec}
Escriba un analizador sintáctico 
usando \verb|Parse::Yapp| para el siguiente lenguaje.
La descripción utiliza una notación tipo BNF: las llaves indican 
0 o mas repeticiones y los corchetes opcionalidad.

\vspace{0.5cm}
\begin{tabular}{lll}
program      &$\rightarrow$& definitions \{ definitions \}\\
definitions  &$\rightarrow$& datadefinition $|$ functiondefinition\\
datadefinition   &$\rightarrow$& basictype declarator \{ ',' declarator \} ';'\\
declarator  &$\rightarrow$& ID \{ '$[$' constantexp '$]$' \}\\
functiondefinition &$\rightarrow$& $[$ basictype $]$ functionheader functionbody\\
basictype    &$\rightarrow$& INT  $|$ CHAR\\
functionheader &$\rightarrow$& ID '(' $[$ parameters $]$ ')'\\
parameters &$\rightarrow$& basictype declarator \{ ',' basictype declarator \} \\
functionbody &$\rightarrow$& '\{' \{ datadefinition \} \{ statement \} '\}'\\
statement &$\rightarrow$& $[$ exp $]$ ';'\\
          &&$|$ '\{' \{ datadefinition \} \{ statement \} '\}'\\
          &&$|$  IF '(' exp ')' statement $[$ ELSE statement $]$\\
          &&$|$  WHILE '(' exp ')' statement\\
          &&$|$  RETURN $[$ exp $]$ ';'\\
constantexp  &$\rightarrow$& exp \\
exp       &$\rightarrow$& lvalue '=' exp $|$ lvalue '+=' exp \\
          &&$|$ exp '\&\&' exp $|$ exp '$||$' exp  $|$\\
          &&$|$ exp '==' exp $|$ exp '!=' exp  $|$\\
          &&$|$ exp '$<$' exp $|$ exp '$>$' exp  $|$ exp '$<=$' exp $|$ exp '$>=$' exp  $|$\\
          &&$|$ exp '+' exp $|$ exp '-' exp  $|$\\
          &&$|$ exp '*' exp $|$ exp '/' exp $|$\\
          &&$|$ unary\\
unary     &$\rightarrow$& '$++$' lvalue  $|$ '$--$' lvalue $|$ primary\\
primary   &$\rightarrow$& '(' exp ')' $|$ ID '(' $[$ argumentlist $]$ ')' $|$ lvalue $|$ NUM $|$ CHARACTER\\
lvalue   &$\rightarrow$& ID  \{ '$[$' exp '$]$' \}\\
argumentlist &$\rightarrow$& exp \{ ',' exp \}
\end{tabular}
\vspace{0.25cm}
Su analizador, además de seguir los consejos explícitados en la 
sección \ref{section:consejosyapp},
deberá cumplir las siguientes especificaciones:

\begin{enumerate}
\item {\bf Método de Trabajo}

Parta de la definición BNF y proceda a introducir las reglas poco a poco:
\begin{verbatim}
1 %token declarator basictype functionheader functionbody
2 %%
3 program: definitionslist
4        ;
5
6 definitionslist: definitions definitionslist
7                | definitions
8                ;
9
10 definitions: datadefinition
11            | functiondefinition
12            ;
13 datadefinition: basictype declaratorlist ';'
14               ;
15
16 declaratorlist: declarator ',' declaratorlist
17               | declarator
18               ;
19 functiondefinition: basictype functionheader functionbody
20                   | functionheader functionbody
21                   ;
22
23 %%
\end{verbatim}

\begin{enumerate}
\item
Comienze trabajando en el cuerpo de la gramática.
\item
Olvídese del 
analizador léxico por ahora. Su objetivo es tener una gramática limpia
de conflictos y que reconozca el lenguaje dado. 
\item
Sustituya las repeticiones
BNF por listas. Si una variable describe una lista de \verb|cosas| llámela
\verb|cosaslist|. 
\item
Si tiene un elemento opcional en la BNF, por ejemplo, en la regla: 

functiondefinition $\rightarrow$ $[$ basictype $]$ functionheader functionbody

sustitúyala por dos reglas una en la que aparece el elemento y otra en la 
que no.
\begin{verbatim}
19 functiondefinition: basictype functionheader functionbody
20                   | functionheader functionbody
21                   ;
\end{verbatim}
\item
Cada par de reglas que introduzca vuelva a recompilar con \verb|yapp| la gramática
para ver si se han producido conflictos. Cuando estoy editando la gramática
suelo escribir a menudo la orden 

\verb|:!yapp %| 

para recompilar:

\vspace{0.5cm}
\begin{tabular}{|p{14.5cm}|}
\hline
\begin{verbatim}
     15
     16 declaratorlist: declarator declaratorlist
     17               | declarator
     18               ;
     19 functiondefinition: basictype functionheader functionbody
     20                   | functionheader functionbody
     21                   ;
     22
     23 %%
~
~
~
~
~
~
~
~
~
~
:!yapp %
\end{verbatim}\\
\hline
\end{tabular}
\vspace{0.5cm}

Esto llama a \verb|yapp| con el fichero bajo edición. Si hay errores los detectaré
enseguida.
\item
Insisto, procure detectar la aparición de un conflicto lo antes posible. Es terrible
tener que limpiar una gramática llena de conflictos.
\item
\underline{Ponga nombres significativos a las variables y terminales}. Por favor,
no los llame \verb|d1|, \verb|d2|, etc.
\item
Cuando esté en el proceso de construcción de la gramática y aún le queden
por rellenar variables sintácticas, declárelas como terminales mediante
\verb|%token| como en el código que aparece encima. De esta manera
evitará las quejas de \verb|yapp|.
\end{enumerate}

\item {\bf Resolución de Conflictos}

Las operaciones de asignación tienen la prioridad mas baja,
seguidas  de las lógicas, los test de igualdad y después 
de los de comparación, a continuación las aditivas, multiplicativas y por 
último los \verb|unary| y \verb|primary|. Exprese la asociatividad natural y la
prioridad especificada usando
los mecanismos que \verb|yapp| provee al efecto.

La gramática es ambigua, ya que para una sentencia como 

\begin{center}
if $E_1$ then if $E_2$ then $S_1$ else $S_2$
\end{center}

existen dos árboles posibles: uno que asocia el ``else'' con el primer ``if'' y otra
que lo asocia con el segundo. Los dos árboles corresponden a las
dos posibles parentizaciones:

\begin{center}
if $E_1$ then (if $E_2$ then $S_1$ else $S_2$)
\end{center}

Esta es la regla de prioridad usada en la mayor parte de los lenguajes:
un ``else'' casa con el ``if'' mas cercano. La otra posible parentización
es:

\begin{center}
if $E_1$ then (if $E_2$ then $S_1$) else $S_2$
\end{center}

Utilice los mecanismos de priorización proporcionados por \verb|yapp|
para resolver el conflicto shift-reduce generado. ¿Es correcta 
en este caso particular la conducta a la que da lugar la acción \verb|yapp|
por defecto?

\item {\bf Analizador Léxico}

Además del tipo de terminal y su valor el analizador
léxico deberá devolver el número de línea.
El analizador léxico deberá aceptar comentarios C.
En la gramática, el terminal \verb|CHARACTER| se refiere a 
caracteres entre comillas simples (por ejemplo \verb|'a'|).

Se aconseja que las palabras reservadas del lenguaje
no se traten con expresiones regulares específicas sino que se
capturen en el patrón de identificador \verb|[a-z_]\w+|. 
Se mantiene para ello un hash con las palabras reservadas 
que es inicializado al comienzo del programa. Cuando 
el analizador léxico encuentra un identificador
mira en primer lugar en dicho hash 
para ver si es una palabra reservada y,
si lo es, devuelve el terminal correspondiente.
En caso contrario se trata de un identificador.

\item {\bf Recuperación de Errores}

Extienda la práctica 
con reglas para la recuperación de errores. 
Para las listas, siga los consejos 
dados en la sección \ref{table:err}.
En aquellos casos en los que la introducción de las reglas
de recuperación produzca ambiguedad, resuelva los conflictos.

\item {\bf Árbol de Análisis Abstracto}

La semántica del lenguaje es similar a la del lenguaje C (por ejemplo,
las expresiones lógicas se tratan como expresiones enteras).
El analizador deberá producir un árbol sintáctico abstracto. Como se hizo para el
lenguaje Tutu introducido en el capítulo 
\ref{chapter:introcomp}, cada clase de nodo 
deberá corresponderse con una clase Perl. 
Por ejemplo, para una regla como 

\begin{center}
\verb|exp '*' exp|
\end{center}

la acción asociada sería algo parecido a 

\begin{center}
\verb| { bless [ $_[1], $_[3]], 'MULT' } |
\end{center}

donde usamos un array anónimo. Mejor aún es usar un hash anónimo:

\begin{center}
\verb| { bless { LEFT => $_[1], RIGHT => $_[3]}, 'MULT' } |
\end{center}

Defina formalmente el arbol especificando la gramática árbol correspondiente a su diseño
(repase la sección \ref{subsection:lenguajesarbol}).
Introduzca en esta parte la tabla de símbolos.
La tabla de símbolos es, como en el compilador de Tutu, una lista 
de referencias a hashes conteniendo las tablas de símbolos locales a 
cada bloque.  En cada momento, la lista refleja el anidamiento de bloques 
actual. Es posible que, en la declaración 
de funciones, le interese crear un nuevo bloque en el que guardar los parámetros,
de manera que las variables globales queden a nivel 0, los parámetros 
de una función a nivel 1 y las variables locales de la función a nivel 2
o superior.
\end{enumerate}

%Recicle
%y extienda de manera apropiada el código que 
%ha escrito para la versión previa de Tutu en las restantes fases: análisis léxico,
%semántico, optimización de código, cálculo de direcciones, generación de código
%y optimización peephole. Extienda el plegado de constantes 
%y las transformaciones algebraicas a las operaciones
%lógicas y de comparación.
%Genere código para la máquina basada en registros.
%Para ello, extienda el juego de instrucciones de manera apropiada.

%Modifique y amplíe los programas de prueba para comprobar que los
%cambios introducidos funcionan correctamente.


\section{La Gramática de {\tt yapp} / {\tt yacc}}
En esta sección veremos con mas detalle, la sintaxis de \verb|Parse::Yapp|,
usando la propia notación \verb|yapp| para describir el lenguaje.
Un programa \verb|yapp| consta de tres partes:
la cabeza, el cuerpo y la cola. Cada una de las partes
va separada de las otras por el símbolo \verb|%%| en una
línea aparte.

\begin{verbatim}
yapp:   head body tail 
head:   headsec '%%' 
headsec: #empty  
    |   decls  
decls:  decls decl  | decl       
body:   rulesec '%%' 
rulesec:  rulesec rules | rules 
rules:  IDENT ':' rhss ';'  
tail:   /*empty*/
    |   TAILCODE   
\end{verbatim}

\subsection{La Cabecera}
En la cabecera se colocan las declaraciones de variables,
terminales, etc. 
\begin{verbatim}
decl:  '\n'                 
    |   TOKEN typedecl symlist '\n'
    |   ASSOC typedecl symlist '\n'  
    |   START ident '\n'       
    |   HEADCODE '\n'         
    |   UNION CODE '\n'      
    |   TYPE typedecl identlist '\n'
    |   EXPECT NUMBER '\n'  

typedecl: # empty
    |   '<' IDENT '>'
\end{verbatim}

El terminal \tei{START} se corresponde con una declaración 
\verb|%start| indicando cual es el símbolo de arranque de la gramática.
Por defecto, el símbolo de arranque es el primero de la gramática.

El terminal \verb|ASSOC| está por los terminales que indican
precedencia y asociatividad.
Esto se ve claro si se analiza el contenido del fichero 
\verb|YappParse.yp| (\pageref{chapter:parseyp})
en el que se puede encontrar 
el código del analizador léxico del módulo 
\verb|Parse::Yapp|.
El código dice:

\begin{verbatim}
    ...
    if($lexlevel == 0) {# In head section
            $$input=~/\G%(left|right|nonassoc)/gc
        and return('ASSOC',[ uc($1), $lineno[0] ]);
            $$input=~/\G%(start)/gc
        and return('START',[ undef, $lineno[0] ]);
            $$input=~/\G%(expect)/gc
        and return('EXPECT',[ undef, $lineno[0] ]);
            $$input=~/\G%{/gc
    ...
\end{verbatim}
La variable \verb|$lexlevel| indica en que sección nos encontramos:
cabecera, cuerpo o cola. El terminal \verb|EXPECT| 
indica la presencia de una declaración \verb|%expect| en el fuente,
la cual cuando es seguida de un número indica el numero de
conflictos shift-reduce que cabe esperar. Use \verb|EXPECT|
si quiere silenciar las advertencias de \verb|yapp| sobre la presencia
de conflictos cuya resolución automática considere correcta.

\subsection{La Cabecera: Diferencias entre {\tt yacc} y {\tt yapp}}
\label{subsection:cabecerayaccyapp}
Las declaraciones de tipo
correspondientes a \verb|%union| y a las especificaciones de 
tipo entre símbolos menor mayor (\verb|<tipo>|) en declaraciones \verb|token| y 
\verb|%type| no son usadas por \verb|yapp|. Estas declaraciones son
necesarias cuando el código de las acciones semánticas
se escribe en \verb|C| como es el caso de \ci{{\tt yacc}} y \ci{{\tt bison}}.
Sigue un ejemplo de programa \verb|yacc|/\verb|bison| que usa declaraciones \verb|%union|
y de tipo para los atributos:

\begin{verbatim}
 1 %{
 2 #include <stdio.h>
 3 
 4 #define CLASE(x) ((x == 1)?"global":"local")
 5 #define TIPO(x) ((x == 1)?"float":"integer")
 6 %}
 7 
 8 %union {
 9   int n;   /* enumerado */
10   char *s; /* cadena */
11 }
12 
13 %token <n> FLOAT INTEGER 
14 %token <n> GLOBAL 
15 %token <n> LOCAL 
16 %token <s> NAME
17 %type <n> class type
18 
19 %%
\end{verbatim}
La declaración \verb|%union| de la línea 8 indica que los atributos
son de dos tipos: enteros y punteros a caracteres. 
El nombre del campo es posteriormente usado en las 
declaraciones de las líneas 13-17 para indicar el tipo 
del atributo asociado con la variable o con el terminal.
Así, la declaración de la línea 13 indica 
que los terminales \verb|FLOAT| e \verb|INTEGER|
son de tipo entero, mientras que la declaración de la línea 16 nos
dice que el terminal \verb|NAME| es de tipo cadena.
\begin{verbatim}
29 class
30   : GLOBAL { $$ = 1; }
31   | LOCAL  { $$ = 2; }
32   ;
33 
34 type
35   : FLOAT   { $$ = 1; }
36   | INTEGER { $$ = 2; }
37   ;
\end{verbatim}
La información proveída sobre los tipos permite a \verb|yacc| 
introducir automáticamente en el código \verb|C| producido 
los \emph{typecasting} o ahormados
para las asignaciones de las líneas 30-31 y 35-36. Obsérve que
en \verb|yacc| el atributo de la variable en la parte izquierda
se denota por \verb|$$|.

Otra diferencia entre \verb|yacc| y \verb|yapp| es que en \verb|yacc| los 
atributos de la parte derecha no constituyen un vector, denotándose
por \verb|$1|, \verb|$2|, \verb|$3| \ldots 

En ocasiones \verb|yacc| no puede determinar el tipo de un atributo. 
En particular cuando se habla del atributo asociado con una acción
intermedia, ya que esta no tiene variable sintáctica asociada 
explícitamente o bien cuando se habla de los atributos
de símbolos que están a la izquierda de la reducción actual
(véase la sección \ref{section:heredados}). Los atributos de símbolos 
a la izquierda de la producción actual se denotan en \verb|yacc| por números 
no positivos \verb|$0|, \verb|$-1|, \verb|$-2| \ldots. 

En estos casos 
el programador deberá especificar explícitamente el tipo del 
atributo usando la notación \verb|$<tipo>#|. Donde \verb|tipo| es 
uno de los campos de la \verb|union| y \verb|#| es el numeral 
del símbolo correspondiente:

\begin{verbatim}
39 namelist
40   : NAME   { printf("%s de clase %s, tipo %s\n",$1,CLASE($<n>-1),TIPO($<n>0)); }
41   | namelist ',' NAME 
42       { printf("%s de clase %s, tipo %s\n",$3,CLASE($<n>-1),TIPO($<n>0)); }
43   ;
44 %%
\end{verbatim}

\subsection{El Cuerpo}
\label{subsection:elcuerpo}
El cuerpo de un programa \verb|yapp| contiene la gramática
y las acciones 
\begin{verbatim}
rhss:   rhss '|' rule | rule 
rule:   rhs prec epscode | rhs 
rhs:    #empty     
    |   rhselts   
rhselts: rhselts rhselt | rhselt  
rhselt: symbol | code 
prec: PREC symbol
epscode: # vacio 
    |   code  
code:   CODE 
\end{verbatim}
Las acciones semánticas (variable sintáctica \verb|code| y terminal \verb|CODE|)
se ejecutan siempre que ocurre una reducción por una regla y, en general, devuelven 
un valor semántico. El código de la acción se copia verbatim
en el analizador. La estrategia usada por el analizador léxico
es contar las llaves abrir y cerrar en 
el texto. Véase el correspondiente fragmento del analizador
léxico:
\begin{verbatim}
    ....
    $lineno[0]=$lineno[1];
    ....
    $$input=~/\G{/gc
    and do {
        my($level,$from,$code);

        $from=pos($$input);
        $level=1;
        while($$input=~/([{}])/gc) {
            substr($$input,pos($$input)-1,1) eq '\\' #Quoted 
            and next;
            $level += ($1 eq '{' ? 1 : -1) or last;
        }
        $level and  _SyntaxError(2,"Unmatched { opened line $lineno[0]",-1);
        $code = substr($$input,$from,pos($$input)-$from-1);
        $lineno[1]+= $code=~tr/\n//;
        return('CODE',[ $code, $lineno[0] ]);
    };
\end{verbatim}
Las llaves dentro de cadenas y comentarios no son significativas en la cuenta.
El problema es que el reconocimiento de cadenas en Perl es mas difícil que
en otros lenguajes: existe toda una variedad de formas de denotar una cadena.
Por tanto, si el programador usuario de \verb|yapp| necesita 
escribir una llave dentro de una cadena de doble comilla, deberá escaparla.
Si la cadena es de simple comilla escaparla no es solución, pues 
aparecería el símbolo de escape en la cadena. En ese caso se deberá añadir 
un comentario con la correspondiente falsa llave. Siguen
algunos ejemplos tomadados de la documentación de \verb|Parse::Yapp|
\begin{verbatim}
"{ My string block }"
"\{ My other string block \}"
qq/ My unmatched brace \} /

# Casamos con el siguiente: {
q/ for my closing brace } / # 

q/ My opening brace { /
# debe cerrarse: }
\end{verbatim}

\begin{exercise}
Genere programas de prueba \verb|yapp| con cadenas que produzcan confusión
en el analizador y observe el comportamiento. Pruébelas en las diferentes
secciones en las que puede ocurrir código: en la cabecera, en el cuerpo 
y en la cola.
\end{exercise}

\subsection{La Cola: Diferencias entre {\tt yacc} y {\tt yapp}}
\label{subsection:colayaccyapp}
La cola de un program \verb|yapp| contiene las rutinas de soporte.
\begin{verbatim}
tail:   /*empty*/
    |   TAILCODE   
\end{verbatim}
el terminal \verb|TAILCODE| al igual que los terminales
\verb|CODE| y \verb|HEADCODE| indican que en ese punto se puede encontrar 
código Perl. La detección de \verb|TAILCODE| y \verb|HEADCODE| son mas sencillas
que las de \verb|CODE|.

La cola de un programa \verb|yacc| es similar.
Para el programa \verb|yacc| cuya cabecera y cuerpo
se mostraron en la sección 
\ref{subsection:cabecerayaccyapp}
la cola es:
\begin{verbatim}
 1 %%
 2 
 3 extern FILE * yyin;
 4 
 5 main(int argc, char **argv) {
 6   if (argc > 1) yyin = fopen(argv[1],"r");
 7   /* yydebug = 1;
 8   */
 9   yyparse();
10 }
11 
12 yyerror(char *s) {
13   printf("%s\n",s);
14 }
\end{verbatim}

La declaración del manejador de fichero \verb|yyin| en la línea 14 
referencia el archivo 
de entrada para el analizador. La variable (comentada, línea 7) 
\verb|yydebug| controla la información para la depuración de la gramática.
Para que sea realmente efectiva, el programa deberá además compilarse
definiendo la macro \verb|YYDEBUG|. Sigue un ejemplo
de \verb|Makefile|:
\begin{verbatim}
 1   inherited: y.tab.c lex.yy.c
 2      gcc -DYYDEBUG=1 -g -o inherited1 y.tab.c lex.yy.c
 3   y.tab.c y.tab.h: inherited1.y 
 4      yacc -d -v inherited1.y 
 5   lex.yy.c: inherited1.l y.tab.h
 6      flex -l inherited1.l
 7   clean:
 8      - rm -f y.tab.c lex.yy.c *.o core inherited1
\end{verbatim}

Al compilar tenemos:
\begin{verbatim}
pl@nereida:~/src/inherited$ make
yacc -d -v inherited1.y
flex -l inherited1.l
gcc -DYYDEBUG=1 -g -o inherited1 y.tab.c lex.yy.c
pl@nereida:~/src/inherited$ ls -ltr
total 232
-rw-r-----  1 pl users   242 Dec 10  2003 Makefile
-rw-r-----  1 pl users   404 Dec 10  2003 inherited1.l
-rw-r-----  1 pl users   878 Dec 10  2003 inherited1.y
-rw-rw----  1 pl users  1891 Jan 26 15:41 y.tab.h
-rw-rw----  1 pl users 30930 Jan 26 15:41 y.tab.c
-rw-rw----  1 pl users  2365 Jan 26 15:41 y.output
-rw-rw----  1 pl users 44909 Jan 26 15:41 lex.yy.c
-rwxrwx--x  1 pl users 56336 Jan 26 15:41 inherited1
\end{verbatim}

\subsection{El Análisis Léxico en {\tt yacc}: {\tt flex}}
\label{subsection:flex}
El analizador léxico para \verb|yacc| desarrollado
en las secciones anteriores ha sido escrito
usando la variante \ci{{\tt flex}} del lenguaje \ci{{\tt LEX}}. Un programa
\verb|flex| tiene una estructura similar a la 
de un program \verb|yacc| con tres partes: cabeza, cuerpo
y cola separados por \verb|%%|. Veamos como ejemplo de manejo de
\verb|flex|, los contenidos
del fichero flex \verb|inherited1.l| utilizado en las secciones
anteriores:

\begin{verbatim}
 1   %{
 2   #include <string.h>
 3   #include "y.tab.h"
 4   %}
 5   id [A-Za-z_][A-Za-z_0-9]*
 6   white [ \t\n]+
 7   %%
 8   global    {  return GLOBAL; }
 9   local     {  return LOCAL; }
10   float     {  return FLOAT; }
11   int       {  return INTEGER; }
12   {id}      {  yylval.s = strdup(yytext); return NAME; }
13   {white}   { ; }
14   ,         { return yytext[0]; }
15   .         { fprintf(stderr,"Error. carácter inesperado.\n"); }
16   %%
17   int yywrap() { return 1; }
\end{verbatim}
La cabeza contiene declaraciones \verb|C| asi como definiciones
regulares. El fichero \verb|y.tab.h| que es incluído en la línea
3, fué generado 
por \verb|yacc| y contiene, entre otras cosas,
la información recolectada
por \verb|yacc| sobre los tipos de los atributos 
(declaración \verb|%union|) y la enumeración de los terminales.
Es, por tanto, necesario que la compilación con \verb|yacc|
preceda a la compilación con \verb|flex|.
La información en \verb|y.tab.h| es usada por el analizador léxico
para ``sincronizarse'' con el analizador sintáctico.
Se definen en las líneas 5 y 6 las 
macros para el reconocimiento de identificadores (\verb|id|)
y blancos (\verb|white|). Estas macros son llamadas en el cuerpo
en las líneas 12 y 13. 
La estructura del cuerpo
consiste en parejas formadas por una definición
regular seguidas de una acción.
La variable \verb|yylval| contiene el atributo asociado
con el terminal actual. Puesto que el token \verb|NAME|
fué declarado del tipo cadena (véase \ref{subsection:cabecerayaccyapp}), 
se usa el correspondiente
nombre de campo \verb|yylval.s|.
La cadena que acaba de casar queda guardada en la variable
\verb|yytext|, y su longitud queda en la
variable entera global \verb|yyleng|.

Una vez compilado con \verb|flex| el fuente,
obtenemos un fichero denominado \verb|lex.yy.c|. 
Este fichero contiene la rutina \verb|yylex()| que realiza el an\'alisis
l\'exico del lenguaje descrito. 

La funci\'on \verb|yylex()| analiza las entradas, buscando la
secuencia mas larga que casa con alguna de las expresiones regulares
y ejecuta la correspondiente acci\'on.
Si no se encuentra ningun  emparejamiento se ejecuta la regla ``por defecto'', que es:

\begin{center}
\verb@(.|\n)  { printf("%s",yytext); }@
\end{center}

Si encuentran dos expresiones regulares con las que la cadena mas larga
casa, elige la que figura primera en el programa \verb|flex|.

Una vez que se ha ejecutado la correspondiente acci\'on, \verb|yylex()|
contin\'ua con el resto de la entrada, buscando por subsiguientes
emparejamientos. Asi continúa hasta encontrar un final de fichero
en cuyo caso termina, retornando un cero o bien hasta que una de las
acciones explicitamente ejecuta una sentencia \verb|return|.

Cuando el analizador l\'exico alcanza el final del fichero, el
comportamiento en las subsiguientes llamadas a \verb|yylex|
resulta indefinido.  En el momento en que  \verb|yylex|
alcanza el final del fichero llama a la funci\'on \verb|yywrap|, la cual retorna un
valor de 0 o 1 seg\'un haya mas entrada o no. Si el valor es 0,
la funci\'on \verb|yylex| asume que la propia \verb|yywrap|
se ha encargado de abrir el nuevo fichero y asignarselo
a \verb|yyin|.  

\subsectionpractica{Uso de {\tt Yacc} y {\tt Lex}}
Use \verb|yacc| y \verb|flex| para 
completar los analizadores sintáctico y léxico descritos en las secciones
\ref{subsection:cabecerayaccyapp},
\ref{subsection:colayaccyapp} y
\ref{subsection:flex}. 
La gramática en cuestión es similar a la descrita
en la sección \ref{section:heredados}.
Usando la variable \verb|yydebug| y la macro \verb|YYDEBUG|
analize el comportamiento para la entrada
\verb|global float x,y|. 

\section{El Analizador Ascendente  {\tt Parse::Yapp}}
\label{section:analizadorLR}

El program \verb|yapp| es un traductor y, por tanto, constituye
un ejemplo de como escribir un traductor. El lenguaje fuente
es el lenguaje \verb|yacc| y el lenguaje objeto es \verb|Perl|.
Como es habitual en muchos lenguajes, el lenguaje objeto se ve 
"expandido" con un conjunto de funciones de soporte. En el caso de 
\verb|yapp| estas funciones de soporte, son en 
realidad métodos y están en el módulo \verb|Parse::Yapp::Driver|.
Cualquier módulo generado por \verb|yapp| hereda de dicho módulo
(véase por ejemplo, el módulo generado para nuestro ejemplo de la calculadora,
en la sección \ref{section:tablas}).

Como se ve en la figura \ref{fig:yappinheritance}, 
los módulos generados por \verb|yapp|
heredan y usan la clase \verb|Parse::Yapp::Driver|
la  cual contiene el analizador sintáctico LR genérico.
Este módulo contiene los métodos de soporte visibles
al usuario \verb|YYParse|, \verb|YYData|, \verb|YYErrok|, \verb|YYSemval|,
etc.

La figura \ref{fig:yappinheritance} muestra además el 
resto de los módulos
que conforman el ``compilador'' \verb|Parse::Yapp|.
La herencia se ha representado mediante flechas contínuas.
Las flechas punteadas indican una relación de uso entre los módulos.
El guión \verb|yapp| es un programa aparte que es
usado para producir el correspondiente
módulo desde el fichero conteniendo la gramática.

\begin{figure}[htb]
%\centerline{\epsfig{file=figures/yapp_inheritance.eps, height=7cm}}
\caption{Esquema de herencia de {\tt Parse::Yapp}. 
Las flechas contínuas indican herencia, las punteadas uso.
La clase {\tt Calc} es implementada en el módulo generado por {\tt yapp}}
\label{fig:yappinheritance}
\end{figure}

(Para ver el contenido de los módulos, descarge \verb|yapp| desde CPAN:
\begin{latexonly}
\begin{verbatim}
\http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.p
\end{verbatim}
\end{latexonly}

\begin{rawhtml}
<a href="http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm">http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm</a> 
\end{rawhtml}
o bien desde uno de nuestros servidores locales; en 
el mismo directorio en que se guarda la
versión HTML de estos apuntes encontrará una copia de 
\htmladdnormallink{Parse-Yapp-1.05.tar.gz}{Parse-Yapp-1.05.tar.gz}).
La versión a la que se refiere este capítulo es la 1.05.

El módulo \verb|Parse/Yapp/Yapp.pm| se limita a contener la documentación
y descansa toda la tarea de análisis en los otros módulos.
El módulo \verb|Parse/Yapp/Output.pm| contiene los métodos
\verb|_CopyDriver| y \verb|Output| los cuales se encargan de escribir
el analizador: partiendo de un esqueleto genérico rellenan 
las partes específicas a partir de la información computada
por los otros módulos. 

El módulo \verb|Parse/Yapp/Options.pm|
analiza las opciones de entrada. El módulo \verb|Parse/Yapp/Lalr.pm|
calcula las tablas de análisis LALR. Por último el módulo
\verb|Parse/Yapp/Grammar| contiene varios métodos de soporte 
para el tratamiento de la gramática.


El modulo {\tt Parse::Yapp::Driver} contiene el método
\verb|YYparse| encargado del análisis.
En realidad, el método \verb|YYparse| delega 
en el método privado \verb|_Parse| la tarea de análisis.
Esta es la estructura del analizador genérico usado por \verb|yapp|.
Léalo con cuidado y compare con la estructura explicada en la
sección \ref{section:algoritmoLR}.

\begin{verbatim}
 1 sub _Parse {
 2   my($self)=shift;
 3 
 4   my($rules,$states,$lex,$error)
 5      = @$self{ 'RULES', 'STATES', 'LEX', 'ERROR' };
 6   my($errstatus,$nberror,$token,$value,$stack,$check,$dotpos)
 7      = @$self{ 'ERRST', 'NBERR', 'TOKEN', 'VALUE', 'STACK', 'CHECK', 'DOTPOS' };
 8 
 9   $$errstatus=0;
10   $$nberror=0;
11   ($$token,$$value)=(undef,undef);
12   @$stack=( [ 0, undef ] ); # push estado 0
13   $$check='';
\end{verbatim}
La componente 0 de \verb|@$stack| es el estado, la componente
1 es el atributo.
\begin{verbatim}
14 
15   while(1) { 
16     my($actions,$act,$stateno);
17 
18     $stateno=$$stack[-1][0];     # sacar el estado en el top de 
19     $actions=$$states[$stateno]; # la pila
\end{verbatim}
\verb|$states| es una referencia a un vector. Cada entrada 
\verb|$$states[$stateno]| es una referencia a un hash que 
contiene dos claves. La clave \verb|ACTIONS| contiene
las acciones para ese estado. La clave \verb|GOTOS|
contiene los saltos correspondientes a ese estado.
\begin{verbatim}
20 
21     if  (exists($$actions{ACTIONS})) {
22       defined($$token) or do {
23         ($$token,$$value)=&$lex($self); # leer siguiente token
24       };
25 
26       # guardar en $act la acción asociada con el estado y el token
27       $act = exists($$actions{ACTIONS}{$$token})?   
28          $$actions{ACTIONS}{$$token} : 
29          exists($$actions{DEFAULT})? $$actions{DEFAULT} : undef;
30     }
31     else { $act=$$actions{DEFAULT}; }
\end{verbatim}
La entrada \verb|DEFAULT| de una acción contiene la acción 
a ejecutar por defecto.
\begin{verbatim}
32 
33     defined($act) and do {
34       $act > 0 and do { # $act >0 indica shift
35          $$errstatus and do { --$$errstatus; };
\end{verbatim}
La línea 35 esta relacionada con la recuperación de errores.
Cuando \verb|yapp| ha podido desplazar varios terminales
sin que se produzca error considerará que se ha recuperado 
con éxito del último error.
\begin{verbatim}
36          # Transitar: guardar (estado, valor)
37          push(@$stack,[ $act, $$value ]);
38          $$token ne ''   #Don't eat the eof
39          and $$token=$$value=undef;
40          next; # siguiente iteración
41       };
\end{verbatim}
A menos que se trate del final de fichero, se reinicializa
la pareja \verb|($$token, $$value)| y se repite el bucle
de análisis.
Si \verb|$act| es negativo se trata de una reducción
y la entrada \verb|$$rules[-$act]| es una referencia
a un vector con tres elementos: la variable sintáctica,
la longitud de la parte derecha y el código asociado:
\begin{verbatim}
43       # $act < 0, indica reduce
44       my($lhs,$len,$code,@sempar,$semval);
45 
46       #obtenemos una referencia a la variable,
47       #longitud de la parte derecha, referencia
48       #a la acción
49       ($lhs,$len,$code)=@{$$rules[-$act]};
50       $act or $self->YYAccept();
\end{verbatim}
Si \verb|$act| es cero indica una acción de aceptación.
El método \verb|YYAccept| se encuentra en \verb|Driver.pm|.
Simplemente contiene:

\begin{verbatim}
              sub YYAccept {
                my($self)=shift;

                ${$$self{CHECK}}='ACCEPT';
                  undef;
              }
\end{verbatim}

Esta entrada será comprobada al final de la iteración para comprobar
la condición de aceptación (a través de la 
variable \verb|$check|, la cuál es una referencia).

\begin{verbatim}
51       $$dotpos=$len; # dotpos es la longitud de la regla
52       unpack('A1',$lhs) eq '@'    #In line rule
53       and do {
54         $lhs =~ /^\@[0-9]+\-([0-9]+)$/
55           or  die "In line rule name '$lhs' ill formed: ".
56                   "report it as a BUG.\n";
57         $$dotpos = $1;
58       };
\end{verbatim}
En la línea 52 obtenemos el primer carácter en el nombre de la variable.
Las acciones intermedias en \verb|yapp| producen una variable
auxiliar que comienza por \verb|@| y casa con el patrón
especificado en la línea 54. Obsérvese que el número después
del guión contiene la posición relativa en la regla 
de la acción intermedia.
\begin{verbatim}
60       @sempar = $$dotpos ?   
61          map { $$_[1] } @$stack[ -$$dotpos .. -1 ] : ();
\end{verbatim}
El array \verb|@sempar| se inicia a la lista vacía 
si \verb|$len| es nulo. En caso contrario
contiene la lista de los atributos de los últimos \verb|$$dotpos|
elementos referenciados en la pila.
Si la regla es intermedia estamos haciendo referencia
a los atributos de los símbolos a su izquierda.
\begin{verbatim}
62       $semval = $code ? &$code( $self, @sempar ) : 
63                         @sempar ? $sempar[0] : undef;
\end{verbatim}
Es en este punto que ocurre la ejecución de la acción.
La subrutina referenciada por \verb|$code| es llamada
con primer argumento la referencia al objeto analizador \verb|$self|
y como argumentos los atributos que se han computado
previamente en \verb|@sempar|. Si no existe tal código se devuelve 
el atributo del primer elemento, si es que existe un tal primer
elemento. 

El valor retornado por la subrutina/acción asociada es guardado en 
\verb|$semval|.

\begin{verbatim}
65       splice(@$stack,-$len,$len);
\end{verbatim}
La funci\'on \verb|splice| toma en general cuatro argumentos:
el array a modificar, el \'{\i}ndice en el cual es modificado,
el n\'umero de elementos a suprimir y la lista de elementos
extra a insertar. Aquí, la llamada a \verb|splice| cambia los elementos de
\verb|@$stack| a partir del índice \verb|-$len|.
El número de elementos a suprimir es \verb|$len|.  
A continuación se comprueba si hay que terminar, bien 
porque se ha llegado al estado de aceptación (\verb|$$check eq 'ACCEPT'|)
o porque ha habido un error fatal:
\begin{verbatim}
      $$check eq 'ACCEPT' and do { return($semval); };
      $$check eq 'ABORT' and  do { return(undef); };
\end{verbatim}
Si las cosas van bien, se empuja en la cima de la pila el estado
resultante de transitar desde el estado en la cima con la variable
sintáctica en el lado izquierdo:
\begin{verbatim}
      $$check eq 'ERROR' or  do { 
          push(@$stack, [ $$states[$$stack[-1][0]]{GOTOS}{$lhs}, $semval ]);
          $$check='';
          next;
      };
\end{verbatim}
La expresión \verb|$$states[$$stack[-1][0]]| es una referencia a un hash cuya
clave \verb|GOTOS| contiene una referencia a un hash conteniendo la 
tabla de transiciones del éstado en la cima de la pila (\verb|$stack[-1][0]|).
La entrada de clave \verb|$lhs| contiene el estado al que se transita al ver la
variable sintáctica de la izquierda de la regla de producción. El atributo
asociado es el devuelto por la acción: \verb|$semval|.
\begin{verbatim}
      $$check='';

    }; # fin de defined($act)

    # Manejo de errores: código suprimido
    ... 

  }
}#_Parse
\end{verbatim}
\ldots{} y el bucle \verb|while(1)| de la línea 15 continúa.  
Compare este código con el seudo-código introducido
en la sección \ref{section:algoritmoLR}.

\section{La Estructura de Datos Generada por {\tt YappParse.yp}}
%Repase los fuentes de Yapp. Puede obtenerlos en
%
%\begin{latexonly}
%\begin{verbatim}
%http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm
%\end{verbatim}
%\end{latexonly}
%
%\begin{rawhtml}
%<a href="http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm">http://search.cpan.org/~fdesar/Parse-Yapp-1.05/lib/Parse/Yapp.pm</a> 
%\end{rawhtml}
%
%o bien en nuestros servidores locales, por ejemplo en 
%el mismo directorio en que se guarda la
%versión HTML de estos apuntes encontrará una copia de 

El fichero \verb|YappParse.yp|.
contiene la gramática \verb|yapp| del lenguaje
\verb|yacc|\footnote{La versión a la que se refiere esta sección es la 1.05
(\htmladdnormallink{Parse-Yapp-1.05.tar.gz}{Parse-Yapp-1.05.tar.gz})}
. 
Además de las dos rutinas de soporte típicas,
la de tratamiento de errores \verb|_Error| y la
de análisis léxico \verb|_Lexer|, el fichero
contiene una subrutina para el manejo de las 
reglas \verb|_AddRules| y otra rutina \verb|Parse| la cuál
 actúa como \emph{wrapper} o filtro sobre el analizador
\verb|YYParse|.

Durante el análisis sintáctico 
de un programa \verb|yapp| se construye una estructura de 
datos para la posterior manipulación y tratamiento de 
la gramática.  
Como ejemplo usaremosla gramática:
\begin{verbatim}
pl@nereida:~/src/perl/Parse-AutoTree/trunk/scripts$ cat -n int.yp
 1  %right '+'
 2  %left 'a'
 3  %nonassoc 'b'
 4  %%
 5  S:   /* empty rule */                       { print "S -> epsilon\n" }
 6   |   'a' { print "Intermediate\n"; } S 'b'  { print "S -> a S b\n" }
 7   |   '+' S '+' %prec 'a'                    { print "S -> + S + prec a\n" }
 8  ;
 9  %%
10
11  sub _Error {
12          exists $_[0]->YYData->{ERRMSG}
13      and do {
14          print $_[0]->YYData->{ERRMSG};
15          delete $_[0]->YYData->{ERRMSG};
16          return;
17      };
18      print "Syntax error.\n";
19  }
20
21  sub _Lexer {
22      my($parser)=shift;
23
24          defined($parser->YYData->{INPUT})
25      or  $parser->YYData->{INPUT} = <STDIN>
26      or  return('',undef);
27
28      $parser->YYData->{INPUT}=~s/^[ \t\n]//;
29
30      for ($parser->YYData->{INPUT}) {
31          s/^(.)//s and return($1,$1);
32      }
33  }
34
35  sub Run {
36      my($self)=shift;
37      $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => 0x1F );
38  }
\end{verbatim}
Para construir la estructura podemos usar la siguiente subrutina:
\begin{verbatim}
sub Parse {
  my $grammar = shift;

  my $x = new Parse::Yapp::Parse;
  my $r = $x->Parse($grammar);

  return $r;
}
\end{verbatim}
La llamada a \verb|Parse| produce la siguiente estructura de datos:
\begin{verbatim}
nereida:~/src/perl/Parse-AutoTree/trunk/scripts> grammar.pl int.yp
$VAR1 = {
  'START' => 'S', # Símbolo de arranque
  'SYMS' => { 'S' => 5, 'b' => 3, 'a' => 2, '+' => 1 }, # Símbolo => línea
  'TERM' => { 
    'b' => [ 'NONASSOC', 2 ],  # terminal => [ Asociatividad, precedencia ]
    'a' => [ 'LEFT', 1 ],      # terminal => [ Asociatividad, precedencia ]
    '+' => [ 'RIGHT', 0 ] },   # terminal => [ Asociatividad, precedencia ]
    # Si el terminal no tiene precedencia toma la forma  terminal => []
  'NTERM' => { 'S' => [ '1', '3', '4' ] }, # variable => [ indice en RULES de las reglas de S ]
  'PREC' => { 'a' => 1 }, # Terminales que son usandos en una directiva %prec
  'NULL' => { 'S' => 1 }, # Variables que producen vacío
  'EXPECT' => 0, # Número de conflictos esperados
  'RULES' => [
     [ '$start', [ 'S', '' ], undef, undef ], # Regla de superarranque
     [
       'S', [], # producción
       undef,   # precedencia explícita de la regla
       [ ' print "S -> epsilon\n" ', 5 ] # [ acción asociada, línea ]
     ],
     [
       '@1-1', [], # Regla intermedia: Variable temporal
       undef,
       [ ' print "Intermediate\n"; ', 6 ]
     ],
     [
       'S', [ 'a', '@1-1', 'S', 'b' ],
       undef,
       [ ' print "S -> a S b\n" ', 6 ]
     ],
     [
       'S', [ '+', 'S', '+' ],
       1, # precedencia explícita de la regla
       [ ' print "S -> + S + prec a\n" ', 7 ]
     ]
   ],
  'HEAD' => undef, # Código de cabecera 
  'TAIL' => [ '... código de cola ...', 9 ], # Línea en la que comienza la sección de cola
};
\end{verbatim}

Las componentes del hash que aparece
arriba se corresponden
con diversas variables usadas por \verb|YYParse| durante el análisis. La correspondencia
se establece dentro  del método \verb|Parse| cuando se hace la asignación:

\begin{verbatim}
   @$parsed{ 'HEAD', 'TAIL', 'RULES', 'NTERM', 'TERM',
              'NULL', 'PREC', 'SYMS',  'START', 'EXPECT' }
    =       (  $head,  $tail,  $rules,  $nterm,  $term,
               $nullable, $precterm, $syms, $start, $expect);
\end{verbatim}
esta asignación es la que crea el hash.
Las variables con identificadores en minúsculas son usadas 
en el analizador. Son visibles en todo el fichero ya que,
aunque declaradas léxicas, su declaración se encuentra 
en la cabecera del analizador:
\begin{verbatim}
%{
require 5.004;

use Carp;

my($input,$lexlevel,@lineno,$nberr,$prec,$labelno);
my($syms,$head,$tail,$token,$term,$nterm,$rules,$precterm,$start,$nullable);
my($expect);

%}
\end{verbatim}

%Responda a las siguientes preguntas:
%
%\begin{itemize}
%\item
%¿Que se guarda en \verb|SYMS|?
%\item
%En este ejemplo los valores del hash \verb|TERM| esta indefinidos. En general
%contienen un array anónimo con información sobre el terminal. ¿Que información
%exactamente? 
%\item
%¿Que contiene el hash \verb|PREC|? ¿tiene algo que ver con la directiva
%\verb|%prec|?
%\item
%¿Cuál es el significado del 5 en la tercera componente de \verb|TAIL|?
%¿Qué contiene el array anónimo de clave \verb|HEAD|?
%\item
%¿Cómo es la estructura de la lista representando una regla? ¿Qué
%significan los diferentes elementos de la lista?
%\item
%¿Cuál es el significado del hash con clave \verb|NULL|? ¿En que forma es
%usado durante el análisis para controlar posibles errores?
%\item
%¿Cómo se denotan las variables sintácticas asociadas con acciones
%intermedias? ¿Sabría señalar el lugar en  \verb|YappParse.yp|
%en que se trata con esta situación?
%\item
%¿Cuál es el significado de la clave \verb|EXPECT|?
%\item
%¿Qué referencian los índices en el array anónimo
%asociado con clave \verb|S| en \verb|NTERM|?
%\item
%¿Que limitaciones observa en  \verb|YappParse.yp|?
%\end{itemize}

\sectionpractica{ El Análisis de las Acciones}
Modifique el código de \verb|YappParse.yp| para que el análisis
léxico de las secciones de código (\verb|HEADCODE|, \verb|CODE| y \verb|TAILCODE|)
se haga a través de las correspondientes rutinas proveida como parámetros 
para el análisis por el usuario. La idea es ofrecer un primer paso
que facilite la generación de analizadores en diferentes 
lenguajes \verb|Perl|, \verb|C|, etc.

Estudie el módulo \verb|Text::Balanced|. Basándose en 
las funciones 

\verb|extract_codeblock| y \verb|extract_quotelike|

del módulo \verb|Text::Balanced|, resuelva el problema del reconocimiento
de código Perl dentro del analizador léxico de \verb|Parse::Yapp|,
evitando forzar al usuario en la escritura de ``llaves fantasma''.
Compare el rendimiento de esta solución con la que provee \verb|Yapp|.
Para analizar el \cei{rendimiento} use el módulo \ci{{\tt Benchmark}}.

¿Cu\'ales son sus conclusiones? ¿Qué es mejor?


\sectionpractica{ Autoacciones}

Extienda \verb|Parse::Yapp| con una directiva \verb|%autoaction CODE| la
cuál cambia la acción por defecto. Cuando una regla de producción 
no tenga una acción asociada, en vez de ejecutarse la acción
\verb|yapp| por defecto %, \verb|{ $_[1] }|,
se ejecutará el código especificado en \verb|CODE|. 
La directiva podrá aparecer en la
parte de cabecera o en el cuerpo del programa \verb|yapp| 
en una sóla línea aparte. Si aparece en el cuerpo no debe hacerlo
en medio de una regla.


Sigue un ejemplo de uso:

\begin{verbatim}
%{
use Data::Dumper;
my %tree_name = ('=' => 'eq', '+' => 'plus', '-' => 'minus', 
                 '*' => 'times', '/' => 'divide');
%}
%right  '='
%left   '-' '+'
%left   '*' '/'
%left   NEG
%autoaction { [$tree_name{$_[2]}, $_[1], $_[3]] }

%%
input:               { undef }
        | input line { undef } 
;

line:     '\n'         { undef }
        | exp '\n'     { print Dumper($_[1]); }
        | error '\n'   { $_[0]->YYErrok }
;

exp:        NUM                 { $_[1] }
        |   VAR                 { $_[1] }
        |   VAR '=' exp | exp '+' exp | exp '-' exp | exp '*' exp | exp '/' exp      
        |   '-' exp %prec NEG   { ['neg', $_[2]] }
        |   '(' exp ')'         { $_[2] }
;

%%
\end{verbatim}
y un ejemplo de ejecución:
\begin{verbatim}
$ ./useautoaction1.pl
2+3*4
^D
$VAR1 = [
          'plus',
          '2',
          [ 'times', '3', '4' ]
        ];
\end{verbatim}
Analice la adecuación de los mensajes de error emitidos por
el compilador de Perl cuando el código en la auto-acción contiene
errores. ¿Son apropiados los números de línea?

Tenga en cuenta los siguientes consejos:

\begin{itemize}
\item
Cuando compile con \verb|yapp| su módulo use 
una orden como: \verb|yapp -m Parse::Yapp::Parse Parse.yp|. 
Este es un caso en que el nombre del fichero de salida (\verb|Parse.pm|)
y el nómbre del package \verb|Parse::Yapp::Parse| no coinciden. 
Este es un caso en que el nombre del fichero de salida (\verb|Parse.pm|)
y el nómbre del package \verb|Parse::Yapp::Parse| no coinciden.
\item
Ahora tiene dos versiones de \verb|Parse::Yapp| en su ordenador.
El compilador de Perl va a intentar cargar la instalada. 
Para ello en su versión del script \verb|yapp| puede incluir
una línea que le indique al compilador que debe buscar primero
en el lugar en el que se encuentra nuestra librería:
\begin{verbatim}
BEGIN { unshift @INC, '/home/lhp/Lperl/src/yapp/Parse-Yapp-Auto/lib/' }
\end{verbatim}
\item ¿Qué estrategia a seguir? Una posibilidad es ``hacerle creer'' al
resto de los módulos en \verb|Yapp| que el usuario ha escrito el 
código de la autoacción en aquellas reglas en las que no existe 
código explícito asociado. Es posible realizar esta práctica modificando
sólo el fichero \verb|YappParse.yp|. El código original 
\verb|Yapp| usa \verb|undef|
para indicar, en el campo adecuado, que una acción no fué definida.
La idea es sustituir ese \verb|undef| por el código asociado con la
autoacción:

\begin{verbatim}
my($code)= $autoaction? $autoaction:undef;
\end{verbatim}

\end{itemize}

\sectionpractica{Nuevos Métodos}
Continuemos extendiendo \verb|Yapp|.
\begin{itemize}
\item
Introduzca en el módulo \verb|Driver.pm| de \verb|Yapp|
un método \verb|YYLhs| que devuelva el identificador
de la variable sintáctica en el lado izquierdo de la regla 
de producción por la que se está reduciendo. 
\item
Para tener disponible el lado izquierdo
deberá modificar la conducta del analizador LALR 
(subrutina \verb|_Parse|) para que guarde como un atributo
el identificador de dicho noterminal.
\item
¿Que identificador se devuelve asociado con las acciones
intermedias?
\end{itemize}

Sigue un ejemplo de como programar haciendo uso de esta y la 
anterior extensión:
\begin{verbatim}
%right  '='
%left   '-' '+'
%left   '*' '/'
%left   NEG
%autoaction { my $n = $#_;  bless [@_[1..$n]], $_[0]->YYLhs }
%%
input:                 
        |   input line 
;
line:     '\n'       { } 
        | exp '\n'   { [ $_[1] ] } 
        | error '\n' { }
;
exp:        NUM         |   VAR         |   VAR '=' exp         
        |   exp '+' exp |   exp '-' exp |   exp '*' exp |   exp '/' exp      
        |   '-' exp %prec NEG 
        |   '(' exp ')' { [ $_[2] ] }     
;
%%
...
\end{verbatim}
Veamos la ejecución correspondiente al ejemplo anterior:
\begin{verbatim}
$ ./uselhs2.pl
2+3*4
$VAR1 = bless( 
[
  bless( [], 'input' ),
  [
    bless( [
      bless( [ '2' ], 'exp' ),
      '+',
      bless( [
        bless( [ '3' ], 'exp' ), '*', bless( [ '4' ], 'exp' ) ], 'exp' )
    ], 'exp' )
  ]
], 'input' );
\end{verbatim}

\sectionpractica{Generación Automática de Árboles}
Partiendo de la práctica anterior, introduzca una directiva
\verb|%autotree| que de lugar a la construcción del árbol de análisis
concreto. La acción de construcción del árbol:
\begin{verbatim}
{ my $n = $#_;  bless [@_[1..$n]], $_[0]->YYLhs }
\end{verbatim}
se ejecutará para cualquier regla que no tenga una acción
explícita asociada.

\section{Recuperacion de Errores: Visión Detallada}
La subrutina \verb|_Parse| contiene el algoritmo de
análisis LR genérico. En esta sección 
nos concentraremos en la forma en la que se ha implantado en
\verb|yapp| la recuperación de errores.
\begin{verbatim}
 1 sub _Parse {
 2   my($self)=shift;
 3   ... 
 4   $$errstatus=0; $$nberror=0;
 \end{verbatim}
 La variable \verb|$$errstatus| nos indica la situación con respecto a la recuperación
 de errores. La variable \verb|$$nberror| contiene el número total de errores.
 \begin{verbatim}
 5   ($$token,$$value)=(undef,undef);
 6   @$stack=( [ 0, undef ] ); $$check='';
 7   while(1) {
 8     my($actions,$act,$stateno);
 9     $stateno=$$stack[-1][0];
10     $actions=$$states[$stateno];
11 
12     if  (exists($$actions{ACTIONS})) { 
13       defined($$token) or  do { ($$token,$$value)=&$lex($self); };
14       ...
15     }
16     else { $act=$$actions{DEFAULT}; }
\end{verbatim}
Si \verb|$act| no esta definida es que ha ocurrido un 
error. En tal caso no se entra a estudiar
si la acción es de desplazamiento o reducción.
\begin{verbatim}
17     defined($act) and do { 
18       $act > 0 and do { #shift
19           $$errstatus and  do { --$$errstatus; };
20           ...
21           next;
22       };
23       #reduce
24       ....
25       $$check eq 'ERROR' or  do {
26         push(@$stack, [ $$states[$$stack[-1][0]]{GOTOS}{$lhs}, $semval ]);
27         $$check='';
28         next;
29       };
30       $$check='';
31     };
\end{verbatim}
Si \verb|$$errstatus| es cero es que estamos
ante un nuevo error:
\begin{verbatim}
32     #Error
33     $$errstatus or   do {
34       $$errstatus = 1;
35       &$error($self);
36       $$errstatus # if 0, then YYErrok has been called
37       or  next;   # so continue parsing
38       ++$$nberror;
39     };
\end{verbatim}
Como el error es ``nuevo'' se llama a la subrutina de 
tratamiento de errores \verb|&$error|. Obsérvese que no
se volverá a llamar a la rutina de manejo de errores
hasta que \verb|$$errstatus| vuelva a alcanzar 
el valor cero. Puesto que \verb|&$error| ha sido
escrita por el usuario, es posible que este haya llamado
al método \verb|YYErrok|. Si ese es el caso, es que el
programador prefiere que el análisis continúe como
si la recuperación de errores se hubiera completado.


Ahora se pone \verb|$$errstatus| a 3:
\begin{verbatim}
47     $$errstatus=3;
\end{verbatim}
Cada vez que se logre un desplazamiento con éxito \verb|$$errstatus|
será decrementado (línea 19).

A continuación se retiran estados de la pila hasta
que se encuentre alguno que pueda transitar ante el 
terminale especial \verb|error|:
\begin{verbatim}
48     while(@$stack
49         and (not exists($$states[$$stack[-1][0]]{ACTIONS})
50         or  not exists($$states[$$stack[-1][0]]{ACTIONS}{error})
51         or  $$states[$$stack[-1][0]]{ACTIONS}{error} <= 0)) {
52       pop(@$stack);
53     }
54     @$stack or do {
55       return(undef);
56     };
\end{verbatim}
Si la pila quedó vacía se devuelve \verb|undef|. En caso contrario
es que el programador escribió alguna regla para la
recuperación de errores. En ese caso, se transita al estado
correspondiente:
\begin{verbatim}
57     #shift the error token
58     push(@$stack, [ $$states[$$stack[-1][0]]{ACTIONS}{error}, undef ]);
59   }
60   #never reached
61   croak("Error in driver logic. Please, report it as a BUG");
62 }#_Parse
\end{verbatim}
Un poco antes tenemos el siguiente código:
\begin{verbatim}
41     $$errstatus == 3  #The next token is not valid: discard it
42     and  do {
43       $$token eq ''  # End of input: no hope
44       and  do { return(undef); }; 
45       $$token=$$value=undef;
46     };
\end{verbatim}
Si hemos alcanzado el final de la entrada en una situación de error
se abandona devolviendo \verb|undef|.
\begin{exercise}
Explique la razón para el comentario de la línea
41. Si \verb|$$errstatus| es 3, el último
terminal no ha producido un desplazamiento correcto. ¿Porqué?
\end{exercise}
A continuación aparecen los códigos de los métodos implicados en 
la recuperación de errores:
\begin{verbatim}
sub YYErrok {
  my($self)=shift;

  ${$$self{ERRST}}=0;
    undef;
}
\end{verbatim}
El método \verb|YYErrok| cambia el valor referenciado por \verb|$errstatus|.
De esta forma se le da al programador \verb|yapp| la oportunidad de anunciar
que es muy probable que la fase de recuperación de errores se haya completado.

Los dos siguientes métodos devuelven el número de errores hasta el momento
(\verb|YYNberr|)
y si nos encontramos o no en fase de recuperación de errores (\verb|YYRecovering|):
\begin{verbatim}
sub YYNberr {
  my($self)=shift;

  ${$$self{NBERR}};
}

sub YYRecovering {
  my($self)=shift;

  ${$$self{ERRST}} != 0;
}
\end{verbatim}

\section{Descripción Eyapp del Lenguaje  SimpleC}
\label{section:simplec}
En este capítulo usaremos \tei{Parse::Eyapp} para desarrollar
un compilador para el siguiente lenguaje, al que denominaremos \tei{Simple C}:

%\vspace{0.5cm}
%\begin{tabular}{lll}
%program      &$\rightarrow$& definitions \{ definitions \}\\
%definitions  &$\rightarrow$& datadefinition $|$ functiondefinition\\
%datadefinition   &$\rightarrow$& basictype declarator \{ ',' declarator \} ';'\\
%declarator  &$\rightarrow$& ID \{ '$[$' constantexp '$]$' \}\\
%functiondefinition &$\rightarrow$& $[$ basictype $]$ functionheader functionbody\\
%basictype    &$\rightarrow$& INT  $|$ CHAR\\
%functionheader &$\rightarrow$& ID '(' $[$ parameters $]$ ')'\\
%parameters &$\rightarrow$& basictype declarator \{ ',' basictype declarator \} \\
%functionbody &$\rightarrow$& '\{' \{ datadefinition \} \{ statement \} '\}'\\
%statement &$\rightarrow$& $[$ exp $]$ ';'\\
%          &&$|$ '\{' \{ datadefinition \} \{ statement \} '\}'\\
%          &&$|$  IF '(' exp ')' statement $[$ ELSE statement $]$\\
%          &&$|$  WHILE '(' exp ')' statement\\
%          &&$|$  RETURN $[$ exp $]$ ';'\\
%constantexp  &$\rightarrow$& exp \\
%exp       &$\rightarrow$& lvalue '=' exp $|$ lvalue '+=' exp \\
%          &&$|$ exp '\&\&' exp $|$ exp '$||$' exp  $|$\\
%          &&$|$ exp '==' exp $|$ exp '!=' exp  $|$\\
%          &&$|$ exp '$<$' exp $|$ exp '$>$' exp  $|$ exp '$<=$' exp $|$ exp '$>=$' exp  $|$\\
%          &&$|$ exp '+' exp $|$ exp '-' exp  $|$\\
%          &&$|$ exp '*' exp $|$ exp '/' exp $|$\\
%          &&$|$ unary\\
%unary     &$\rightarrow$& '$++$' lvalue  $|$ '$--$' lvalue $|$ primary\\
%primary   &$\rightarrow$& '(' exp ')' $|$ ID '(' $[$ argumentlist $]$ ')' $|$ lvalue\\
%          &             & $|$ NUM $|$ CHARACTER $|$ STRING\\
%lvalue   &$\rightarrow$& ID  \{ '$[$' exp '$]$' \}\\
%argumentlist &$\rightarrow$& exp \{ ',' exp \}
%\end{tabular}
%\vspace{0.25cm}
%
%La descripción utiliza una notación tipo BNF: las llaves indican 
%0 o mas repeticiones y los corchetes opcionalidad.

\begin{verbatim}
program: definition+

definition: funcDef | basictype funcDef | declaration

basictype: INT | CHAR

funcDef: ID '('  params  ')' block

params: ( basictype ID arraySpec)<* ','>

block: '{' declaration* statement* '}'

declaration: basictype declList ';'

declList: (ID arraySpec) <+ ','>

arraySpec: ( '[' INUM ']')*

statement:
    expression ';'
  | ';'
  | BREAK ';'
  | CONTINUE ';'
  | RETURN ';'
  | RETURN expression ';'
  | block
  | ifPrefix statement %prec '+'
  | ifPrefix statement 'ELSE' statement
  | loopPrefix statement

ifPrefix: IF '(' expression ')'

loopPrefix: WHILE '(' expression ')'

expression: binary <+ ','>

Variable: ID ('[' binary ']') *

Primary:
    INUM
  | CHARCONSTANT
  | Variable
  | '(' expression ')'
  | function_call

function_call:  ID  '(' binary <* ','> ')'

Unary: '++' Variable | '--' Variable | Primary

binary:
    Unary
  | binary '+' binary
  | binary '-' binary
  | binary '*' binary
  | binary '/' binary
  | binary '%' binary
  | binary '<' binary
  | binary '>' binary
  | binary '>=' binary
  | binary '<=' binary
  | binary '==' binary
  | binary '!=' binary
  | binary '&' binary
  | binary '**' binary
  | binary '|' binary
  | Variable '=' binary
  | Variable '+=' binary
  | Variable '-=' binary
  | Variable '*=' binary
  | Variable '/=' binary
  | Variable '%=' binary
  | etc. etc.
\end{verbatim}

\section{Diseño de Analizadores con {\tt Parse::Eyapp}}
\label{section:consejoseyapp}
A la hora de construir un analizador sintáctico tenga en cuenta 
las siguientes normas de buena programación:

\begin{enumerate}
\item
Comienze trabajando en el cuerpo de la gramática.
\item
Olvídese al principio del 
analizador léxico. Su primer objetivo es tener una gramática limpia
de conflictos y que reconozca el lenguaje dado. 
\item
Sustituya las repeticiones
BNF por listas usando los operadores \verb|eyapp| \verb|+|, \verb|*| y sus variantes con separadores. 
Si una variable describe una lista de \verb|cosas| pongale un adjetivo adecuado como
\verb|cosaslist|. 
\underline{Ponga nombres significativos a las variables y terminales}. 
No los llame \verb|d1|, \verb|d2|, etc.
\item
Si tiene un elemento opcional en la BNF, por ejemplo, en la regla: 

functiondefinition $\rightarrow$ $[$ basictype $]$ functionheader functionbody

use el operador \verb|?|.
\item
Cada par de reglas que introduzca vuelva a recompilar con \verb|eyapp| la gramática
para ver si se introducido ambiguedad. Cuando estoy editando la gramática
suelo escribir a menudo la orden 

\verb|:!eyapp %| 

para recompilar:

\vspace{0.5cm}
\begin{tabular}{|p{14.5cm}|}
\hline
\begin{verbatim}
     15
     16 declaratorlist: declarator +
     17 ;
     18 functiondefinition: 
     19    basictype functionheader functionbody
     20  | functionheader functionbody
     21 ;
     22
     23 %%
~
~
~
~
~
~
~
~
~
~
:!eyapp %
\end{verbatim}\\
\hline
\end{tabular}
\vspace{0.5cm}

Esto llama a \verb|eyapp| con el fichero bajo edición. Si hay errores o conflictos (esto es,
hemos introducido ambiguedad) los detectarémos enseguida.
Procure detectar la aparición de un conflicto lo antes posible.
Observe el sangrado del ejemplo. Es el que le recomiendo.
\item
Cuando esté en el proceso de construcción de la gramática y aún le queden
por rellenar variables sintácticas, declárelas como terminales mediante
\verb|%token|. De esta manera
evitará las quejas de \verb|eyapp|.

\item {\bf Resolución de Ambiguedades y Conflictos}

Las operaciones de asignación tienen la prioridad mas baja,
seguidas  de las lógicas, los test de igualdad,
los de comparación, a continuación las aditivas, multiplicativas y por 
último las operaciones de tipo \verb|unary| y \verb|primary|.
Exprese la asociatividad natural y la
prioridad especificada usando
los mecanismos que \verb|eyapp| provee al efecto: \verb|%left|, \verb|%right|,
\verb|%nonassoc| y \verb|%prec|.

\item
La gramática de SimpleC es ambigua, ya que para una sentencia como 

\begin{center}
if $E_1$ then if $E_2$ then $S_1$ else $S_2$
\end{center}

existen dos árboles posibles: uno que asocia el ``else'' con el primer ``if'' y otra
que lo asocia con el segundo. Los dos árboles corresponden a las
dos posibles parentizaciones:

\begin{center}
if $E_1$ then (if $E_2$ then $S_1$ else $S_2$)
\end{center}

Esta es la regla de prioridad usada en la mayor parte de los lenguajes:
un ``else'' casa con el ``if'' mas cercano. La otra posible parentización
es:

\begin{center}
if $E_1$ then (if $E_2$ then $S_1$) else $S_2$
\end{center}

\emph{La conducta por defecto de {\tt eyapp} es parentizar a derechas}.
El generador  {\tt eyapp}  nos informará del conflicto pero si no se le indica 
como resolverlo parentizará a derechas.
Resuelva este conflicto.

\item {\it ¿Que clase de árbol debe producir el analizador?}
La respuesta es que sea lo mas abstracto posible.
Debe 
\begin{itemize}
\item
Contener toda la información necesaria para el manejo eficiente
de las fases subsiguientes: Análisis de ámbito, Comprobación de tipos,
Optimización independiente de la máquina, etc.
\item 
Ser uniforme
\item
Legible (human-friendly)
\item
No contener nodos que no portan información. 
\end{itemize}

El siguiente ejemplo muestra una versión aceptable de árbol abstracto.
Cuando se le proporciona el programa de entrada:

\begin{verbatim}
nereida:~/doc/casiano/PLBOOK/PLBOOK/code> cat -n prueba5.c
     1  int f(int a)
     2  {
     3    if (a>0)
     4      a = f(a-1);
     5  }
\end{verbatim}


El siguiente árbol ha sido producido por un analizador usando la directiva 
\verb|%tree| y añadiendo las correspondientes acciones de \verb|bypass|.
Puede considerarse un ejemplo aceptable de AST:

\begin{verbatim}
nereida:~/doc/casiano/PLBOOK/PLBOOK/code> eyapp Simple2 ;\
                                  usesimple2.pl prueba5.c
PROGRAM(
  TYPEDFUNC(
    INT(TERMINAL[INT:1]),
    FUNCTION(
      TERMINAL[f:1],
      PARAMS(
        PARAM(
          INT(TERMINAL[INT:1]),
          TERMINAL[a:1],
          ARRAYSPEC
        )
      ),
      BLOCK(
        DECLARATIONS,
        STATEMENTS(
          IF(
            GT(
              VAR(TERMINAL[a:3]),
              INUM(TERMINAL[0:3])
            ),
            ASSIGN(
              VAR(TERMINAL[a:4]),
              FUNCTIONCALL(
                TERMINAL[f:4],
                ARGLIST(
                  MINUS(
                    VAR(TERMINAL[a:4]),
                    INUM(TERMINAL[1:4])
                  )
                ) # ARGLIST
              ) # FUNCTIONCALL
            ) # ASSIGN
          ) # IF
        ) # STATEMENTS
      ) # BLOCK
    ) # FUNCTION
  ) # TYPEDFUNC
) # PROGRAM
\end{verbatim}

Es deseable  darle una estructura uniforme al árbol. Por ejemplo, como consecuencia 
de que la gramática admite funciones con declaración implícita del tipo
retornado cuando este es entero

\begin{verbatim}
 1  definition:
 2      funcDef { $_[1]->type("INTFUNC"); $_[1] }
 3    | %name TYPEDFUNC
 4      basictype funcDef
 5    | declaration { $_[1] }
 6  ;
\end{verbatim}
\end{enumerate}

se producen dos tipos de árboles. Es conveniente
convertir las definiciones de función con declaración 
implícita en el mismo árbol que se obtiene con 
declaración explícita. 

\sectionpractica{Construcción del AST para el Lenguaje Simple C}
\label{practica:esquemadetradsimple}
Utilice 
\htmladdnormallink{Parse-Eyapp}{Parse-Eyapp.tar.gz}.
para construir un árbol de análisis sintáctico abstracto 
para la gramática descrita en la sección
\ref{section:simplec}.
Su analizador deberá seguir los consejos explícitados en la 
sección \ref{section:consejoseyapp}.

\paragraph{Analizador Léxico}

Además del tipo de terminal y su valor el analizador
léxico deberá devolver el número de línea.
El analizador léxico deberá aceptar comentarios C.
En la gramática, el terminal \verb|CHARACTER| se refiere a 
caracteres entre comillas simples (por ejemplo \verb|'a'|).
El terminal \verb|STRING| se refiere a 
caracteres entre comillas dobles (por ejemplo \verb|"hola"|).

Se aconseja que las palabras reservadas del lenguaje
no se traten con expresiones regulares específicas sino que se
capturen en el patrón de identificador \verb|[a-z_]\w+|. 
Se mantiene para ello un hash con las palabras reservadas 
que es inicializado al comienzo del programa. Cuando 
el analizador léxico encuentra un identificador
mira en primer lugar en dicho hash 
para ver si es una palabra reservada y,
si lo es, devuelve el terminal correspondiente.
En caso contrario se trata de un identificador.


\section{El Generador de Analizadores {\tt byacc}}
%http://home.debitel.net/user/boesswetter/xml_yylex/XML-YYLex.html
Existe una version del \verb|yacc| de Berkeley que permite producir 
código para Perl:
\begin{verbatim}
> byacc -V
byacc: Berkeley yacc version 1.8.2 (C or perl)
\end{verbatim}
Se trata por tanto de un generador de analizadores LALR.
Es bastante compatible con \verb|AT&T yacc|. Puedes encontrar 
una versión en formato \verb|tar.gz| en nuestro servidor
\htmladdnormallink{http://nereida.deioc.ull.es/\~{}pl/pyacc-pack.tgz}{http://nereida.deioc.ull.es/~pl/pyacc-pack.tgz}
o también desde 
\htmladdnormallink{http://www.perl.com/CPAN/src/misc/}{http://www.perl.com/CPAN/src/misc/}.

El formato de llamada es:
\begin{verbatim}
byacc  [ -CPcdlrtv ] [ -b file_prefix ] [ -p symbol_prefix ] filename
\end{verbatim}

Las opciones \verb|C| o \verb|c| permiten generar código C. Usando \verb|-P|
se genera código Perl. Las opciones \verb|d| y \verb|v| funcionan como es usual en 
\verb|yacc|. Con \verb|t| se incorpora código para la depuración de la gramática.
Si se especifica \verb|l| el código del usuario no es insertado.
La opción \verb|r| permite generar ficheros separados para el código y las tablas. No la use
con Perl.

Fichero conteniendo la gramática:
\begin{verbatim}
%{
%}

%token INT EOL
%token LEFT_PAR RIGHT_PAR
%left PLUS MINUS
%left MULT DIV

%%
start:	|
		start input
	;

input:		expr EOL	{ print $1 . "\n"; }
	|	EOL
	;

expr:		INT		{ $p->mydebug("INT -> Expr!"); $$ = $1; }
	|	expr PLUS expr	{ $p->mydebug("PLUS -> Expr!"); $$ = $1 + $3; }
	|	expr MINUS expr	{ $p->mydebug("MINUS -> Expr!"); $$ = $1 - $3; }
	|	expr MULT expr	{ $p->mydebug("MULT -> Expr!"); $$ = $1 * $3; }
	|	expr DIV expr	{ $p->mydebug("DIV -> Expr!"); $$ = $1 / $3; }
	|	LEFT_PAR expr RIGHT_PAR { $p->mydebug("PARENS -> Expr!"); $$ = $2; }
	;
%%

sub yyerror {
    my ($msg, $s) = @_;
    my ($package, $filename, $line) = caller;
    
    die "$msg at <DATA> \n$package\n$filename\n$line\n";
}

sub mydebug {
    my $p = shift;
    my $msg = shift;
    if ($p->{'yydebug'})
    {
        print "$msg\n";
    }
}
\end{verbatim}
La compilación con \verb|byacc| del fichero \verb|calc.y|
conteniendo la descripción de la gramática produce el módulo 
Perl conteniendo el analizador.
\begin{verbatim}
> ls -l
total 12
-rw-r-----    1 pl       casiano        47 Dec 29  2002 Makefile
-rw-r-----    1 pl       casiano       823 Dec 29  2002 calc.y
-rwxr-x--x    1 pl       casiano       627 Nov 10 15:37 tokenizer.pl
> cat Makefile
MyParser.pm: calc.y
        byacc -d -P MyParser $<

> make
byacc -d -P MyParser calc.y
> ls -ltr
total 28
-rw-r-----    1 pl       casiano       823 Dec 29  2002 calc.y
-rw-r-----    1 pl       casiano        47 Dec 29  2002 Makefile
-rwxr-x--x    1 pl       casiano       627 Nov 10 15:37 tokenizer.pl
-rw-rw----    1 pl       users          95 Nov 16 12:49 y.tab.ph
-rw-rw----    1 pl       users        9790 Nov 16 12:49 MyParser.pm
\end{verbatim}
Observe que la opción \verb|-P| es la que permite producir código Perl.
Anteriormente se usaba la opción \verb|-p|. Esto se hizo para mantener la 
compatibilidad con otras versiones de \verb|yacc| en las que la opción \verb|-p|
se usa para cambiar el prefijo por defecto (\verb|yy|). Ese es el significado actual
de la opción \verb|-p| en \verb|perl-byacc|.

El fichero \verb|y.tab.ph| generado contiene las definiciones de los \emph{tokens}:
\begin{verbatim}
 cat y.tab.ph
$INT=257;
$EOL=258;
$LEFT_PAR=259;
$RIGHT_PAR=260;
$PLUS=261;
$MINUS=262;
$MULT=263;
$DIV=264;
\end{verbatim}
El programa \verb|tokenizer.pl| contiene la llamada al analizador 
y la definición del analizador léxico:
\begin{verbatim}
> cat tokenizer.pl
#!/usr/local/bin/perl5.8.0

require 5.004;
use strict;
use Parse::YYLex;
use MyParser;

print STDERR "Version $Parse::ALex::VERSION\n";

my (@tokens) = ((LEFT_PAR => '\(',
                 RIGHT_PAR => '\)',
                 MINUS => '-',
                 PLUS => '\+',
                 MULT => '\*',
                 DIV => '/',
                 INT => '[1-9][0-9]*',
                 EOL => '\n',
                 ERROR => '.*'),
                sub { die "!can\'t analyze: \"$_[1]\"\n!"; });

my $lexer = Parse::YYLex->new(@tokens);

sub yyerror
{
    die "There was an error:" . join("\n", @_). "\n";
}

my $debug = 0;
my $parser = new MyParser($lexer->getyylex(), \&MyParser::yyerror , $debug);
$lexer->from(\*STDIN);
$parser->yyparse(\*STDIN);
\end{verbatim}
El módulo \verb|Parse::YYLex| contiene una versión de \verb|Parse::Lex| 
que ha sido adaptada para funcionar con  \verb|byacc|. Todas las versiones de \verb|yacc| 
esperan que el analizador léxico devuelva un \emph{token} numérico, mientras que 
\verb|Parse::Lex| devuelbe un objeto de la clase \emph{token}.
Veamos un ejemplo de ejecución:
\begin{verbatim}
> tokenizer.pl
Version 2.15
yydebug: state 0, reducing by rule 1 (start :)
yydebug: after reduction, shifting from state 0 to state 1
3*(5-9)
yydebug: state 1, reading 257 (INT)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 5 (expr : INT)
INT -> Expr!
yydebug: after reduction, shifting from state 1 to state 6
yydebug: state 6, reading 263 (MULT)
yydebug: state 6, shifting to state 11
yydebug: state 11, reading 259 (LEFT_PAR)
yydebug: state 11, shifting to state 4
yydebug: state 4, reading 257 (INT)
yydebug: state 4, shifting to state 2
yydebug: state 2, reducing by rule 5 (expr : INT)
INT -> Expr!
yydebug: after reduction, shifting from state 4 to state 7
yydebug: state 7, reading 262 (MINUS)
yydebug: state 7, shifting to state 10
yydebug: state 10, reading 257 (INT)
yydebug: state 10, shifting to state 2
yydebug: state 2, reducing by rule 5 (expr : INT)
INT -> Expr!
yydebug: after reduction, shifting from state 10 to state 15
yydebug: state 15, reading 260 (RIGHT_PAR)
yydebug: state 15, reducing by rule 7 (expr : expr MINUS expr)
MINUS -> Expr!
yydebug: after reduction, shifting from state 4 to state 7
yydebug: state 7, shifting to state 13
yydebug: state 13, reducing by rule 10 (expr : LEFT_PAR expr RIGHT_PAR)
PARENS -> Expr!
yydebug: after reduction, shifting from state 11 to state 16
yydebug: state 16, reducing by rule 8 (expr : expr MULT expr)
MULT -> Expr!
yydebug: after reduction, shifting from state 1 to state 6
yydebug: state 6, reading 258 (EOL)
yydebug: state 6, shifting to state 8
yydebug: state 8, reducing by rule 3 (input : expr EOL)
-12
yydebug: after reduction, shifting from state 1 to state 5
yydebug: state 5, reducing by rule 2 (start : start input)
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, reading 0 (end-of-file)

\end{verbatim}

%%% TEXEXPAND: END FILE ./chapter_bottomup/analisis_bottomup_en_perl.tex

\chapter{Análisis Sintáctico Ascendente en C con {\tt yacc} y {\tt bison}}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter_bottomup/yaccexamples.tex
\section{Introducción a {\tt yacc}}
\label{section:introyacc}
Los fuentes de esta sección pueden encontrarse en
\htmladdnormallink{https://github.com/crguezl/yacc-examples}{https://github.com/crguezl/yacc-examples}.


Veamos un ejemplo sencillo de analizador sintáctico escrito en \tei{yacc}.
La gramática se especifica entre las dos líneas de \verb|%%|. 
Por defecto, el símbolo de arranque es el primero que aparece, en este caso
\verb|list|. En \verb|bison| es posible hacer que otro variable lo sea
utilizando la declaración \verb|%start|:

\parrafo{Ejemplo: La Calculadora en {\tt yacc}}

\begin{program} Calculadora elemental. Análizador sintáctico.
\label{prog:calc1}
\begin{verbatim}
nereida:~/src/precedencia/hoc1> cat -n hoc1.y
 1  %{
 2  /* File: /home/pl/src/precedencia/hoc1/hoc1.y */
 3  #define YYSTYPE double
 4  #include <stdio.h>
 5  %}
 6  %token NUMBER
 7  %left '+' '-'
 8  %left '*' '/'
 9  %%
10  list
11      :
12      | list '\n'
13      | list expr   { printf("%.8g\n",$2);}
14      ;
15
16  expr
17      : NUMBER { $$ = $1;}
18      | expr '+' expr {$$ = $1 + $3;}
19      | expr '-' expr {$$ = $1 - $3;}
20      | expr '*' expr {$$ = $1 * $3;}
21      | expr '/' expr {$$ = $1 / $3;}
22      ;
23
24  %%
25
26  extern FILE * yyin;
27
28  main(int argc, char **argv) {
29    if (argc > 1) yyin = fopen(argv[1],"r");
30    yydebug = 1;
31    yyparse();
32  }
33
34  yyerror(char *s) {
35    printf("%s\n",s);
36  }
\end{verbatim}
\end{program}
La macro \tei{YYSTYPE} (línea 3) contiene el tipo del valor semántico.
Si no se declara se asume \verb|int|.

El fichero \tei{yyin} (líneas 26 y 29) es definido en el 
fichero conteniendo el analizador léxico 
\tei{lex.yy.c}. Refiere al fichero de entrada conteniendo
el texto a analizar.

Al poner la variable \tei{yydebug} a 1 activamos el modo depuración.
Para que la depuración se haga efectiva es necesario definir además
la macro \tei{YYDEBUG}.

El analizador sintáctico proveido por \verb|yacc| se llama \tei{yyparse} 
(línea 31). Por defecto su declaración es \verb|int yyparse ()|

\parrafo{El Analizador Léxico}

\begin{program} 
\label{program:hoc1l}
Calculadora elemental.  Analizador léxico:
\begin{verbatim}
nereida:~/src/precedencia/hoc1> cat -n hoc1.l
 1  %{
 2  #include "y.tab.h"
 3  extern YYSTYPE yylval;
 4  %}
 5  number [0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?
 6  %%
 7  {number} { yylval = atof(yytext); return NUMBER; }
 8  .|\n     { return yytext[0];}
 9  %%
10  int yywrap() { return 1; }
\end{verbatim}
\end{program}

\parrafo{Compilación}

Al compilar el program \verb|yacc| con la opción \verb|-d|
se produce además del fichero \tei{y.tab.c} conteniendo el
analizador sintáctico un fichero adicional de cabecera \tei{y.tab.h}
conteniendo
las definiciones de los terminales:
\begin{verbatim}
nereida:~/src/precedencia/hoc1> yacc -d -v hoc1.y
nereida:~/src/precedencia/hoc1> ls -lt | head -4
total 200
-rw-rw----  1 pl users    2857 2007-01-18 10:26 y.output
-rw-rw----  1 pl users   35936 2007-01-18 10:26 y.tab.c
-rw-rw----  1 pl users    1638 2007-01-18 10:26 y.tab.h
nereida:~/src/precedencia/hoc1> sed -ne '27,48p' y.tab.h | cat -n
 1  #ifndef YYTOKENTYPE
 2  # define YYTOKENTYPE
 3     /* Put the tokens into the symbol table, so that GDB and other debuggers
 4        know about them.  */
 5     enum yytokentype {
 6       NUMBER = 258
 7     };
 8  #endif
 9  /* Tokens.  */
10  #define NUMBER 258
..  .........................................................
15  #if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
16  typedef int YYSTYPE;
17  # define yystype YYSTYPE /* obsolescent; will be withdrawn */
18  # define YYSTYPE_IS_DECLARED 1
19  # define YYSTYPE_IS_TRIVIAL 1
20  #endif
21
22  extern YYSTYPE yylval;
\end{verbatim}
La variable \tei{yylval} (líneas 3 y 7 del listado \ref{program:hoc1l}) 
es declarada por el
analizador sintáctico y usada por el analizador 
léxico. El analizador léxico deja en la misma el valor semántico
asociado con el token actual.

\parrafo{Makefile}

Para compilar todo el proyecto usaremos el siguiente
fichero Makefile:
\begin{program} Calculadora elemental.  Makefile:
\begin{verbatim}
> cat Makefile
hoc1: y.tab.c lex.yy.c
        gcc -DYYDEBUG=1 -g -o hoc1 y.tab.c lex.yy.c
y.tab.c y.tab.h: hoc1.y
        yacc -d -v hoc1.y
lex.yy.c: hoc1.l y.tab.h
        flex -l hoc1.l
clean:
        - rm -f y.tab.c lex.yy.c *.o core hoc1
\end{verbatim}
\end{program}

\parrafo{Ejecución}

\begin{execution}
Para saber que esta haciendo el analizador, insertamos una
asignación: \verb2yydebug = 1;2 justo antes de la llamada a
\verb1yyparse()1 y ejecutamos el programa resultante:
\begin{verbatim}
$ hoc1
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
2.5+3.5+1
\end{verbatim}
Introducimos la expresión \verb|2.5+3.5+1|. Antes que incluso ocurra la entrada, el algoritmo LR reduce por la regla $List \rightarrow \epsilon$.
\begin{verbatim}
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 43 ('+')
yydebug: state 4, shifting to state 5
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 5 to state 6
yydebug: state 6, reducing by rule 5 (expr : expr '+' expr)
\end{verbatim}
Observe como la declaración de la asociatividad a izquierdas \verb|%left '+'| se traduce en la reducción por la regla 5.

\begin{verbatim}
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 43 ('+')
yydebug: state 4, shifting to state 5
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 5 to state 6
yydebug: state 6, reducing by rule 5 (expr : expr '+' expr)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, reducing by rule 3 (list : list expr)
7
\end{verbatim}
La reducción por la regla $list \rightarrow list\ expr$ produce la ejecución
del \verb|printf("%.8g\n",$2);| asociado con la regla y la salida
del valor \verb|7| que constituye el atributo de $expr$.
\begin{verbatim}    
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 2 (list : list '\n')
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, reading 0 (end-of-file)
$                         
\end{verbatim}
En Unix la combinación de teclas CTRL-D nos permite
generar el final de fichero.

\end{execution}

\section{Precedencia y Asociatividad}
\label{section:precandascoyacc}
En caso de que no existan indicaciones específicas \emph{yacc} resuelve
los conflictos que aparecen en la construcción de la tabla utilizando las siguientes reglas:
\begin{enumerate}
\item
Un conflicto \emph{reduce-reduce} se resuelve eligiendo la producción que se listó primero en la especificación de la gramática.
\item
Un conflicto \emph{shift-reduce} se resuelve siempre en favor del \emph{shift}
\end{enumerate}
La precedencia se utiliza para modificar estos criterios. Para 
ello se define:

\begin{enumerate}
\item
La precedencia de los \emph{tokens} es determinada según el orden de 
declaración. La declaración de \emph{tokens} mediante la palabra reservada \verb1token1 no modifica la precedencia. Si lo hacen las declaraciones realizadas usando las palabras \verb1left1, \verb1right1 y \verb1nonassoc1. Los \emph{tokens} declarados  en la misma línea
tienen igual precedencia. La precedencia es mayor cuanto mas abajo en
el texto. Así, en el ejemplo que sigue, el \emph{token} \verb1*1 tiene 
mayor precedencia que \verb1+1 pero la misma que \verb1/1.
\item
La precedencia de una regla $A \rightarrow \alpha$ se
define como la del terminal mas a la derecha que aparece en
$\alpha$. En el ejemplo, la producción 

\begin{center}
\verb1 expr : expr '+' expr1 
\end{center}

tiene la precedencia del \emph{token} \verb1+1.
\item
Para decidir en un conflicto \emph{shift-reduce} se comparan la precedencia 
de la regla con la del terminal que va a ser desplazado. Si la de la regla es mayor se reduce
si la del \emph{token} es mayor, se desplaza.
\item
Si en un conflicto \emph{shift-reduce} ambos la regla y el terminal que va a ser desplazado
tiene la misma precedencia \emph{yacc} considera la asociatividad, si es asociativa a izquierdas,
reduce y si es asociativa a derechas desplaza. Si no es asociativa, genera un mensaje de error.\\
Obsérvese que, en esta situación, la asociatividad de la regla y la del \emph{token} han de ser por fuerza, las mismas. 
Ello es así, porque en \emph{yacc} los \emph{tokens} con la misma 
precedencia se declaran en la misma línea. 

\emph{ Por tanto es imposible declarar dos \emph{tokens} con diferente asociatividad y la misma precedencia}.
\item
Es posible modificar la precedencia ``natural'' de una regla, calificándola con un \emph{token} específico.
para ello se escribe a la derecha de la regla \verb|prec token|, donde \verb|token| es un \emph{token}
con la precedencia que deseamos. Vea el uso del \emph{token} \verb|dummy| en el siguiente ejercicio.
\end{enumerate}

\begin{program} Este programa muestra el manejo de las reglas de precedencia.
\label{prog:prec}
\begin{verbatim}
%{
#define YYSTYPE double
#include <stdio.h>
%}
%token NUMBER
%left '@' 
%right '&'  dummy
%%
list 
    :
    | list '\n'  
    | list e 
    ;

e : NUMBER  
  | e '&' e 
  | e '@' e %prec dummy
    ;

%%
extern FILE * yyin;
 
main(int argc, char **argv) {
  if (argc > 1) yyin = fopen(argv[1],"r");
  yydebug = 1;
  yyparse();
}
 
yyerror(char *s) {
  printf("%s\n",s);
}
\end{verbatim}            
\end{program}

\begin{exercise} Dado el programa \verb|yacc| \ref{prog:prec}
Responda a las siguientes cuestiones:
\begin{enumerate}
\item
Construya las tablas SLR de acciones y \emph{gotos}.
\item
Determine el árbol construido para las frases:
\verb|4@3@5|, \verb|4&3&5|, \verb|4@3&5|, \verb|4&3@5|.
\item
¿Cuál es la asociatividad final de la regla \verb|e : e '@' e|?
\end{enumerate}
\end{exercise}

\begin{listing}
Fichero \emph{y.output}:\\
\begin{verbatim}
   0  $accept : list $end

   1  list :
   2       | list '\n'
   3       | list e

   4  e : NUMBER
   5    | e '&' e
   6    | e '@' e
\end{verbatim}

\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
\begin{verbatim}
state 0
	$accept : . list $end  (0)
	list : .  (1)

	.  reduce 1

	list  goto 1


state 1
	$accept : list . $end  (0)
	list : list . '\n'  (2)
	list : list . e  (3)

	$end  accept
	NUMBER  shift 2
	'\n'  shift 3
	.  error

	e  goto 4


state 2
	e : NUMBER .  (4)

	.  reduce 4


state 3
	list : list '\n' .  (2)

	.  reduce 2


state 4
	list : list e .  (3)
	e : e . '&' e  (5)
	e : e . '@' e  (6)

	'@'  shift 5
	'&'  shift 6
	$end  reduce 3
	NUMBER  reduce 3
	'\n'  reduce 3
\end{verbatim}
&
\begin{verbatim}
state 5
	e : e '@' . e  (6)

	NUMBER  shift 2
	.  error

	e  goto 7


state 6
	e : e '&' . e  (5)

	NUMBER  shift 2
	.  error

	e  goto 8


state 7
	e : e . '&' e  (5)
	e : e . '@' e  (6)
	e : e '@' e .  (6)

	'&'  shift 6
	$end  reduce 6
	NUMBER  reduce 6
	'@'  reduce 6
	'\n'  reduce 6

state 8
	e : e . '&' e  (5)
	e : e '&' e .  (5)
	e : e . '@' e  (6)

	'&'  shift 6
	$end  reduce 5
	NUMBER  reduce 5
	'@'  reduce 5
	'\n'  reduce 5
\end{verbatim}\\
\hline
\end{tabular}

\begin{verbatim}
7 terminals, 3 nonterminals
7 grammar rules, 9 states
\end{verbatim}
\end{listing}

\begin{example}
Contrasta tu respuesta con la traza seguida por el programa anterior
ante la entrada \verb|1@2&3|, al establecer la variable \verb|yydebug = 1|
y definir la macro \verb|YYDEBUG|:
\begin{execution}
\begin{verbatim}
$ hocprec
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
1@2&3
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 64 ('@')
yydebug: state 4, shifting to state 5
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 5 to state 7
yydebug: state 7, reading 38 ('&')
yydebug: state 7, shifting to state 6
\end{verbatim}
\end{execution}
¿Por  que se desplaza? ¿No va eso en contra de la declaración 
\verb|%left '@'|?.  ¿O quizá es porque la precedencia de \verb|@|
es menor que la de \verb|&|? La respuesta es que la precedencia
asignada por la declaración 
\begin{center}
\verb|e : e '@' e %prec dummy|
\end{center}
cambio la asociatividad de la regla. Ahora la regla se
``enfrenta'' a un \emph{token}, \verb|&| con su misma precedencia.
Al pasar a ser asociativa a derechas (debido a que
\verb|dummy| lo es), se debe desplazar y no reducir.
\end{example}

\begin{example}
Otra ejecución, esta vez con entrada \verb41&2@34. Compara tus predicciones con los resultados. 

\begin{execution}
\begin{verbatim}
$ hocprec
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
1&2@3
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 38 ('&')
yydebug: state 4, shifting to state 6
yydebug: state 6, reading 257 (NUMBER)
yydebug: state 6, shifting to state 2
yydebug: state 2, reducing by rule 4 (e : NUMBER)
yydebug: after reduction, shifting from state 6 to state 8
yydebug: state 8, reading 64 ('@')
yydebug: state 8, reducing by rule 5 (e : e '&' e)
\end{verbatim}
\end{execution}
En este caso se comparan la producción :
\begin{center}
\verb1e1 $\rightarrow$ \verb1e & e1 
\end{center}
con el \emph{token} \verb1@1. La regla tiene mayor  precedencia
que el \emph{token},dado que la precedencia de la regla es la de 
\verb|&|. 
\end{example}

\section{Uso de union y type}
\label{section:union}
En general, los atributos asociados con las diferentes variables sintácticas y terminales tendrán tipos de datos distintos. Para ello, \verb|yacc| provee
la declaración \verb|%union|.

La declaración \verb|%union| especifica la colección de posibles tipos de datos de \verb|yylval| y de los atributos \verb|$1|, \verb|$2|, \ldots 

He aqui un ejemplo:

\begin{verbatim}
%union {
  double val;
  int index;
}
\end{verbatim}
Esto dice que los dos tipos de alternativas son \verb|double| y \verb|int |. Se les han dado los nombres \verb|val| y \verb|index|.
\begin{verbatim}
%token <val>   NUMBER
%token <index> VAR
%type  <val>   expr
%right '='
%left '+' '-'
%left '*' '/'
\end{verbatim}

Estos nombres \verb|<val>| e \verb|<index>| se utilizan en las declaraciones de \verb1%token1 y \verb1%type1 para definir el tipo del correspondiente atributo asociado.

Dentro de las acciones, se puede especificar el tipo de un símbolo insertando \verb|<tipo>| despues del \verb|$| que referencia al atributo. En el ejemplo anterior podríamos escribir \verb|$<val>1| para indicar que manipulamos el atributo
del primer símbolo de la parte derecha de la regla como si fuera un \verb|double|.

La información que provee la declaración \verb|%union| es utilizada por  \verb|yacc|
para realizar la sustitución de las referencias textuales/formales
(\verb|$$|, \verb|$1|, \ldots \verb|$|$|\alpha|$) a los  atributos de
los símbolos que conforman la regla (que pueden verse como parámetros
formales de las acciones) por las referencias a las zonas de memoria
en las que se guardan (que están asociadas con los correspondientes
estados de la pila) cuando tiene lugar la reducción en el algoritmo de
análisis LR:

\begin{flushleft}
    \verb|    case "reduce A |$\rightarrow \alpha$\verb|" : |
\\* \verb|      execute("reduce A |$\rightarrow \alpha$\verb|", top(|$|\alpha|$\verb|-1), |$\cdots$\verb| , top(0));| 
\\* \verb|      pop(|$|\alpha|$\verb|);| 
\\* \verb|      push(goto[top(0)][A];| 
\\* \verb|      break;|
\end{flushleft}

Asi, \verb|yacc| es capaz de insertar 
el código de ahormado de tipos correcto.
Ello puede hacerse porque se conocen los tipos 
asociados con los símbolos en la parte derecha de 
una regla, ya que han sido proveídos en  
las declaraciones \verb|%union|, \verb|%token| y \verb|%type|.
 
\section{Acciones en medio de una regla}
\label{section:mediareglayacc}
A veces necesitamos insertar una acción en medio de una regla.
Una acción en medio de una regla puede hacer referencia a los atributos de
los símbolos que la preceden (usando \verb|$n|), pero no a los que le siguen.

Cuando se  inserta una acción $\left \{ action_1\right \}$
para su ejecución en medio de una regla $A \rightarrow \alpha
\beta$ :
\begin{center}
$A \rightarrow \alpha \left \{ action_1 \right \} \beta \left \{ action_2\right \}$ 
\end{center}
\verb|yacc| crea una variable sintáctica temporal $T$ e introduce una nueva regla:

\begin{center}
\begin{enumerate}
\item
$A \rightarrow \alpha T \beta \left \{ action_2\right \}$ 
\item
$T \rightarrow \epsilon \left \{ action_1 \right \}$ 
\end{enumerate}
\end{center}

Las acciones en mitad de una regla cuentan como un símbolo mas en la parte 
derecha de la regla. Asi pues, en una acción posterior en la regla,
se deberán referenciar los  atributos de los símbolos, teniendo en cuenta este hecho.

Las acciones en mitad de la regla pueden tener un atributo. La acción en cuestión puede
hacer referencia a ese atributo mediante \verb|$$|, y las acciones posteriores
en la regla se referirán a él como \verb|$n|, siendo \verb|n| su número de orden
en la parte derecha. Dado que no existe un símbolo explícito que identifique a 
la acción, no hay manera de que el programador declare su tipo. Sin embargo, es
posible utilizar la construcción \verb|$<valtipo>#| para especificar 
la forma en la que queremos manipular su atributo.

Na hay forma de darle, en una acción a media regla, un valor al atributo asociado con
la variable en la izquierda de la regla de producción (ya que \verb|$$| se refiere
al atributo de la variable temporal utilizada para introducir la acción a media regla).

\begin{program} El siguiente programa ilustra el uso de \verb|%union| y de las
acciones en medio de una regla.
\label{prog:media}
\begin{verbatim}
%{
#include <string.h>
char buffer[256];
#define YYDEBUG 1
%}
%union {
  char tA;
  char *tx;
}
%token <tA> A
%type <tx> x
%%
s : x { *$1 = '\0'; printf("%s\n",buffer); } '\n' s 
  |
  ;

x : A { $$ = buffer + sprintf(buffer,"%c",$1); }
  | A { $<tx>$ = strdup("**"); } x 
    { $$ = $3 + sprintf($3,"%s%c",$<tx>2,$1); free($2); }
  ;

%%

main() {
  yydebug=1;
  yyparse();
}

yyerror(char *s) {
  printf("%s\n",s);
}
\end{verbatim}
\end{program}

\begin{program} El analizador léxico utilizado es el siguiente:
\begin{verbatim}
%{
#include "y.tab.h"
%}
%%
[\t ]+
[a-zA-Z0-9]   { yylval.tA = yytext[0]; return A; }
(.|\n)        { return yytext[0]; }
%%
yywrap() { return 1; }
\end{verbatim}
\end{program}

\begin{example}
Considere el programa \verb|yacc| \ref{prog:media}. ¿Cuál es la salida para la entrada 
$ABC$?

La gramática inicial se ve aumentada con dos nuevas variables sintácticas temporales
y dos reglas $t_1 \rightarrow \epsilon$ y $t_2 \rightarrow \epsilon$. Además las reglas
correspondientes pasan a ser: $s \rightarrow x t_1 s$ y $x \rightarrow A t_2 x$. El análisis 
de la entrada $ABC$ nos produce el siguiente árbol anotado:

\end{example}

\begin{execution}
Observe la salida de la ejecución del programa \ref{prog:media}.
La variable ``temporal'' creada por \verb|yacc|  para la acción
en medio de la regla
\begin{center}
\verb|s |$\rightarrow$ \verb@ x { *$1 = '\0'; printf("%s\n",buffer); } '\n' s@ 
\end{center}
se denota por \verb|$$1|. La asociada con la acción en medio de la regla
\begin{center}
\verb|x | $\rightarrow$ \verb| A { $<tx>$ = strdup("**"); } x| 
\end{center}
se denota \verb|$$2|.
\begin{verbatim}
$ yacc -d -v media4.y ; flex -l medial.l ; gcc -g y.tab.c lex.yy.c
$ a.out
ABC
yydebug: state 0, reading 257 (A)
yydebug: state 0, shifting to state 1
yydebug: state 1, reading 257 (A)
yydebug: state 1, reducing by rule 5 ($$2 :)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, shifting to state 1
yydebug: state 1, reading 257 (A)
yydebug: state 1, reducing by rule 5 ($$2 :)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, shifting to state 1
yydebug: state 1, reading 10 ('\n')
yydebug: state 1, reducing by rule 4 (x : A)
yydebug: after reduction, shifting from state 4 to state 6
yydebug: state 6, reducing by rule 6 (x : A $$2 x)
yydebug: after reduction, shifting from state 4 to state 6
yydebug: state 6, reducing by rule 6 (x : A $$2 x)
yydebug: after reduction, shifting from state 0 to state 3
yydebug: state 3, reducing by rule 1 ($$1 :)
C**B**A
yydebug: after reduction, shifting from state 3 to state 5
yydebug: state 5, shifting to state 7
yydebug: state 7, reading 0 (end-of-file)
yydebug: state 7, reducing by rule 3 (s :)
yydebug: after reduction, shifting from state 7 to state 8
yydebug: state 8, reducing by rule 2 (s : x $$1 '\n' s)
yydebug: after reduction, shifting from state 0 to state 2      
\end{verbatim}
\end{execution}

\begin{example}
\label{exa:conflicto}
¿Que ocurre si en el programa \ref{prog:media} adelantamos la acción intermedia  en la regla
\begin{center}
\verb|x| $\rightarrow$ \verb| A { $<tx>$ = strdup("**"); } x|
\end{center}
y la reescribimos 
\begin{center}
\verb|x| $\rightarrow$ \verb|  { $<tx>$ = strdup("**"); } A x|?
\end{center}

\begin{execution} En tal caso obtendremos:
\begin{verbatim}
$ yacc -d -v media3.y
yacc: 1 rule never reduced
yacc: 3 shift/reduce conflicts. 
\end{verbatim}
¿Cuáles son esos 3 conflictos?
\end{execution}
\begin{listing} El fichero \verb|y.output| comienza enumerando las reglas de 
la gramática extendida:
\begin{verbatim}
 1    0  $accept : s $end
 2
 3    1  $$1 :
 4
 5    2  s : x $$1 '\n' s
 6    3    |
 7
 8    4  x : A
 9
10    5  $$2 :
11
12    6  x : $$2 A x
13 ^L
\end{verbatim}
A continuación nos informa de un conflicto 
en el estado 0. Ante el \emph{token} \verb|A|
no se sabe si se debe desplazar al estado 1
o reducir por la regla 5: \verb| $$2 : |.
\begin{verbatim}
14 0: shift/reduce conflict (shift 1, reduce 5) on A
15 state 0
16         $accept : . s $end  (0)
17         s : .  (3)
18         $$2 : .  (5)
19
20         A  shift 1
21         $end  reduce 3
22
23         s  goto 2
24         x  goto 3
25         $$2  goto 4         
\end{verbatim}
Observe que, efectivamente, \verb|$$2 : .| esta
en la clausura del estado de arranque del NFA (\verb|$accept : . s $end|)
Esto es asi, ya que al estar el marcador junto a \verb|x|, estará el item
 \verb|s : . x $$1 '\n' s| y de aqui que también este
\verb|x : . $$2 A x|. 

Además el \emph{token} \verb|A| está en 
el conjunto $FOLLOW(\verb|$$2|)$ (Basta con mirar la regla 6 para confirmarlo). 
Por razones análogas también está en la clausura del estado de 
arranque el item \verb|x : . A| que es el que motiva el
desplazamiento al estado 1.

La dificultad para \verb|yacc| se resolvería si
dispusiera de información acerca de cual es el \emph{token}
que viene después de la \verb|A| que causa el conflicto. 
\end{listing}
\end{example}

\begin{exercise}
¿Que acción debe tomarse en el conflicto del ejemplo \ref{exa:conflicto} 
si el \emph{token} que viene después de \verb|A| es \verb|\n|?
¿Y si el \emph{token} es \verb|A|? ¿Se debe reducir o desplazar?
\end{exercise}

\section{Recuperación de Errores}
\label{section:recuperryacc}
Las entradas de un traductor pueden contener errores. 
El lenguaje \verb|yacc| proporciona un \emph{token} especial,
\verb|error|, que puede ser utilizado en el programa fuente
para extender el traductor con producciones de error 
que lo doten de cierta capacidad para 
recuperase de  una entrada errónea y poder continuar 
analizando el resto de la entrada.
\begin{execution}
Consideremos lo que ocurre al ejecutar el programa \verb|yacc|
\ref{prog:calc1} con una entrada errónea:
\begin{verbatim}
$ hoc1
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
3--2
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 2
yydebug: state 2, reducing by rule 4 (expr : NUMBER)
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 45 (illegal-symbol)
syntax error
yydebug: error recovery discarding state 4
yydebug: error recovery discarding state 1
yydebug: error recovery discarding state 0
\end{verbatim}
\end{execution}

Después de detectar el mensaje \verb|yacc| emite el mensaje 
\verb|syntax error| y comienza a sacar estados de la pìla hasta que esta se vacía.

\begin{program}
\label{prog:calc1err}
La conducta anterior puede modificarse si se introducen ``reglas de 
recuperación de errores'' como en la siguiente modificación
del programa \ref{prog:calc1}:
\begin{verbatim}
%{
#define YYSTYPE double
#define YYDEBUG 1
#include <stdio.h>
%}
%token NUMBER
%left '-'
%%
list 
    :
    | list '\n'  
    | list error '\n'  { yyerrok; }
    | list expr   { printf("%.8g\n",$2);}
    ;

expr 
    : NUMBER { $$ = $1;} 
    | expr '-' expr {$$ = $1 - $3;}
    ;

%%
\end{verbatim}
\end{program}
La regla \verb|list |$\rightarrow$ \verb|list error '\n'| es una producción de
error. La idea general de uso es que, a traves de la misma, el programador 
le indica a \verb|yacc| que, cuando se produce un error
dentro de una expresión, descarte todos los \emph{tokens} hasta llegar al
retorno del carro y prosiga con el análisis. 
Además, mediante la llamada a  la macro \verb|yyerrok| el programador
anuncia que, si se alcanza este punto, la recuperación puede considerarse ``completa''  y que 
\verb|yacc| puede emitir a partir de ese moemnto mensajes de error
con la seguridad de que no son consecuencia de un comportamiento inestable
provocado por el primer error.

\begin{algorithm}
\label{alg:errorrecovery1}
El esquema general del algoritmo de recuperación de errores usado 
por la versión actual de \verb|yacc| es el siguiente:

\begin{enumerate}
\item
Cuando se encuentra ante una acción de error, el analizador genera un 
\emph{token} \verb1error1.

\item
A continuación pasa a retirar estados de la pila hasta que descubre un estado capaz de transitar ante 
el \emph{token} \verb1error1. 

\item
En este punto transita al estado correspondiente a desplazar el 
\emph{token} \verb1error1. 

\item
Entonces lee \emph{tokens} y los descarta hasta encontrar
uno que sea aceptable. 

\item
Sólo se envían nuevos mensajes de error una vez asimilados (desplazados) tres símbolos terminales. De este modos se intenta evitar la aparición masiva de mensajes de error.
\end{enumerate}
\end{algorithm}

\begin{algorithm} El cuerpo principal del analizador LR permanece
sin demasiados cambios:
\begin{verbatim}
goodtoken = 3; b = yylex();
for( ; ; ;) {
  s = top(); a = b;
  switch (action[s][a])) {
    case "shift t" : push(t); b = yylex(); goodtoken++; break;
    case "reduce A -> alpha" : 
            pop(strlen(alpha));
            push(goto[top()][A]; 
          break; 
    case "accept" : return (1); 
    default : if (errorrecovery("syntax error")) return (ERROR);
  }
}
\end{verbatim}
\end{algorithm}
\begin{algorithm}
El siguiente seudocódigo es una reescritura mas detallada del algoritmo \ref{alg:errorrecovery1}. Asumimos que las funciones \verb1pop()1 y \verb1popstate()1
comprueban que hay suficientes elementos en
la pila para retirar. En caso contrario se emitirá un mensaje de error y 
se terminará el análisis. 

\begin{verbatim}
errorrecovery(char * s) {
 if (goodtoken > 2) { 
   yyerror(s); goodtoken = 0; 
 }
 while (action[s][error] != shift)
   popstate(s);
 push(goto[s][error]);
 s = top();
 while (action[s][a] == reduce A -> alpha) {
   pop(strlen(|alpha|)); 
   push(goto[top()][A]; 
   s = top(); 
 }
 switch (action[s][a])) {
   case "shift t" : 
     push(t); 
     b = yylex(); 
     goodtoken++; 
     RETURN RECOVERING;
   case "accept" : return (ERROR); 
   default : 
     do b = yylex(); 
     while ((b != EOF)&&(action[s][b] == error); 
     if (b == EOF) 
       return (ERROR); 
     else 
       RETURN RECOVERING
}
\end{verbatim}
\end{algorithm}
Parecen existir diferencias en la forma en la que \emph{bison} y \emph{yacc} se recuperan de los errores.

\begin{execution}
Ejecutemos el programa \ref{prog:calc1err} con \verb|yacc|.
\begin{verbatim}
$ yacc -d hoc1.y; flex -l hoc1.l; gcc y.tab.c lex.yy.c; a.out
yydebug: state 0, reducing by rule 1 (list :)
yydebug: after reduction, shifting from state 0 to state 1
2--3-1
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 5 (expr : NUMBER)
yydebug: after reduction, shifting from state 1 to state 5
yydebug: state 5, reading 45 ('-')
yydebug: state 5, shifting to state 7
yydebug: state 7, reading 45 ('-')
syntax error
\end{verbatim}
Puesto que es el primer error, se cumple que 
\verb|(goodtoken > 2)|, emitiéndose el mensaje de error.
Ahora comienzan a ejecutarse las líneas:

\begin{center}
\noindent \verb|while (!(action[s][error] != shift)) popstate(s);|
\end{center}

\noindent que descartan los estados, hasta encontrar el estado
que contiene el item 

\verb|list| $\rightarrow$ \verb| list| $\uparrow$ \verb| error '\n'|  
\begin{verbatim}
yydebug: error recovery discarding state 7
yydebug: error recovery discarding state 5
yydebug: state 1, error recovery shifting to state 2
\end{verbatim}
Una vez en ese estado, transitamos con el token \verb|error|,
\begin{verbatim}
yydebug: state 2, error recovery discards token 45 ('-')
yydebug: state 2, reading 257 (NUMBER)
yydebug: state 2, error recovery discards token 257 (NUMBER)
yydebug: state 2, reading 45 ('-')
yydebug: state 2, error recovery discards token 45 ('-')
yydebug: state 2, reading 257 (NUMBER)
yydebug: state 2, error recovery discards token 257 (NUMBER)
\end{verbatim}
Se ha procedido a descartar \emph{tokens} hasta encontrar el retorno
de carro, ejecutando las líneas:
\begin{center}
\verb|b = yylex(); while ((b != EOF)&&(action[s][b] == error);|
\end{center}

\begin{verbatim}
yydebug: state 2, reading 10 ('\n')
yydebug: state 2, shifting to state 6
yydebug: state 6, reducing by rule 3 (list : list error '\n')
yydebug: after reduction, shifting from state 0 to state 1
\end{verbatim}
Al reducir por la regla de error, se ejecuta \verb|yyerrok|
y \verb|yacc| reestablece el valor de \verb|goodtoken|.
Si se producen nuevos errores serán señalados.
\end{execution}

\section{Recuperación de Errores en Listas}
\label{section:recuperryacclistas}
Aunque no existe un método exacto para decidir como ubicar
las reglas de recuperación de errores, 
en general, los s\'{\i}mbolos de error deben ubicarse intentado 
satisfacer las siguientes reglas:

\begin{itemize}
\item
Tan cerca como sea posible del s\'{\i}mbolo de arranque.
\item
Tan cerca como sea posible de los s\'{\i}mbolos terminales.
\item
Sin introducir nuevos conflictos.
\end{itemize}

\begin{scheme}
\label{scheme:errinlists}
En el caso particular de las listas, se recomienda seguir el
siguiente esquema:

\begin{math}
\begin{array}{lll}
Construct         & EBNF & yacc\ input\\
\hline
optional\ sequence & x:\{y\}   & \verb|x : /* null */             |\\ 
                   &           & \verb|  | x y  { yyerrok; }      |\\
                   &           & \verb|  | x error                |\\
\hline
sequence          & x:y\{y\}  & \verb|x : y                      |\\ 
                  &           & \verb|  | xy   { yyerrok; }      |\\
                &           & \verb|  | error                  |\\
                &           & \verb|  | x error                |\\
\hline
list              & x:y\{Ty\} & \verb|x : y                       |\\ 
                  &           & \verb|  | x T y { yyerrok; }      |\\
                &           & \verb|  | error                   |\\
                &           & \verb|  | x error                 |\\
                &           & \verb|  | x error y { yyerrok; }  |\\
                &           & \verb|  | x  T error              |\\
\hline
\end{array}
\end{math}
\end{scheme}

\begin{program} 
Para comprobar el funcionamiento y la validez de la metodología 
esquematizada en el esquema \ref{scheme:errinlists}, 
consideremos los contenidos del fichero \verb1error.y1.
En el se muestra el tercer caso x:y\{Ty\} con 
x = {\tt list}, T = {\tt ,} e y = {\tt NUMBER}:
\begin{verbatim}
%{
#include <stdio.h>
void put(double x);
void err(int code); 
%}

%union { 
  double val; 
}
%token <val>NUMBER
%%
command 
  : 
  | command list '\n' { yyerrok; } 
  ;

list 
    : NUMBER            { put($1); }
    | list ',' NUMBER   { put($3); yyerrok; }
    | error             { err(1); }
    | list error        { err(2); }
    | list error NUMBER { err(3); put($3); yyerrok; }
    | list ',' error    { err(4); }
    ;
    
%%    
void put(double x) {   
  printf("%2.1lf\n",x);
}

void err(int code) {
  printf("err %d\n",code);
}

main() {
  yydebug = 1;
  yyparse();
}

yyerror(char *s) {
  printf("%s\n",s);
}
\end{verbatim} 
\end{program} 

\begin{listing}
La compilación con \verb1yacc1 da lugar a una tabla ligeramente diferente
de la producida por \verb|bison|.
El fichero \verb1y.output1 contiene la tabla:
\begin{verbatim}
   0  $accept : command $end

   1  command :
   2          | command list '\n'

   3  list : NUMBER
   4       | list ',' NUMBER
   5       | error
   6       | list error
   7       | list error NUMBER
   8       | list ',' error

state 0
	$accept : . command $end  (0)
	command : .  (1)

	.  reduce 1

	command  goto 1


state 1
	$accept : command . $end  (0)
	command : command . list '\n'  (2)

	$end  accept
	error  shift 2
	NUMBER  shift 3
	.  error

	list  goto 4


state 2
	list : error .  (5)

	.  reduce 5


state 3
	list : NUMBER .  (3)

	.  reduce 3


state 4
	command : command list . '\n'  (2)
	list : list . ',' NUMBER  (4)
	list : list . error  (6)
	list : list . error NUMBER  (7)
	list : list . ',' error  (8)

	error  shift 5
	'\n'  shift 6
	','  shift 7
	.  error


state 5
	list : list error .  (6)
	list : list error . NUMBER  (7)

	NUMBER  shift 8
	error  reduce 6
	'\n'  reduce 6
	','  reduce 6


state 6
	command : command list '\n' .  (2)

	.  reduce 2


state 7
	list : list ',' . NUMBER  (4)
	list : list ',' . error  (8)

	error  shift 9
	NUMBER  shift 10
	.  error


state 8
	list : list error NUMBER .  (7)

	.  reduce 7


state 9
	list : list ',' error .  (8)

	.  reduce 8


state 10
	list : list ',' NUMBER .  (4)

	.  reduce 4


5 terminals, 3 nonterminals
9 grammar rules, 11 states
\end{verbatim}
\end{listing}
\begin{execution}
La ejecución del programa generado por {\tt yacc} es como sigue:
\begin{verbatim}
> error
yydebug: state 0, reducing by rule 1 (command :)
yydebug: after reduction, shifting from state 0 to state 1
10 20
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 3 (list : NUMBER)
10.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 257 (NUMBER)
syntax error
yydebug: state 4, error recovery shifting to state 5
yydebug: state 5, shifting to state 8
yydebug: state 8, reducing by rule 7 (list : list error NUMBER)
err 3
20.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
10;20 30
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 3 (list : NUMBER)
10.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 59 (illegal-symbol)
syntax error
yydebug: state 4, error recovery shifting to state 5
yydebug: state 5, error recovery discards token 59 (illegal-symbol)
yydebug: state 5, reading 257 (NUMBER)
yydebug: state 5, shifting to state 8
yydebug: state 8, reducing by rule 7 (list : list error NUMBER)
err 3
20.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 257 (NUMBER)
syntax error
yydebug: state 4, error recovery shifting to state 5
yydebug: state 5, shifting to state 8
yydebug: state 8, reducing by rule 7 (list : list error NUMBER)
err 3
30.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
3,
yydebug: state 1, reading 257 (NUMBER)
yydebug: state 1, shifting to state 3
yydebug: state 3, reducing by rule 3 (list : NUMBER)
3.0
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, reading 44 (',')
yydebug: state 4, shifting to state 7
yydebug: state 7, reading 10 ('\n')
syntax error
yydebug: state 7, error recovery shifting to state 9
yydebug: state 9, reducing by rule 8 (list : list ',' error)
err 4
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
#
yydebug: state 1, reading 35 (illegal-symbol)
syntax error
yydebug: state 1, error recovery shifting to state 2
yydebug: state 2, reducing by rule 5 (list : error)
err 1
yydebug: after reduction, shifting from state 1 to state 4
yydebug: state 4, error recovery discards token 35 (illegal-symbol)
yydebug: state 4, reading 10 ('\n')
yydebug: state 4, shifting to state 6
yydebug: state 6, reducing by rule 2 (command : command list '\n')
yydebug: after reduction, shifting from state 0 to state 1
yydebug: state 1, reading 0 (end-of-file)
\end{verbatim}
\end{execution}

%%% TEXEXPAND: END FILE ./chapter_bottomup/yaccexamples.tex

\chapter{Análisis Semántico}

\chapter{Generación de Código}

\chapter{Optimización de Código}

\part{TERCERA PARTE: BITÁCORA DEL CURSO}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter99/bitacora.tex
\chapter{2013}

\section{31/01/13}
\begin{itemize}
\item Presentación de la Asignatura
\item Ejercicio: \htmladdnormallink{Darse de alta en la comunidad de google plus
PL Grado ULL 12/13>}{https://plus.google.com/u/0/communities/100856772699690495413"}
\item Ejercicio: Indicar un mail en gmail para compartir recursos
\item Ejercicio: Indicar página en GitHub
\end{itemize}

\section{Repaso: Primera Parte. Prueba del 14/03/13}

\begin{enumerate}
%%% TEXEXPAND: INCLUDED FILE MARKER ./chapter99/repasos/070313/preguntas.tex

\item
¿Que retorna?
\begin{verbatim}
"hello small world and blue sky".match(/(\S+)\s+(\S+)/);
\end{verbatim}

\item
Indique que casa con el primer paréntesis y que con el segundo en las siguientes expresiones regulares:
\begin{verbatim}
> x = "I have 2 numbers: 53147"
> pats = [ /(.*)(\d*)/, 
           /(.*)(\d+)/, 
           /(.*?)(\d*)/, 
           /(.*?)(\d+)/, 
           /(.*)(\d+)$/, 
           /(.*?)(\d+)$/, 
           /(.*)\b(\d+)$/, 
           /(.*\D)(\d+)$/ ]
\end{verbatim}
Es decir, compute la salida de:
\begin{verbatim}
   pats.map( function(r) { return r.exec(x).slice(1); })
\end{verbatim}
\item
¿Que retorna el matching?:
\begin{verbatim}
>  a = "hola juan"
 => "hola juan" 
> a.match(/(?:hola )*(juan)/)
\end{verbatim}

\item 
Escriba una expresión regular que reconozca cadenas de dobles comillas como \verb|"hello world"|
y en las que las comillas puedan aparecer escapadas como en \verb|"Hello \"Jane\" and Jakes"|

\item
Escriba una expresión regular que reconozca los números en punto flotante como
\verb|2.34|, \verb|-5.2e-1| y \verb|0.9e3|

\item
\label{item:ccomments}
¿Que queda en \verb|m[0]|?
\begin{verbatim}
m = 'main() /* 1c */ { /* 2c */ return; /* 3c */ }'.match(new RegExp('/\\*.*\\*/'))
\end{verbatim}
¿Por qué?
\item 
¿Por qué debemos duplicar el carácter de escape \verb|\| en  la expresión regular \verb|new RegExp('/\\*.*\\*/')| de la pregunta anterior \ref{item:ccomments}?
\item
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
> 'ab,cd,4,3,   de,   fg'.replace(/,/, ', ')
=> "ab, cd, 4, 3,    de,    fg" 
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique

\item
Escribe un patrón regular
que reconozca las cadenas  que representan números no primos en unario
de manera que el primer paréntesis case con el divisor mas grande del número.

\item
Escribe un patrón regular
que reconozca las cadenas  que representan números no primos en unario
de manera que el primer paréntesis case con el divisor mas pequeño del número.

\item Escriba una expresión regular que reconozca los comentarios del lenguaje JavaScript de la forma
\verb|// ...  |

\item Escriba una expresión regular que reconozca los comentarios del lenguaje JavaScript de la forma
\verb|/* ...  */|


\item Rellene lo que falta para que la salida sea la que aparece en la sesión de node:
\begin{verbatim}
> re = __________
> str = "John Smith"
'John Smith'
> newstr = str.replace(re, "______")
'Smith, John'
\end{verbatim}
\item  Rellene las partes que faltan:
\begin{verbatim}
> re = /d(b+)(d)/ig
/d(b+)(d)/gi
> z = "dBdxdbbdzdbd"
'dBdxdbbdzdbd'
> result = re.exec(z)
[ ______, _____, ______, index: __, input: 'dBdxdbbdzdbd' ]
> re.lastIndex
______
> result = re.exec(z)
[ ______, _____, ______, index: __, input: 'dBdxdbbdzdbd' ]
> re.lastIndex
______
> result = re.exec(z)
[ ______, _____, ______, index: __, input: 'dBdxdbbdzdbd' ]
> re.lastIndex
______
> result = re.exec(z)
_____
\end{verbatim}
\item Escriba la expresión regular \verb|r| para que produzca el resultado final:
\begin{verbatim}
> x = "hello"
> r = /l(___)/
> z = r.exec(x)
[ 'l', index: 3, input: 'hello' ]
\end{verbatim}
\item 
\begin{verbatim}
> z = "dBdDBBD"
> re = /d(b+)(d)/ig
> re.lastIndex = ________
> result = re.exec(z)
[ 'DBBD',
  'BB',
  'D',
  index: 3,
  input: 'dBdDBBD' ]
\end{verbatim}
\item  Conteste:
\begin{enumerate}
\item Explique que hace el siguiente fragmento de código:
\begin{verbatim}
> RegExp.prototype.bexec = function(str) {
...   var i = this.lastIndex;
...   var m = this.exec(str);
...   if (m && m.index == i) return m;
...   return null;
... }
[Function]
\end{verbatim}
\item Rellene las salidas que faltan:
\begin{verbatim}
> re = /d(b+)(d)/ig
/d(b+)(d)/gi
> z = "dBdXXXXDBBD"
'dBdXXXXDBBD'
> re.lastIndex = 3
> re.bexec(z)
_____________________________________________________
> re.lastIndex = 7
> re.bexec(z)
_____________________________________________________
\end{verbatim}
\end{enumerate}
\item  En el siguiente programa - que calcula la conversión
de temperaturas entre grados Farenheit y Celsius - rellene las partes que faltan:
\begin{enumerate}
\item  index.html:
\begin{verbatim}
<html>
  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=_____">
      <title>JavaScript Temperature Converter</title>
      <link ____="global.css" ___="stylesheet" ____="text/css">

     <script type="_______________" src="temperature.js"></script>
  </head>
  <____>
    <h1>Temperature Converter</h1>
    <table>
      <tr>
        <th>Enter  Temperature (examples: 32F, 45C, -2.5f):</th>
        <td><input id="________" ________="calculate();"></td>
      </tr>
      <tr>
        <th>Converted Temperature:</th>
        <td><span class="output" id="_________"></span></td>
      </tr>
    </table>
  </____>
</html>
\end{verbatim}

\item Rellene las partes del código JavaScript que faltan en \verb|temperature.js|:
\begin{verbatim}
"use strict"; // Use ECMAScript 5 strict mode in browsers that support it
function calculate() {
  var result;
  var original       = document.getElementById("________");
  var temp = original.value;
  var regexp = /_______________________________/;
  
  var m = temp.match(______);
  
  if (m) {
    var num = ____;  // paréntesis correspondiente
    var type = ____;
    num = parseFloat(num);
    if (type == 'c' || type == 'C') {
      result = (num * 9/5)+32;
      result = ______________________________ // 1 sólo decimal y el tipo
    }
    else {
      result = (num - 32)*5/9;
      result = ____________________________ // 1 sólo decimal y el tipo
    }
    converted._________ = result; // Insertar "result" en la página
  }
  else {
    converted._________ = "ERROR! Try something like '-4.2C' instead";
  }
}
\end{verbatim}
\end{enumerate}
\item  ¿Que hace \verb|autofocus|?
\begin{verbatim}
<td><textarea autofocus cols = "80" rows = "5" id="original"></textarea></td> 
\end{verbatim}
\item  ¿Que hacen las siguientes pseudo-clases estructurales CSS3?
\begin{verbatim}
tr:nth-child(odd)    { background-color:#eee; }
tr:nth-child(even)    { background-color:#00FF66; }
\end{verbatim}
\item ¿Que contiene el objeto \verb|window| en un programa JavaScript que se ejecuta en un navegador?

\item 
\begin{enumerate}
\item 
¿Que es \htmladdnormallink{Local Storage}{http://diveinto.html5doctor.com/storage.html}? ¿Que hace la siguiente línea?
\begin{verbatim}
  if (window.localStorage) localStorage.original  = temp;
\end{verbatim}
\item  ¿Cuando se ejecutará esta callback? ¿Que hace?
\begin{verbatim}
window.onload = function() {
  // If the browser supports localStorage and we have some stored data
  if (window.localStorage && localStorage.original) {
    document.getElementById("original").value = localStorage.original;
  }
};
\end{verbatim}
\end{enumerate}

\item 
Escriba una expresión JavaScript que permita reemplazar todas las apariciones de palabras repetidas en una String por una sóla aparición de la misma
\item  ¿Cómo se hace para que elementos de la página web permanezcan ocultos para 
posteriormente mostrarlos? ¿Que hay que hacer en el HTML, en la hoja de estilo y en el JavaScript?
\item Rellene los estilos para los elementos de las clases para que su visibilidad
case con la que su nombre indica:
\begin{verbatim}
.hidden      { display: ____; }
.unhidden    { display: _____; }
\end{verbatim}
\item  El siguiente fragmento de código tiene por objetivo
escapar las entidades HTML para que no sean intérpretadas como código HTML.
Rellene las partes que faltan.
\begin{verbatim}
var entityMap = {
    "&": "&___;",
    "<": "&__;",
    ">": "&__;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
  };

function escapeHtml(string) {
  return String(string).replace(/_________/g, function (s) {
    return ____________;
  });
\end{verbatim}
\item 
Supongamos que se usa una función como segundo argumento de \verb|replace|.
¿Que argumentos recibe?
\item 
¿Cual es la salida?
\begin{verbatim}
> "bb".match(/b|bb/)

> "bb".match(/bb|b/)

\end{verbatim}



\item 
Los siguientes textos corresponden  a los ficheros de 
la práctica 
de construcción de un analizador léxico de los ficheros de configuración INI. 
Rellena las partes que faltan.
\begin{enumerate}
\item  Rellena las partes que faltan en el contenido del fichero \verb|index.html|. 
Comenta que hace el tag \verb|<input>|.
Comenta que hace el tag \verb|<pre>|.
\begin{verbatim}
<html>
  <head>
     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
     <title>INI files</title>
     <link href="global.css" rel="__________" type="text/css">

     <script type="_______________" src="underscore.js"></script>
     <script type="_______________" src="jquery.js"></script>
     <script type="_______________" src="______"></script>
  </head>
  <body>
    <h1>INI files</h1>
    <input type="file" id="_________" />
    <div id="out" class="hidden">
    <table>
      <tr><th>Original</th><th>Tokens</th></tr>
      <tr>
        <td>
          <pre class="input" id="____________"></pre>
        </td>
        <td>
          <pre class="output" id="___________"></pre>
        </td>
      </tr>
    </table>
    </div>
  </body>
</html>
\end{verbatim}

\item 
A continuación siguen los contenidos del fichero \verb|ini.js| conteniendo el JavaScript.
\begin{enumerate}
\item 
Rellena las partes que faltan. 
El siguiente ejemplo de fichero \verb|.ini| le puede ayudar
a recordar la parte de las expresiones regulares 
\begin{verbatim}
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.
\end{verbatim}
\item 
Explica 
el uso del template.
\item 
Explica el uso de JSON.stringify
\end{enumerate}
\begin{verbatim}
"use ______"; // Use ECMAScript 5 strict mode in browsers that support it

$(document)._____(function() {
   $("#fileinput").______(calculate);
});

function calculate(evt) {
  var f = evt.target.files[0]; 

  if (f) {
    var r = new __________();
    r.onload = function(e) { 
      var contents = e.target.______;
      
      var tokens = lexer(contents);
      var pretty = tokensToString(tokens);
      
      out.className = 'unhidden';
      initialinput._________ = contents;
      finaloutput._________ = pretty;
    }
    r.__________(f); // Leer como texto
  } else { 
    alert("Failed to load file");
  }
}

var temp = '<li> <span class = "<%= ______ %>"> <%= _ %> </span>\n';

function tokensToString(tokens) {
   var r = '';
   for(var i in tokens) {
     var t = tokens[i];
     var s = JSON.stringify(t, undefined, 2); //______________________________
     s = _.template(temp, {t: t, s: s});
     r += s;
   }
   return '<ol>\n'+r+'</ol>';
}

function lexer(input) {
  var blanks         = /^___/;
  var iniheader      = /^________________/;
  var comments       = /^________/;
  var nameEqualValue = /^________________________/;
  var any            = /^_______/;

  var out = [];
  var m = null;

  while (input != '') {
    if (m = blanks.____(input)) {
      input = input.substr(m.index+___________);
      out.push({ type : ________, match: _ });
    }
    else if (m = iniheader.exec(input)) {
      input = input.substr(___________________);
      _______________________________________ // avanzemos en input
    }
    else if (m = comments.exec(input)) {
      input = input.substr(___________________);
      _________________________________________
    }
    else if (m = nameEqualValue.exec(input)) {
      input = input.substr(___________________);
      _______________________________________________
    }
    else if (m = any.exec(input)) {
      _______________________________________
      input = '';
    }
    else {
      alert("Fatal Error!"+substr(input,0,20));
      input = '';
    }
  }
  return out;
}
\end{verbatim}
\end{enumerate}

%%% TEXEXPAND: END FILE ./chapter99/repasos/070313/preguntas.tex
\end{enumerate}
%%% TEXEXPAND: END FILE ./chapter99/bitacora.tex

\tableofcontents 
\listoffigures
\listoftables

\printindex

\bibliographystyle{unsrt}
%\bibliographystyle{plain}
%\bibliography{perlbib/perl}
\bibliography{perlbib/ruby}
\end{document}
