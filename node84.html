<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>unput()</TITLE>
<META NAME="description" CONTENT="unput()">
<META NAME="keywords" CONTENT="javascriptexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="previous" HREF="node83.html">
<LINK REL="up" HREF="node81.html">
<LINK REL="next" HREF="node85.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2812"
  HREF="node85.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2806"
  HREF="node81.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2802"
  HREF="node83.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2808"
  HREF="node194.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2810"
  HREF="node197.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2813"
  HREF="node85.html">Expresiones Regulares en sed</A>
<B>Sup:</B> <A NAME="tex2html2807"
  HREF="node81.html">Expresiones Regulares en C</A>
<B> Ant:</B> <A NAME="tex2html2803"
  HREF="node83.html">Expresiones Regulares en Flex</A>
<B> Con:</B> 
<A NAME="tex2html2808"
  HREF="node194.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>
<B> Ind:</B> 
<A NAME="tex2html2810"
  HREF="node197.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2814"
  HREF="node84.html#SECTION05231000000000000000">input()</A>
<LI><A NAME="tex2html2815"
  HREF="node84.html#SECTION05232000000000000000">REJECT</A>
<LI><A NAME="tex2html2816"
  HREF="node84.html#SECTION05233000000000000000">yymore()</A>
<LI><A NAME="tex2html2817"
  HREF="node84.html#SECTION05234000000000000000">yyless()</A>
<LI><A NAME="tex2html2818"
  HREF="node84.html#SECTION05235000000000000000">Estados</A>
<LI><A NAME="tex2html2819"
  HREF="node84.html#SECTION05236000000000000000">La pila de estados</A>
<UL>
<LI><A NAME="tex2html2820"
  HREF="node84.html#SECTION05236100000000000000">Ejemplo</A>
</UL>
<BR>
<LI><A NAME="tex2html2821"
  HREF="node84.html#SECTION05237000000000000000">Final de Fichero</A>
<LI><A NAME="tex2html2822"
  HREF="node84.html#SECTION05238000000000000000">Uso de Dos Analizadores</A>
<LI><A NAME="tex2html2823"
  HREF="node84.html#SECTION05239000000000000000">La Opción <TT>outfile</TT></A>
<LI><A NAME="tex2html2824"
  HREF="node84.html#SECTION052310000000000000000">Leer desde una Cadena: YY_INPUT</A>
<LI><A NAME="tex2html2825"
  HREF="node84.html#SECTION052311000000000000000">El operador de ``trailing context'' o ``lookahead'' positivo</A>
<LI><A NAME="tex2html2826"
  HREF="node84.html#SECTION052312000000000000000">Manejo de directivas <TT>include</TT></A>
<LI><A NAME="tex2html2827"
  HREF="node84.html#SECTION052313000000000000000">An&#225;lisis Léxico desde una Cadena: <TT>yy_scan_string</TT></A>
<LI><A NAME="tex2html2828"
  HREF="node84.html#SECTION052314000000000000000">An&#225;lisis de la L&#305;nea de Comandos y 2 Analizadores</A>
<LI><A NAME="tex2html2829"
  HREF="node84.html#SECTION052315000000000000000">Declaraciones pointer y array</A>
<LI><A NAME="tex2html2830"
  HREF="node84.html#SECTION052316000000000000000">Las Macros <TT>YY_USER_ACTION</TT>, <TT>yy_act</TT> e <TT>YY_NUM_RULES</TT></A>
<LI><A NAME="tex2html2831"
  HREF="node84.html#SECTION052317000000000000000">Las opciones <TT>interactive</TT></A>
<LI><A NAME="tex2html2832"
  HREF="node84.html#SECTION052318000000000000000">La macro <TT>YY_BREAK</TT></A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05230000000000000000">
unput()</A>
</H1>
La funci&#243;n <SPAN  CLASS="textit">unput(c)</SPAN> coloca el car&#225;cter <SPAN  CLASS="textit">c</SPAN> en el flujo
de entrada, de manera que ser&#225; el primer car&#225;cter le&#305;do en pr&#243;xima
ocasi&#243;n.
<PRE>
$ cat unput2.l
%array
%%
[a-z] {unput(toupper(yytext[0]));}
[A-Z] ECHO;
%%
$ flex unput2.l ; gcc lex.yy.c -lfl;a.out
abcd
ABCD
</PRE>
Un problema importante con <SPAN  CLASS="textit">unput</SPAN> es que, cuando se utiliza la
opci&#243;n <code>%pointer</code>, las llamadas a <SPAN  CLASS="textit">unput</SPAN> destruyen los
contenidos de <SPAN  CLASS="textit">yytext</SPAN>. Es por eso que, en el siguiente ejemplo se
hace una copia de <SPAN  CLASS="textit">yytext</SPAN>. La otra alternativa es, por supuesto,
usar la opci&#243;n <code>%array</code>.
<PRE>
$ cat unput.l
%%
[0-9]+ {
  int i;
  char *yycopy = (char *) strdup(yytext);
 
  unput(')');
  for(i=strlen(yycopy)-1; i&gt;=0; --i)
    unput(yycopy[i]);
  unput('(');
  free(yycopy);
}
\([0-9]+\) printf("Num inside parenthesis: %s\n",yytext);
.|\n
$ flex unput.l ; gcc lex.yy.c -lfl ; a.out
32
Num inside parenthesis: (32)
(43)
Num inside parenthesis: (43)
</PRE>

<P>

<H2><A NAME="SECTION05231000000000000000"></A>
<A NAME="section:input"></A>
<BR>
input()
</H2>
La funci&#243;n <SPAN  CLASS="textit">input()</SPAN> lee desde el flujo de entrada 
el siguiente car&#225;cter. Normalmente la utilizaremos si queremos 
tomar ``personalmente el control''  del an&#225;lisis. El ejemplo 
permite ``engullir'' los comentarios (no anidados):
<PRE>
$ cat input.l
%%
"/*" {
        int c;
        for(;;) {
          while ((c=input()) != '*' &amp;&amp; c != EOF)
            ;
          if (c == '*')  {
            while ((c = input()) == '*')
              ;
            if (c == '/') break;
          }
          if (c == EOF) {
            fprintf(stderr,"Error: EOF in comment");
            yyterminate();
          }
        }
      }
</PRE>
La funci&#243;n <code>yyterminate()</code> termina la rutina de an&#225;lisis l&#233;xico y devuelve un cero indicándole a la rutina que llama que todo se ha acabado. 
Por defecto, <code>yyterminate()</code> es llamada cuando se encuentra 
un final de fichero. Es una macro y puede ser redefinida.
<PRE>
$ flex input.l ; gcc lex.yy.c -lfl ; a.out
hello /* world */
hello
unfinished /* comment
unfinished Error: EOF in comment
</PRE>
He presionado CTRL-D despu&#233;s de entrar la palabra <SPAN  CLASS="textit">comment</SPAN>.

<P>

<H2><A NAME="SECTION05232000000000000000">
REJECT</A>
</H2>
La directiva  <code>REJECT</code> le indica al analizador que proceda con la 
siguiente regla que casa con un prefijo de la entrada. Como es habitual en
<SPAN  CLASS="textit">flex</SPAN>, se elige la siguiente regla que casa  con la cadena mas
larga. Consideremos el siguiente ejemplo:
<PRE>
$ cat reject.l
%%
a    |
ab   |
abc  |
abcd ECHO; REJECT; printf("Never seen\n");
.|\n
</PRE>
La salida es:
<PRE>
$ gcc lex.yy.c -lfl;a.out
abcd
abcdabcaba
</PRE>
Observe que <code>REJECT</code> supone un cambio en el flujo de control:
El c&#243;digo que figura despu&#233;s de <code>REJECT</code> no es ejecutado.

<P>

<H2><A NAME="SECTION05233000000000000000">
yymore()</A>
</H2>
La funci&#243;n <code>yymore()</code> hace que, en vez de vaciar <SPAN  CLASS="textit">yytext</SPAN>
para el siguiente <SPAN  CLASS="textit">matching</SPAN>, el valor actual se mantenga,
concatenando el valor actual de <SPAN  CLASS="textit">yytext</SPAN> con el siguiente:
<PRE>
$ cat yymore.l
%%
mega- ECHO; yymore();
kludge ECHO;
 
$ flex yymore.l ; gcc lex.yy.c -lfl ; a.out
mega-kludge
mega-mega-kludge
</PRE>
La variable <code>yyleng</code> no deber&#305;a ser modificada si se hace uso de la
funci&#243;n <code>yymore()</code>.

<P>

<H2><A NAME="SECTION05234000000000000000">
yyless()</A>
</H2>
La funci&#243;n <code>yyless(n)</code> permite retrasar el puntero de lectura  
de manera que apunta al car&#225;cter <SPAN  CLASS="textit">n</SPAN> de <SPAN  CLASS="textit">yytext</SPAN>. 
Veamos un ejemplo:
<PRE>
$ cat yyless.l
%%
foobar ECHO; yyless(4);
[a-z]+ ECHO;
 
$ flex yyless.l; gcc lex.yy.c -lfl; a.out
foobar
foobarar
</PRE>
Veamos un ejemplo mas ``real''. supongamos que tenemos que reconocer 
las cadenas entre comillas dobles, pero que pueden aparecer en las
mismas secuencias de escape <code>\"</code>. La estrategia general del algoritmo
es utilizar la expresión regular <code>\"[^"]+\"</code> y examinar si
los dos últimos  carácteres en <code>yytext</code> son <code>\"</code>. En tal caso, 
se concatena la cadena actual (sin la <code>"</code> final) como prefijo para
el próximo emparejamiento (utilizando <code>yymore</code>). 
La eliminación de la <code>"</code> se hace a través de la ejecución de 
<code>yyless(yyleng-1)</code>, que al mismo tiempo garantiza que el próximo emparejamiento 
tendrá lugar con este mismo patrón <code>\"[^"]+\"</code>.
<PRE>
$ cat quotes.l
%%
\"[^"]+\" {
            printf("Processing string. %d: %s\n",yyleng,yytext);
            if (yytext[yyleng-2] =='\\') {
             yyless(yyleng-1); /* so that it will match next time */
             yymore(); /* concatenate  with current yytext */
             printf("After yyless. %d: %s\n",yyleng,yytext);
            } else {
              printf("Finished. The string is: %s\n",yytext);
            }
          }
</PRE>
El ejemplo no puede entenderse si no se tiene en cuenta que
<code>yyless(yyleng-1)</code> actualiza los valores de <SPAN  CLASS="textit">yyleng</SPAN> 
y <SPAN  CLASS="textit">yytext</SPAN>, como muestra la salida.
<BR>¿Qu&#233; ocurre si intercambiamos las posiciones de <code>yymore()</code>
e <code>yyless(yyleng-1)</code> en el c&#243;digo? &gt;Cambiara la salida? 
La respuesta es que no. Parece que la concatenaci&#243;n se hace con el valor
final de <SPAN  CLASS="textit">yytext</SPAN> y no con el valor que este ten&#305;a en el momento de
la llamada a <SPAN  CLASS="textit">yymore</SPAN>.
<BR>
Otra observaci&#243;n  a tener en cuenta es que <SPAN  CLASS="textit">yyless()</SPAN>
es una macro y que, por tanto,
s&#243;lo puede ser utilizada dentro del fichero <SPAN  CLASS="textit">lex</SPAN> y no en otros
ficheros fuentes.

<P>
En general, el uso de estas funciones  nos puede resolver el problema
de reconocer l&#305;mites que de otra forma ser&#305;an dif&#305;ciles de expresar
con una expresi&#243;n regular.
<PRE>
$ flex quotes.l ; gcc lex.yy.c -lfl ; a.out
"Hello \"Peter\", nice to meet you"
Procesing string. 9: "Hello \"
After yyless. 8: "Hello \
Procesing string. 16: "Hello \"Peter\"
After yyless. 15: "Hello \"Peter\
Procesing string. 35: "Hello \"Peter\", nice to meet you"
Finished. The string is: "Hello \"Peter\", nice to meet you"
</PRE>

<P>

<H2><A NAME="SECTION05235000000000000000">
Estados</A>
</H2>
Las expresiones regulares pueden ser prefijadas mediante <SPAN  CLASS="textit">estados</SPAN>.
Los estados o condiciones de arranque, se denotan mediante un
identificador entre &#225;ngulos y se declaran
en la parte de las definiciones. Las declaraciones se hacen mediante 
<code>%s</code> para los estados ``inclusivos'' o bien <code>%x</code> para los estados ``exclusivos'',
seguidos de los nombres de los estados. No pueden haber caracteres en blanco antes de la declaración.
Un <SPAN  CLASS="textit">estado</SPAN> se activa mediante la 
acci&#243;n BEGIN <SPAN  CLASS="textit">estado</SPAN>. A partir de ese momento, las reglas que esten
prefijadas con el estado pasan a estar activas. En el caso de que el estado
sea inclusivo, las reglas no prefijadas tambi&#233;n permanecen activas.
Los estados exclusivos son especialmente útiles para especificar ``sub analizadores''
que analizan porciones de la entrada cuya estructura ``sintáctica'' es diferente
de la del resto de la entrada.

<P>
El ejemplo ``absorbe'' los comentarios, conservando el numero de
l&#305;neas del fichero en la variable <code>linenum</code>

<P>
<PRE>
$ cat comments.l
%option noyywrap
%{
  int linenum = 0;
%}
%x comment
%%
 
"/*" BEGIN(comment); printf("comment=%d, YY_START = %d, YYSTATE = %d",comment,YY_START,YYSTATE);
&lt;comment&gt;[^*\n]* /* eat anything that is not a star * /
&lt;comment&gt;"*"+[^*/\n]* /* eat up starts not followed by / */
&lt;comment&gt;\n ++linenum; /* update number of lines */
&lt;comment&gt;"*"+"/" BEGIN(0);
 
\n ECHO; linenum++;
.  ECHO;
%%
main() {
  yylex();
  printf("\n%d lines\n",linenum);
}
</PRE>
La opción <code>noyywrap</code> hace que <code>yylex()</code> no llame a la función <code>yywrap()</code>
al final del fichero y que asuma que no hay mas entrada por procesar.

<P>
Los estados se traducen por enteros, pudiendo ser manipulados como tales.
La macro <code>INITIAL</code> puede utilizarse para referirse al estado 0.
Las macros <code>YY_START</code> y <code>YYSTATE</code> contienen el valor del estado actual.
<PRE>
$ flex comments.l ; gcc lex.yy.c ; a.out &lt; hello.c
main() &lt;%
int a&lt;:1:&gt;; comment=1, YY_START = 1, YYSTATE = 1
  a&lt;:0:&gt; = 4; comment=1, YY_START = 1, YYSTATE = 1
  printf("hello world! a(0) is %d\n",a&lt;:0:&gt;);
%&gt;
 
6 lines     
$ cat hello.c
main() &lt;%
int a&lt;:1:&gt;; /* a comment */
  a&lt;:0:&gt; = 4; /* a comment in
                 two lines */
  printf("hello world! a(0) is %d\n",a&lt;:0:&gt;);
%&gt;                                  
</PRE>
En <SPAN  CLASS="textit">flex</SPAN> es posible asociar un &#225;mbito con los estados o 
condiciones iniciales. Basta con colocar entre llaves las 
parejas <SPAN  CLASS="textit">patr&#243;n acci&#243;n</SPAN> gobernadas por ese estado.
El siguiente ejemplo procesa las cadenas <SPAN  CLASS="textit">C</SPAN>:
<PRE>
$ cat ststring.l
%option main
%x str
%{
#define MAX_STR_CONST 256
 
  char string_buffer[MAX_STR_CONST];
  char *string_buf_ptr;
%}
 
%%
\"  string_buf_ptr  = string_buffer; BEGIN(str);
&lt;str&gt;{
\"             {BEGIN (INITIAL); *string_buf_ptr = '\0'; printf("%s",string_buffer); }
\n             { printf("Error: non terminated string\n"); exit(1); }
\\[0-7]{1,3}   { int result; /* octal escape sequence */
                        (void) sscanf(yytext+1,"%o",&amp;result);
                         if (result &gt; 0xff) {printf("Error: constant out of bounds\n"); exit(2); }
                         *string_buf_ptr++ = result;
                    }
\\[0-9]+       { printf("Error: bad escape sequence\n"); exit(2); }
\\n            {*string_buf_ptr++ = '\n';}
\\t            {*string_buf_ptr++ = '\t';}
\\b            {*string_buf_ptr++ = '\b';}
\\r            {*string_buf_ptr++ = '\r';}
\\f            {*string_buf_ptr++ = '\f';}
\\(.|\n)       {*string_buf_ptr++ = yytext[1];}
[^\\\n\"]+     {char *yptr = yytext; while(*yptr) *string_buf_ptr++ = *yptr++; }
}
(.|\n)
%%                            
$ flex ststring.l ; gcc lex.yy.c ; a.out &lt; hello.c
        hello
world! a(0) is %d
$ cat hello.c
main() &lt;%
int a&lt;:1:&gt;; /* a comment */
  a&lt;:0:&gt; = 4; /* a comment in
                 two lines */
  printf("\thell\157\nworld! a(0) is %d\n",a&lt;:0:&gt;);
%&gt;                                   
</PRE>
Obsérve la conducta del programa ante las siguientes entradas:

<UL>
<LI>Entrada:
<PRE>
"hello \
dolly"
</PRE>
¿Cuál será la salida? ¿Que patrón del programa anterior es el que casa aqui?
</LI>
<LI>Entrada:
<code>"hello\ndolly"</code>.
¿Cuál será la salida? ¿Que patrón del programa anterior es el que casa aqui?
</LI>
<LI><PRE>|
"hello
</PRE>
Donde hay un retorno del carro después de <code>hello</code>.
¿Cuál será la salida? </LI>
</UL>

<P>

<H2><A NAME="SECTION05236000000000000000">
La pila de estados</A>
</H2>
Mediante el uso de la opción

<P>
<code>%option stack</code>

<P>
tendremos acceso a una pila de estados y a tres rutinas para  manipularla:
<BR>
<UL>
<LI><code>void yy_push_state(int new_state)</code>
<BR>
Empuja el estado actual y bifurca a <code>new_state</code>.
<BR></LI>
<LI><code>void yy_pop_state()</code>
<BR>
Saca el estado en el <SPAN  CLASS="textit">top</SPAN> de la pila y bifurca a el mismo.
<BR></LI>
<LI><code>int yy_top_state()</code>
<BR>
Nos devuelve el estado en el <SPAN  CLASS="textit">top</SPAN> de la pila, sin alterar
los contenidos de la misma.
</LI>
</UL>

<P>

<H3><A NAME="SECTION05236100000000000000">
Ejemplo</A>
</H3>
El siguiente programa <code>flex</code> utiliza las funciones de la pila
de estados para reconocer el lenguaje (no regular) 
<!-- MATH
 $\{a^n b^n\ /\ n \in N\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="125" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$ \{a^n b^n / n \in N\}$"></SPAN>

<P>
<PRE>
%option main
%option noyywrap
%option stack
%{
#include &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
%}
%x estado_a
%%
^a { yy_push_state(estado_a);}
&lt;estado_a&gt;{
a      { yy_push_state(estado_a); }
b      { yy_pop_state();  }
b[^b\n]+    {   printf ("Error\n"); 
        while (YYSTATE != INITIAL)
          yy_pop_state();
        while (input() != '\n') ;
      }
(.|\n)  {  printf ("Error\n"); 
        while (YYSTATE != INITIAL)
          yy_pop_state();
        while (input() != '\n') ;
      }
}
.      {  printf ("Error\n");
        while (input() != '\n') ;
      }
\n      { printf("Aceptar\n");}
%%
</PRE>

<P>

<H2><A NAME="SECTION05237000000000000000">
Final de Fichero</A>
</H2>
El patrón <code>&lt;&lt;EOF&gt;&gt;</code> permite asociar acciones que se deban 
ejecutar cuando se ha encontrado un <SPAN  CLASS="textit">end of file</SPAN> y la 
macro <code>yywrap()</code> ha devuelto un valor no nulo. 

<P>
Cualquiera que sea, la acción asociada deberá de optar por una de estas 
cuatro alternativas:

<UL>
<LI>Asignar <code>yyin</code> a un nuevo fichero de entrada
</LI>
<LI>Ejecutar <code>return</code>
</LI>
<LI>Ejecutar <code>yyterminate()</code> (véase  la sección <A HREF="#section:input">29.3.1</A>)
</LI>
<LI>Cambiar de <SPAN  CLASS="textit">buffer</SPAN> de entrada utilizando la función
<code>yy_switch_buffer</code> (véase  la sección <A HREF="#section:include">29.3.12</A>).
</LI>
</UL>

<P>
El patrón <code>&lt;&lt;EOF&gt;&gt;</code> no puede usarse con otras expresiones regulares. Sin embargo, es correcto prefijarlo con estados.

<P>
Si  <code>&lt;&lt;EOF&gt;&gt;</code> aparece sin condiciones de arranque, la regla se aplica a todos los estados que no tienen una regla  <code>&lt;&lt;EOF&gt;&gt;</code> específica.
Si lo que se quiere es que la regla se restringa al ámbito del estado inicial se deberá escribir:

<P>
<code>&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;</code> 

<P>
Sigue un programa que reconoce los comentarios anidados en C.
Para detectar comentarios incacabados usaremos  <code>&lt;&lt;EOF&gt;&gt;</code>.
<A NAME="nestedcomments"></A><PRE>
%option stack
%x comment
%%
"/*"   { yy_push_state(comment); }
(.|\n) ECHO;
&lt;comment&gt;"/*"     { yy_push_state(comment); } 
&lt;comment&gt;"*/"     { yy_pop_state(); } 
&lt;comment&gt;(.|\n)   ;
&lt;comment&gt;&lt;&lt;EOF&gt;&gt;  { fprintf(stderr,"Error\n"); exit(1); }
%%
</PRE>

<P>
<PRE>
$ cat hello.c
main() {
int a[1]; /* a /* nested comment */. */
  a[0] = 4; /* a  /* nested comment in
                 /* two */ lines  */ *****/
}                                                   
$ flex nestedcom.l ; gcc lex.yy.c -lfl ; a.out &lt; hello.c
main() {
int a[1];
  a[0] = 4;
}
$ cat hello4.c
main() {
int a[1]; /* a /* nested comment */. */
  a[0] = 4; /* an  /* incorrectly nested comment in
                 /* two  lines  */ *****/
}
$ a.out &lt; hello4.c
main() {
int a[1];
Error
  a[0] = 4;
</PRE>

<P>

<H2><A NAME="SECTION05238000000000000000">
Uso de Dos Analizadores</A>
</H2>
La opción <code>-Pprefix</code> de flex cambia el prefijo por defecto <code>yy</code>
para todas las variables globales y funciones. Por ejemplo 
<code>-Pfoo</code> cambia el nombre de  <code>yytext</code> <code>footext</code>.  
También cambia el nombre del fichero de salida 
de  <code>lex.yy.c</code>  a <code>lex.foo.c</code>.  
Sigue la lista de identificadores afectados:
<PRE> 
yy_create_buffer
yy_delete_buffer
yy_flex_debug
yy_init_buffer
yy_flush_buffer
yy_load_buffer_state
yy_switch_to_buffer
yyin
yyleng
yylex
yylineno
yyout
yyrestart
yytext
yywrap
</PRE> 
Desde dentro del analizador léxico puedes referirte a las 
variables globales y funciones por cualquiera de los nombres,
pero externamente tienen el nombre cambiado.
Esta opción nos permite enlazar diferentes programas flex en un mismo ejecutable.

<P>
Sigue un ejemplo de uso de dos analizadores l&#233;xicos dentro del mismo programa:
<PRE>
$ cat one.l
%%
one {printf("1\n"); return 1;}
.   {printf("First analyzer: %s\n",yytext);}
%%
 
int onewrap(void) {
  return 1;
}
 
$ cat two.l
%%
two {printf("2\n"); return 2;}
.   {printf("Second analyzer: %s\n",yytext);}
%%
int twowrap(void) {
  return 1;
}
$ cat onetwo.c
main() {
  onelex();
  twolex();
}
</PRE>
Como hemos mencionado, la compilaci&#243;n <SPAN  CLASS="textit">flex</SPAN> se debe realizar con el opci&#243;n <code>-P</code>,
que cambia el prefijo por defecto <code>yy</code> de las funciones
y variables accesibles por el usuario.
El mismo efecto puede conseguirse utilizando la opción <code>prefix</code>, escribiendo
<code>%option prefix="one"</code> y <code>%option prefix="two"</code> en los respectivos programas 
<code>one.l</code> y <code>two.l</code>. 
<PRE>
$ flex -Pone one.l
$ flex -Ptwo two.l
$ ls -ltr | tail -2
-rw-rw----   1 pl       casiano     36537 Nov  7 09:52 lex.one.c
-rw-rw----   1 pl       casiano     36524 Nov  7 09:52 lex.two.c
$ gcc onetwo.c lex.one.c lex.two.c
$ a.out
two
First analyzer: t
First analyzer: w
First analyzer: o
 
one
1
one
Second analyzer: o
Second analyzer: n
Second analyzer: e
 
two
2
$
</PRE>

<P>

<H2><A NAME="SECTION05239000000000000000">
La Opción <TT>outfile</TT></A>
</H2>
Es posible utilizar la opción <code>-ooutput.c</code>  para escribir el 
analizador léxico en el fichero <code>output.c</code> en vez de  en <code>lex.yy.c</code>.
El mismo efecto puede obtenerse usando la opción <code>outfile="output.c"</code> dentro
del programa <code>lex</code>.

<P>

<H2><A NAME="SECTION052310000000000000000">
Leer desde una Cadena: YY_INPUT</A>
</H2>
En general, la rutina que hace el an&#225;lisis l&#233;xico,
<SPAN  CLASS="textit">yylex()</SPAN>, lee su entrada a trav&#233;s de la macro
<code>YY_INPUT</code>. Esta macro es llamada con tres par&#225;metros
<DIV ALIGN="CENTER">
<code>YY_INPUT(buf,result,max)</code> 

</DIV>
el primero, <SPAN  CLASS="textit">buf</SPAN> es utilizado para guardar la entrada.
el tercero <SPAN  CLASS="textit">max</SPAN> indica el n&#250;mero de caracteres que <SPAN  CLASS="textit">yylex()</SPAN>
pretende leer de la entrada. El segundo <SPAN  CLASS="textit">result</SPAN> contendr&#225; el n&#250;mero 
de caracteres realmente le&#305;dos. Para poder leer desde una cadena
(<SPAN  CLASS="textit">string</SPAN>) basta
con modificar <code>YY_INPUT</code> para que copie los datos de la cadena en
el <SPAN  CLASS="textit">buffer</SPAN> pasado como par&#225;metro a <code>YY_INPUT</code>. 
Sigue un ejemplo: 
<PRE>
$ cat string.l
%{
#undef YY_INPUT
#define YY_INPUT(b,r,m) (r = yystringinput(b,m))
#define min(a,b) ((a&lt;b)?(a):(b))
%}
 
%%
[0-9]+ printf("Num-");
[a-zA-Z][a-zA-Z_0-9]* printf("Id-");
[ \t]+
. printf("%c-",yytext[0]);
%%
 
extern char string[];
extern char *yyinputptr;
extern char *yyinputlim;
 
int yystringinput(char *buf, int maxsize) {
  int n = min(maxsize, yyinputlim-yyinputptr);
 
  if (n &gt; 0) {
    memcpy(buf, yyinputptr, n);
    yyinputptr += n;
  }
  return n;
}
 
int yywrap() { return 1; }
</PRE>
Este es el fichero conteniendo la funci&#243;n <SPAN  CLASS="textit">main</SPAN>:
<PRE>
$ cat stringmain.c
char string[] = "one=1;two=2";
char *yyinputptr;
char *yyinputlim;
 
main() {
  yyinputptr = string;
  yyinputlim = string + strlen(string);
  yylex();
  printf("\n");
}
</PRE>
Y esta es la salida:
<PRE>
$ a.out
Id-=-Num-;-Id-=-Num-
</PRE>
La cadena <code>string = "one=1;two=2"</code> definida en la línea 2 ha sido utilizada 
como entrada para el análisis léxico.

<P>

<H2><A NAME="SECTION052311000000000000000">
El operador de ``trailing context'' o ``lookahead'' positivo</A>
</H2>
En el lenguaje FORTRAN original los ``blancos'' no eran significativos
y no se distinguía entre mayúsculas y minúsculas.
Así pues la cadena <code>do i = 1, 10</code> es equivalente a la cadena
<code>DOI=1,10</code>. Un conocido conflicto ocurre entre una cadena 
con la estructura <code>do i = 1.10</code> (esto es <code>DOI=1.10</code>) y  
la cadena anterior. En la primera <code>DO</code> e <code>I</code> son dos
``tokens'' diferentes, el primero correspondiendo a la palabra reservada que indica un bucle. En la segunda, <code>DOI</code> constituye un único ``token''
y la sentencia se refiere a una asignación.
El conflicto puede resolverse utilizando el operador de ``trailing'' <code>r/s</code>. 
Como se mencionó, el operador de ``trailing''<code>r/s</code> permite reconocer una <code>r</code> pero s&#243;lo si va seguida de una <code>s</code>. El texto casado con <code>s</code> se incluye a la hora de decidir cual es el emparejamiento mas largo, pero se devuelve a la entrada cuando se ejecuta la acci&#243;n. La acci&#243;n s&#243;lo ve el texto asociado con <code>r</code>.  El fichero <code>fortran4.l</code> ilustra una posible solución:
<PRE>
 cat fortran4.l
%array
%{
#include &lt;string.h&gt;
#undef YY_INPUT
#define YY_INPUT(buf,result,max) (result = my_input(buf,max))
%}
number [0-9]+
integer [+-]?{number}
float ({integer}\.{number}?|\.{number})(E{integer})?
label [A-Z0-9]+
id   [A-Z]{label}*
%%
DO/{label}={number}\, { printf("do loop\n"); }
{id} { printf("Identifier %s\n",yytext); }
{number} { printf("Num %d\n",atoi(yytext)); }
{float} { printf("Float %f\n",atof(yytext)); }
(.|\n)
%%

int my_input(char *buf, int max)
{
  char *q1, *q2, *p = (char *) malloc(max);
  int i;
  if ('\0' != fgets(p,max,yyin)) {
    for(i=0, q1=buf, q2=p;(*q2 != '\0');q2++) {
      if (*q2 != ' ') { *q1++ = toupper(*q2); i++; };
    }
    free(p);
    return i;
  }
  else exit(1);
}
</PRE>
La función 

<P>
<code>char *fgets(char *s, int size, FILE *stream)</code> 

<P>
lee a lo mas uno menos que <code>size</code> caracteres desde <code>stream</code> y los almacena en el <SPAN  CLASS="textit">buffer</SPAN>
apuntado por <code>s</code>. La lectura termina después de un  <code>EOF</code> o un retorno de carro.
Si se lee un <code>\n</code>, se almacena en el <SPAN  CLASS="textit">buffer</SPAN>. La función pone un carácter nulo <code>\0</code> 
como último carácter en el <SPAN  CLASS="textit">buffer</SPAN>.

<P>
A continuación, puedes ver los detalles de una ejecución:
<PRE>
$ flex fortran4.l; gcc lex.yy.c -lfl; a.out
do j = 1 . 10
Identifier DOJ
Float 1.100000
do k = 1, 5
do loop
Identifier K
Num 1
Num 5
</PRE>

<P>

<H2><A NAME="SECTION052312000000000000000"></A>
<A NAME="section:include"></A>
<BR>
Manejo de directivas <TT>include</TT>
</H2>
El analisis l&#233;xico de algunos lenguajes requiere que, durante la
ejecuci&#243;n, se realice la lectura desde
diferentes ficheros de entrada. El ejemplo t&#305;pico es el manejo de las
directivas <SPAN  CLASS="textit">include file</SPAN> existentes en la mayor&#305;a de los lenguajes de
programaci&#243;n.
<BR>¿Donde est&#225; el problema? La dificultad reside en que los
analizadores generados por <SPAN  CLASS="textit">flex</SPAN>
proveen almacenamiento intermedio (<SPAN  CLASS="textit">buffers</SPAN>) para aumentar el
rendimiento. No basta con reescribir nuestro propio <SPAN  CLASS="textit">YY_INPUT</SPAN> de
manera que tenga en cuenta con que fichero se esta trabajando. 
El analizador s&#243;lo llama a <SPAN  CLASS="textit">YY_INPUT</SPAN> cuando alcanza el final de su
<SPAN  CLASS="textit">buffer</SPAN>, lo cual puede ocurrir bastante despu&#233;s de haber
encontrado la sentencia <SPAN  CLASS="textit">include</SPAN> que requiere el cambio de
fichero de entrada.
<PRE>
$ cat include.l
%x incl
%{
#define yywrap() 1
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}
%%
include          BEGIN(incl);
.                ECHO;
&lt;incl&gt;[ \t]*
&lt;incl&gt;[^ \t\n]+  { /* got the file name */
                   if (include_stack_ptr &gt;= MAX_INCLUDE_DEPTH) {
                     fprintf(stderr,"Includes nested too deeply\n");
                     exit(1);
                   }
                   include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
                   yyin = fopen(yytext,"r");
                   if (!yyin) {
                     fprintf(stderr,"File %s not found\n",yytext);
                     exit(1);
                   }
                   yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
                   BEGIN(INITIAL);
                 }
&lt;&lt;EOF&gt;&gt; {
          if ( --include_stack_ptr &lt; 0) {
            yyterminate();
          } else {
            yy_delete_buffer(YY_CURRENT_BUFFER);
            yy_switch_to_buffer(include_stack[include_stack_ptr]);
          }
        }
%%
main(int argc, char ** argv) {
 
  yyin = fopen(argv[1],"r");
  yylex();
}
</PRE>
La funci&#243;n <code>yy_create_buffer(yyin, YY_BUF_SIZE));</code> crea  un <SPAN  CLASS="textit">buffer</SPAN>
lo suficientemente grande para mantener <code>YY_BUF_SIZE</code> caracteres. Devuelve un 
<code>YY_BUFFER_STATE</code>, que puede ser pasado a otras rutinas. <code>YY_BUFFER_STATE</code> es un puntero a
una estructura de datos opaca (<code>struct yy_buffer_state</code>) que contiene la informaci&#243;n para la manipulaci&#243;n
del <SPAN  CLASS="textit">buffer</SPAN>. Es posible por tanto inicializar un puntero <code>YY_BUFFER_STATE</code>
usando la expresión <code>((YY_BUFFER_STATE) 0)</code>.

<P>
La funci&#243;n <code>yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);</code> conmuta la entrada 
del analizador l&#233;xico. La funci&#243;n <code>void yy_delete_buffer( YY_BUFFER_STATE buffer )</code>
se usa para recuperar la memoria consumida por un <SPAN  CLASS="textit">buffer</SPAN>.  Tambi&#233;n se pueden limpiar 
los contenidos actuales de un buffer llamando a:
<code>void yy_flush_buffer( YY_BUFFER_STATE buffer )</code>

<P>
La regla especial <code>&lt;&lt;EOF&gt;&gt;</code> indica la acci&#243;n a ejecutar cuando 
se ha encontrado un final de fichero e <code>yywrap()</code> retorna un valor
distinto de cero. Cualquiera que sea la acci&#243;n asociada, esta debe terminar 
con uno de estos cuatro supuestos:

<OL>
<LI>Asignar <code>yyin</code> a un nuevo fichero de entrada.
</LI>
<LI>Ejecutar <code>return</code>.
</LI>
<LI>Ejecutar <code>yyterminate()</code>.
</LI>
<LI>Cambiar a un nuevo buffer usando <code>yy_switch_to_buffer()</code>.

<P>
La regla <code>&lt;&lt;EOF&gt;&gt;</code> no se puede mezclar con otros patrones.
</LI>
</OL>

<P>
Este es el resultado de una ejecuci&#243;n del programa:
<PRE>
$ cat hello.c
#include hello2.c
main() &lt;%
int a&lt;:1:&gt;; /* a comment */
  a&lt;:0:&gt; = 4; /* a comment in
                 two lines */
  printf("\thell\157\nworld! a(0) is %d\n",a&lt;:0:&gt;);
%&gt;
$ cat hello2.c
#include hello3.c
/* file hello2.c  */
$ cat hello3.c
/*
third file
*/
$ flex include.l ; gcc lex.yy.c ; a.out hello.c
##/*
third file
*/
 
/* file hello2.c  */
 
main() &lt;%
int a&lt;:1:&gt;; /* a comment */
  a&lt;:0:&gt; = 4; /* a comment in
                 two lines */
  printf("\thell\157\nworld! a(0) is %d\n",a&lt;:0:&gt;);
%&gt;                                                            
</PRE>
Una alternativa a usar el patrón <code>&lt;&lt;EOF&gt;&gt;</code>
es dejar la responsabilidad de recuperar el <SPAN  CLASS="textit">buffer</SPAN> anterior
a <code>yywrap()</code>. En tal caso suprimiríamos esta parajea patrón-acción
y reescribiríamos <code>yywrap()</code>:
<PRE>
%x incl
%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}
%%
include          BEGIN(incl);
.                ECHO;
&lt;incl&gt;[ \t]*
&lt;incl&gt;[^ \t\n]+  { /* got the file name */
                   if (include_stack_ptr &gt;= MAX_INCLUDE_DEPTH) {
		     fprintf(stderr,"Includes nested too deeply\n");
		     exit(1);
		   }
		   include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
		   yyin = fopen(yytext,"r");
		   if (!yyin) {
		     fprintf(stderr,"File %s not found\n",yytext);
		     exit(1);
		   }
		   yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
		   BEGIN(INITIAL);
		 }
%%
main(int argc, char ** argv) {

  yyin = fopen(argv[1],"r");
  yylex();
}

int yywrap() {
  if ( --include_stack_ptr &lt; 0) { 
    return 1;
  } else {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(include_stack[include_stack_ptr]);
    return 0;
  }
}
</PRE>

<P>

<H2><A NAME="SECTION052313000000000000000">
An&#225;lisis Léxico desde una Cadena: <TT>yy_scan_string</TT></A>
</H2>
El objetivo de este ejercicio es mostrar como realizar un
an&#225;lisis l&#233;xico de los argumentos pasados en la l&#305;nea de
comandos. Para ello <SPAN  CLASS="textit">flex</SPAN> provee la funci&#243;n <code>yy_scan_string(const char * str)</code>.
Esta rutina crea un nuevo <SPAN  CLASS="textit">buffer</SPAN> de entrada y devuelve el correspondiente
manejador <code>YY_BUFFER_STATE</code> asociado con la cadena
<code>str</code>. Esta cadena debe estar terminada por un car&#225;cter <code>\0</code>. 
Podemos liberar la memoria asociada con
dicho <SPAN  CLASS="textit">buffer</SPAN> utilizando <code>yy_delete_buffer(BUFFER)</code>.
La siguiente llamada a <code>yylex()</code> realizar&#225; el an&#225;lisis l&#233;xico
de la cadena <code>str</code>.

<P>
<PRE>
$ cat scan_str.l
%%
[0-9]+     printf("num\n");
[a-zA-Z]+  printf("Id\n");
%%
main(int argc, char ** argv) {
int i;
 
  for(i=1;i&lt;argc;i++) {
    yy_scan_string(argv[i]);
    yylex();
    yy_delete_buffer(YY_CURRENT_BUFFER);
  }
}
 
int yywrap() { return 1; }
$ flex scan_str.l ; gcc lex.yy.c ; a.out Hello World! 1234
Id
Id
!num
</PRE>
Alternativamente, la función <code>main()</code> podría haber sido escrita asi:
<PRE>
main(int argc, char ** argv) {
int i;
YY_BUFFER_STATE p;

  for(i=1;i&lt;argc;i++) {
    p = yy_scan_string(argv[i]);
    yylex();
    yy_delete_buffer(p);
  }
}
</PRE>
La funci&#243;n <code>yy_scan_bytes(const char * bytes, int len)</code> hace lo mismo que 
<code>yy_scan_string</code> pero en vez de una cadena terminada en
el car&#225;cter nulo, se usa la longitud <code>len</code>.
Ambas funciones <code>yy_scan_string(const char * str)</code> y
<code>yy_scan_bytes(const char * bytes, int len)</code> hacen una copia
de la cadena pasada como argumento.

<P>
Estas dos funciones crean una copia de la cadena original. Es mejor que sea asi, ya que <code>yylex()</code>
modifica los contenidos del <SPAN  CLASS="textit">buffer</SPAN> de trabajo. Si queremos evitar la copia,
podemos usar 

<P>
<code>yy_scan_buffer(char *base, yy_size_t size)</code>,

<P>
la cual trabaja directamente con el <SPAN  CLASS="textit">buffer</SPAN> que comienza en <code>base</code>, 
de tamaño <code>size</code> <SPAN  CLASS="textit">bytes</SPAN>, los últimos dos de los cuáles deben
ser <code>YY_END_OF_BUFFER_CHAR</code> (ASCII  NUL).   
Estos dos últimos <SPAN  CLASS="textit">bytes</SPAN> no son ``escaneados''. El área de rastreo va
desde <code>base[0]</code> a <code>base[size-2]</code>, inclusive.
Si nos olvidamos de hacerlo de este modo y no establecemos los dos <SPAN  CLASS="textit">bytes</SPAN> finales,
la función <code>yy_scan_buffer()</code> devuelve un puntero nulo
y no llega a crear el nuevo buffer de entrada.
El tipo  <code>yy_size_t</code> es un tipo entero.
Como cabe esperar, <code>size</code> se refiere al tamaño del <SPAN  CLASS="textit">buffer</SPAN>.

<P>

<H2><A NAME="SECTION052314000000000000000">
An&#225;lisis de la L&#305;nea de Comandos y 2 Analizadores</A>
</H2>
El objetivo de este ejercicio es mostrar como realizar un
an&#225;lisis l&#233;xico de los argumentos pasados en la l&#305;nea de
comandos.  Para ello dise&#241;aremos una librer&#305;a que proporcionar&#225; un 
funci&#243;n <code>yylexarg(argc,argv)</code> que hace el an&#225;lisis
de la l&#305;nea de acuerdo con la especificaci&#243;n
<SPAN  CLASS="textit">flex</SPAN> correspondiente. En el ejemplo, esta descripci&#243;n del analizador l&#233;xico
es proporcionada en el fichero <SPAN  CLASS="textit">fl.l</SPAN>.  Para complicar un poco mas
las cosas, supondremos que queremos hacer el an&#225;lisis l&#233;xico
de un fichero (especificado en la l&#305;nea de comandos) seg&#250;n 
se especifica en un segundo analizador l&#233;xico <SPAN  CLASS="textit">trivial.l</SPAN>.
El siguiente ejemplo de ejecuci&#243;n muestra la conducta del programa:
<PRE>
$ fl -v -V -f tokens.h
verbose mode is on
version 1.0
File name is: tokens.h
Analyzing tokens.h
#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks
-int-blanks-#-id-blanks-id-blanks-int-blanks-#-id-blanks-id-blanks-int-blanks-
</PRE>
Los contenidos del fichero <SPAN  CLASS="textit">Makefile</SPAN> definen las dependencias 
y la estructura de la aplicaci&#243;n:
<PRE>
$ cat Makefile
LIBS=-lflarg
CC=gcc -g
LIBPATH=-L. -L~/lib
INCLUDES=-I. -I~/include
 
fl: main.c lex.arg.c lex.yy.c libflarg.a tokens.h
        $(CC) $(LIBPATH) $(INCLUDES) main.c lex.arg.c lex.yy.c $(LIBS) -o fl
lex.arg.c: fl.l
        flex -Parg fl.l
lex.yy.c: trivial.l tokens.h
        flex trivial.l
libflarg.a: flarg.o
        ar r libflarg.a flarg.o
flarg.o: flarg.c
        $(CC) -c flarg.c
clean:                                 
$ make clean;make
rm lex.arg.c lex.yy.c *.o  fl
flex -Parg fl.l
flex trivial.l
gcc -g -c flarg.c
ar r libflarg.a flarg.o
gcc -g -L. -L~/lib -I. -I~/include main.c lex.arg.c lex.yy.c -lflarg -o fl
</PRE>
Observa el uso de la opci&#243;n <code>-Parg</code> en la traducci&#243;n del fichero 
<SPAN  CLASS="textit">fl.l</SPAN>. As&#305; no solo el fichero generado por <SPAN  CLASS="textit">flex</SPAN>, sino todas las variables
y rutinas accesibles estar&#225;n prefijadas por <SPAN  CLASS="textit">arg</SPAN> en vez de <SPAN  CLASS="textit">yy</SPAN>. 
La librer&#305;a la denominamos <SPAN  CLASS="textit">libflarg.a</SPAN>. (<SPAN  CLASS="textit">flarg</SPAN> 
por <SPAN ID="txt2764">fl</SPAN>ex <SPAN ID="txt2765">arg</SPAN>uments). 
El correspondiente fichero cabecera ser&#225; <SPAN  CLASS="textit">flarg.h</SPAN>.
Los fuentes de las rutinas que compondr&#225;n la 
librer&#305;a se mantendr&#225;n en el fichero <SPAN  CLASS="textit">flarg.c</SPAN>.

<P>
Lo que haremos ser&#225; redefinir <code>YY_INPUT(buf, result, max)</code> para que
lea su entrada desde la l&#305;nea de argumentos.
<PRE>
$ cat flarg.h
int yyarglex(int argc, char **argv);
int YY_input_from_argv(char *buf, int max);
int argwrap(void);
 
#undef YY_INPUT
#define YY_INPUT(buf,result,max) (result = YY_input_from_argv(buf,max))
</PRE>
La funci&#243;n <code>int YY_input_from_argv(char *buf, int max)</code> utiliza los punteros
<code>char **YY_targv</code> y <code>char **YY_arglim</code> para moverse a trav&#233;s
de la familia de argumentos. Mientras que el primero es utilizado para el
recorrido, el segundo marca el l&#305;mite final. Su inicializaci&#243;n ocurre en

<P>
<DIV ALIGN="CENTER">
<code>yyarglex(int argc, char **argv)</code>

</DIV>
con las asignaciones:
<PRE>
  YY_targv = argv+1;
  YY_arglim = argv+argc;
</PRE>

<P>
despues, de lo cual, se llama al analizador l&#233;xico generado, <SPAN  CLASS="textit">arglex</SPAN> .

<P>
<PRE>
$ cat flarg.c
char **YY_targv;
char **YY_arglim;
 
int YY_input_from_argv(char *buf, int max)
{
  static unsigned offset = 0;
 
  int len, copylen;
 
    if (YY_targv &gt;= YY_arglim) return 0;        /* EOF */
    len = strlen(*YY_targv)-offset;     /* amount of current arg */
    if(len &gt;= max) {copylen = max-1; offset += copylen; }
    else copylen = len;
    if(len &gt; 0) memcpy(buf, YY_targv[0]+offset, copylen);
    if(YY_targv[0][offset+copylen] == '\0') {   /* end of arg */
      buf[copylen] = ' '; copylen++; offset = 0; YY_targv++;
    }
    return copylen;
}
 
int yyarglex(int argc, char **argv) {
  YY_targv = argv+1;
  YY_arglim = argv+argc;
  return arglex();
}
 
int argwrap(void) {
  return 1;
}
</PRE>
El fichero <SPAN  CLASS="textit">fl.l</SPAN> contiene el analizador l&#233;xico de la l&#305;nea de comandos:
<PRE>
$ cat fl.l
%{
unsigned verbose;
unsigned thereisfile;
char *progName;
char fileName[256];
#include "flarg.h"
#include "tokens.h"
%}
 
%%
-h      |
"-?"    |
-help   { printf("usage is: %s [-help | -h | -? ] [-verbose | -v]"
         " [-Version | -V]"
         " [-f filename]\n", progName);
        }
 
-v      |
-verbose { printf("verbose mode is on\n"); verbose = 1; }
 
-V      |
-version { printf("version 1.0\n"); }
 
-f[[:blank:]]+[^ \t\n]+ {
              strcpy(fileName,argtext+3);
              printf("File name is: %s\n",fileName);
              thereisfile = 1;
            }
.
 
\n
</PRE>
Observe el uso de la clase <code>[:blank:]</code> para reconocer
los blancos. Las clases son las mismas que las introducidas
en <SPAN  CLASS="textit">gawk</SPAN>.

<P>
El an&#225;lisis l&#233;xico del fichero que se lee despu&#233;s de procesar la
l&#305;nea de comandos es descrito en <SPAN  CLASS="textit">trivial.l</SPAN>.
Partiendo de <SPAN  CLASS="textit">trivial.l</SPAN>, la ejecuci&#243;n del <SPAN  CLASS="textit">Makefile</SPAN>
da lugar a la construcci&#243;n por parte de <SPAN  CLASS="textit">flex</SPAN> del fichero 
<SPAN  CLASS="textit">lex.yy.c</SPAN> conteniendo la rutina <SPAN  CLASS="textit">yylex</SPAN>.
<PRE>
$ cat trivial.l
%{
#include "tokens.h"
%}
digit [0-9]
id [a-zA-Z][a-zA-Z0-9]+
blanks [ \t\n]+
operator [+*/-]
%%
{digit}+ {return INTTOKEN; }
{digit}+"."{digit}+ {return FLOATTOKEN; }
{id} {return IDTOKEN;}
{operator} {return OPERATORTOKEN;}
{blanks} {return BLANKTOKEN;}
. {return (int) yytext[0];}
%%
int yywrap() {
  return 1;
}
</PRE>
El fichero <SPAN  CLASS="textit">tokens.h</SPAN> contiene la definici&#243;n de los <SPAN  CLASS="textit">tokens</SPAN>
y es compartido con <SPAN  CLASS="textit">main.c</SPAN>. 
<PRE>
$ cat tokens.h
#define INTTOKEN  256
#define FLOATTOKEN 257
#define IDTOKEN 258
#define OPERATORTOKEN 259
#define BLANKTOKEN 260
</PRE>
Nos queda por presentar el fichero <SPAN  CLASS="textit">main.c</SPAN>:
<PRE>
$ cat main.c
#include &lt;stdio.h&gt;
#include "flarg.h"
#include "tokens.h"
extern unsigned verbose;
extern unsigned thereisfile;
extern char *progName;
extern char fileName[256];
extern FILE * yyin;
 
main(int argc, char **argv) {
  unsigned lookahead;
  FILE * file;
 
  progName = *argv;
  yyarglex(argc,argv);
  if (thereisfile) {
    if (verbose) printf("Analyzing %s\n",fileName);
    file = (fopen(fileName,"r"));
    if (file == NULL) exit(1);
    yyin = file;
    while (lookahead = yylex()) {
      switch (lookahead) {
        case INTTOKEN:
            printf("int-");
            break;
          case FLOATTOKEN:
            printf("float-");
            break;
          case IDTOKEN:
            printf("id-");
            break;
          case OPERATORTOKEN:
            printf("operator-");
            break;
          case BLANKTOKEN:
            printf("blanks-");
            break;
          default: printf("%c-",lookahead);
       }
    } /* while */
    printf("\n");
  } /* if */
}
</PRE>

<P>

<H2><A NAME="SECTION052315000000000000000">
Declaraciones pointer y array</A>
</H2>
Como se coment&#243;, las opciones <code>%pointer</code> y <code>%array</code>
controlan la definici&#243;n que
<SPAN  CLASS="textit">flex</SPAN> hace de <SPAN  CLASS="textit">yytext</SPAN>. en el caso en que eligamos la opci&#243;n 
<code>%array</code> la variable <code>YYLMAX</code> controla el tama&#241;o del
<SPAN  CLASS="textit">array</SPAN>. Supongamos que en el fichero <SPAN  CLASS="textit">trivial.l</SPAN> del ejemplo
anterior introducimos las siguientes modificaciones:
<PRE>
$ cat trivial.l
%array
%{
#undef YYLMAX
#define YYLMAX 4
#include "tokens.h"
%}
digit [0-9]
id [a-zA-Z][a-zA-Z0-9]+
blanks [ \t\n]+
operator [+*/-]
%%
{digit}+ {return INTTOKEN; }
{digit}+"."{digit}+ {return FLOATTOKEN; }
{id} {return IDTOKEN;}
{operator} {return OPERATORTOKEN;}
{blanks} {return BLANKTOKEN;}
. {return (int) yytext[0];}
%%
int yywrap() {
  return 1;
  }
</PRE>
En tal caso, la definici&#243;n excesivamente peque&#241;a de YYLMAX provoca
un error en tiempo de ejecuci&#243;n:
<PRE>
$ fl -V -f tokens.h
version 1.0
File name is: tokens.h
token too large, exceeds YYLMAX
</PRE>

<P>

<H2><A NAME="SECTION052316000000000000000">
Las Macros <TT>YY_USER_ACTION</TT>, <TT>yy_act</TT> e <TT>YY_NUM_RULES</TT></A>
</H2>
La macro <code>YY_USER_ACTION</code> permite ejecutar una acción inmediatamente después del ``emparejamiento'' y antes de  la ejecución de la acción asociada.
cuando se la invoca, la variable <code>yy_act</code> contiene el número de la regla que ha emparejado (las reglas se numeran a partir de uno). La macro <code>YY_NUM_RULES</code> contiene el número de reglas, incluyendo la regla por defecto.

<P>
El siguiente programa aprovecha
dichas macros para mostrar las frecuencias de uso de las reglas.
<PRE>
$ cat user_action.l
%array
%{
#include &lt;string.h&gt;
 
int ctrl[YY_NUM_RULES];
#undef YY_USER_ACTION
#define YY_USER_ACTION { ++ctrl[yy_act]; }
%}
number [0-9]+
id   [a-zA-Z_]+[a-zA-Z0-9_]*
whites [ \t\n]+
%%
{id}
{number}
{whites}
.
%%
 
int yywrap() {
  int i;
 
  for(i=1;i&lt;YY_NUM_RULES;i++)
    printf("Rule %d: %d occurrences\n",i,ctrl[i]);
}
                                                  
$ flex user_action.l ; gcc lex.yy.c -lfl ; a.out
a=b+2*(c-4)
Rule 1: 3 occurrences
Rule 2: 2 occurrences
Rule 3: 1 occurrences
Rule 4: 6 occurrences
</PRE>

<P>

<H2><A NAME="SECTION052317000000000000000">
Las opciones <TT>interactive</TT></A>
</H2>
La opción <code>option always-interactive</code>  hace que <code>flex</code> genere un analizador que considera que su entrada es ``interactiva''. Concretamente, el analizador para cada nuevo fichero de entrada, intenta determinar si se trata de un a entrada interactiva o desde fichero haciendo una llamada a la función <code>isatty()</code>.  Vea un ejemplo de uso de esta función:

<P>
<PRE>
$ cat isatty.c
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
main() {
 
  if (isatty(0))
    printf("interactive\n");
  else
    printf("non interactive\n");
}
$ gcc isatty.c; a.out
interactive
$ a.out &lt; isatty.c
non interactive
$
</PRE>
cuando se usa la opción <code>option always-interactive</code>, se elimina esta llamada.

<P>

<H2><A NAME="SECTION052318000000000000000">
La macro <TT>YY_BREAK</TT></A>
</H2>
Las acciones asociadas con los patrones se agrupan en 
la rutina de análisis léxico <code>yylex()</code> en una sentencia
<code>switch</code> y se separan mediante llamadas a la
macro <code>YY_BREAK</code>. Asi, al compilar con
<code>flex</code> el siguiente fichero <code>.l</code>
<PRE>
$ cat interactive.l
%%
. printf("::%c",yytext[0]);
\n printf("::%c",yytext[0]);      
</PRE>
tenemos el fichero de salida <code>lex.yy.c</code>
que aparece a continuación (hemos omitido 
las líneas de código en las que estamos menos interesados, 
sustituyendolas por puntos suspensivos)
<PRE>
/* A lexical scanner generated by flex */
....
#define YY_NUM_RULES 3
#line 1 "interactive.l"
#define INITIAL 0
#line 363 "lex.yy.c"
....
YY_DECL {
 ....
#line 1 "interactive.l"
#line 516 "lex.yy.c"
 ....
 if ( yy_init ) {
   yy_init = 0;
#ifdef YY_USER_INIT
   YY_USER_INIT;
#endif
   if ( ! yy_start ) yy_start = 1;  /* first start state */
   if ( ! yyin ) yyin = stdin;
   if ( ! yyout ) yyout = stdout;
   if ( ! yy_current_buffer ) yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
   yy_load_buffer_state();
 }
 while ( 1 )    /* loops until end-of-file is reached */ {
   ............................
yy_match:
   do {
    .....
   }
   ............
yy_find_action:
   ............
   YY_DO_BEFORE_ACTION;
   do_action:  /* This label is used only to access EOF actions. */
     switch ( yy_act ) { /* beginning of action switch */
       case 0: 
         ...................
         goto yy_find_action;
     case 1:
     YY_RULE_SETUP
     #line 2 "interactive.l"
     printf("::%c",yytext[0]);
       YY_BREAK
     case 2:
     YY_RULE_SETUP
     #line 3 "interactive.l"
     printf("::%c",yytext[0]);
       YY_BREAK
     case 3:
     YY_RULE_SETUP
     #line 4 "interactive.l"
     ECHO;
       YY_BREAK
     #line 614 "lex.yy.c"
     case YY_STATE_EOF(INITIAL):
       yyterminate();
       case YY_END_OF_BUFFER:
         { .....  }
     default:
       YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
  } /* end of action switch */
 } /* end of scanning one token */
} /* end of yylex */

#if YY_MAIN
int main()
  { yylex(); return 0; }
#endif
#line 4 "interactive.l"
</PRE>
Por defecto, la macro 

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2812"
  HREF="node85.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2806"
  HREF="node81.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2802"
  HREF="node83.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2808"
  HREF="node194.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html2810"
  HREF="node197.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~plgrado/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="PL"></A><A NAME="tex2html3"
  HREF="http://campusvirtual.ull.es/1213m2/course/view.php?id=271"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="PL moodle"></A><A NAME="tex2html4"
  HREF="javascriptexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="ps"></A><A NAME="tex2html5"
  HREF="https://dl.dropbox.com/u/14539152/PLgrado/PLgradoBOOK/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html6"
  HREF="https://developer.mozilla.org/es/docs/JavaScript"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html7"
  HREF="http://github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="google code project hosting"></A><A NAME="tex2html8"
  HREF="http://jquery.com/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html9"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html10"
  HREF="http://www.ull.es/view/centros/etsii/Grado/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html11"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html12"
  HREF="http://crondinosaur.blogspot.com/"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="pcgull"></A>
<BR>
<B> Sig:</B> <A NAME="tex2html2813"
  HREF="node85.html">Expresiones Regulares en sed</A>
<B>Sup:</B> <A NAME="tex2html2807"
  HREF="node81.html">Expresiones Regulares en C</A>
<B> Ant:</B> <A NAME="tex2html2803"
  HREF="node83.html">Expresiones Regulares en Flex</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Casiano Rodríguez León <BR>
2013-04-12</I>
</ADDRESS>
</BODY>
</HTML>
